<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.classfile.ClassFileWriter$StackMapTable.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.classfile.ClassFileWriter$StackMapTable.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.classfile;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.mozilla.javascript.ObjArray;
import org.mozilla.javascript.UintMap;

import java.util.Arrays;

/**
 * ClassFileWriter
 *
 * A ClassFileWriter is used to write a Java class file. Methods are
 * provided to create fields and methods, and within methods to write
 * Java bytecodes.
 *
 * @author Roger Lawrence
 */
public class ClassFileWriter {

    /**
     * Thrown for cases where the error in generating the class file is due to a program size
     * constraints rather than a likely bug in the compiler.
     */
    public static class ClassFileFormatException extends RuntimeException {

        private static final long serialVersionUID = 1263998431033790599L;

        ClassFileFormatException(String message) {
            super(message);
        }
    }

    /**
     * Construct a ClassFileWriter for a class.
     *
     * @param className the name of the class to write, including full package qualification.
     * @param superClassName the name of the superclass of the class to write, including full package
     * qualification.
     * @param sourceFileName the name of the source file to use for producing debug information, or
     * null if debug information is not desired
     */
    public ClassFileWriter(String className, String superClassName,
        String sourceFileName) {
        generatedClassName = className;
        itsConstantPool = new ConstantPool(this);
        itsThisClassIndex = itsConstantPool.addClass(className);
        itsSuperClassIndex = itsConstantPool.addClass(superClassName);
        if (sourceFileName != null)
            itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);
        // All "new" implementations are supposed to output ACC_SUPER as a
        // class flag. This is specified in the first JVM spec, so it should
        // be old enough that it's okay to always set it.
        itsFlags = ACC_PUBLIC | ACC_SUPER;
    }

    public final String getClassName() {
        return generatedClassName;
    }

    /**
     * Add an interface implemented by this class.
     *
     * This method may be called multiple times for classes that implement multiple interfaces.
     *
     * @param interfaceName a name of an interface implemented by the class being written, including
     * full package qualification.
     */
    public void addInterface(String interfaceName) {
        short interfaceIndex = itsConstantPool.addClass(interfaceName);
        itsInterfaces.add(Short.valueOf(interfaceIndex));
    }

    public static final short
        ACC_PUBLIC = 0x0001,
        ACC_PRIVATE = 0x0002,
        ACC_PROTECTED = 0x0004,
        ACC_STATIC = 0x0008,
        ACC_FINAL = 0x0010,
        ACC_SUPER = 0x0020,
        ACC_SYNCHRONIZED = 0x0020,
        ACC_VOLATILE = 0x0040,
        ACC_TRANSIENT = 0x0080,
        ACC_NATIVE = 0x0100,
        ACC_ABSTRACT = 0x0400;

    /**
     * Set the class's flags.
     *
     * Flags must be a set of the following flags, bitwise or'd together: ACC_PUBLIC ACC_PRIVATE
     * ACC_PROTECTED ACC_FINAL ACC_ABSTRACT TODO: check that this is the appropriate set
     *
     * @param flags the set of class flags to set
     */
    public void setFlags(short flags) {
        itsFlags = flags;
    }

    static String getSlashedForm(String name) {
        return name.replace('.', '/');
    }

    /**
     * Convert Java class name in dot notation into "Lname-with-dots-replaced-by-slashes;" form
     * suitable for use as JVM type signatures.
     */
    public static String classNameToSignature(String name) {
        int nameLength = name.length();
        int colonPos = 1 + nameLength;
        char[] buf = new char[colonPos + 1];
        buf[0] = 'L';
        buf[colonPos] = ';';
        name.getChars(0, nameLength, buf, 1);
        for (int i = 1; i != colonPos; ++i) {
            if (buf[i] == '.') {
                buf[i] = '/';
            }
        }
        return new String(buf, 0, colonPos + 1);
    }

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     */
    public void addField(String fieldName, String type, short flags) {
        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
        short typeIndex = itsConstantPool.addUtf8(type);
        itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));
    }

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial integral value
     */
    public void addField(String fieldName, String type, short flags,
        int value) {
        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
        short typeIndex = itsConstantPool.addUtf8(type);
        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,
            flags);
        field.setAttributes(itsConstantPool.addUtf8("ConstantValue"),
            (short) 0,
            (short) 0,
            itsConstantPool.addConstant(value));
        itsFields.add(field);
    }

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial long value
     */
    public void addField(String fieldName, String type, short flags,
        long value) {
        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
        short typeIndex = itsConstantPool.addUtf8(type);
        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,
            flags);
        field.setAttributes(itsConstantPool.addUtf8("ConstantValue"),
            (short) 0,
            (short) 2,
            itsConstantPool.addConstant(value));
        itsFields.add(field);
    }

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial double value
     */
    public void addField(String fieldName, String type, short flags,
        double value) {
        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
        short typeIndex = itsConstantPool.addUtf8(type);
        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,
            flags);
        field.setAttributes(itsConstantPool.addUtf8("ConstantValue"),
            (short) 0,
            (short) 2,
            itsConstantPool.addConstant(value));
        itsFields.add(field);
    }

    /**
     * Add Information about java variable to use when generating the local variable table.
     *
     * @param name variable name.
     * @param type variable type as bytecode descriptor string.
     * @param startPC the starting bytecode PC where this variable is live, or -1 if it does not have
     * a Java register.
     * @param register the Java register number of variable or -1 if it does not have a Java
     * register.
     */
    public void addVariableDescriptor(String name, String type, int startPC, int register) {
        int nameIndex = itsConstantPool.addUtf8(name);
        int descriptorIndex = itsConstantPool.addUtf8(type);
        int[] chunk = {nameIndex, descriptorIndex, startPC, register};
        if (itsVarDescriptors == null) {
            itsVarDescriptors = new ObjArray();
        }
        itsVarDescriptors.add(chunk);
    }

    /**
     * Add a method and begin adding code.
     *
     * This method must be called before other methods for adding code, exception tables, etc. can be
     * invoked.
     *
     * @param methodName the name of the method
     * @param type a string representing the type
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     */
    public void startMethod(String methodName, String type, short flags) {
        short methodNameIndex = itsConstantPool.addUtf8(methodName);
        short typeIndex = itsConstantPool.addUtf8(type);
        itsCurrentMethod = new ClassFileMethod(methodName, methodNameIndex,
            type, typeIndex, flags);
        itsJumpFroms = new UintMap();
        itsMethods.add(itsCurrentMethod);
        addSuperBlockStart(0);
    }

    /**
     * Complete generation of the method.
     *
     * After this method is called, no more code can be added to the method begun with
     * <code>startMethod</code>.
     *
     * @param maxLocals the maximum number of local variable slots (a.k.a. Java registers) used by the
     * method
     */
    public void stopMethod(short maxLocals) {
        if (itsCurrentMethod == null)
            throw new IllegalStateException("No method to stop");

        fixLabelGotos();

        itsMaxLocals = maxLocals;

        StackMapTable stackMap = null;
        if (GenerateStackMap) {
            finalizeSuperBlockStarts();
            stackMap = new StackMapTable();
            stackMap.generate();
        }

        int lineNumberTableLength = 0;
        if (itsLineNumberTable != null) {
            // 6 bytes for the attribute header
            // 2 bytes for the line number count
            // 4 bytes for each entry
            lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);
        }

        int variableTableLength = 0;
        if (itsVarDescriptors != null) {
            // 6 bytes for the attribute header
            // 2 bytes for the variable count
            // 10 bytes for each entry
            variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);
        }

        int stackMapTableLength = 0;
        if (stackMap != null) {
            int stackMapWriteSize = stackMap.computeWriteSize();
            if (stackMapWriteSize > 0) {
                stackMapTableLength = 6 + stackMapWriteSize;
            }
        }

        int attrLength = 2 +                    // attribute_name_index
            4 +                    // attribute_length
            2 +                    // max_stack
            2 +                    // max_locals
            4 +                    // code_length
            itsCodeBufferTop +
            2 +                    // exception_table_length
            (itsExceptionTableTop * 8) +
            2 +                    // attributes_count
            lineNumberTableLength +
            variableTableLength +
            stackMapTableLength;

        if (attrLength > 65536) {
            // See http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html,
            // section 4.10, "The amount of code per non-native, non-abstract
            // method is limited to 65536 bytes...
            throw new ClassFileFormatException(
                "generated bytecode for method exceeds 64K limit.");
        }
        byte[] codeAttribute = new byte[attrLength];
        int index = 0;
        int codeAttrIndex = itsConstantPool.addUtf8("Code");
        index = putInt16(codeAttrIndex, codeAttribute, index);
        attrLength -= 6;                 // discount the attribute header
        index = putInt32(attrLength, codeAttribute, index);
        index = putInt16(itsMaxStack, codeAttribute, index);
        index = putInt16(itsMaxLocals, codeAttribute, index);
        index = putInt32(itsCodeBufferTop, codeAttribute, index);
        System.arraycopy(itsCodeBuffer, 0, codeAttribute, index,
            itsCodeBufferTop);
        index += itsCodeBufferTop;

        if (itsExceptionTableTop > 0) {
            index = putInt16(itsExceptionTableTop, codeAttribute, index);
            for (int i = 0; i < itsExceptionTableTop; i++) {
                ExceptionTableEntry ete = itsExceptionTable[i];
                short startPC = (short) getLabelPC(ete.itsStartLabel);
                short endPC = (short) getLabelPC(ete.itsEndLabel);
                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);
                short catchType = ete.itsCatchType;
                if (startPC == -1)
                    throw new IllegalStateException("start label not defined");
                if (endPC == -1)
                    throw new IllegalStateException("end label not defined");
                if (handlerPC == -1)
                    throw new IllegalStateException(
                        "handler label not defined");

                index = putInt16(startPC, codeAttribute, index);
                index = putInt16(endPC, codeAttribute, index);
                index = putInt16(handlerPC, codeAttribute, index);
                index = putInt16(catchType, codeAttribute, index);
            }
        } else {
            // write 0 as exception table length
            index = putInt16(0, codeAttribute, index);
        }

        int attributeCount = 0;
        if (itsLineNumberTable != null)
            attributeCount++;
        if (itsVarDescriptors != null)
            attributeCount++;
        if (stackMapTableLength > 0) {
            attributeCount++;
        }
        index = putInt16(attributeCount, codeAttribute, index);

        if (itsLineNumberTable != null) {
            int lineNumberTableAttrIndex
                = itsConstantPool.addUtf8("LineNumberTable");
            index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);
            int tableAttrLength = 2 + (itsLineNumberTableTop * 4);
            index = putInt32(tableAttrLength, codeAttribute, index);
            index = putInt16(itsLineNumberTableTop, codeAttribute, index);
            for (int i = 0; i < itsLineNumberTableTop; i++) {
                index = putInt32(itsLineNumberTable[i], codeAttribute, index);
            }
        }

        if (itsVarDescriptors != null) {
            int variableTableAttrIndex
                = itsConstantPool.addUtf8("LocalVariableTable");
            index = putInt16(variableTableAttrIndex, codeAttribute, index);
            int varCount = itsVarDescriptors.size();
            int tableAttrLength = 2 + (varCount * 10);
            index = putInt32(tableAttrLength, codeAttribute, index);
            index = putInt16(varCount, codeAttribute, index);
            for (int i = 0; i < varCount; i++) {
                int[] chunk = (int[]) itsVarDescriptors.get(i);
                int nameIndex = chunk[0];
                int descriptorIndex = chunk[1];
                int startPC = chunk[2];
                int register = chunk[3];
                int length = itsCodeBufferTop - startPC;

                index = putInt16(startPC, codeAttribute, index);
                index = putInt16(length, codeAttribute, index);
                index = putInt16(nameIndex, codeAttribute, index);
                index = putInt16(descriptorIndex, codeAttribute, index);
                index = putInt16(register, codeAttribute, index);
            }
        }

        if (stackMapTableLength > 0) {
            int stackMapTableAttrIndex =
                itsConstantPool.addUtf8("StackMapTable");
            int start = index;
            index = putInt16(stackMapTableAttrIndex, codeAttribute, index);
            index = stackMap.write(codeAttribute, index);
        }

        itsCurrentMethod.setCodeAttribute(codeAttribute);

        itsExceptionTable = null;
        itsExceptionTableTop = 0;
        itsLineNumberTableTop = 0;
        itsCodeBufferTop = 0;
        itsCurrentMethod = null;
        itsMaxStack = 0;
        itsStackTop = 0;
        itsLabelTableTop = 0;
        itsFixupTableTop = 0;
        itsVarDescriptors = null;
        itsSuperBlockStarts = null;
        itsSuperBlockStartsTop = 0;
        itsJumpFroms = null;
    }

    /**
     * Add the single-byte opcode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     */
    public void add(int theOpCode) {
        if (opcodeCount(theOpCode) != 0)
            throw new IllegalArgumentException("Unexpected operands");
        int newStack = itsStackTop + stackChange(theOpCode);
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);
        if (DEBUGCODE)
            System.out.println("Add " + bytecodeStr(theOpCode));
        addToCodeBuffer(theOpCode);
        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
        if (theOpCode == ByteCode.ATHROW) {
            addSuperBlockStart(itsCodeBufferTop);
        }
    }

    /**
     * Add a single-operand opcode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     * @param theOperand the operand of the bytecode
     */
    public void add(int theOpCode, int theOperand) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + Integer.toHexString(theOperand));
        }
        int newStack = itsStackTop + stackChange(theOpCode);
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);

        switch (theOpCode) {
            case ByteCode.GOTO:
                // This is necessary because dead code is seemingly being
                // generated and Sun's verifier is expecting type state to be
                // placed even at dead blocks of code.
                addSuperBlockStart(itsCodeBufferTop + 3);
                // fallthru...
            case ByteCode.IFEQ:
            case ByteCode.IFNE:
            case ByteCode.IFLT:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPNE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.JSR:
            case ByteCode.IFNULL:
            case ByteCode.IFNONNULL: {
                if ((theOperand & 0x80000000) != 0x80000000) {
                    if ((theOperand < 0) || (theOperand > 65535))
                        throw new IllegalArgumentException(
                            "Bad label for branch");
                }
                int branchPC = itsCodeBufferTop;
                addToCodeBuffer(theOpCode);
                if ((theOperand & 0x80000000) != 0x80000000) {
                    // hard displacement
                    addToCodeInt16(theOperand);
                    int target = theOperand + branchPC;
                    addSuperBlockStart(target);
                    itsJumpFroms.put(target, branchPC);
                } else {  // a label
                    int targetPC = getLabelPC(theOperand);
                    if (DEBUGLABELS) {
                        int theLabel = theOperand & 0x7FFFFFFF;
                        System.out.println("Fixing branch to " +
                            theLabel + " at " + targetPC +
                            " from " + branchPC);
                    }
                    if (targetPC != -1) {
                        int offset = targetPC - branchPC;
                        addToCodeInt16(offset);
                        addSuperBlockStart(targetPC);
                        itsJumpFroms.put(targetPC, branchPC);
                    } else {
                        addLabelFixup(theOperand, branchPC + 1);
                        addToCodeInt16(0);
                    }
                }
            }
            break;

            case ByteCode.BIPUSH:
                if ((byte) theOperand != theOperand)
                    throw new IllegalArgumentException("out of range byte");
                addToCodeBuffer(theOpCode);
                addToCodeBuffer((byte) theOperand);
                break;

            case ByteCode.SIPUSH:
                if ((short) theOperand != theOperand)
                    throw new IllegalArgumentException("out of range short");
                addToCodeBuffer(theOpCode);
                addToCodeInt16(theOperand);
                break;

            case ByteCode.NEWARRAY:
                if (!(0 <= theOperand && theOperand < 256))
                    throw new IllegalArgumentException("out of range index");
                addToCodeBuffer(theOpCode);
                addToCodeBuffer(theOperand);
                break;

            case ByteCode.GETFIELD:
            case ByteCode.PUTFIELD:
                if (!(0 <= theOperand && theOperand < 65536))
                    throw new IllegalArgumentException("out of range field");
                addToCodeBuffer(theOpCode);
                addToCodeInt16(theOperand);
                break;

            case ByteCode.LDC:
            case ByteCode.LDC_W:
            case ByteCode.LDC2_W:
                if (!(0 <= theOperand && theOperand < 65536))
                    throw new IllegalArgumentException("out of range index");
                if (theOperand >= 256
                    || theOpCode == ByteCode.LDC_W
                    || theOpCode == ByteCode.LDC2_W) {
                    if (theOpCode == ByteCode.LDC) {
                        addToCodeBuffer(ByteCode.LDC_W);
                    } else {
                        addToCodeBuffer(theOpCode);
                    }
                    addToCodeInt16(theOperand);
                } else {
                    addToCodeBuffer(theOpCode);
                    addToCodeBuffer(theOperand);
                }
                break;

            case ByteCode.RET:
            case ByteCode.ILOAD:
            case ByteCode.LLOAD:
            case ByteCode.FLOAD:
            case ByteCode.DLOAD:
            case ByteCode.ALOAD:
            case ByteCode.ISTORE:
            case ByteCode.LSTORE:
            case ByteCode.FSTORE:
            case ByteCode.DSTORE:
            case ByteCode.ASTORE:
                if (!(0 <= theOperand && theOperand < 65536))
                    throw new ClassFileFormatException("out of range variable");
                if (theOperand >= 256) {
                    addToCodeBuffer(ByteCode.WIDE);
                    addToCodeBuffer(theOpCode);
                    addToCodeInt16(theOperand);
                } else {
                    addToCodeBuffer(theOpCode);
                    addToCodeBuffer(theOperand);
                }
                break;

            default:
                throw new IllegalArgumentException(
                    "Unexpected opcode for 1 operand");
        }

        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
    }

    /**
     * Generate the load constant bytecode for the given integer.
     *
     * @param k the constant
     */
    public void addLoadConstant(int k) {
        switch (k) {
            case 0:
                add(ByteCode.ICONST_0);
                break;
            case 1:
                add(ByteCode.ICONST_1);
                break;
            case 2:
                add(ByteCode.ICONST_2);
                break;
            case 3:
                add(ByteCode.ICONST_3);
                break;
            case 4:
                add(ByteCode.ICONST_4);
                break;
            case 5:
                add(ByteCode.ICONST_5);
                break;
            default:
                add(ByteCode.LDC, itsConstantPool.addConstant(k));
                break;
        }
    }

    /**
     * Generate the load constant bytecode for the given long.
     *
     * @param k the constant
     */
    public void addLoadConstant(long k) {
        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
    }

    /**
     * Generate the load constant bytecode for the given float.
     *
     * @param k the constant
     */
    public void addLoadConstant(float k) {
        add(ByteCode.LDC, itsConstantPool.addConstant(k));
    }

    /**
     * Generate the load constant bytecode for the given double.
     *
     * @param k the constant
     */
    public void addLoadConstant(double k) {
        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
    }

    /**
     * Generate the load constant bytecode for the given string.
     *
     * @param k the constant
     */
    public void addLoadConstant(String k) {
        add(ByteCode.LDC, itsConstantPool.addConstant(k));
    }

    /**
     * Add the given two-operand bytecode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     * @param theOperand1 the first operand of the bytecode
     * @param theOperand2 the second operand of the bytecode
     */
    public void add(int theOpCode, int theOperand1, int theOperand2) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + Integer.toHexString(theOperand1)
                + ", " + Integer.toHexString(theOperand2));
        }
        int newStack = itsStackTop + stackChange(theOpCode);
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);

        if (theOpCode == ByteCode.IINC) {
            if (!(0 <= theOperand1 && theOperand1 < 65536))
                throw new ClassFileFormatException("out of range variable");
            if (!(0 <= theOperand2 && theOperand2 < 65536))
                throw new ClassFileFormatException("out of range increment");

            if (theOperand1 > 255 || theOperand2 < -128 || theOperand2 > 127) {
                addToCodeBuffer(ByteCode.WIDE);
                addToCodeBuffer(ByteCode.IINC);
                addToCodeInt16(theOperand1);
                addToCodeInt16(theOperand2);
            } else {
                addToCodeBuffer(ByteCode.IINC);
                addToCodeBuffer(theOperand1);
                addToCodeBuffer(theOperand2);
            }
        } else if (theOpCode == ByteCode.MULTIANEWARRAY) {
            if (!(0 <= theOperand1 && theOperand1 < 65536))
                throw new IllegalArgumentException("out of range index");
            if (!(0 <= theOperand2 && theOperand2 < 256))
                throw new IllegalArgumentException("out of range dimensions");

            addToCodeBuffer(ByteCode.MULTIANEWARRAY);
            addToCodeInt16(theOperand1);
            addToCodeBuffer(theOperand2);
        } else {
            throw new IllegalArgumentException(
                "Unexpected opcode for 2 operands");
        }
        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }

    }

    public void add(int theOpCode, String className) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + className);
        }
        int newStack = itsStackTop + stackChange(theOpCode);
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);
        switch (theOpCode) {
            case ByteCode.NEW:
            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.INSTANCEOF: {
                short classIndex = itsConstantPool.addClass(className);
                addToCodeBuffer(theOpCode);
                addToCodeInt16(classIndex);
            }
            break;

            default:
                throw new IllegalArgumentException(
                    "bad opcode for class reference");
        }
        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
    }


    public void add(int theOpCode, String className, String fieldName,
        String fieldType) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + className + ", " + fieldName + ", " + fieldType);
        }
        int newStack = itsStackTop + stackChange(theOpCode);
        char fieldTypeChar = fieldType.charAt(0);
        int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D')
            ? 2 : 1;
        switch (theOpCode) {
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
                newStack += fieldSize;
                break;
            case ByteCode.PUTSTATIC:
            case ByteCode.PUTFIELD:
                newStack -= fieldSize;
                break;
            default:
                throw new IllegalArgumentException(
                    "bad opcode for field reference");
        }
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);
        short fieldRefIndex = itsConstantPool.addFieldRef(className,
            fieldName, fieldType);
        addToCodeBuffer(theOpCode);
        addToCodeInt16(fieldRefIndex);

        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
    }

    public void addInvoke(int theOpCode, String className, String methodName,
        String methodType) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + className + ", " + methodName + ", "
                + methodType);
        }
        int parameterInfo = sizeOfParameters(methodType);
        int parameterCount = parameterInfo >>> 16;
        int stackDiff = (short) parameterInfo;

        int newStack = itsStackTop + stackDiff;
        newStack += stackChange(theOpCode);     // adjusts for 'this'
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);

        switch (theOpCode) {
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEINTERFACE: {
                addToCodeBuffer(theOpCode);
                if (theOpCode == ByteCode.INVOKEINTERFACE) {
                    short ifMethodRefIndex
                        = itsConstantPool.addInterfaceMethodRef(
                        className, methodName,
                        methodType);
                    addToCodeInt16(ifMethodRefIndex);
                    addToCodeBuffer(parameterCount + 1);
                    addToCodeBuffer(0);
                } else {
                    short methodRefIndex = itsConstantPool.addMethodRef(
                        className, methodName,
                        methodType);
                    addToCodeInt16(methodRefIndex);
                }
            }
            break;

            default:
                throw new IllegalArgumentException(
                    "bad opcode for method reference");
        }
        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
    }

    public void addInvokeDynamic(String methodName, String methodType,
        MHandle bsm, Object... bsmArgs) {
        if (DEBUGCODE) {
            System.out.println("Add invokedynamic, " + methodName + ", " + methodType);
        }
        // JDK 1.7 major class file version is required for invokedynamic
        if (MajorVersion < 51) {
            throw new RuntimeException(
                "Please build and run with JDK 1.7 for invokedynamic support");
        }

        int parameterInfo = sizeOfParameters(methodType);
        // int parameterCount = parameterInfo >>> 16;
        int stackDiff = (short) parameterInfo;

        int newStack = itsStackTop + stackDiff;
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);

        BootstrapEntry bsmEntry = new BootstrapEntry(bsm, bsmArgs);

        if (itsBootstrapMethods == null) {
            itsBootstrapMethods = new ObjArray();
        }
        int bootstrapIndex = itsBootstrapMethods.indexOf(bsmEntry);
        if (bootstrapIndex == -1) {
            bootstrapIndex = itsBootstrapMethods.size();
            itsBootstrapMethods.add(bsmEntry);
            itsBootstrapMethodsLength += bsmEntry.code.length;
        }

        short invokedynamicIndex = itsConstantPool.addInvokeDynamic(
            methodName, methodType, bootstrapIndex);

        addToCodeBuffer(ByteCode.INVOKEDYNAMIC);
        addToCodeInt16(invokedynamicIndex);
        addToCodeInt16(0);

        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After invokedynamic stack = " + itsStackTop);
        }

    }

    /**
     * Generate code to load the given integer on stack.
     *
     * @param k the constant
     */
    public void addPush(int k) {
        if ((byte) k == k) {
            if (k == -1) {
                add(ByteCode.ICONST_M1);
            } else if (0 <= k && k <= 5) {
                add((byte) (ByteCode.ICONST_0 + k));
            } else {
                add(ByteCode.BIPUSH, (byte) k);
            }
        } else if ((short) k == k) {
            add(ByteCode.SIPUSH, (short) k);
        } else {
            addLoadConstant(k);
        }
    }

    public void addPush(boolean k) {
        add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);
    }

    /**
     * Generate code to load the given long on stack.
     *
     * @param k the constant
     */
    public void addPush(long k) {
        int ik = (int) k;
        if (ik == k) {
            addPush(ik);
            add(ByteCode.I2L);
        } else {
            addLoadConstant(k);
        }
    }

    /**
     * Generate code to load the given double on stack.
     *
     * @param k the constant
     */
    public void addPush(double k) {
        if (k == 0.0) {
            // zero
            add(ByteCode.DCONST_0);
            if (1.0 / k < 0) {
                // Negative zero
                add(ByteCode.DNEG);
            }
        } else if (k == 1.0 || k == -1.0) {
            add(ByteCode.DCONST_1);
            if (k < 0) {
                add(ByteCode.DNEG);
            }
        } else {
            addLoadConstant(k);
        }
    }

    /**
     * Generate the code to leave on stack the given string even if the string encoding exeeds the
     * class file limit for single string constant
     *
     * @param k the constant
     */
    public void addPush(String k) {
        int length = k.length();
        int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);
        if (limit == length) {
            addLoadConstant(k);
            return;
        }
        // Split string into picies fitting the UTF limit and generate code for
        // StringBuilder sb = new StringBuilder(length);
        // sb.append(loadConstant(piece_1));
        // ...
        // sb.append(loadConstant(piece_N));
        // sb.toString();
        final String SB = "java/lang/StringBuilder";
        add(ByteCode.NEW, SB);
        add(ByteCode.DUP);
        addPush(length);
        addInvoke(ByteCode.INVOKESPECIAL, SB, "<init>", "(I)V");
        int cursor = 0;
        for (; ; ) {
            add(ByteCode.DUP);
            String s = k.substring(cursor, limit);
            addLoadConstant(s);
            addInvoke(ByteCode.INVOKEVIRTUAL, SB, "append",
                "(Ljava/lang/String;)Ljava/lang/StringBuilder;");
            add(ByteCode.POP);
            if (limit == length) {
                break;
            }
            cursor = limit;
            limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);
        }
        addInvoke(ByteCode.INVOKEVIRTUAL, SB, "toString",
            "()Ljava/lang/String;");
    }

    /**
     * Check if k fits limit on string constant size imposed by class file format.
     *
     * @param k the string constant
     */
    public boolean isUnderStringSizeLimit(String k) {
        return itsConstantPool.isUnderUtfEncodingLimit(k);
    }

    /**
     * Store integer from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addIStore(int local) {
        xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);
    }

    /**
     * Store long from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addLStore(int local) {
        xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);
    }

    /**
     * Store float from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addFStore(int local) {
        xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);
    }

    /**
     * Store double from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addDStore(int local) {
        xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);
    }

    /**
     * Store object from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addAStore(int local) {
        xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);
    }

    /**
     * Load integer from the given local into stack.
     *
     * @param local number of local register
     */
    public void addILoad(int local) {
        xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);
    }

    /**
     * Load long from the given local into stack.
     *
     * @param local number of local register
     */
    public void addLLoad(int local) {
        xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);
    }

    /**
     * Load float from the given local into stack.
     *
     * @param local number of local register
     */
    public void addFLoad(int local) {
        xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);
    }

    /**
     * Load double from the given local into stack.
     *
     * @param local number of local register
     */
    public void addDLoad(int local) {
        xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);
    }

    /**
     * Load object from the given local into stack.
     *
     * @param local number of local register
     */
    public void addALoad(int local) {
        xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);
    }

    /**
     * Load "this" into stack.
     */
    public void addLoadThis() {
        add(ByteCode.ALOAD_0);
    }

    private void xop(int shortOp, int op, int local) {
        switch (local) {
            case 0:
                add(shortOp);
                break;
            case 1:
                add(shortOp + 1);
                break;
            case 2:
                add(shortOp + 2);
                break;
            case 3:
                add(shortOp + 3);
                break;
            default:
                add(op, local);
        }
    }

    public int addTableSwitch(int low, int high) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(ByteCode.TABLESWITCH)
                + " " + low + " " + high);
        }
        if (low > high)
            throw new ClassFileFormatException("Bad bounds: " + low + ' ' + high);

        int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);

        int entryCount = high - low + 1;
        int padSize = 3 & ~itsCodeBufferTop; // == 3 - itsCodeBufferTop % 4

        int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));
        int switchStart = N;
        itsCodeBuffer[N++] = (byte) ByteCode.TABLESWITCH;
        while (padSize != 0) {
            itsCodeBuffer[N++] = 0;
            --padSize;
        }
        N += 4; // skip default offset
        N = putInt32(low, itsCodeBuffer, N);
        putInt32(high, itsCodeBuffer, N);

        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(ByteCode.TABLESWITCH)
                + " stack = " + itsStackTop);
        }

        return switchStart;
    }

    public final void markTableSwitchDefault(int switchStart) {
        addSuperBlockStart(itsCodeBufferTop);
        itsJumpFroms.put(itsCodeBufferTop, switchStart);
        setTableSwitchJump(switchStart, -1, itsCodeBufferTop);
    }

    public final void markTableSwitchCase(int switchStart, int caseIndex) {
        addSuperBlockStart(itsCodeBufferTop);
        itsJumpFroms.put(itsCodeBufferTop, switchStart);
        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
    }

    public final void markTableSwitchCase(int switchStart, int caseIndex,
        int stackTop) {
        if (!(0 <= stackTop && stackTop <= itsMaxStack))
            throw new IllegalArgumentException("Bad stack index: " + stackTop);
        itsStackTop = (short) stackTop;
        addSuperBlockStart(itsCodeBufferTop);
        itsJumpFroms.put(itsCodeBufferTop, switchStart);
        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
    }

    /**
     * Set a jump case for a tableswitch instruction. The jump target should be marked as a super
     * block start for stack map generation.
     */
    public void setTableSwitchJump(int switchStart, int caseIndex,
        int jumpTarget) {
        if (!(0 <= jumpTarget && jumpTarget <= itsCodeBufferTop))
            throw new IllegalArgumentException("Bad jump target: " + jumpTarget);
        if (!(caseIndex >= -1))
            throw new IllegalArgumentException("Bad case index: " + caseIndex);

        int padSize = 3 & ~switchStart; // == 3 - switchStart % 4
        int caseOffset;
        if (caseIndex < 0) {
            // default label
            caseOffset = switchStart + 1 + padSize;
        } else {
            caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);
        }
        if (!(0 <= switchStart
            && switchStart <= itsCodeBufferTop - 4 * 4 - padSize - 1)) {
            throw new IllegalArgumentException(
                switchStart + " is outside a possible range of tableswitch"
                    + " in already generated code");
        }
        if ((0xFF & itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {
            throw new IllegalArgumentException(
                switchStart + " is not offset of tableswitch statement");
        }
        if (!(0 <= caseOffset && caseOffset + 4 <= itsCodeBufferTop)) {
            // caseIndex >= -1 does not guarantee that caseOffset >= 0 due
            // to a possible overflow.
            throw new ClassFileFormatException(
                "Too big case index: " + caseIndex);
        }
        // ALERT: perhaps check against case bounds?
        putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);
    }

    public int acquireLabel() {
        int top = itsLabelTableTop;
        if (itsLabelTable == null || top == itsLabelTable.length) {
            if (itsLabelTable == null) {
                itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
            } else {
                int[] tmp = new int[itsLabelTable.length * 2];
                System.arraycopy(itsLabelTable, 0, tmp, 0, top);
                itsLabelTable = tmp;
            }
        }
        itsLabelTableTop = top + 1;
        itsLabelTable[top] = -1;
        return top | 0x80000000;
    }

    public void markLabel(int label) {
        if (!(label < 0))
            throw new IllegalArgumentException("Bad label, no biscuit");

        label &= 0x7FFFFFFF;
        if (label > itsLabelTableTop)
            throw new IllegalArgumentException("Bad label");

        if (itsLabelTable[label] != -1) {
            throw new IllegalStateException("Can only mark label once");
        }

        itsLabelTable[label] = itsCodeBufferTop;
    }

    public void markLabel(int label, short stackTop) {
        markLabel(label);
        itsStackTop = stackTop;
    }

    public void markHandler(int theLabel) {
        itsStackTop = 1;
        markLabel(theLabel);
    }

    public int getLabelPC(int label) {
        if (!(label < 0))
            throw new IllegalArgumentException("Bad label, no biscuit");
        label &= 0x7FFFFFFF;
        if (!(label < itsLabelTableTop))
            throw new IllegalArgumentException("Bad label");
        return itsLabelTable[label];
    }

    private void addLabelFixup(int label, int fixupSite) {
        if (!(label < 0))
            throw new IllegalArgumentException("Bad label, no biscuit");
        label &= 0x7FFFFFFF;
        if (!(label < itsLabelTableTop))
            throw new IllegalArgumentException("Bad label");
        int top = itsFixupTableTop;
        if (itsFixupTable == null || top == itsFixupTable.length) {
            if (itsFixupTable == null) {
                itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
            } else {
                long[] tmp = new long[itsFixupTable.length * 2];
                System.arraycopy(itsFixupTable, 0, tmp, 0, top);
                itsFixupTable = tmp;
            }
        }
        itsFixupTableTop = top + 1;
        itsFixupTable[top] = ((long) label << 32) | fixupSite;
    }

    private void fixLabelGotos() {
        byte[] codeBuffer = itsCodeBuffer;
        for (int i = 0; i < itsFixupTableTop; i++) {
            long fixup = itsFixupTable[i];
            int label = (int) (fixup >> 32);
            int fixupSite = (int) fixup;
            int pc = itsLabelTable[label];
            if (pc == -1) {
                // Unlocated label
                throw new RuntimeException();
            }
            // -1 to get delta from instruction start
            addSuperBlockStart(pc);
            itsJumpFroms.put(pc, fixupSite - 1);
            int offset = pc - (fixupSite - 1);
            if ((short) offset != offset) {
                throw new ClassFileFormatException
                    ("Program too complex: too big jump offset");
            }
            codeBuffer[fixupSite] = (byte) (offset >> 8);
            codeBuffer[fixupSite + 1] = (byte) offset;
        }
        itsFixupTableTop = 0;
    }

    /**
     * Get the current offset into the code of the current method.
     *
     * @return an integer representing the offset
     */
    public int getCurrentCodeOffset() {
        return itsCodeBufferTop;
    }

    public short getStackTop() {
        return itsStackTop;
    }

    public void setStackTop(short n) {
        itsStackTop = n;
    }

    public void adjustStackTop(int delta) {
        int newStack = itsStackTop + delta;
        if (newStack < 0 || Short.MAX_VALUE < newStack)
            badStack(newStack);
        itsStackTop = (short) newStack;
        if (newStack > itsMaxStack)
            itsMaxStack = (short) newStack;
        if (DEBUGSTACK) {
            System.out.println("After " + "adjustStackTop(" + delta + ")"
                + " stack = " + itsStackTop);
        }
    }

    private void addToCodeBuffer(int b) {
        int N = addReservedCodeSpace(1);
        itsCodeBuffer[N] = (byte) b;
    }

    private void addToCodeInt16(int value) {
        int N = addReservedCodeSpace(2);
        putInt16(value, itsCodeBuffer, N);
    }

    private int addReservedCodeSpace(int size) {
        if (itsCurrentMethod == null)
            throw new IllegalArgumentException("No method to add to");
        int oldTop = itsCodeBufferTop;
        int newTop = oldTop + size;
        if (newTop > itsCodeBuffer.length) {
            int newSize = itsCodeBuffer.length * 2;
            if (newTop > newSize) {
                newSize = newTop;
            }
            byte[] tmp = new byte[newSize];
            System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);
            itsCodeBuffer = tmp;
        }
        itsCodeBufferTop = newTop;
        return oldTop;
    }

    public void addExceptionHandler(int startLabel, int endLabel,
        int handlerLabel, String catchClassName) {
        if ((startLabel & 0x80000000) != 0x80000000)
            throw new IllegalArgumentException("Bad startLabel");
        if ((endLabel & 0x80000000) != 0x80000000)
            throw new IllegalArgumentException("Bad endLabel");
        if ((handlerLabel & 0x80000000) != 0x80000000)
            throw new IllegalArgumentException("Bad handlerLabel");

        /*
         * If catchClassName is null, use 0 for the catch_type_index; which
         * means catch everything.  (Even when the verifier has let you throw
         * something other than a Throwable.)
         */
        short catch_type_index = (catchClassName == null)
            ? 0
            : itsConstantPool.addClass(catchClassName);
        ExceptionTableEntry newEntry = new ExceptionTableEntry(
            startLabel,
            endLabel,
            handlerLabel,
            catch_type_index);
        int N = itsExceptionTableTop;
        if (N == 0) {
            itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];
        } else if (N == itsExceptionTable.length) {
            ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];
            System.arraycopy(itsExceptionTable, 0, tmp, 0, N);
            itsExceptionTable = tmp;
        }
        itsExceptionTable[N] = newEntry;
        itsExceptionTableTop = N + 1;

    }

    public void addLineNumberEntry(short lineNumber) {
        if (itsCurrentMethod == null)
            throw new IllegalArgumentException("No method to stop");
        int N = itsLineNumberTableTop;
        if (N == 0) {
            itsLineNumberTable = new int[LineNumberTableSize];
        } else if (N == itsLineNumberTable.length) {
            int[] tmp = new int[N * 2];
            System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);
            itsLineNumberTable = tmp;
        }
        itsLineNumberTable[N] = (itsCodeBufferTop << 16) + lineNumber;
        itsLineNumberTableTop = N + 1;
    }

    /**
     * A stack map table is a code attribute introduced in Java 6 that gives type information at key
     * points in the method body (namely, at the beginning of each super block after the first). Each
     * frame of a stack map table contains the state of local variable and operand stack for a given
     * super block.
     */
    final class StackMapTable {

<span class='uc' id='L1441' title='5|5|5 - Total: 5'>        StackMapTable() {
</span><span class='uc' id='L1442' title='3|3|3 - Total: 3'>            superBlocks = null;
</span><span class='uc' id='L1443' title='6|6|6 - Total: 6'>            locals = stack = null;
</span><span class='uc' id='L1444' title='3|3|3 - Total: 3'>            workList = null;
</span><span class='uc' id='L1445' title='3|3|3 - Total: 3'>            rawStackMap = null;
</span><span class='uc' id='L1446' title='3|3|3 - Total: 3'>            localsTop = 0;
</span><span class='uc' id='L1447' title='3|3|3 - Total: 3'>            stackTop = 0;
</span><span class='uc' id='L1448' title='3|3|3 - Total: 3'>            workListTop = 0;
</span><span class='uc' id='L1449' title='3|3|3 - Total: 3'>            rawStackMapTop = 0;
</span><span class='uc' id='L1450' title='3|3|3 - Total: 3'>            wide = false;
</span><span class='uc' id='L1451' title='1|1|1 - Total: 1'>        }
</span>
        void generate() {
<span class='uc' id='L1454' title='6|6|6 - Total: 6'>            superBlocks = new SuperBlock[itsSuperBlockStartsTop];
</span><span class='uc' id='L1455' title='4|4|4 - Total: 4'>            int[] initialLocals = createInitialLocals();
</span>
<span class='uc' id='L1457' title='2|2|2 - Total: 2'>            for (int i = 0; i < itsSuperBlockStartsTop; i++) {
</span><span class='uc' id='L1458' title='6|6|6 - Total: 6'>                int start = itsSuperBlockStarts[i];
</span>                int end;
<span class='uc' id='L1460' title='2|2|2 - Total: 2'>                if (i == itsSuperBlockStartsTop - 1) {
</span><span class='uc' id='L1461' title='5|5|5 - Total: 5'>                    end = itsCodeBufferTop;
</span>                } else {
<span class='uc' id='L1463' title='8|8|8 - Total: 8'>                    end = itsSuperBlockStarts[i + 1];
</span>                }
<span class='uc' id='L1465' title='11|11|11 - Total: 11'>                superBlocks[i] = new SuperBlock(i, start, end, initialLocals);
</span>            }

            if (DEBUGSTACKMAP) {
                System.out.println("super blocks: ");
                for (int i = 0;
                    i < superBlocks.length && superBlocks[i] != null; i++) {
                    System.out.println("sb " + i + ": [" +
                        superBlocks[i].getStart() + ", " +
                        superBlocks[i].getEnd() + ")");
                }
            }

<span class='uc' id='L1478' title='4|4|4 - Total: 4'>            superBlockDeps = getSuperBlockDependencies();
</span>
<span class='uc' id='L1480' title='2|2|2 - Total: 2'>            verify();
</span>
            if (DEBUGSTACKMAP) {
                System.out.println("type information:");
                for (int i = 0; i < superBlocks.length; i++) {
                    SuperBlock sb = superBlocks[i];
                    System.out.println("sb " + i + ":");
                    TypeInfo.print(sb.getLocals(), sb.getStack(),
                        itsConstantPool);
                }
            }
<span class='uc' id='L1491' title='1|1|1 - Total: 1'>        }
</span>
        private SuperBlock getSuperBlockFromOffset(int offset) {
<span class='upc' id='L1494' title='1|1|1 - Total: 2'>            for (int i = 0; i < superBlocks.length; i++) {
</span><span class='uc' id='L1495' title='5|5|5 - Total: 5'>                SuperBlock sb = superBlocks[i];
</span><span class='upc' id='L1496' title='1|1|1 - Total: 2'>                if (sb == null) {
</span><span class='nc' id='L1497' title='0|0|0 - Total: 1'>                    break;
</span><span class='upc' id='L1498' title='3|3|3 - Total: 4'>                } else if (offset >= sb.getStart() && offset < sb.getEnd()) {
</span><span class='uc' id='L1499' title='2|2|2 - Total: 2'>                    return sb;
</span>                }
            }
<span class='nc' id='L1502' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException("bad offset: " + offset);
</span>        }

        /**
         * Determine whether or not an opcode is an actual end to a super block. This includes any
         * returns or unconditional jumps.
         */
        private boolean isSuperBlockEnd(int opcode) {
<span class='uc' id='L1510' title='2|2|2 - Total: 2'>            switch (opcode) {
</span>                case ByteCode.ARETURN:
                case ByteCode.FRETURN:
                case ByteCode.IRETURN:
                case ByteCode.LRETURN:
                case ByteCode.RETURN:
                case ByteCode.ATHROW:
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                case ByteCode.TABLESWITCH:
                case ByteCode.LOOKUPSWITCH:
<span class='uc' id='L1521' title='2|2|2 - Total: 2'>                    return true;
</span>                default:
<span class='uc' id='L1523' title='2|2|2 - Total: 2'>                    return false;
</span>            }
        }

        /**
         * Calculate partial dependencies for super blocks.
         *
         * This is used as a workaround for dead code that is generated. Only one dependency per super
         * block is given.
         */
        private SuperBlock[] getSuperBlockDependencies() {
<span class='uc' id='L1534' title='5|5|5 - Total: 5'>            SuperBlock[] deps = new SuperBlock[superBlocks.length];
</span>
<span class='uc' id='L1536' title='2|2|2 - Total: 2'>            for (int i = 0; i < itsExceptionTableTop; i++) {
</span><span class='uc' id='L1537' title='6|6|6 - Total: 6'>                ExceptionTableEntry ete = itsExceptionTable[i];
</span><span class='uc' id='L1538' title='7|7|7 - Total: 7'>                short startPC = (short) getLabelPC(ete.itsStartLabel);
</span><span class='uc' id='L1539' title='7|7|7 - Total: 7'>                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);
</span><span class='uc' id='L1540' title='4|4|4 - Total: 4'>                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);
</span><span class='uc' id='L1541' title='4|4|4 - Total: 4'>                SuperBlock dep = getSuperBlockFromOffset(startPC);
</span><span class='uc' id='L1542' title='5|5|5 - Total: 5'>                deps[handlerSB.getIndex()] = dep;
</span>            }
<span class='uc' id='L1544' title='5|5|5 - Total: 5'>            int[] targetPCs = itsJumpFroms.getKeys();
</span><span class='uc' id='L1545' title='2|2|2 - Total: 2'>            for (int i = 0; i < targetPCs.length; i++) {
</span><span class='uc' id='L1546' title='4|4|4 - Total: 4'>                int targetPC = targetPCs[i];
</span><span class='uc' id='L1547' title='7|7|7 - Total: 7'>                int branchPC = itsJumpFroms.getInt(targetPC, -1);
</span><span class='uc' id='L1548' title='4|4|4 - Total: 4'>                SuperBlock branchSB = getSuperBlockFromOffset(branchPC);
</span><span class='uc' id='L1549' title='4|4|4 - Total: 4'>                SuperBlock targetSB = getSuperBlockFromOffset(targetPC);
</span><span class='uc' id='L1550' title='5|5|5 - Total: 5'>                deps[targetSB.getIndex()] = branchSB;
</span>            }

<span class='uc' id='L1553' title='2|2|2 - Total: 2'>            return deps;
</span>        }

        /**
         * Get the target super block of a branch instruction.
         *
         * @param bci the index of the branch instruction in the code buffer
         */
        private SuperBlock getBranchTarget(int bci) {
            int target;
<span class='upc' id='L1563' title='1|1|1 - Total: 2'>            if ((itsCodeBuffer[bci] & 0xFF) == ByteCode.GOTO_W) {
</span><span class='nc' id='L1564' title='0|0|0 - Total: 10'>                target = bci + getOperand(bci + 1, 4);
</span>            } else {
<span class='uc' id='L1566' title='10|10|10 - Total: 10'>                target = bci + (short) getOperand(bci + 1, 2);
</span>            }
<span class='uc' id='L1568' title='4|4|4 - Total: 4'>            return getSuperBlockFromOffset(target);
</span>        }

        /**
         * Determine whether or not an opcode is a conditional or unconditional jump.
         */
        private boolean isBranch(int opcode) {
<span class='uc' id='L1575' title='2|2|2 - Total: 2'>            switch (opcode) {
</span>                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                case ByteCode.IFEQ:
                case ByteCode.IFGE:
                case ByteCode.IFGT:
                case ByteCode.IFLE:
                case ByteCode.IFLT:
                case ByteCode.IFNE:
                case ByteCode.IFNONNULL:
                case ByteCode.IFNULL:
                case ByteCode.IF_ACMPEQ:
                case ByteCode.IF_ACMPNE:
                case ByteCode.IF_ICMPEQ:
                case ByteCode.IF_ICMPGE:
                case ByteCode.IF_ICMPGT:
                case ByteCode.IF_ICMPLE:
                case ByteCode.IF_ICMPLT:
                case ByteCode.IF_ICMPNE:
<span class='uc' id='L1594' title='2|2|2 - Total: 2'>                    return true;
</span>                default:
<span class='uc' id='L1596' title='2|2|2 - Total: 2'>                    return false;
</span>            }
        }

        private int getOperand(int offset) {
<span class='uc' id='L1601' title='5|5|5 - Total: 5'>            return getOperand(offset, 1);
</span>        }

        /**
         * Extract a logical operand from the byte code.
         *
         * This is used, for example, to get branch offsets.
         */
        private int getOperand(int start, int size) {
<span class='uc' id='L1610' title='2|2|2 - Total: 2'>            int result = 0;
</span><span class='upc' id='L1611' title='1|1|1 - Total: 2'>            if (size > 4) {
</span><span class='nc' id='L1612' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException("bad operand size");
</span>            }
<span class='uc' id='L1614' title='2|2|2 - Total: 2'>            for (int i = 0; i < size; i++) {
</span><span class='uc' id='L1615' title='14|14|14 - Total: 14'>                result = (result << 8) | (itsCodeBuffer[start + i] & 0xFF);
</span>            }
<span class='uc' id='L1617' title='2|2|2 - Total: 2'>            return result;
</span>        }

        /**
         * Calculate initial local variable and op stack types for each super block in the method.
         */
        private void verify() {
<span class='uc' id='L1624' title='4|4|4 - Total: 4'>            int[] initialLocals = createInitialLocals();
</span><span class='uc' id='L1625' title='14|14|14 - Total: 14'>            superBlocks[0].merge(initialLocals, initialLocals.length,
</span><span class='uc' id='L1626' title='1|1|1 - Total: 1'>                new int[0], 0, itsConstantPool);
</span>
            // Start from the top of the method and queue up block dependencies
            // as they come along.
<span class='uc' id='L1630' title='11|11|11 - Total: 11'>            workList = new SuperBlock[]{superBlocks[0]};
</span><span class='uc' id='L1631' title='3|3|3 - Total: 3'>            workListTop = 1;
</span><span class='uc' id='L1632' title='2|2|2 - Total: 2'>            executeWorkList();
</span>
            // Replace dead code with no-ops.
<span class='uc' id='L1635' title='2|2|2 - Total: 2'>            for (int i = 0; i < superBlocks.length; i++) {
</span><span class='uc' id='L1636' title='5|5|5 - Total: 5'>                SuperBlock sb = superBlocks[i];
</span><span class='uc' id='L1637' title='2|2|2 - Total: 2'>                if (!sb.isInitialized()) {
</span><span class='uc' id='L1638' title='3|3|3 - Total: 3'>                    killSuperBlock(sb);
</span>                }
            }
<span class='uc' id='L1641' title='2|2|2 - Total: 2'>            executeWorkList();
</span><span class='uc' id='L1642' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Replace the contents of a super block with no-ops.
         *
         * The above description is not strictly true; the last instruction is an athrow instruction.
         * This technique is borrowed from ASM's developer guide: http://asm.ow2.org/doc/developer-guide.html#deadcode
         *
         * The proposed algorithm fills a block with nop, ending it with an athrow. The stack map
         * generated would be empty locals with an exception on the stack. In theory, it shouldn't
         * matter what the locals are, as long as the stack has an exception for the athrow bit.
         * However, it turns out that if the code being modified falls into an exception handler, it
         * causes problems. Therefore, if it does, then we steal the locals from the exception block.
         *
         * If the block itself is an exception handler, we remove it from the exception table to
         * simplify block dependencies.
         */
        private void killSuperBlock(SuperBlock sb) {
<span class='uc' id='L1660' title='3|3|3 - Total: 3'>            int[] locals = new int[0];
</span><span class='uc' id='L1661' title='10|10|10 - Total: 10'>            int[] stack = new int[]{TypeInfo.OBJECT("java/lang/Throwable",
</span><span class='uc' id='L1662' title='1|1|1 - Total: 1'>                itsConstantPool)};
</span>
            // If the super block is handled by any exception handler, use its
            // locals as the killed block's locals. Ignore uninitialized
            // handlers, because they will also be killed and removed from the
            // exception table.
<span class='uc' id='L1668' title='2|2|2 - Total: 2'>            for (int i = 0; i < itsExceptionTableTop; i++) {
</span><span class='uc' id='L1669' title='6|6|6 - Total: 6'>                ExceptionTableEntry ete = itsExceptionTable[i];
</span><span class='uc' id='L1670' title='6|6|6 - Total: 6'>                int eteStart = getLabelPC(ete.itsStartLabel);
</span><span class='uc' id='L1671' title='6|6|6 - Total: 6'>                int eteEnd = getLabelPC(ete.itsEndLabel);
</span><span class='uc' id='L1672' title='6|6|6 - Total: 6'>                int handlerPC = getLabelPC(ete.itsHandlerLabel);
</span><span class='uc' id='L1673' title='4|4|4 - Total: 4'>                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);
</span><span class='uc' id='L1674' title='4|4|4 - Total: 4'>                if ((sb.getStart() > eteStart && sb.getStart() < eteEnd) ||
</span><span class='uc' id='L1675' title='4|4|4 - Total: 4'>                    (eteStart > sb.getStart() && eteStart < sb.getEnd()) &&
</span><span class='upc' id='L1676' title='1|1|1 - Total: 2'>                        handlerSB.isInitialized()) {
</span><span class='uc' id='L1677' title='3|3|3 - Total: 3'>                    locals = handlerSB.getLocals();
</span><span class='uc' id='L1678' title='1|1|1 - Total: 1'>                    break;
</span>                }
            }

            // Remove any exception table entry whose handler is the killed
            // block. This removes block dependencies to make stack maps for
            // dead blocks easier to create.
<span class='uc' id='L1685' title='2|2|2 - Total: 2'>            for (int i = 0; i < itsExceptionTableTop; i++) {
</span><span class='uc' id='L1686' title='6|6|6 - Total: 6'>                ExceptionTableEntry ete = itsExceptionTable[i];
</span><span class='uc' id='L1687' title='6|6|6 - Total: 6'>                int eteStart = getLabelPC(ete.itsStartLabel);
</span><span class='uc' id='L1688' title='2|2|2 - Total: 2'>                if (eteStart == sb.getStart()) {
</span><span class='uc' id='L1689' title='2|2|2 - Total: 2'>                    for (int j = i + 1; j < itsExceptionTableTop; j++) {
</span><span class='uc' id='L1690' title='12|12|12 - Total: 12'>                        itsExceptionTable[j - 1] = itsExceptionTable[j];
</span>                    }
<span class='uc' id='L1692' title='4|4|4 - Total: 4'>                    itsExceptionTableTop--;
</span><span class='uc' id='L1693' title='1|1|1 - Total: 1'>                    i--;
</span>                }
            }

<span class='uc' id='L1697' title='11|11|11 - Total: 11'>            sb.merge(locals, locals.length, stack, stack.length,
</span><span class='uc' id='L1698' title='1|1|1 - Total: 1'>                itsConstantPool);
</span>
<span class='uc' id='L1700' title='5|5|5 - Total: 5'>            int end = sb.getEnd() - 1;
</span><span class='uc' id='L1701' title='6|6|6 - Total: 6'>            itsCodeBuffer[end] = (byte) ByteCode.ATHROW;
</span><span class='uc' id='L1702' title='2|2|2 - Total: 2'>            for (int bci = sb.getStart(); bci < end; bci++) {
</span><span class='uc' id='L1703' title='6|6|6 - Total: 6'>                itsCodeBuffer[bci] = (byte) ByteCode.NOP;
</span>            }
<span class='uc' id='L1705' title='1|1|1 - Total: 1'>        }
</span>
        private void executeWorkList() {
<span class='uc' id='L1708' title='2|2|2 - Total: 2'>            while (workListTop > 0) {
</span><span class='uc' id='L1709' title='11|11|11 - Total: 11'>                SuperBlock work = workList[--workListTop];
</span><span class='uc' id='L1710' title='3|3|3 - Total: 3'>                work.setInQueue(false);
</span><span class='uc' id='L1711' title='4|4|4 - Total: 4'>                locals = work.getLocals();
</span><span class='uc' id='L1712' title='4|4|4 - Total: 4'>                stack = work.getStack();
</span><span class='uc' id='L1713' title='5|5|5 - Total: 5'>                localsTop = locals.length;
</span><span class='uc' id='L1714' title='5|5|5 - Total: 5'>                stackTop = stack.length;
</span><span class='uc' id='L1715' title='3|3|3 - Total: 3'>                executeBlock(work);
</span><span class='uc' id='L1716' title='1|1|1 - Total: 1'>            }
</span><span class='uc' id='L1717' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Simulate the local variable and op stack for a super block.
         */
        private void executeBlock(SuperBlock work) {
<span class='uc' id='L1723' title='2|2|2 - Total: 2'>            int bc = 0;
</span><span class='uc' id='L1724' title='2|2|2 - Total: 2'>            int next = 0;
</span>
            if (DEBUGSTACKMAP) {
                System.out.println("working on sb " + work.getIndex());
                System.out.println("initial type state:");
                TypeInfo.print(locals, localsTop, stack, stackTop,
                    itsConstantPool);
            }

<span class='uc' id='L1733' title='2|2|2 - Total: 2'>            for (int bci = work.getStart(); bci < work.getEnd(); bci += next) {
</span><span class='uc' id='L1734' title='8|8|8 - Total: 8'>                bc = itsCodeBuffer[bci] & 0xFF;
</span><span class='uc' id='L1735' title='4|4|4 - Total: 4'>                next = execute(bci);
</span>
                // If we have a branch to some super block, we need to merge
                // the current state of the local table and op stack with what's
                // currently stored as the initial state of the super block. If
                // something actually changed, we need to add it to the work
                // list.
<span class='uc' id='L1742' title='2|2|2 - Total: 2'>                if (isBranch(bc)) {
</span><span class='uc' id='L1743' title='4|4|4 - Total: 4'>                    SuperBlock targetSB = getBranchTarget(bci);
</span>                    if (DEBUGSTACKMAP) {
                        System.out.println("sb " + work.getIndex() +
                            " points to sb " +
                            targetSB.getIndex() +
                            " (offset " + bci + " -> " +
                            targetSB.getStart() + ")");
                        System.out.println("type state at " + bci + ":");
                        TypeInfo.print(locals, localsTop, stack, stackTop,
                            itsConstantPool);
                    }
<span class='uc' id='L1754' title='3|3|3 - Total: 3'>                    flowInto(targetSB);
</span>                    if (DEBUGSTACKMAP) {
                        System.out.println("type state of " + targetSB +
                            " after merge:");
                        TypeInfo.print(targetSB.getLocals(),
                            targetSB.getStack(), itsConstantPool);
                    }
<span class='uc' id='L1761' title='2|2|2 - Total: 2'>                } else if (bc == ByteCode.TABLESWITCH) {
</span><span class='uc' id='L1762' title='10|10|10 - Total: 10'>                    int switchStart = bci + 1 + (3 & ~bci); // 3 - bci % 4
</span><span class='uc' id='L1763' title='5|5|5 - Total: 5'>                    int defaultOffset = getOperand(switchStart, 4);
</span><span class='uc' id='L1764' title='4|4|4 - Total: 4'>                    SuperBlock targetSB =
</span><span class='uc' id='L1765' title='2|2|2 - Total: 2'>                        getSuperBlockFromOffset(bci + defaultOffset);
</span>                    if (DEBUGSTACK) {
                        System.out.println("merging sb " + work.getIndex() +
                            " with sb " + targetSB.getIndex());
                    }
<span class='uc' id='L1770' title='3|3|3 - Total: 3'>                    flowInto(targetSB);
</span><span class='uc' id='L1771' title='7|7|7 - Total: 7'>                    int low = getOperand(switchStart + 4, 4);
</span><span class='uc' id='L1772' title='7|7|7 - Total: 7'>                    int high = getOperand(switchStart + 8, 4);
</span><span class='uc' id='L1773' title='6|6|6 - Total: 6'>                    int numCases = high - low + 1;
</span><span class='uc' id='L1774' title='4|4|4 - Total: 4'>                    int caseBase = switchStart + 12;
</span><span class='uc' id='L1775' title='2|2|2 - Total: 2'>                    for (int i = 0; i < numCases; i++) {
</span><span class='uc' id='L1776' title='11|11|11 - Total: 11'>                        int label = bci + getOperand(caseBase + 4 * i, 4);
</span><span class='uc' id='L1777' title='4|4|4 - Total: 4'>                        targetSB = getSuperBlockFromOffset(label);
</span>                        if (DEBUGSTACKMAP) {
                            System.out.println("merging sb " +
                                work.getIndex() + " with sb " +
                                targetSB.getIndex());
                        }
<span class='uc' id='L1783' title='3|3|3 - Total: 3'>                        flowInto(targetSB);
</span>                    }
                }

<span class='uc' id='L1787' title='2|2|2 - Total: 2'>                for (int i = 0; i < itsExceptionTableTop; i++) {
</span><span class='uc' id='L1788' title='6|6|6 - Total: 6'>                    ExceptionTableEntry ete = itsExceptionTable[i];
</span><span class='uc' id='L1789' title='7|7|7 - Total: 7'>                    short startPC = (short) getLabelPC(ete.itsStartLabel);
</span><span class='uc' id='L1790' title='7|7|7 - Total: 7'>                    short endPC = (short) getLabelPC(ete.itsEndLabel);
</span><span class='uc' id='L1791' title='4|4|4 - Total: 4'>                    if (bci < startPC || bci >= endPC) {
</span><span class='uc' id='L1792' title='1|1|1 - Total: 1'>                        continue;
</span>                    }
<span class='uc' id='L1794' title='4|4|4 - Total: 4'>                    short handlerPC =
</span><span class='uc' id='L1795' title='3|3|3 - Total: 3'>                        (short) getLabelPC(ete.itsHandlerLabel);
</span><span class='uc' id='L1796' title='4|4|4 - Total: 4'>                    SuperBlock sb = getSuperBlockFromOffset(handlerPC);
</span>                    int exceptionType;

<span class='uc' id='L1799' title='2|2|2 - Total: 2'>                    if (ete.itsCatchType == 0) {
</span><span class='uc' id='L1800' title='5|5|5 - Total: 5'>                        exceptionType = TypeInfo.OBJECT(
</span><span class='uc' id='L1801' title='3|3|3 - Total: 3'>                            itsConstantPool.addClass("java/lang/Throwable"));
</span>                    } else {
<span class='uc' id='L1803' title='4|4|4 - Total: 4'>                        exceptionType = TypeInfo.OBJECT(ete.itsCatchType);
</span>                    }
<span class='uc' id='L1805' title='16|16|16 - Total: 16'>                    sb.merge(locals, localsTop, new int[]{exceptionType}, 1,
</span><span class='uc' id='L1806' title='1|1|1 - Total: 1'>                        itsConstantPool);
</span><span class='uc' id='L1807' title='3|3|3 - Total: 3'>                    addToWorkList(sb);
</span>                }
            }

            if (DEBUGSTACKMAP) {
                System.out.println("end of sb " + work.getIndex() + ":");
                TypeInfo.print(locals, localsTop, stack, stackTop,
                    itsConstantPool);
            }

            // Check the last instruction to see if it is a true end of a
            // super block (ie., if the instruction is a return). If it
            // isn't, we need to continue processing the next chunk.
<span class='uc' id='L1820' title='2|2|2 - Total: 2'>            if (!isSuperBlockEnd(bc)) {
</span><span class='uc' id='L1821' title='5|5|5 - Total: 5'>                int nextIndex = work.getIndex() + 1;
</span><span class='upc' id='L1822' title='1|1|1 - Total: 2'>                if (nextIndex < superBlocks.length) {
</span>                    if (DEBUGSTACKMAP) {
                        System.out.println("continuing from sb " +
                            work.getIndex() + " into sb " +
                            nextIndex);
                    }
<span class='uc' id='L1828' title='6|6|6 - Total: 6'>                    flowInto(superBlocks[nextIndex]);
</span>                }
            }
<span class='uc' id='L1831' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Perform a merge of type state and add the super block to the work list if the merge changed
         * anything.
         */
        private void flowInto(SuperBlock sb) {
<span class='uc' id='L1838' title='2|2|2 - Total: 2'>            if (sb.merge(locals, localsTop, stack, stackTop, itsConstantPool)) {
</span><span class='uc' id='L1839' title='3|3|3 - Total: 3'>                addToWorkList(sb);
</span>            }
<span class='uc' id='L1841' title='1|1|1 - Total: 1'>        }
</span>
        private void addToWorkList(SuperBlock sb) {
<span class='uc' id='L1844' title='2|2|2 - Total: 2'>            if (!sb.isInQueue()) {
</span><span class='uc' id='L1845' title='3|3|3 - Total: 3'>                sb.setInQueue(true);
</span><span class='uc' id='L1846' title='3|3|3 - Total: 3'>                sb.setInitialized(true);
</span><span class='uc' id='L1847' title='2|2|2 - Total: 2'>                if (workListTop == workList.length) {
</span><span class='uc' id='L1848' title='6|6|6 - Total: 6'>                    SuperBlock[] tmp = new SuperBlock[workListTop * 2];
</span><span class='uc' id='L1849' title='8|8|8 - Total: 8'>                    System.arraycopy(workList, 0, tmp, 0, workListTop);
</span><span class='uc' id='L1850' title='3|3|3 - Total: 3'>                    workList = tmp;
</span>                }
<span class='uc' id='L1852' title='11|11|11 - Total: 11'>                workList[workListTop++] = sb;
</span>            }
<span class='uc' id='L1854' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Execute a single byte code instruction.
         *
         * @param bci the index of the byte code instruction to execute
         * @return the length of the byte code instruction
         */
        private int execute(int bci) {
<span class='uc' id='L1863' title='8|8|8 - Total: 8'>            int bc = itsCodeBuffer[bci] & 0xFF;
</span>            int type, type2, index;
<span class='uc' id='L1865' title='2|2|2 - Total: 2'>            int length = 0;
</span>            long lType, lType2;
            String className;

<span class='upc' id='L1869' title='39|39|39 - Total: 52'>            switch (bc) {
</span>                case ByteCode.NOP:
                case ByteCode.IINC:
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                    // No change
<span class='uc' id='L1875' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.CHECKCAST:
<span class='uc' id='L1877' title='3|3|3 - Total: 3'>                    pop();
</span><span class='uc' id='L1878' title='9|9|9 - Total: 9'>                    push(TypeInfo.OBJECT(getOperand(bci + 1, 2)));
</span><span class='uc' id='L1879' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.IASTORE: // pop; pop; pop
                case ByteCode.LASTORE:
                case ByteCode.FASTORE:
                case ByteCode.DASTORE:
                case ByteCode.AASTORE:
                case ByteCode.BASTORE:
                case ByteCode.CASTORE:
                case ByteCode.SASTORE:
<span class='uc' id='L1888' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.PUTFIELD: // pop; pop
                case ByteCode.IF_ICMPEQ:
                case ByteCode.IF_ICMPNE:
                case ByteCode.IF_ICMPLT:
                case ByteCode.IF_ICMPGE:
                case ByteCode.IF_ICMPGT:
                case ByteCode.IF_ICMPLE:
                case ByteCode.IF_ACMPEQ:
                case ByteCode.IF_ACMPNE:
<span class='uc' id='L1899' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.IFEQ: // pop
                case ByteCode.IFNE:
                case ByteCode.IFLT:
                case ByteCode.IFGE:
                case ByteCode.IFGT:
                case ByteCode.IFLE:
                case ByteCode.IFNULL:
                case ByteCode.IFNONNULL:
                case ByteCode.POP:
                case ByteCode.MONITORENTER:
                case ByteCode.MONITOREXIT:
                case ByteCode.PUTSTATIC:
<span class='uc' id='L1913' title='3|3|3 - Total: 3'>                    pop();
</span><span class='uc' id='L1914' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.POP2:
<span class='uc' id='L1916' title='3|3|3 - Total: 3'>                    pop2();
</span><span class='uc' id='L1917' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ACONST_NULL:
<span class='uc' id='L1919' title='3|3|3 - Total: 3'>                    push(TypeInfo.NULL);
</span><span class='uc' id='L1920' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.IALOAD: // pop; pop; push(INTEGER)
                case ByteCode.BALOAD:
                case ByteCode.CALOAD:
                case ByteCode.SALOAD:
                case ByteCode.IADD:
                case ByteCode.ISUB:
                case ByteCode.IMUL:
                case ByteCode.IDIV:
                case ByteCode.IREM:
                case ByteCode.ISHL:
                case ByteCode.ISHR:
                case ByteCode.IUSHR:
                case ByteCode.IAND:
                case ByteCode.IOR:
                case ByteCode.IXOR:
                case ByteCode.LCMP:
                case ByteCode.FCMPL:
                case ByteCode.FCMPG:
                case ByteCode.DCMPL:
                case ByteCode.DCMPG:
<span class='uc' id='L1941' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.INEG: // pop; push(INTEGER)
                case ByteCode.L2I:
                case ByteCode.F2I:
                case ByteCode.D2I:
                case ByteCode.I2B:
                case ByteCode.I2C:
                case ByteCode.I2S:
                case ByteCode.ARRAYLENGTH:
                case ByteCode.INSTANCEOF:
<span class='uc' id='L1952' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.ICONST_M1: // push(INTEGER)
                case ByteCode.ICONST_0:
                case ByteCode.ICONST_1:
                case ByteCode.ICONST_2:
                case ByteCode.ICONST_3:
                case ByteCode.ICONST_4:
                case ByteCode.ICONST_5:
                case ByteCode.ILOAD:
                case ByteCode.ILOAD_0:
                case ByteCode.ILOAD_1:
                case ByteCode.ILOAD_2:
                case ByteCode.ILOAD_3:
                case ByteCode.BIPUSH:
                case ByteCode.SIPUSH:
<span class='uc' id='L1968' title='3|3|3 - Total: 3'>                    push(TypeInfo.INTEGER);
</span><span class='uc' id='L1969' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.LALOAD: // pop; pop; push(LONG)
                case ByteCode.LADD:
                case ByteCode.LSUB:
                case ByteCode.LMUL:
                case ByteCode.LDIV:
                case ByteCode.LREM:
                case ByteCode.LSHL:
                case ByteCode.LSHR:
                case ByteCode.LUSHR:
                case ByteCode.LAND:
                case ByteCode.LOR:
                case ByteCode.LXOR:
<span class='uc' id='L1982' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.LNEG: // pop; push(LONG)
                case ByteCode.I2L:
                case ByteCode.F2L:
                case ByteCode.D2L:
<span class='uc' id='L1988' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.LCONST_0: // push(LONG)
                case ByteCode.LCONST_1:
                case ByteCode.LLOAD:
                case ByteCode.LLOAD_0:
                case ByteCode.LLOAD_1:
                case ByteCode.LLOAD_2:
                case ByteCode.LLOAD_3:
<span class='uc' id='L1997' title='3|3|3 - Total: 3'>                    push(TypeInfo.LONG);
</span><span class='uc' id='L1998' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.FALOAD: // pop; pop; push(FLOAT)
                case ByteCode.FADD:
                case ByteCode.FSUB:
                case ByteCode.FMUL:
                case ByteCode.FDIV:
                case ByteCode.FREM:
<span class='nc' id='L2005' title='0|0|0 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.FNEG: // pop; push(FLOAT)
                case ByteCode.I2F:
                case ByteCode.L2F:
                case ByteCode.D2F:
<span class='nc' id='L2011' title='0|0|0 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.FCONST_0: // push(FLOAT)
                case ByteCode.FCONST_1:
                case ByteCode.FCONST_2:
                case ByteCode.FLOAD:
                case ByteCode.FLOAD_0:
                case ByteCode.FLOAD_1:
                case ByteCode.FLOAD_2:
                case ByteCode.FLOAD_3:
<span class='uc' id='L2021' title='3|3|3 - Total: 3'>                    push(TypeInfo.FLOAT);
</span><span class='uc' id='L2022' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DALOAD: // pop; pop; push(DOUBLE)
                case ByteCode.DADD:
                case ByteCode.DSUB:
                case ByteCode.DMUL:
                case ByteCode.DDIV:
                case ByteCode.DREM:
<span class='uc' id='L2029' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.DNEG: // pop; push(DOUBLE)
                case ByteCode.I2D:
                case ByteCode.L2D:
                case ByteCode.F2D:
<span class='uc' id='L2035' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.DCONST_0: // push(DOUBLE)
                case ByteCode.DCONST_1:
                case ByteCode.DLOAD:
                case ByteCode.DLOAD_0:
                case ByteCode.DLOAD_1:
                case ByteCode.DLOAD_2:
                case ByteCode.DLOAD_3:
<span class='uc' id='L2044' title='3|3|3 - Total: 3'>                    push(TypeInfo.DOUBLE);
</span><span class='uc' id='L2045' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ISTORE:
<span class='uc' id='L2047' title='2|2|2 - Total: 2'>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.INTEGER);
</span><span class='uc' id='L2048' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ISTORE_0:
                case ByteCode.ISTORE_1:
                case ByteCode.ISTORE_2:
                case ByteCode.ISTORE_3:
<span class='nc' id='L2053' title='0|0|0 - Total: 6'>                    executeStore(bc - ByteCode.ISTORE_0, TypeInfo.INTEGER);
</span><span class='nc' id='L2054' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.LSTORE:
<span class='nc' id='L2056' title='0|0|0 - Total: 2'>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.LONG);
</span><span class='nc' id='L2057' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.LSTORE_0:
                case ByteCode.LSTORE_1:
                case ByteCode.LSTORE_2:
                case ByteCode.LSTORE_3:
<span class='nc' id='L2062' title='0|0|0 - Total: 6'>                    executeStore(bc - ByteCode.LSTORE_0, TypeInfo.LONG);
</span><span class='nc' id='L2063' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.FSTORE:
<span class='nc' id='L2065' title='0|0|0 - Total: 2'>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.FLOAT);
</span><span class='nc' id='L2066' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.FSTORE_0:
                case ByteCode.FSTORE_1:
                case ByteCode.FSTORE_2:
                case ByteCode.FSTORE_3:
<span class='nc' id='L2071' title='0|0|0 - Total: 6'>                    executeStore(bc - ByteCode.FSTORE_0, TypeInfo.FLOAT);
</span><span class='nc' id='L2072' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.DSTORE:
<span class='uc' id='L2074' title='2|2|2 - Total: 2'>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.DOUBLE);
</span><span class='uc' id='L2075' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DSTORE_0:
                case ByteCode.DSTORE_1:
                case ByteCode.DSTORE_2:
                case ByteCode.DSTORE_3:
<span class='nc' id='L2080' title='0|0|0 - Total: 6'>                    executeStore(bc - ByteCode.DSTORE_0, TypeInfo.DOUBLE);
</span><span class='nc' id='L2081' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.ALOAD:
<span class='upc' id='L2083' title='1|1|1 - Total: 2'>                    executeALoad(getOperand(bci + 1, wide ? 2 : 1));
</span><span class='uc' id='L2084' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ALOAD_0:
                case ByteCode.ALOAD_1:
                case ByteCode.ALOAD_2:
                case ByteCode.ALOAD_3:
<span class='uc' id='L2089' title='5|5|5 - Total: 5'>                    executeALoad(bc - ByteCode.ALOAD_0);
</span><span class='uc' id='L2090' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ASTORE:
<span class='upc' id='L2092' title='1|1|1 - Total: 2'>                    executeAStore(getOperand(bci + 1, wide ? 2 : 1));
</span><span class='uc' id='L2093' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ASTORE_0:
                case ByteCode.ASTORE_1:
                case ByteCode.ASTORE_2:
                case ByteCode.ASTORE_3:
<span class='uc' id='L2098' title='5|5|5 - Total: 5'>                    executeAStore(bc - ByteCode.ASTORE_0);
</span><span class='uc' id='L2099' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.IRETURN:
                case ByteCode.LRETURN:
                case ByteCode.FRETURN:
                case ByteCode.DRETURN:
                case ByteCode.ARETURN:
                case ByteCode.RETURN:
<span class='uc' id='L2106' title='2|2|2 - Total: 2'>                    clearStack();
</span><span class='uc' id='L2107' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ATHROW:
<span class='uc' id='L2109' title='3|3|3 - Total: 3'>                    type = pop();
</span><span class='uc' id='L2110' title='2|2|2 - Total: 2'>                    clearStack();
</span><span class='uc' id='L2111' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2112' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.SWAP:
<span class='uc' id='L2114' title='3|3|3 - Total: 3'>                    type = pop();
</span><span class='uc' id='L2115' title='3|3|3 - Total: 3'>                    type2 = pop();
</span><span class='uc' id='L2116' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2117' title='3|3|3 - Total: 3'>                    push(type2);
</span><span class='uc' id='L2118' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.LDC:
                case ByteCode.LDC_W:
                case ByteCode.LDC2_W:
<span class='uc' id='L2122' title='2|2|2 - Total: 2'>                    if (bc == ByteCode.LDC) {
</span><span class='uc' id='L2123' title='7|7|7 - Total: 7'>                        index = getOperand(bci + 1);
</span>                    } else {
<span class='uc' id='L2125' title='7|7|7 - Total: 7'>                        index = getOperand(bci + 1, 2);
</span>                    }
<span class='uc' id='L2127' title='6|6|6 - Total: 6'>                    byte constType = itsConstantPool.getConstantType(index);
</span><span class='upc' id='L2128' title='3|3|3 - Total: 6'>                    switch (constType) {
</span>                        case ConstantPool.CONSTANT_Double:
<span class='uc' id='L2130' title='3|3|3 - Total: 3'>                            push(TypeInfo.DOUBLE);
</span><span class='uc' id='L2131' title='1|1|1 - Total: 1'>                            break;
</span>                        case ConstantPool.CONSTANT_Float:
<span class='nc' id='L2133' title='0|0|0 - Total: 3'>                            push(TypeInfo.FLOAT);
</span><span class='nc' id='L2134' title='0|0|0 - Total: 1'>                            break;
</span>                        case ConstantPool.CONSTANT_Long:
<span class='nc' id='L2136' title='0|0|0 - Total: 3'>                            push(TypeInfo.LONG);
</span><span class='nc' id='L2137' title='0|0|0 - Total: 1'>                            break;
</span>                        case ConstantPool.CONSTANT_Integer:
<span class='uc' id='L2139' title='3|3|3 - Total: 3'>                            push(TypeInfo.INTEGER);
</span><span class='uc' id='L2140' title='1|1|1 - Total: 1'>                            break;
</span>                        case ConstantPool.CONSTANT_String:
<span class='uc' id='L2142' title='6|6|6 - Total: 6'>                            push(TypeInfo.OBJECT("java/lang/String",
</span><span class='uc' id='L2143' title='1|1|1 - Total: 1'>                                itsConstantPool));
</span><span class='uc' id='L2144' title='1|1|1 - Total: 1'>                            break;
</span>                        default:
<span class='nc' id='L2146' title='0|0|0 - Total: 12'>                            throw new IllegalArgumentException(
</span>                                "bad const type " + constType);
                    }
                    break;
                case ByteCode.NEW:
<span class='uc' id='L2151' title='4|4|4 - Total: 4'>                    push(TypeInfo.UNINITIALIZED_VARIABLE(bci));
</span><span class='uc' id='L2152' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.NEWARRAY:
<span class='uc' id='L2154' title='3|3|3 - Total: 3'>                    pop();
</span><span class='uc' id='L2155' title='2|2|2 - Total: 2'>                    char componentType =
</span><span class='uc' id='L2156' title='7|7|7 - Total: 7'>                        arrayTypeToName(itsCodeBuffer[bci + 1]);
</span><span class='uc' id='L2157' title='13|13|13 - Total: 13'>                    index = itsConstantPool.addClass("[" + componentType);
</span><span class='uc' id='L2158' title='5|5|5 - Total: 5'>                    push(TypeInfo.OBJECT((short) index));
</span><span class='uc' id='L2159' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.ANEWARRAY:
<span class='uc' id='L2161' title='7|7|7 - Total: 7'>                    index = getOperand(bci + 1, 2);
</span><span class='uc' id='L2162' title='7|7|7 - Total: 7'>                    className = (String) itsConstantPool.getConstantData(index);
</span><span class='uc' id='L2163' title='3|3|3 - Total: 3'>                    pop();
</span><span class='uc' id='L2164' title='15|15|15 - Total: 15'>                    push(TypeInfo.OBJECT("[L" + className + ';',
</span><span class='uc' id='L2165' title='1|1|1 - Total: 1'>                        itsConstantPool));
</span><span class='uc' id='L2166' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.INVOKEVIRTUAL:
                case ByteCode.INVOKESPECIAL:
                case ByteCode.INVOKESTATIC:
                case ByteCode.INVOKEINTERFACE:
<span class='uc' id='L2171' title='7|7|7 - Total: 7'>                    index = getOperand(bci + 1, 2);
</span><span class='uc' id='L2172' title='2|2|2 - Total: 2'>                    FieldOrMethodRef m = (FieldOrMethodRef)
</span><span class='uc' id='L2173' title='5|5|5 - Total: 5'>                        itsConstantPool.getConstantData(index);
</span><span class='uc' id='L2174' title='3|3|3 - Total: 3'>                    String methodType = m.getType();
</span><span class='uc' id='L2175' title='3|3|3 - Total: 3'>                    String methodName = m.getName();
</span><span class='uc' id='L2176' title='5|5|5 - Total: 5'>                    int parameterCount = sizeOfParameters(methodType) >>> 16;
</span><span class='uc' id='L2177' title='2|2|2 - Total: 2'>                    for (int i = 0; i < parameterCount; i++) {
</span><span class='uc' id='L2178' title='3|3|3 - Total: 3'>                        pop();
</span>                    }
<span class='uc' id='L2180' title='2|2|2 - Total: 2'>                    if (bc != ByteCode.INVOKESTATIC) {
</span><span class='uc' id='L2181' title='3|3|3 - Total: 3'>                        int instType = pop();
</span><span class='uc' id='L2182' title='3|3|3 - Total: 3'>                        int tag = TypeInfo.getTag(instType);
</span><span class='uc' id='L2183' title='4|4|4 - Total: 4'>                        if (tag == TypeInfo.UNINITIALIZED_VARIABLE(0) ||
</span>                            tag == TypeInfo.UNINITIALIZED_THIS) {
<span class='upc' id='L2185' title='1|1|1 - Total: 2'>                            if ("<init>".equals(methodName)) {
</span><span class='uc' id='L2186' title='2|2|2 - Total: 2'>                                int newType =
</span><span class='uc' id='L2187' title='3|3|3 - Total: 3'>                                    TypeInfo.OBJECT(itsThisClassIndex);
</span><span class='uc' id='L2188' title='4|4|4 - Total: 4'>                                initializeTypeInfo(instType, newType);
</span><span class='uc' id='L2189' title='1|1|1 - Total: 1'>                            } else {
</span><span class='nc' id='L2190' title='0|0|0 - Total: 5'>                                throw new IllegalStateException("bad instance");
</span>                            }
                        }
                    }
<span class='uc' id='L2194' title='4|4|4 - Total: 4'>                    int rParen = methodType.indexOf(')');
</span><span class='uc' id='L2195' title='6|6|6 - Total: 6'>                    String returnType = methodType.substring(rParen + 1);
</span><span class='uc' id='L2196' title='3|3|3 - Total: 3'>                    returnType = descriptorToInternalName(returnType);
</span><span class='uc' id='L2197' title='2|2|2 - Total: 2'>                    if (!returnType.equals("V")) {
</span><span class='uc' id='L2198' title='8|8|8 - Total: 8'>                        push(TypeInfo.fromType(returnType, itsConstantPool));
</span>                    }
                    break;
                case ByteCode.INVOKEDYNAMIC:
<span class='nc' id='L2202' title='0|0|0 - Total: 7'>                    index = getOperand(bci + 1, 2);
</span><span class='nc' id='L2203' title='0|0|0 - Total: 7'>                    methodType = (String) itsConstantPool.getConstantData(index);
</span><span class='nc' id='L2204' title='0|0|0 - Total: 5'>                    parameterCount = sizeOfParameters(methodType) >>> 16;
</span><span class='nc' id='L2205' title='0|0|0 - Total: 2'>                    for (int i = 0; i < parameterCount; i++) {
</span><span class='nc' id='L2206' title='0|0|0 - Total: 3'>                        pop();
</span>                    }
<span class='nc' id='L2208' title='0|0|0 - Total: 4'>                    rParen = methodType.indexOf(')');
</span><span class='nc' id='L2209' title='0|0|0 - Total: 6'>                    returnType = methodType.substring(rParen + 1);
</span><span class='nc' id='L2210' title='0|0|0 - Total: 3'>                    returnType = descriptorToInternalName(returnType);
</span><span class='nc' id='L2211' title='0|0|0 - Total: 2'>                    if (!returnType.equals("V")) {
</span><span class='nc' id='L2212' title='0|0|0 - Total: 8'>                        push(TypeInfo.fromType(returnType, itsConstantPool));
</span>                    }
                    break;
                case ByteCode.GETFIELD:
<span class='uc' id='L2216' title='3|3|3 - Total: 3'>                    pop();
</span>                    // fallthru
                case ByteCode.GETSTATIC:
<span class='uc' id='L2219' title='7|7|7 - Total: 7'>                    index = getOperand(bci + 1, 2);
</span><span class='uc' id='L2220' title='2|2|2 - Total: 2'>                    FieldOrMethodRef f = (FieldOrMethodRef)
</span><span class='uc' id='L2221' title='5|5|5 - Total: 5'>                        itsConstantPool.getConstantData(index);
</span><span class='uc' id='L2222' title='4|4|4 - Total: 4'>                    String fieldType = descriptorToInternalName(f.getType());
</span><span class='uc' id='L2223' title='7|7|7 - Total: 7'>                    push(TypeInfo.fromType(fieldType, itsConstantPool));
</span><span class='uc' id='L2224' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DUP:
<span class='uc' id='L2226' title='3|3|3 - Total: 3'>                    type = pop();
</span><span class='uc' id='L2227' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2228' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2229' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DUP_X1:
<span class='uc' id='L2231' title='3|3|3 - Total: 3'>                    type = pop();
</span><span class='uc' id='L2232' title='3|3|3 - Total: 3'>                    type2 = pop();
</span><span class='uc' id='L2233' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2234' title='3|3|3 - Total: 3'>                    push(type2);
</span><span class='uc' id='L2235' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2236' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DUP_X2:
<span class='nc' id='L2238' title='0|0|0 - Total: 3'>                    type = pop();
</span><span class='nc' id='L2239' title='0|0|0 - Total: 3'>                    lType = pop2();
</span><span class='nc' id='L2240' title='0|0|0 - Total: 3'>                    push(type);
</span><span class='nc' id='L2241' title='0|0|0 - Total: 3'>                    push2(lType);
</span><span class='nc' id='L2242' title='0|0|0 - Total: 3'>                    push(type);
</span><span class='nc' id='L2243' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.DUP2:
<span class='uc' id='L2245' title='3|3|3 - Total: 3'>                    lType = pop2();
</span><span class='uc' id='L2246' title='3|3|3 - Total: 3'>                    push2(lType);
</span><span class='uc' id='L2247' title='3|3|3 - Total: 3'>                    push2(lType);
</span><span class='uc' id='L2248' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DUP2_X1:
<span class='uc' id='L2250' title='3|3|3 - Total: 3'>                    lType = pop2();
</span><span class='uc' id='L2251' title='3|3|3 - Total: 3'>                    type = pop();
</span><span class='uc' id='L2252' title='3|3|3 - Total: 3'>                    push2(lType);
</span><span class='uc' id='L2253' title='3|3|3 - Total: 3'>                    push(type);
</span><span class='uc' id='L2254' title='3|3|3 - Total: 3'>                    push2(lType);
</span><span class='uc' id='L2255' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.DUP2_X2:
<span class='nc' id='L2257' title='0|0|0 - Total: 3'>                    lType = pop2();
</span><span class='nc' id='L2258' title='0|0|0 - Total: 3'>                    lType2 = pop2();
</span><span class='nc' id='L2259' title='0|0|0 - Total: 3'>                    push2(lType);
</span><span class='nc' id='L2260' title='0|0|0 - Total: 3'>                    push2(lType2);
</span><span class='nc' id='L2261' title='0|0|0 - Total: 3'>                    push2(lType);
</span><span class='nc' id='L2262' title='0|0|0 - Total: 1'>                    break;
</span>                case ByteCode.TABLESWITCH:
<span class='uc' id='L2264' title='10|10|10 - Total: 10'>                    int switchStart = bci + 1 + (3 & ~bci);
</span><span class='uc' id='L2265' title='7|7|7 - Total: 7'>                    int low = getOperand(switchStart + 4, 4);
</span><span class='uc' id='L2266' title='7|7|7 - Total: 7'>                    int high = getOperand(switchStart + 8, 4);
</span><span class='uc' id='L2267' title='12|12|12 - Total: 12'>                    length = 4 * (high - low + 4) + switchStart - bci;
</span><span class='uc' id='L2268' title='3|3|3 - Total: 3'>                    pop();
</span><span class='uc' id='L2269' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.AALOAD:
<span class='uc' id='L2271' title='3|3|3 - Total: 3'>                    pop();
</span><span class='uc' id='L2272' title='5|5|5 - Total: 5'>                    int typeIndex = pop() >>> 8;
</span><span class='uc' id='L2273' title='2|2|2 - Total: 2'>                    className =
</span><span class='uc' id='L2274' title='5|5|5 - Total: 5'>                        (String) itsConstantPool.getConstantData(typeIndex);
</span><span class='uc' id='L2275' title='2|2|2 - Total: 2'>                    String arrayType = className;
</span><span class='upc' id='L2276' title='1|1|1 - Total: 2'>                    if (arrayType.charAt(0) != '[') {
</span><span class='nc' id='L2277' title='0|0|0 - Total: 5'>                        throw new IllegalStateException("bad array type");
</span>                    }
<span class='uc' id='L2279' title='4|4|4 - Total: 4'>                    String elementDesc = arrayType.substring(1);
</span><span class='uc' id='L2280' title='3|3|3 - Total: 3'>                    String elementType = descriptorToInternalName(elementDesc);
</span><span class='uc' id='L2281' title='6|6|6 - Total: 6'>                    typeIndex = itsConstantPool.addClass(elementType);
</span><span class='uc' id='L2282' title='4|4|4 - Total: 4'>                    push(TypeInfo.OBJECT(typeIndex));
</span><span class='uc' id='L2283' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.WIDE:
                    // Alters behaviour of next instruction
<span class='uc' id='L2286' title='3|3|3 - Total: 3'>                    wide = true;
</span><span class='uc' id='L2287' title='1|1|1 - Total: 1'>                    break;
</span>                case ByteCode.MULTIANEWARRAY:
                case ByteCode.LOOKUPSWITCH:
                    // Currently not used in any part of Rhino, so ignore it
                case ByteCode.JSR: // TODO: JSR is deprecated
                case ByteCode.RET:
                case ByteCode.JSR_W:
                default:
<span class='nc' id='L2295' title='0|0|0 - Total: 12'>                    throw new IllegalArgumentException("bad opcode: " + bc);
</span>            }

<span class='uc' id='L2298' title='2|2|2 - Total: 2'>            if (length == 0) {
</span><span class='uc' id='L2299' title='5|5|5 - Total: 5'>                length = opcodeLength(bc, wide);
</span>            }
<span class='uc' id='L2301' title='4|4|4 - Total: 4'>            if (wide && bc != ByteCode.WIDE) {
</span><span class='uc' id='L2302' title='3|3|3 - Total: 3'>                wide = false;
</span>            }
<span class='uc' id='L2304' title='2|2|2 - Total: 2'>            return length;
</span>        }

        private void executeALoad(int localIndex) {
<span class='uc' id='L2308' title='4|4|4 - Total: 4'>            int type = getLocal(localIndex);
</span><span class='uc' id='L2309' title='3|3|3 - Total: 3'>            int tag = TypeInfo.getTag(type);
</span><span class='upc' id='L2310' title='6|6|6 - Total: 8'>            if (tag == TypeInfo.OBJECT_TAG ||
</span>                tag == TypeInfo.UNINITIALIZED_THIS ||
                tag == TypeInfo.UNINITIALIZED_VAR_TAG ||
                tag == TypeInfo.NULL) {
<span class='uc' id='L2314' title='4|4|4 - Total: 4'>                push(type);
</span>            } else {
<span class='nc' id='L2316' title='0|0|0 - Total: 16'>                throw new IllegalStateException("bad local variable type: " +
</span>                    type + " at index: " +
                    localIndex);
            }
<span class='uc' id='L2320' title='1|1|1 - Total: 1'>        }
</span>
        private void executeAStore(int localIndex) {
<span class='uc' id='L2323' title='5|5|5 - Total: 5'>            setLocal(localIndex, pop());
</span><span class='uc' id='L2324' title='1|1|1 - Total: 1'>        }
</span>
        private void executeStore(int localIndex, int typeInfo) {
<span class='uc' id='L2327' title='3|3|3 - Total: 3'>            pop();
</span><span class='uc' id='L2328' title='4|4|4 - Total: 4'>            setLocal(localIndex, typeInfo);
</span><span class='uc' id='L2329' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Change an UNINITIALIZED_OBJECT or UNINITIALIZED_THIS to the proper type of the object. This
         * occurs when the proper constructor is invoked.
         */
        private void initializeTypeInfo(int prevType, int newType) {
<span class='uc' id='L2336' title='8|8|8 - Total: 8'>            initializeTypeInfo(prevType, newType, locals, localsTop);
</span><span class='uc' id='L2337' title='8|8|8 - Total: 8'>            initializeTypeInfo(prevType, newType, stack, stackTop);
</span><span class='uc' id='L2338' title='1|1|1 - Total: 1'>        }
</span>
        private void initializeTypeInfo(int prevType, int newType, int[] data,
            int dataTop) {
<span class='uc' id='L2342' title='2|2|2 - Total: 2'>            for (int i = 0; i < dataTop; i++) {
</span><span class='uc' id='L2343' title='2|2|2 - Total: 2'>                if (data[i] == prevType) {
</span><span class='uc' id='L2344' title='4|4|4 - Total: 4'>                    data[i] = newType;
</span>                }
            }
<span class='uc' id='L2347' title='1|1|1 - Total: 1'>        }
</span>
        private int getLocal(int localIndex) {
<span class='upc' id='L2350' title='1|1|1 - Total: 2'>            if (localIndex < localsTop) {
</span><span class='uc' id='L2351' title='5|5|5 - Total: 5'>                return locals[localIndex];
</span>            } else {
<span class='nc' id='L2353' title='0|0|0 - Total: 2'>                return TypeInfo.TOP;
</span>            }
        }

        private void setLocal(int localIndex, int typeInfo) {
<span class='upc' id='L2358' title='1|1|1 - Total: 2'>            if (localIndex >= localsTop) {
</span><span class='nc' id='L2359' title='0|0|0 - Total: 5'>                int[] tmp = new int[localIndex + 1];
</span><span class='nc' id='L2360' title='0|0|0 - Total: 8'>                System.arraycopy(locals, 0, tmp, 0, localsTop);
</span><span class='nc' id='L2361' title='0|0|0 - Total: 3'>                locals = tmp;
</span><span class='nc' id='L2362' title='0|0|0 - Total: 5'>                localsTop = localIndex + 1;
</span>            }
<span class='uc' id='L2364' title='5|5|5 - Total: 5'>            locals[localIndex] = typeInfo;
</span><span class='uc' id='L2365' title='1|1|1 - Total: 1'>        }
</span>
        private void push(int typeInfo) {
<span class='uc' id='L2368' title='2|2|2 - Total: 2'>            if (stackTop == stack.length) {
</span><span class='uc' id='L2369' title='8|8|8 - Total: 8'>                int[] tmp = new int[Math.max(stackTop * 2, 4)];
</span><span class='uc' id='L2370' title='8|8|8 - Total: 8'>                System.arraycopy(stack, 0, tmp, 0, stackTop);
</span><span class='uc' id='L2371' title='3|3|3 - Total: 3'>                stack = tmp;
</span>            }
<span class='uc' id='L2373' title='11|11|11 - Total: 11'>            stack[stackTop++] = typeInfo;
</span><span class='uc' id='L2374' title='1|1|1 - Total: 1'>        }
</span>
        private int pop() {
<span class='uc' id='L2377' title='11|11|11 - Total: 11'>            return stack[--stackTop];
</span>        }

        /**
         * Push two words onto the op stack.
         *
         * This is only meant to be used as a complement to pop2(), and both methods are helpers for the
         * more complex DUP operations.
         */
        private void push2(long typeInfo) {
<span class='uc' id='L2387' title='6|6|6 - Total: 6'>            push((int) (typeInfo & 0xFFFFFF));
</span><span class='uc' id='L2388' title='4|4|4 - Total: 4'>            typeInfo >>>= 32;
</span><span class='upc' id='L2389' title='1|1|1 - Total: 2'>            if (typeInfo != 0) {
</span><span class='nc' id='L2390' title='0|0|0 - Total: 6'>                push((int) (typeInfo & 0xFFFFFF));
</span>            }
<span class='uc' id='L2392' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Pop two words from the op stack.
         *
         * If the top of the stack is a DOUBLE or LONG, then the bottom 32 bits reflects the appropriate
         * type and the top 32 bits are 0. Otherwise, the top 32 bits are the first word on the stack
         * and the lower 32 bits are the second word on the stack.
         */
        private long pop2() {
<span class='uc' id='L2402' title='4|4|4 - Total: 4'>            long type = pop();
</span><span class='upc' id='L2403' title='1|1|1 - Total: 2'>            if (TypeInfo.isTwoWords((int) type)) {
</span><span class='uc' id='L2404' title='2|2|2 - Total: 2'>                return type;
</span>            } else {
<span class='nc' id='L2406' title='0|0|0 - Total: 10'>                return type << 32 | (pop() & 0xFFFFFF);
</span>            }
        }

        private void clearStack() {
<span class='uc' id='L2411' title='3|3|3 - Total: 3'>            stackTop = 0;
</span><span class='uc' id='L2412' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Compute the output size of the stack map table.
         *
         * Because this would share much in common with actual writing of the stack map table, we
         * instead just write the stack map table to a buffer and return the size from it. The buffer is
         * later used in the actual writing of bytecode.
         */
        int computeWriteSize() {
            // Allocate a buffer that can handle the worst case size of the
            // stack map to prevent lots of reallocations.
<span class='uc' id='L2424' title='3|3|3 - Total: 3'>            int writeSize = getWorstCaseWriteSize();
</span><span class='uc' id='L2425' title='4|4|4 - Total: 4'>            rawStackMap = new byte[writeSize];
</span><span class='uc' id='L2426' title='2|2|2 - Total: 2'>            computeRawStackMap();
</span><span class='uc' id='L2427' title='5|5|5 - Total: 5'>            return rawStackMapTop + 2;
</span>        }

        int write(byte[] data, int offset) {
<span class='uc' id='L2431' title='8|8|8 - Total: 8'>            offset = putInt32(rawStackMapTop + 2, data, offset);
</span><span class='uc' id='L2432' title='9|9|9 - Total: 9'>            offset = putInt16(superBlocks.length - 1, data, offset);
</span><span class='uc' id='L2433' title='8|8|8 - Total: 8'>            System.arraycopy(rawStackMap, 0, data, offset, rawStackMapTop);
</span><span class='uc' id='L2434' title='5|5|5 - Total: 5'>            return offset + rawStackMapTop;
</span>        }

        /**
         * Compute a space-optimal stack map table.
         */
        private void computeRawStackMap() {
<span class='uc' id='L2441' title='5|5|5 - Total: 5'>            SuperBlock prev = superBlocks[0];
</span><span class='uc' id='L2442' title='3|3|3 - Total: 3'>            int[] prevLocals = prev.getTrimmedLocals();
</span><span class='uc' id='L2443' title='2|2|2 - Total: 2'>            int prevOffset = -1;
</span><span class='uc' id='L2444' title='2|2|2 - Total: 2'>            for (int i = 1; i < superBlocks.length; i++) {
</span><span class='uc' id='L2445' title='5|5|5 - Total: 5'>                SuperBlock current = superBlocks[i];
</span><span class='uc' id='L2446' title='3|3|3 - Total: 3'>                int[] currentLocals = current.getTrimmedLocals();
</span><span class='uc' id='L2447' title='3|3|3 - Total: 3'>                int[] currentStack = current.getStack();
</span><span class='uc' id='L2448' title='7|7|7 - Total: 7'>                int offsetDelta = current.getStart() - prevOffset - 1;
</span>
<span class='uc' id='L2450' title='2|2|2 - Total: 2'>                if (currentStack.length == 0) {
</span><span class='uc' id='L2451' title='2|2|2 - Total: 2'>                    int last = prevLocals.length > currentLocals.length ?
</span>                        currentLocals.length : prevLocals.length;
<span class='uc' id='L2453' title='7|7|7 - Total: 7'>                    int delta = Math.abs(prevLocals.length -
</span>                        currentLocals.length);
                    int j;
                    // Compare locals until one is different or the end of a
                    // local variable array is reached
<span class='uc' id='L2458' title='2|2|2 - Total: 2'>                    for (j = 0; j < last; j++) {
</span><span class='uc' id='L2459' title='2|2|2 - Total: 2'>                        if (prevLocals[j] != currentLocals[j]) {
</span><span class='uc' id='L2460' title='1|1|1 - Total: 1'>                            break;
</span>                        }
                    }
<span class='uc' id='L2463' title='4|4|4 - Total: 4'>                    if (j == currentLocals.length && delta == 0) {
</span>                        // All of the compared locals are equal and the local
                        // arrays are of equal size
<span class='uc' id='L2466' title='5|5|5 - Total: 5'>                        writeSameFrame(currentLocals, offsetDelta);
</span><span class='uc' id='L2467' title='4|4|4 - Total: 4'>                    } else if (j == currentLocals.length && delta <= 3) {
</span>                        // All of the compared locals are equal and the current
                        // frame has less locals than the previous frame
<span class='uc' id='L2470' title='5|5|5 - Total: 5'>                        writeChopFrame(delta, offsetDelta);
</span><span class='uc' id='L2471' title='4|4|4 - Total: 4'>                    } else if (j == prevLocals.length && delta <= 3) {
</span>                        // All of the compared locals are equal and the current
                        // frame has more locals than the previous frame
<span class='uc' id='L2474' title='6|6|6 - Total: 6'>                        writeAppendFrame(currentLocals, delta, offsetDelta);
</span>                    } else {
                        // Not all locals were compared were equal, so a full
                        // frame is necessary
<span class='uc' id='L2478' title='5|5|5 - Total: 5'>                        writeFullFrame(currentLocals, currentStack,
</span>                            offsetDelta);
                    }
<span class='uc' id='L2481' title='2|2|2 - Total: 2'>                } else if (currentStack.length == 1) {
</span><span class='uc' id='L2482' title='2|2|2 - Total: 2'>                    if (Arrays.equals(prevLocals, currentLocals)) {
</span><span class='uc' id='L2483' title='6|6|6 - Total: 6'>                        writeSameLocalsOneStackItemFrame(currentLocals,
</span>                            currentStack,
                            offsetDelta);
                    } else {
                        // Output a full frame, since no other frame types have
                        // one operand stack item.
<span class='uc' id='L2489' title='6|6|6 - Total: 6'>                        writeFullFrame(currentLocals, currentStack,
</span>                            offsetDelta);
                    }
                } else {
                    // Any stack map frame that has more than one operand stack
                    // item has to be a full frame. All other frame types have
                    // at most one item on the stack.
<span class='uc' id='L2496' title='5|5|5 - Total: 5'>                    writeFullFrame(currentLocals, currentStack, offsetDelta);
</span>                }

<span class='uc' id='L2499' title='2|2|2 - Total: 2'>                prev = current;
</span><span class='uc' id='L2500' title='2|2|2 - Total: 2'>                prevLocals = currentLocals;
</span><span class='uc' id='L2501' title='3|3|3 - Total: 3'>                prevOffset = current.getStart();
</span>            }
<span class='uc' id='L2503' title='1|1|1 - Total: 1'>        }
</span>
        /**
         * Get the worst case write size of the stack map table.
         *
         * This computes how much full frames would take, if each full frame contained the maximum
         * number of locals and stack operands, and each verification type was 3 bytes.
         */
        private int getWorstCaseWriteSize() {
<span class='uc' id='L2512' title='15|15|15 - Total: 15'>            return (superBlocks.length - 1) * (7 + itsMaxLocals * 3 +
</span><span class='uc' id='L2513' title='5|5|5 - Total: 5'>                itsMaxStack * 3);
</span>        }

        private void writeSameFrame(int[] locals, int offsetDelta) {
<span class='uc' id='L2517' title='2|2|2 - Total: 2'>            if (offsetDelta <= 63) {
</span>                // Output a same_frame frame. Despite the name,
                // the operand stack may differ, but the current
                // operand stack must be empty.
<span class='uc' id='L2521' title='13|13|13 - Total: 13'>                rawStackMap[rawStackMapTop++] = (byte) offsetDelta;
</span>            } else {
                // Output a same_frame_extended frame. Similar to
                // the above, except with a larger offset delta.
<span class='uc' id='L2525' title='11|11|11 - Total: 11'>                rawStackMap[rawStackMapTop++] = (byte) 251;
</span><span class='uc' id='L2526' title='8|8|8 - Total: 8'>                rawStackMapTop = putInt16(offsetDelta, rawStackMap,
</span>                    rawStackMapTop);
            }
<span class='uc' id='L2529' title='1|1|1 - Total: 1'>        }
</span>
        private void writeSameLocalsOneStackItemFrame(int[] locals,
            int[] stack,
            int offsetDelta) {
<span class='uc' id='L2534' title='2|2|2 - Total: 2'>            if (offsetDelta <= 63) {
</span>                // Output a same_locals_1_stack_item frame. Similar
                // to same_frame, only with one item on the operand
                // stack instead of zero.
<span class='uc' id='L2538' title='15|15|15 - Total: 15'>                rawStackMap[rawStackMapTop++] = (byte) (64 + offsetDelta);
</span>            } else {
                // Output a same_locals_1_stack_item_extended frame.
                // Similar to same_frame_extended, only with one
                // item on the operand stack instead of zero.
<span class='uc' id='L2543' title='11|11|11 - Total: 11'>                rawStackMap[rawStackMapTop++] = (byte) 247;
</span><span class='uc' id='L2544' title='8|8|8 - Total: 8'>                rawStackMapTop = putInt16(offsetDelta, rawStackMap,
</span>                    rawStackMapTop);
            }
<span class='uc' id='L2547' title='6|6|6 - Total: 6'>            writeType(stack[0]);
</span><span class='uc' id='L2548' title='1|1|1 - Total: 1'>        }
</span>
        private void writeFullFrame(int[] locals, int[] stack,
            int offsetDelta) {
<span class='uc' id='L2552' title='11|11|11 - Total: 11'>            rawStackMap[rawStackMapTop++] = (byte) 255;
</span><span class='uc' id='L2553' title='8|8|8 - Total: 8'>            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);
</span><span class='uc' id='L2554' title='9|9|9 - Total: 9'>            rawStackMapTop = putInt16(locals.length, rawStackMap,
</span>                rawStackMapTop);
<span class='uc' id='L2556' title='5|5|5 - Total: 5'>            rawStackMapTop = writeTypes(locals);
</span><span class='uc' id='L2557' title='9|9|9 - Total: 9'>            rawStackMapTop = putInt16(stack.length, rawStackMap,
</span>                rawStackMapTop);
<span class='uc' id='L2559' title='5|5|5 - Total: 5'>            rawStackMapTop = writeTypes(stack);
</span><span class='uc' id='L2560' title='1|1|1 - Total: 1'>        }
</span>
        private void writeAppendFrame(int[] locals, int localsDelta,
            int offsetDelta) {
<span class='uc' id='L2564' title='5|5|5 - Total: 5'>            int start = locals.length - localsDelta;
</span><span class='uc' id='L2565' title='14|14|14 - Total: 14'>            rawStackMap[rawStackMapTop++] = (byte) (251 + localsDelta);
</span><span class='uc' id='L2566' title='8|8|8 - Total: 8'>            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);
</span><span class='uc' id='L2567' title='6|6|6 - Total: 6'>            rawStackMapTop = writeTypes(locals, start);
</span><span class='uc' id='L2568' title='1|1|1 - Total: 1'>        }
</span>
        private void writeChopFrame(int localsDelta, int offsetDelta) {
<span class='uc' id='L2571' title='14|14|14 - Total: 14'>            rawStackMap[rawStackMapTop++] = (byte) (251 - localsDelta);
</span><span class='uc' id='L2572' title='8|8|8 - Total: 8'>            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);
</span><span class='uc' id='L2573' title='1|1|1 - Total: 1'>        }
</span>
        private int writeTypes(int[] types) {
<span class='uc' id='L2576' title='5|5|5 - Total: 5'>            return writeTypes(types, 0);
</span>        }

        private int writeTypes(int[] types, int start) {
<span class='uc' id='L2580' title='3|3|3 - Total: 3'>            int startOffset = rawStackMapTop;
</span><span class='uc' id='L2581' title='2|2|2 - Total: 2'>            for (int i = start; i < types.length; i++) {
</span><span class='uc' id='L2582' title='7|7|7 - Total: 7'>                rawStackMapTop = writeType(types[i]);
</span>            }
<span class='uc' id='L2584' title='3|3|3 - Total: 3'>            return rawStackMapTop;
</span>        }

        private int writeType(int type) {
<span class='uc' id='L2588' title='4|4|4 - Total: 4'>            int tag = type & 0xFF;
</span><span class='uc' id='L2589' title='12|12|12 - Total: 12'>            rawStackMap[rawStackMapTop++] = (byte) tag;
</span><span class='upc' id='L2590' title='3|3|3 - Total: 4'>            if (tag == TypeInfo.OBJECT_TAG ||
</span>                tag == TypeInfo.UNINITIALIZED_VAR_TAG) {
<span class='uc' id='L2592' title='10|10|10 - Total: 10'>                rawStackMapTop = putInt16(type >>> 8, rawStackMap,
</span>                    rawStackMapTop);
            }
<span class='uc' id='L2595' title='3|3|3 - Total: 3'>            return rawStackMapTop;
</span>        }

        // Intermediate operand stack and local variable state. During
        // execution of a block, these are initialized to copies of the initial
        // block type state and are modified by the actual stack/local
        // emulation.
        private int[] locals;
        private int localsTop;
        private int[] stack;
        private int stackTop;

        private SuperBlock[] workList;
        private int workListTop;

        private SuperBlock[] superBlocks;
        private SuperBlock[] superBlockDeps;

        private byte[] rawStackMap;
        private int rawStackMapTop;

        private boolean wide;

        static final boolean DEBUGSTACKMAP = false;
    }

    /**
     * Convert a newarray operand into an internal type.
     */
    private static char arrayTypeToName(int type) {
        switch (type) {
            case ByteCode.T_BOOLEAN:
                return 'Z';
            case ByteCode.T_CHAR:
                return 'C';
            case ByteCode.T_FLOAT:
                return 'F';
            case ByteCode.T_DOUBLE:
                return 'D';
            case ByteCode.T_BYTE:
                return 'B';
            case ByteCode.T_SHORT:
                return 'S';
            case ByteCode.T_INT:
                return 'I';
            case ByteCode.T_LONG:
                return 'J';
            default:
                throw new IllegalArgumentException("bad operand");
        }
    }

    /**
     * Convert a class descriptor into an internal name.
     *
     * For example, descriptor Ljava/lang/Object; becomes java/lang/Object.
     */
    private static String classDescriptorToInternalName(String descriptor) {
        return descriptor.substring(1, descriptor.length() - 1);
    }

    /**
     * Convert a non-method type descriptor into an internal type.
     *
     * @param descriptor the simple type descriptor to convert
     */
    private static String descriptorToInternalName(String descriptor) {
        switch (descriptor.charAt(0)) {
            case 'B':
            case 'C':
            case 'D':
            case 'F':
            case 'I':
            case 'J':
            case 'S':
            case 'Z':
            case 'V':
            case '[':
                return descriptor;
            case 'L':
                return classDescriptorToInternalName(descriptor);
            default:
                throw new IllegalArgumentException("bad descriptor:" +
                    descriptor);
        }
    }

    /**
     * Compute the initial local variable array for the current method.
     *
     * Creates an array of the size of the method's max locals, regardless of the number of parameters
     * in the method.
     */
    private int[] createInitialLocals() {
        int[] initialLocals = new int[itsMaxLocals];
        int localsTop = 0;
        // Instance methods require the first local variable in the array
        // to be "this". However, if the method being created is a
        // constructor, aka the method is <init>, then the type of "this"
        // should be StackMapTable.UNINITIALIZED_THIS
        if ((itsCurrentMethod.getFlags() & ACC_STATIC) == 0) {
            if ("<init>".equals(itsCurrentMethod.getName())) {
                initialLocals[localsTop++] = TypeInfo.UNINITIALIZED_THIS;
            } else {
                initialLocals[localsTop++] = TypeInfo.OBJECT(itsThisClassIndex);
            }
        }

        // No error checking should be necessary, sizeOfParameters does this
        String type = itsCurrentMethod.getType();
        int lParenIndex = type.indexOf('(');
        int rParenIndex = type.indexOf(')');
        if (lParenIndex != 0 || rParenIndex < 0) {
            throw new IllegalArgumentException("bad method type");
        }
        int start = lParenIndex + 1;
        StringBuilder paramType = new StringBuilder();
        while (start < rParenIndex) {
            switch (type.charAt(start)) {
                case 'B':
                case 'C':
                case 'D':
                case 'F':
                case 'I':
                case 'J':
                case 'S':
                case 'Z':
                    paramType.append(type.charAt(start));
                    ++start;
                    break;
                case 'L':
                    int end = type.indexOf(';', start) + 1;
                    String name = type.substring(start, end);
                    paramType.append(name);
                    start = end;
                    break;
                case '[':
                    paramType.append('[');
                    ++start;
                    continue;
            }
            String internalType =
                descriptorToInternalName(paramType.toString());
            int typeInfo = TypeInfo.fromType(internalType, itsConstantPool);
            initialLocals[localsTop++] = typeInfo;
            if (TypeInfo.isTwoWords(typeInfo)) {
                localsTop++;
            }
            paramType.setLength(0);
        }
        return initialLocals;
    }

    /**
     * Write the class file to the OutputStream.
     *
     * @param oStream the stream to write to
     * @throws IOException if writing to the stream produces an exception
     */
    public void write(OutputStream oStream)
        throws IOException {
        byte[] array = toByteArray();
        oStream.write(array);
    }

    private int getWriteSize() {
        int size = 0;

        if (itsSourceFileNameIndex != 0) {
            itsConstantPool.addUtf8("SourceFile");
        }

        size += 8; //writeLong(FileHeaderConstant);
        size += itsConstantPool.getWriteSize();
        size += 2; //writeShort(itsFlags);
        size += 2; //writeShort(itsThisClassIndex);
        size += 2; //writeShort(itsSuperClassIndex);
        size += 2; //writeShort(itsInterfaces.size());
        size += 2 * itsInterfaces.size();

        size += 2; //writeShort(itsFields.size());
        for (int i = 0; i < itsFields.size(); i++) {
            size += ((ClassFileField) (itsFields.get(i))).getWriteSize();
        }

        size += 2; //writeShort(itsMethods.size());
        for (int i = 0; i < itsMethods.size(); i++) {
            size += ((ClassFileMethod) (itsMethods.get(i))).getWriteSize();
        }

        size += 2; //writeShort(1);  attributes count, could be zero
        if (itsSourceFileNameIndex != 0) {
            size += 2; //writeShort(sourceFileAttributeNameIndex);
            size += 4; //writeInt(2);
            size += 2; //writeShort(itsSourceFileNameIndex);
        }
        if (itsBootstrapMethods != null) {
            size += 2; //writeShort(bootstrapMethodsAttrNameIndex);
            size += 4; //writeInt(itsBootstrapMethodsLength);
            size += 2; //writeShort(bootstrapMethods.size());
            size += itsBootstrapMethodsLength;
        }

        return size;
    }

    /**
     * Get the class file as array of bytesto the OutputStream.
     */
    public byte[] toByteArray() {
        short bootstrapMethodsAttrNameIndex = 0;
        int attributeCount = 0;

        short sourceFileAttributeNameIndex = 0;
        if (itsBootstrapMethods != null) {
            ++attributeCount;
            bootstrapMethodsAttrNameIndex = itsConstantPool.addUtf8("BootstrapMethods");
        }

        if (itsSourceFileNameIndex != 0) {
            ++attributeCount;
            sourceFileAttributeNameIndex = itsConstantPool.addUtf8(
                "SourceFile");
        }

        // Don't calculate the data size until we know how many bootstrap
        // methods there will be.
        int offset = 0;
        int dataSize = getWriteSize();
        byte[] data = new byte[dataSize];

        offset = putInt32(FileHeaderConstant, data, offset);
        offset = putInt16(MinorVersion, data, offset);
        offset = putInt16(MajorVersion, data, offset);
        offset = itsConstantPool.write(data, offset);
        offset = putInt16(itsFlags, data, offset);
        offset = putInt16(itsThisClassIndex, data, offset);
        offset = putInt16(itsSuperClassIndex, data, offset);
        offset = putInt16(itsInterfaces.size(), data, offset);
        for (int i = 0; i < itsInterfaces.size(); i++) {
            int interfaceIndex = ((Short) (itsInterfaces.get(i))).shortValue();
            offset = putInt16(interfaceIndex, data, offset);
        }
        offset = putInt16(itsFields.size(), data, offset);
        for (int i = 0; i < itsFields.size(); i++) {
            ClassFileField field = (ClassFileField) itsFields.get(i);
            offset = field.write(data, offset);
        }
        offset = putInt16(itsMethods.size(), data, offset);
        for (int i = 0; i < itsMethods.size(); i++) {
            ClassFileMethod method = (ClassFileMethod) itsMethods.get(i);
            offset = method.write(data, offset);
        }
        offset = putInt16(attributeCount, data, offset); // attributes count
        if (itsBootstrapMethods != null) {
            offset = putInt16(bootstrapMethodsAttrNameIndex, data, offset);
            offset = putInt32(itsBootstrapMethodsLength + 2, data, offset);
            offset = putInt16(itsBootstrapMethods.size(), data, offset);
            for (int i = 0; i < itsBootstrapMethods.size(); i++) {
                BootstrapEntry entry = (BootstrapEntry) itsBootstrapMethods.get(i);
                System.arraycopy(entry.code, 0, data, offset, entry.code.length);
                offset += entry.code.length;
            }
        }
        if (itsSourceFileNameIndex != 0) {
            offset = putInt16(sourceFileAttributeNameIndex, data, offset);
            offset = putInt32(2, data, offset);
            offset = putInt16(itsSourceFileNameIndex, data, offset);
        }

        if (offset != dataSize) {
            // Check getWriteSize is consistent with write!
            throw new RuntimeException();
        }

        return data;
    }

    static int putInt64(long value, byte[] array, int offset) {
        offset = putInt32((int) (value >>> 32), array, offset);
        return putInt32((int) value, array, offset);
    }

    private static void badStack(int value) {
        String s;
        if (value < 0) {
            s = "Stack underflow: " + value;
        } else {
            s = "Too big stack: " + value;
        }
        throw new IllegalStateException(s);
    }

    /*
        Really weird. Returns an int with # parameters in hi 16 bits, and
        stack difference removal of parameters from stack and pushing the
        result (it does not take into account removal of this in case of
        non-static methods).
        If Java really supported references we wouldn't have to be this
        perverted.
    */
    private static int sizeOfParameters(String pString) {
        int length = pString.length();
        int rightParenthesis = pString.lastIndexOf(')');
        if (3 <= length /* minimal signature takes at least 3 chars: ()V */
            && pString.charAt(0) == '('
            && 1 <= rightParenthesis && rightParenthesis + 1 < length) {
            boolean ok = true;
            int index = 1;
            int stackDiff = 0;
            int count = 0;
            stringLoop:
            while (index != rightParenthesis) {
                switch (pString.charAt(index)) {
                    default:
                        ok = false;
                        break stringLoop;
                    case 'J':
                    case 'D':
                        --stackDiff;
                        // fallthru
                    case 'B':
                    case 'S':
                    case 'C':
                    case 'I':
                    case 'Z':
                    case 'F':
                        --stackDiff;
                        ++count;
                        ++index;
                        continue;
                    case '[':
                        ++index;
                        int c = pString.charAt(index);
                        while (c == '[') {
                            ++index;
                            c = pString.charAt(index);
                        }
                        switch (c) {
                            default:
                                ok = false;
                                break stringLoop;
                            case 'J':
                            case 'D':
                            case 'B':
                            case 'S':
                            case 'C':
                            case 'I':
                            case 'Z':
                            case 'F':
                                --stackDiff;
                                ++count;
                                ++index;
                                continue;
                            case 'L':
                                // fallthru
                        }
                        // fallthru
                    case 'L': {
                        --stackDiff;
                        ++count;
                        ++index;
                        int semicolon = pString.indexOf(';', index);
                        if (!(index + 1 <= semicolon
                            && semicolon < rightParenthesis)) {
                            ok = false;
                            break stringLoop;
                        }
                        index = semicolon + 1;
                        continue;
                    }
                }
            }
            if (ok) {
                switch (pString.charAt(rightParenthesis + 1)) {
                    default:
                        ok = false;
                        break;
                    case 'J':
                    case 'D':
                        ++stackDiff;
                        // fallthru
                    case 'B':
                    case 'S':
                    case 'C':
                    case 'I':
                    case 'Z':
                    case 'F':
                    case 'L':
                    case '[':
                        ++stackDiff;
                        // fallthru
                    case 'V':
                        break;
                }
                if (ok) {
                    return ((count << 16) | (0xFFFF & stackDiff));
                }
            }
        }
        throw new IllegalArgumentException(
            "Bad parameter signature: " + pString);
    }

    static int putInt16(int value, byte[] array, int offset) {
        array[offset + 0] = (byte) (value >>> 8);
        array[offset + 1] = (byte) value;
        return offset + 2;
    }

    static int putInt32(int value, byte[] array, int offset) {
        array[offset + 0] = (byte) (value >>> 24);
        array[offset + 1] = (byte) (value >>> 16);
        array[offset + 2] = (byte) (value >>> 8);
        array[offset + 3] = (byte) value;
        return offset + 4;
    }

    /**
     * Size of a bytecode instruction, counting the opcode and its operands.
     *
     * This is different from opcodeCount, since opcodeCount counts logical operands.
     */
    private static int opcodeLength(int opcode, boolean wide) {
        switch (opcode) {
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP:
            case ByteCode.POP2:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
                return 1;
            case ByteCode.BIPUSH:
            case ByteCode.LDC:
            case ByteCode.NEWARRAY:
                return 2;
            case ByteCode.ALOAD:
            case ByteCode.ASTORE:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.ILOAD:
            case ByteCode.ISTORE:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.RET:
                return wide ? 3 : 2;

            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.JSR:
            case ByteCode.LDC_W:
            case ByteCode.LDC2_W:
            case ByteCode.NEW:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.SIPUSH:
                return 3;

            case ByteCode.IINC:
                return wide ? 5 : 3;

            case ByteCode.MULTIANEWARRAY:
                return 4;

            case ByteCode.GOTO_W:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKEDYNAMIC:
            case ByteCode.JSR_W:
                return 5;

            /*
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.TABLESWITCH:
                return -1;
            */
        }
        throw new IllegalArgumentException("Bad opcode: " + opcode);
    }

    /**
     * Number of operands accompanying the opcode.
     */
    private static int opcodeCount(int opcode) {
        switch (opcode) {
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP:
            case ByteCode.POP2:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
                return 0;
            case ByteCode.ALOAD:
            case ByteCode.ANEWARRAY:
            case ByteCode.ASTORE:
            case ByteCode.BIPUSH:
            case ByteCode.CHECKCAST:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.GOTO_W:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.ILOAD:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.ISTORE:
            case ByteCode.JSR:
            case ByteCode.JSR_W:
            case ByteCode.LDC:
            case ByteCode.LDC2_W:
            case ByteCode.LDC_W:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.NEW:
            case ByteCode.NEWARRAY:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.RET:
            case ByteCode.SIPUSH:
                return 1;

            case ByteCode.IINC:
            case ByteCode.MULTIANEWARRAY:
                return 2;

            case ByteCode.LOOKUPSWITCH:
            case ByteCode.TABLESWITCH:
                return -1;
        }
        throw new IllegalArgumentException("Bad opcode: " + opcode);
    }

    /**
     * The effect on the operand stack of a given opcode.
     */
    private static int stackChange(int opcode) {
        // For INVOKE... accounts only for popping this (unless static),
        // ignoring parameters and return type
        switch (opcode) {
            case ByteCode.DASTORE:
            case ByteCode.LASTORE:
                return -4;

            case ByteCode.AASTORE:
            case ByteCode.BASTORE:
            case ByteCode.CASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.FASTORE:
            case ByteCode.IASTORE:
            case ByteCode.LCMP:
            case ByteCode.SASTORE:
                return -3;

            case ByteCode.DADD:
            case ByteCode.DDIV:
            case ByteCode.DMUL:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.LADD:
            case ByteCode.LAND:
            case ByteCode.LDIV:
            case ByteCode.LMUL:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSTORE:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LXOR:
            case ByteCode.POP2:
                return -2;

            case ByteCode.AALOAD:
            case ByteCode.ARETURN:
            case ByteCode.ASTORE:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.CALOAD:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FDIV:
            case ByteCode.FMUL:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.GETFIELD:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IDIV:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IMUL:
            case ByteCode.INVOKEINTERFACE:       //
            case ByteCode.INVOKESPECIAL:         // but needs to account for
            case ByteCode.INVOKEVIRTUAL:         // pops 'this' (unless static)
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LUSHR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.POP:
            case ByteCode.PUTFIELD:
            case ByteCode.SALOAD:
            case ByteCode.TABLESWITCH:
                return -1;

            case ByteCode.ANEWARRAY:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.BREAKPOINT:
            case ByteCode.CHECKCAST:
            case ByteCode.D2L:
            case ByteCode.DALOAD:
            case ByteCode.DNEG:
            case ByteCode.F2I:
            case ByteCode.FNEG:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.GOTO_W:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2F:
            case ByteCode.I2S:
            case ByteCode.IINC:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.INEG:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEDYNAMIC:
            case ByteCode.L2D:
            case ByteCode.LALOAD:
            case ByteCode.LNEG:
            case ByteCode.NEWARRAY:
            case ByteCode.NOP:
            case ByteCode.PUTSTATIC:
            case ByteCode.RET:
            case ByteCode.RETURN:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
                return 0;

            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.BIPUSH:
            case ByteCode.DUP:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2L:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FLOAD:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.I2D:
            case ByteCode.I2L:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.ILOAD:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.JSR:
            case ByteCode.JSR_W:
            case ByteCode.LDC:
            case ByteCode.LDC_W:
            case ByteCode.MULTIANEWARRAY:
            case ByteCode.NEW:
            case ByteCode.SIPUSH:
                return 1;

            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DLOAD:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDC2_W:
            case ByteCode.LLOAD:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
                return 2;
        }
        throw new IllegalArgumentException("Bad opcode: " + opcode);
    }

        /*
         * Number of bytes of operands generated after the opcode.
         * Not in use currently.
         */
/*
    int extra(int opcode)
    {
        switch (opcode) {
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP2:
            case ByteCode.POP:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
                return 0;

            case ByteCode.ALOAD:
            case ByteCode.ASTORE:
            case ByteCode.BIPUSH:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.ILOAD:
            case ByteCode.ISTORE:
            case ByteCode.LDC:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.NEWARRAY:
            case ByteCode.RET:
                return 1;

            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.IINC:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.JSR:
            case ByteCode.LDC2_W:
            case ByteCode.LDC_W:
            case ByteCode.NEW:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.SIPUSH:
                return 2;

            case ByteCode.MULTIANEWARRAY:
                return 3;

            case ByteCode.GOTO_W:
            case ByteCode.JSR_W:
                return 4;

            case ByteCode.LOOKUPSWITCH:    // depends on alignment
            case ByteCode.TABLESWITCH: // depends on alignment
                return -1;
        }
        throw new IllegalArgumentException("Bad opcode: "+opcode);
    }
*/

    @SuppressWarnings("unused")
    private static String bytecodeStr(int code) {
        if (DEBUGSTACK || DEBUGCODE) {
            switch (code) {
                case ByteCode.NOP:
                    return "nop";
                case ByteCode.ACONST_NULL:
                    return "aconst_null";
                case ByteCode.ICONST_M1:
                    return "iconst_m1";
                case ByteCode.ICONST_0:
                    return "iconst_0";
                case ByteCode.ICONST_1:
                    return "iconst_1";
                case ByteCode.ICONST_2:
                    return "iconst_2";
                case ByteCode.ICONST_3:
                    return "iconst_3";
                case ByteCode.ICONST_4:
                    return "iconst_4";
                case ByteCode.ICONST_5:
                    return "iconst_5";
                case ByteCode.LCONST_0:
                    return "lconst_0";
                case ByteCode.LCONST_1:
                    return "lconst_1";
                case ByteCode.FCONST_0:
                    return "fconst_0";
                case ByteCode.FCONST_1:
                    return "fconst_1";
                case ByteCode.FCONST_2:
                    return "fconst_2";
                case ByteCode.DCONST_0:
                    return "dconst_0";
                case ByteCode.DCONST_1:
                    return "dconst_1";
                case ByteCode.BIPUSH:
                    return "bipush";
                case ByteCode.SIPUSH:
                    return "sipush";
                case ByteCode.LDC:
                    return "ldc";
                case ByteCode.LDC_W:
                    return "ldc_w";
                case ByteCode.LDC2_W:
                    return "ldc2_w";
                case ByteCode.ILOAD:
                    return "iload";
                case ByteCode.LLOAD:
                    return "lload";
                case ByteCode.FLOAD:
                    return "fload";
                case ByteCode.DLOAD:
                    return "dload";
                case ByteCode.ALOAD:
                    return "aload";
                case ByteCode.ILOAD_0:
                    return "iload_0";
                case ByteCode.ILOAD_1:
                    return "iload_1";
                case ByteCode.ILOAD_2:
                    return "iload_2";
                case ByteCode.ILOAD_3:
                    return "iload_3";
                case ByteCode.LLOAD_0:
                    return "lload_0";
                case ByteCode.LLOAD_1:
                    return "lload_1";
                case ByteCode.LLOAD_2:
                    return "lload_2";
                case ByteCode.LLOAD_3:
                    return "lload_3";
                case ByteCode.FLOAD_0:
                    return "fload_0";
                case ByteCode.FLOAD_1:
                    return "fload_1";
                case ByteCode.FLOAD_2:
                    return "fload_2";
                case ByteCode.FLOAD_3:
                    return "fload_3";
                case ByteCode.DLOAD_0:
                    return "dload_0";
                case ByteCode.DLOAD_1:
                    return "dload_1";
                case ByteCode.DLOAD_2:
                    return "dload_2";
                case ByteCode.DLOAD_3:
                    return "dload_3";
                case ByteCode.ALOAD_0:
                    return "aload_0";
                case ByteCode.ALOAD_1:
                    return "aload_1";
                case ByteCode.ALOAD_2:
                    return "aload_2";
                case ByteCode.ALOAD_3:
                    return "aload_3";
                case ByteCode.IALOAD:
                    return "iaload";
                case ByteCode.LALOAD:
                    return "laload";
                case ByteCode.FALOAD:
                    return "faload";
                case ByteCode.DALOAD:
                    return "daload";
                case ByteCode.AALOAD:
                    return "aaload";
                case ByteCode.BALOAD:
                    return "baload";
                case ByteCode.CALOAD:
                    return "caload";
                case ByteCode.SALOAD:
                    return "saload";
                case ByteCode.ISTORE:
                    return "istore";
                case ByteCode.LSTORE:
                    return "lstore";
                case ByteCode.FSTORE:
                    return "fstore";
                case ByteCode.DSTORE:
                    return "dstore";
                case ByteCode.ASTORE:
                    return "astore";
                case ByteCode.ISTORE_0:
                    return "istore_0";
                case ByteCode.ISTORE_1:
                    return "istore_1";
                case ByteCode.ISTORE_2:
                    return "istore_2";
                case ByteCode.ISTORE_3:
                    return "istore_3";
                case ByteCode.LSTORE_0:
                    return "lstore_0";
                case ByteCode.LSTORE_1:
                    return "lstore_1";
                case ByteCode.LSTORE_2:
                    return "lstore_2";
                case ByteCode.LSTORE_3:
                    return "lstore_3";
                case ByteCode.FSTORE_0:
                    return "fstore_0";
                case ByteCode.FSTORE_1:
                    return "fstore_1";
                case ByteCode.FSTORE_2:
                    return "fstore_2";
                case ByteCode.FSTORE_3:
                    return "fstore_3";
                case ByteCode.DSTORE_0:
                    return "dstore_0";
                case ByteCode.DSTORE_1:
                    return "dstore_1";
                case ByteCode.DSTORE_2:
                    return "dstore_2";
                case ByteCode.DSTORE_3:
                    return "dstore_3";
                case ByteCode.ASTORE_0:
                    return "astore_0";
                case ByteCode.ASTORE_1:
                    return "astore_1";
                case ByteCode.ASTORE_2:
                    return "astore_2";
                case ByteCode.ASTORE_3:
                    return "astore_3";
                case ByteCode.IASTORE:
                    return "iastore";
                case ByteCode.LASTORE:
                    return "lastore";
                case ByteCode.FASTORE:
                    return "fastore";
                case ByteCode.DASTORE:
                    return "dastore";
                case ByteCode.AASTORE:
                    return "aastore";
                case ByteCode.BASTORE:
                    return "bastore";
                case ByteCode.CASTORE:
                    return "castore";
                case ByteCode.SASTORE:
                    return "sastore";
                case ByteCode.POP:
                    return "pop";
                case ByteCode.POP2:
                    return "pop2";
                case ByteCode.DUP:
                    return "dup";
                case ByteCode.DUP_X1:
                    return "dup_x1";
                case ByteCode.DUP_X2:
                    return "dup_x2";
                case ByteCode.DUP2:
                    return "dup2";
                case ByteCode.DUP2_X1:
                    return "dup2_x1";
                case ByteCode.DUP2_X2:
                    return "dup2_x2";
                case ByteCode.SWAP:
                    return "swap";
                case ByteCode.IADD:
                    return "iadd";
                case ByteCode.LADD:
                    return "ladd";
                case ByteCode.FADD:
                    return "fadd";
                case ByteCode.DADD:
                    return "dadd";
                case ByteCode.ISUB:
                    return "isub";
                case ByteCode.LSUB:
                    return "lsub";
                case ByteCode.FSUB:
                    return "fsub";
                case ByteCode.DSUB:
                    return "dsub";
                case ByteCode.IMUL:
                    return "imul";
                case ByteCode.LMUL:
                    return "lmul";
                case ByteCode.FMUL:
                    return "fmul";
                case ByteCode.DMUL:
                    return "dmul";
                case ByteCode.IDIV:
                    return "idiv";
                case ByteCode.LDIV:
                    return "ldiv";
                case ByteCode.FDIV:
                    return "fdiv";
                case ByteCode.DDIV:
                    return "ddiv";
                case ByteCode.IREM:
                    return "irem";
                case ByteCode.LREM:
                    return "lrem";
                case ByteCode.FREM:
                    return "frem";
                case ByteCode.DREM:
                    return "drem";
                case ByteCode.INEG:
                    return "ineg";
                case ByteCode.LNEG:
                    return "lneg";
                case ByteCode.FNEG:
                    return "fneg";
                case ByteCode.DNEG:
                    return "dneg";
                case ByteCode.ISHL:
                    return "ishl";
                case ByteCode.LSHL:
                    return "lshl";
                case ByteCode.ISHR:
                    return "ishr";
                case ByteCode.LSHR:
                    return "lshr";
                case ByteCode.IUSHR:
                    return "iushr";
                case ByteCode.LUSHR:
                    return "lushr";
                case ByteCode.IAND:
                    return "iand";
                case ByteCode.LAND:
                    return "land";
                case ByteCode.IOR:
                    return "ior";
                case ByteCode.LOR:
                    return "lor";
                case ByteCode.IXOR:
                    return "ixor";
                case ByteCode.LXOR:
                    return "lxor";
                case ByteCode.IINC:
                    return "iinc";
                case ByteCode.I2L:
                    return "i2l";
                case ByteCode.I2F:
                    return "i2f";
                case ByteCode.I2D:
                    return "i2d";
                case ByteCode.L2I:
                    return "l2i";
                case ByteCode.L2F:
                    return "l2f";
                case ByteCode.L2D:
                    return "l2d";
                case ByteCode.F2I:
                    return "f2i";
                case ByteCode.F2L:
                    return "f2l";
                case ByteCode.F2D:
                    return "f2d";
                case ByteCode.D2I:
                    return "d2i";
                case ByteCode.D2L:
                    return "d2l";
                case ByteCode.D2F:
                    return "d2f";
                case ByteCode.I2B:
                    return "i2b";
                case ByteCode.I2C:
                    return "i2c";
                case ByteCode.I2S:
                    return "i2s";
                case ByteCode.LCMP:
                    return "lcmp";
                case ByteCode.FCMPL:
                    return "fcmpl";
                case ByteCode.FCMPG:
                    return "fcmpg";
                case ByteCode.DCMPL:
                    return "dcmpl";
                case ByteCode.DCMPG:
                    return "dcmpg";
                case ByteCode.IFEQ:
                    return "ifeq";
                case ByteCode.IFNE:
                    return "ifne";
                case ByteCode.IFLT:
                    return "iflt";
                case ByteCode.IFGE:
                    return "ifge";
                case ByteCode.IFGT:
                    return "ifgt";
                case ByteCode.IFLE:
                    return "ifle";
                case ByteCode.IF_ICMPEQ:
                    return "if_icmpeq";
                case ByteCode.IF_ICMPNE:
                    return "if_icmpne";
                case ByteCode.IF_ICMPLT:
                    return "if_icmplt";
                case ByteCode.IF_ICMPGE:
                    return "if_icmpge";
                case ByteCode.IF_ICMPGT:
                    return "if_icmpgt";
                case ByteCode.IF_ICMPLE:
                    return "if_icmple";
                case ByteCode.IF_ACMPEQ:
                    return "if_acmpeq";
                case ByteCode.IF_ACMPNE:
                    return "if_acmpne";
                case ByteCode.GOTO:
                    return "goto";
                case ByteCode.JSR:
                    return "jsr";
                case ByteCode.RET:
                    return "ret";
                case ByteCode.TABLESWITCH:
                    return "tableswitch";
                case ByteCode.LOOKUPSWITCH:
                    return "lookupswitch";
                case ByteCode.IRETURN:
                    return "ireturn";
                case ByteCode.LRETURN:
                    return "lreturn";
                case ByteCode.FRETURN:
                    return "freturn";
                case ByteCode.DRETURN:
                    return "dreturn";
                case ByteCode.ARETURN:
                    return "areturn";
                case ByteCode.RETURN:
                    return "return";
                case ByteCode.GETSTATIC:
                    return "getstatic";
                case ByteCode.PUTSTATIC:
                    return "putstatic";
                case ByteCode.GETFIELD:
                    return "getfield";
                case ByteCode.PUTFIELD:
                    return "putfield";
                case ByteCode.INVOKEVIRTUAL:
                    return "invokevirtual";
                case ByteCode.INVOKESPECIAL:
                    return "invokespecial";
                case ByteCode.INVOKESTATIC:
                    return "invokestatic";
                case ByteCode.INVOKEINTERFACE:
                    return "invokeinterface";
                case ByteCode.INVOKEDYNAMIC:
                    return "invokedynamic";
                case ByteCode.NEW:
                    return "new";
                case ByteCode.NEWARRAY:
                    return "newarray";
                case ByteCode.ANEWARRAY:
                    return "anewarray";
                case ByteCode.ARRAYLENGTH:
                    return "arraylength";
                case ByteCode.ATHROW:
                    return "athrow";
                case ByteCode.CHECKCAST:
                    return "checkcast";
                case ByteCode.INSTANCEOF:
                    return "instanceof";
                case ByteCode.MONITORENTER:
                    return "monitorenter";
                case ByteCode.MONITOREXIT:
                    return "monitorexit";
                case ByteCode.WIDE:
                    return "wide";
                case ByteCode.MULTIANEWARRAY:
                    return "multianewarray";
                case ByteCode.IFNULL:
                    return "ifnull";
                case ByteCode.IFNONNULL:
                    return "ifnonnull";
                case ByteCode.GOTO_W:
                    return "goto_w";
                case ByteCode.JSR_W:
                    return "jsr_w";
                case ByteCode.BREAKPOINT:
                    return "breakpoint";

                case ByteCode.IMPDEP1:
                    return "impdep1";
                case ByteCode.IMPDEP2:
                    return "impdep2";
            }
        }
        return "";
    }

    final char[] getCharBuffer(int minimalSize) {
        if (minimalSize > tmpCharBuffer.length) {
            int newSize = tmpCharBuffer.length * 2;
            if (minimalSize > newSize) {
                newSize = minimalSize;
            }
            tmpCharBuffer = new char[newSize];
        }
        return tmpCharBuffer;
    }

    /**
     * Add a pc as the start of super block.
     *
     * A pc is the beginning of a super block if: - pc == 0 - it is the target of a branch instruction
     * - it is the beginning of an exception handler - it is directly after an unconditional jump
     */
    private void addSuperBlockStart(int pc) {
        if (GenerateStackMap) {
            if (itsSuperBlockStarts == null) {
                itsSuperBlockStarts = new int[SuperBlockStartsSize];
            } else if (itsSuperBlockStarts.length == itsSuperBlockStartsTop) {
                int[] tmp = new int[itsSuperBlockStartsTop * 2];
                System.arraycopy(itsSuperBlockStarts, 0, tmp, 0,
                    itsSuperBlockStartsTop);
                itsSuperBlockStarts = tmp;
            }
            itsSuperBlockStarts[itsSuperBlockStartsTop++] = pc;
        }
    }

    /**
     * Sort the list of recorded super block starts and remove duplicates.
     *
     * Also adds exception handling blocks as block starts, since there is no explicit control flow to
     * these. Used for stack map table generation.
     */
    private void finalizeSuperBlockStarts() {
        if (GenerateStackMap) {
            for (int i = 0; i < itsExceptionTableTop; i++) {
                ExceptionTableEntry ete = itsExceptionTable[i];
                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);
                addSuperBlockStart(handlerPC);
            }
            Arrays.sort(itsSuperBlockStarts, 0, itsSuperBlockStartsTop);
            int prev = itsSuperBlockStarts[0];
            int copyTo = 1;
            for (int i = 1; i < itsSuperBlockStartsTop; i++) {
                int curr = itsSuperBlockStarts[i];
                if (prev != curr) {
                    if (copyTo != i) {
                        itsSuperBlockStarts[copyTo] = curr;
                    }
                    copyTo++;
                    prev = curr;
                }
            }
            itsSuperBlockStartsTop = copyTo;
            if (itsSuperBlockStarts[copyTo - 1] == itsCodeBufferTop) {
                itsSuperBlockStartsTop--;
            }
        }
    }

    private int[] itsSuperBlockStarts = null;
    private int itsSuperBlockStartsTop = 0;
    private static final int SuperBlockStartsSize = 4;

    // Used to find blocks of code with no dependencies (aka dead code).
    // Necessary for generating type information for dead code, which is
    // expected by the Sun verifier. It is only necessary to store a single
    // jump source to determine if a block is reachable or not.
    private UintMap itsJumpFroms = null;

    private static final int LineNumberTableSize = 16;
    private static final int ExceptionTableSize = 4;

    private static final int MajorVersion;
    private static final int MinorVersion;
    private static final boolean GenerateStackMap;

    static {
        // Figure out which classfile version should be generated. This assumes
        // that the runtime used to compile the JavaScript files is the same as
        // the one used to run them. This is important because there are cases
        // when bytecode is generated at runtime, where it is not easy to pass
        // along what version is necessary. Instead, we grab the version numbers
        // from the bytecode of this class and use that.
        //
        // Based on the version numbers we scrape, we can also determine what
        // bytecode features we need. For example, Java 6 bytecode (classfile
        // version 50) should have stack maps generated.
        InputStream is = null;
        int major = 48, minor = 0;
        try {
            is = ClassFileWriter.class.getResourceAsStream("ClassFileWriter.class");
            if (is == null) {
                is = ClassLoader.getSystemResourceAsStream(
                    "org/mozilla/classfile/ClassFileWriter.class");
            }
            byte[] header = new byte[8];
            // read loop is required since JDK7 will only provide 2 bytes
            // on the first read() - see bug #630111
            int read = 0;
            while (read < 8) {
                int c = is.read(header, read, 8 - read);
                if (c < 0)
                    throw new IOException();
                read += c;
            }
            minor = (header[4] << 8) | (header[5] & 0xff);
            major = (header[6] << 8) | (header[7] & 0xff);
        } catch (Exception e) {
            // Unable to get class file, use default bytecode version
        } finally {
            MinorVersion = minor;
            MajorVersion = major;
            GenerateStackMap = major >= 50;
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                }
            }
        }
    }

    final class BootstrapEntry {

        final byte[] code;

        BootstrapEntry(ClassFileWriter.MHandle bsm, Object... bsmArgs) {
            int length = 2 + 2 + bsmArgs.length * 2;
            code = new byte[length];
            putInt16(itsConstantPool.addMethodHandle(bsm), code, 0);
            putInt16(bsmArgs.length, code, 2);
            for (int i = 0; i < bsmArgs.length; i++) {
                putInt16(itsConstantPool.addConstant(bsmArgs[i]), code, 4 + i * 2);
            }
        }

        @Override
        public boolean equals(Object obj) {
            return obj instanceof BootstrapEntry
                && Arrays.equals(code, ((BootstrapEntry) obj).code);
        }

        @Override
        public int hashCode() {
            return ~Arrays.hashCode(code);
        }
    }

    public static final class MHandle {

        final byte tag;
        final String owner;
        final String name;
        final String desc;

        public MHandle(byte tag, String owner, String name, String desc) {
            this.tag = tag;
            this.owner = owner;
            this.name = name;
            this.desc = desc;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof MHandle)) {
                return false;
            }
            MHandle mh = (MHandle) obj;
            return tag == mh.tag && owner.equals(mh.owner)
                && name.equals(mh.name) && desc.equals(mh.desc);
        }

        @Override
        public int hashCode() {
            return tag + owner.hashCode() * name.hashCode() * desc.hashCode();
        }

        @Override
        public String toString() {
            return owner + '.' + name + desc + " (" + tag + ')';
        }
    }

    private final static int FileHeaderConstant = 0xCAFEBABE;
    // Set DEBUG flags to true to get better checking and progress info.
    private static final boolean DEBUGSTACK = false;
    private static final boolean DEBUGLABELS = false;
    private static final boolean DEBUGCODE = false;

    private String generatedClassName;

    private ExceptionTableEntry itsExceptionTable[];
    private int itsExceptionTableTop;

    private int itsLineNumberTable[];   // pack start_pc & line_number together
    private int itsLineNumberTableTop;

    private byte[] itsCodeBuffer = new byte[256];
    private int itsCodeBufferTop;

    private ConstantPool itsConstantPool;

    private ClassFileMethod itsCurrentMethod;
    private short itsStackTop;

    private short itsMaxStack;
    private short itsMaxLocals;

    private ObjArray itsMethods = new ObjArray();
    private ObjArray itsFields = new ObjArray();
    private ObjArray itsInterfaces = new ObjArray();

    private short itsFlags;
    private short itsThisClassIndex;
    private short itsSuperClassIndex;
    private short itsSourceFileNameIndex;

    private static final int MIN_LABEL_TABLE_SIZE = 32;
    private int[] itsLabelTable;
    private int itsLabelTableTop;

    // itsFixupTable[i] = (label_index << 32) | fixup_site
    private static final int MIN_FIXUP_TABLE_SIZE = 40;
    private long[] itsFixupTable;
    private int itsFixupTableTop;
    private ObjArray itsVarDescriptors;
    private ObjArray itsBootstrapMethods;
    private int itsBootstrapMethodsLength = 0;

    private char[] tmpCharBuffer = new char[64];
}

</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>