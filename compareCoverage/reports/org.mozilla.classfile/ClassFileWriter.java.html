<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.classfile.ClassFileWriter.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.classfile.ClassFileWriter.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.classfile;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.mozilla.javascript.ObjArray;
import org.mozilla.javascript.UintMap;

import java.util.Arrays;

/**
 * ClassFileWriter
 *
 * A ClassFileWriter is used to write a Java class file. Methods are
 * provided to create fields and methods, and within methods to write
 * Java bytecodes.
 *
 * @author Roger Lawrence
 */
public class ClassFileWriter {

    /**
     * Thrown for cases where the error in generating the class file is due to a program size
     * constraints rather than a likely bug in the compiler.
     */
    public static class ClassFileFormatException extends RuntimeException {

        private static final long serialVersionUID = 1263998431033790599L;

        ClassFileFormatException(String message) {
            super(message);
        }
    }

    /**
     * Construct a ClassFileWriter for a class.
     *
     * @param className the name of the class to write, including full package qualification.
     * @param superClassName the name of the superclass of the class to write, including full package
     * qualification.
     * @param sourceFileName the name of the source file to use for producing debug information, or
     * null if debug information is not desired
     */
    public ClassFileWriter(String className, String superClassName,
<span class='bc' id='L51' title='0|2|2 - Total: 2'>        String sourceFileName) {
</span><span class='bc' id='L52' title='0|3|3 - Total: 3'>        generatedClassName = className;
</span><span class='bc' id='L53' title='0|6|6 - Total: 6'>        itsConstantPool = new ConstantPool(this);
</span><span class='bc' id='L54' title='0|6|6 - Total: 6'>        itsThisClassIndex = itsConstantPool.addClass(className);
</span><span class='bc' id='L55' title='0|6|6 - Total: 6'>        itsSuperClassIndex = itsConstantPool.addClass(superClassName);
</span><span class='bc' id='L56' title='0|2|2 - Total: 2'>        if (sourceFileName != null)
</span><span class='bc' id='L57' title='0|6|6 - Total: 6'>            itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);
</span>        // All "new" implementations are supposed to output ACC_SUPER as a
        // class flag. This is specified in the first JVM spec, so it should
        // be old enough that it's okay to always set it.
<span class='bc' id='L61' title='0|3|3 - Total: 3'>        itsFlags = ACC_PUBLIC | ACC_SUPER;
</span><span class='bc' id='L62' title='0|1|1 - Total: 1'>    }
</span>
    public final String getClassName() {
<span class='bc' id='L65' title='0|3|3 - Total: 3'>        return generatedClassName;
</span>    }

    /**
     * Add an interface implemented by this class.
     *
     * This method may be called multiple times for classes that implement multiple interfaces.
     *
     * @param interfaceName a name of an interface implemented by the class being written, including
     * full package qualification.
     */
    public void addInterface(String interfaceName) {
<span class='bc' id='L77' title='0|5|5 - Total: 5'>        short interfaceIndex = itsConstantPool.addClass(interfaceName);
</span><span class='bc' id='L78' title='0|5|5 - Total: 5'>        itsInterfaces.add(Short.valueOf(interfaceIndex));
</span><span class='bc' id='L79' title='0|1|1 - Total: 1'>    }
</span>
    public static final short
        ACC_PUBLIC = 0x0001,
        ACC_PRIVATE = 0x0002,
        ACC_PROTECTED = 0x0004,
        ACC_STATIC = 0x0008,
        ACC_FINAL = 0x0010,
        ACC_SUPER = 0x0020,
        ACC_SYNCHRONIZED = 0x0020,
        ACC_VOLATILE = 0x0040,
        ACC_TRANSIENT = 0x0080,
        ACC_NATIVE = 0x0100,
        ACC_ABSTRACT = 0x0400;

    /**
     * Set the class's flags.
     *
     * Flags must be a set of the following flags, bitwise or'd together: ACC_PUBLIC ACC_PRIVATE
     * ACC_PROTECTED ACC_FINAL ACC_ABSTRACT TODO: check that this is the appropriate set
     *
     * @param flags the set of class flags to set
     */
    public void setFlags(short flags) {
<span class='nc' id='L103' title='0|0|0 - Total: 3'>        itsFlags = flags;
</span><span class='nc' id='L104' title='0|0|0 - Total: 1'>    }
</span>
    static String getSlashedForm(String name) {
<span class='bc' id='L107' title='0|5|5 - Total: 5'>        return name.replace('.', '/');
</span>    }

    /**
     * Convert Java class name in dot notation into "Lname-with-dots-replaced-by-slashes;" form
     * suitable for use as JVM type signatures.
     */
    public static String classNameToSignature(String name) {
<span class='bc' id='L115' title='0|3|3 - Total: 3'>        int nameLength = name.length();
</span><span class='bc' id='L116' title='0|4|4 - Total: 4'>        int colonPos = 1 + nameLength;
</span><span class='bc' id='L117' title='0|5|5 - Total: 5'>        char[] buf = new char[colonPos + 1];
</span><span class='bc' id='L118' title='0|4|4 - Total: 4'>        buf[0] = 'L';
</span><span class='bc' id='L119' title='0|4|4 - Total: 4'>        buf[colonPos] = ';';
</span><span class='bc' id='L120' title='0|6|6 - Total: 6'>        name.getChars(0, nameLength, buf, 1);
</span><span class='bc' id='L121' title='0|2|2 - Total: 2'>        for (int i = 1; i != colonPos; ++i) {
</span><span class='bc' id='L122' title='0|2|2 - Total: 2'>            if (buf[i] == '.') {
</span><span class='bc' id='L123' title='0|4|4 - Total: 4'>                buf[i] = '/';
</span>            }
        }
<span class='bc' id='L126' title='0|9|9 - Total: 9'>        return new String(buf, 0, colonPos + 1);
</span>    }

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     */
    public void addField(String fieldName, String type, short flags) {
<span class='bc' id='L137' title='0|5|5 - Total: 5'>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
</span><span class='bc' id='L138' title='0|5|5 - Total: 5'>        short typeIndex = itsConstantPool.addUtf8(type);
</span><span class='bc' id='L139' title='0|9|9 - Total: 9'>        itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));
</span><span class='bc' id='L140' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial integral value
     */
    public void addField(String fieldName, String type, short flags,
        int value) {
<span class='nc' id='L152' title='0|0|0 - Total: 5'>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
</span><span class='nc' id='L153' title='0|0|0 - Total: 5'>        short typeIndex = itsConstantPool.addUtf8(type);
</span><span class='nc' id='L154' title='0|0|0 - Total: 7'>        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,
</span>            flags);
<span class='nc' id='L156' title='0|0|0 - Total: 11'>        field.setAttributes(itsConstantPool.addUtf8("ConstantValue"),
</span>            (short) 0,
            (short) 0,
<span class='nc' id='L159' title='0|0|0 - Total: 1'>            itsConstantPool.addConstant(value));
</span><span class='nc' id='L160' title='0|0|0 - Total: 4'>        itsFields.add(field);
</span><span class='nc' id='L161' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial long value
     */
    public void addField(String fieldName, String type, short flags,
        long value) {
<span class='nc' id='L173' title='0|0|0 - Total: 5'>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
</span><span class='nc' id='L174' title='0|0|0 - Total: 5'>        short typeIndex = itsConstantPool.addUtf8(type);
</span><span class='nc' id='L175' title='0|0|0 - Total: 7'>        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,
</span>            flags);
<span class='nc' id='L177' title='0|0|0 - Total: 11'>        field.setAttributes(itsConstantPool.addUtf8("ConstantValue"),
</span>            (short) 0,
            (short) 2,
<span class='nc' id='L180' title='0|0|0 - Total: 1'>            itsConstantPool.addConstant(value));
</span><span class='nc' id='L181' title='0|0|0 - Total: 4'>        itsFields.add(field);
</span><span class='nc' id='L182' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial double value
     */
    public void addField(String fieldName, String type, short flags,
        double value) {
<span class='nc' id='L194' title='0|0|0 - Total: 5'>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
</span><span class='nc' id='L195' title='0|0|0 - Total: 5'>        short typeIndex = itsConstantPool.addUtf8(type);
</span><span class='nc' id='L196' title='0|0|0 - Total: 7'>        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,
</span>            flags);
<span class='nc' id='L198' title='0|0|0 - Total: 11'>        field.setAttributes(itsConstantPool.addUtf8("ConstantValue"),
</span>            (short) 0,
            (short) 2,
<span class='nc' id='L201' title='0|0|0 - Total: 1'>            itsConstantPool.addConstant(value));
</span><span class='nc' id='L202' title='0|0|0 - Total: 4'>        itsFields.add(field);
</span><span class='nc' id='L203' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Add Information about java variable to use when generating the local variable table.
     *
     * @param name variable name.
     * @param type variable type as bytecode descriptor string.
     * @param startPC the starting bytecode PC where this variable is live, or -1 if it does not have
     * a Java register.
     * @param register the Java register number of variable or -1 if it does not have a Java
     * register.
     */
    public void addVariableDescriptor(String name, String type, int startPC, int register) {
<span class='bc' id='L216' title='0|5|5 - Total: 5'>        int nameIndex = itsConstantPool.addUtf8(name);
</span><span class='bc' id='L217' title='0|5|5 - Total: 5'>        int descriptorIndex = itsConstantPool.addUtf8(type);
</span><span class='bc' id='L218' title='0|19|19 - Total: 19'>        int[] chunk = {nameIndex, descriptorIndex, startPC, register};
</span><span class='bc' id='L219' title='0|2|2 - Total: 2'>        if (itsVarDescriptors == null) {
</span><span class='bc' id='L220' title='0|5|5 - Total: 5'>            itsVarDescriptors = new ObjArray();
</span>        }
<span class='bc' id='L222' title='0|4|4 - Total: 4'>        itsVarDescriptors.add(chunk);
</span><span class='bc' id='L223' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Add a method and begin adding code.
     *
     * This method must be called before other methods for adding code, exception tables, etc. can be
     * invoked.
     *
     * @param methodName the name of the method
     * @param type a string representing the type
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     */
    public void startMethod(String methodName, String type, short flags) {
<span class='bc' id='L236' title='0|5|5 - Total: 5'>        short methodNameIndex = itsConstantPool.addUtf8(methodName);
</span><span class='bc' id='L237' title='0|5|5 - Total: 5'>        short typeIndex = itsConstantPool.addUtf8(type);
</span><span class='bc' id='L238' title='0|10|10 - Total: 10'>        itsCurrentMethod = new ClassFileMethod(methodName, methodNameIndex,
</span>            type, typeIndex, flags);
<span class='bc' id='L240' title='0|5|5 - Total: 5'>        itsJumpFroms = new UintMap();
</span><span class='bc' id='L241' title='0|5|5 - Total: 5'>        itsMethods.add(itsCurrentMethod);
</span><span class='bc' id='L242' title='0|3|3 - Total: 3'>        addSuperBlockStart(0);
</span><span class='bc' id='L243' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Complete generation of the method.
     *
     * After this method is called, no more code can be added to the method begun with
     * <code>startMethod</code>.
     *
     * @param maxLocals the maximum number of local variable slots (a.k.a. Java registers) used by the
     * method
     */
    public void stopMethod(short maxLocals) {
<span class='bpc' id='L255' title='0|1|1 - Total: 2'>        if (itsCurrentMethod == null)
</span><span class='nc' id='L256' title='0|0|0 - Total: 5'>            throw new IllegalStateException("No method to stop");
</span>
<span class='bc' id='L258' title='0|2|2 - Total: 2'>        fixLabelGotos();
</span>
<span class='bc' id='L260' title='0|3|3 - Total: 3'>        itsMaxLocals = maxLocals;
</span>
<span class='bc' id='L262' title='0|2|2 - Total: 2'>        StackMapTable stackMap = null;
</span><span class='bpc' id='L263' title='0|1|1 - Total: 2'>        if (GenerateStackMap) {
</span><span class='bc' id='L264' title='0|2|2 - Total: 2'>            finalizeSuperBlockStarts();
</span><span class='bc' id='L265' title='0|5|5 - Total: 5'>            stackMap = new StackMapTable();
</span><span class='bc' id='L266' title='0|2|2 - Total: 2'>            stackMap.generate();
</span>        }

<span class='bc' id='L269' title='0|2|2 - Total: 2'>        int lineNumberTableLength = 0;
</span><span class='bc' id='L270' title='0|2|2 - Total: 2'>        if (itsLineNumberTable != null) {
</span>            // 6 bytes for the attribute header
            // 2 bytes for the line number count
            // 4 bytes for each entry
<span class='bc' id='L274' title='0|7|7 - Total: 7'>            lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);
</span>        }

<span class='bc' id='L277' title='0|2|2 - Total: 2'>        int variableTableLength = 0;
</span><span class='bc' id='L278' title='0|2|2 - Total: 2'>        if (itsVarDescriptors != null) {
</span>            // 6 bytes for the attribute header
            // 2 bytes for the variable count
            // 10 bytes for each entry
<span class='bc' id='L282' title='0|8|8 - Total: 8'>            variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);
</span>        }

<span class='bc' id='L285' title='0|2|2 - Total: 2'>        int stackMapTableLength = 0;
</span><span class='bpc' id='L286' title='0|1|1 - Total: 2'>        if (stackMap != null) {
</span><span class='bc' id='L287' title='0|3|3 - Total: 3'>            int stackMapWriteSize = stackMap.computeWriteSize();
</span><span class='bpc' id='L288' title='0|1|1 - Total: 2'>            if (stackMapWriteSize > 0) {
</span><span class='bc' id='L289' title='0|4|4 - Total: 4'>                stackMapTableLength = 6 + stackMapWriteSize;
</span>            }
        }

<span class='bc' id='L293' title='0|20|20 - Total: 20'>        int attrLength = 2 +                    // attribute_name_index
</span>            4 +                    // attribute_length
            2 +                    // max_stack
            2 +                    // max_locals
            4 +                    // code_length
            itsCodeBufferTop +
            2 +                    // exception_table_length
            (itsExceptionTableTop * 8) +
            2 +                    // attributes_count
            lineNumberTableLength +
            variableTableLength +
            stackMapTableLength;

<span class='bpc' id='L306' title='0|1|1 - Total: 2'>        if (attrLength > 65536) {
</span>            // See http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html,
            // section 4.10, "The amount of code per non-native, non-abstract
            // method is limited to 65536 bytes...
<span class='nc' id='L310' title='0|0|0 - Total: 5'>            throw new ClassFileFormatException(
</span>                "generated bytecode for method exceeds 64K limit.");
        }
<span class='bc' id='L313' title='0|3|3 - Total: 3'>        byte[] codeAttribute = new byte[attrLength];
</span><span class='bc' id='L314' title='0|2|2 - Total: 2'>        int index = 0;
</span><span class='bc' id='L315' title='0|5|5 - Total: 5'>        int codeAttrIndex = itsConstantPool.addUtf8("Code");
</span><span class='bc' id='L316' title='0|5|5 - Total: 5'>        index = putInt16(codeAttrIndex, codeAttribute, index);
</span><span class='bc' id='L317' title='0|1|1 - Total: 1'>        attrLength -= 6;                 // discount the attribute header
</span><span class='bc' id='L318' title='0|5|5 - Total: 5'>        index = putInt32(attrLength, codeAttribute, index);
</span><span class='bc' id='L319' title='0|6|6 - Total: 6'>        index = putInt16(itsMaxStack, codeAttribute, index);
</span><span class='bc' id='L320' title='0|6|6 - Total: 6'>        index = putInt16(itsMaxLocals, codeAttribute, index);
</span><span class='bc' id='L321' title='0|6|6 - Total: 6'>        index = putInt32(itsCodeBufferTop, codeAttribute, index);
</span><span class='bc' id='L322' title='0|8|8 - Total: 8'>        System.arraycopy(itsCodeBuffer, 0, codeAttribute, index,
</span>            itsCodeBufferTop);
<span class='bc' id='L324' title='0|5|5 - Total: 5'>        index += itsCodeBufferTop;
</span>
<span class='bc' id='L326' title='0|2|2 - Total: 2'>        if (itsExceptionTableTop > 0) {
</span><span class='bc' id='L327' title='0|6|6 - Total: 6'>            index = putInt16(itsExceptionTableTop, codeAttribute, index);
</span><span class='bc' id='L328' title='0|2|2 - Total: 2'>            for (int i = 0; i < itsExceptionTableTop; i++) {
</span><span class='bc' id='L329' title='0|5|5 - Total: 5'>                ExceptionTableEntry ete = itsExceptionTable[i];
</span><span class='bc' id='L330' title='0|6|6 - Total: 6'>                short startPC = (short) getLabelPC(ete.itsStartLabel);
</span><span class='bc' id='L331' title='0|6|6 - Total: 6'>                short endPC = (short) getLabelPC(ete.itsEndLabel);
</span><span class='bc' id='L332' title='0|6|6 - Total: 6'>                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);
</span><span class='bc' id='L333' title='0|3|3 - Total: 3'>                short catchType = ete.itsCatchType;
</span><span class='bpc' id='L334' title='0|1|1 - Total: 2'>                if (startPC == -1)
</span><span class='nc' id='L335' title='0|0|0 - Total: 5'>                    throw new IllegalStateException("start label not defined");
</span><span class='bpc' id='L336' title='0|1|1 - Total: 2'>                if (endPC == -1)
</span><span class='nc' id='L337' title='0|0|0 - Total: 5'>                    throw new IllegalStateException("end label not defined");
</span><span class='bpc' id='L338' title='0|1|1 - Total: 2'>                if (handlerPC == -1)
</span><span class='nc' id='L339' title='0|0|0 - Total: 5'>                    throw new IllegalStateException(
</span>                        "handler label not defined");

<span class='bc' id='L342' title='0|5|5 - Total: 5'>                index = putInt16(startPC, codeAttribute, index);
</span><span class='bc' id='L343' title='0|5|5 - Total: 5'>                index = putInt16(endPC, codeAttribute, index);
</span><span class='bc' id='L344' title='0|5|5 - Total: 5'>                index = putInt16(handlerPC, codeAttribute, index);
</span><span class='bc' id='L345' title='0|5|5 - Total: 5'>                index = putInt16(catchType, codeAttribute, index);
</span>            }
        } else {
            // write 0 as exception table length
<span class='bc' id='L349' title='0|5|5 - Total: 5'>            index = putInt16(0, codeAttribute, index);
</span>        }

<span class='bc' id='L352' title='0|2|2 - Total: 2'>        int attributeCount = 0;
</span><span class='bc' id='L353' title='0|2|2 - Total: 2'>        if (itsLineNumberTable != null)
</span><span class='bc' id='L354' title='0|1|1 - Total: 1'>            attributeCount++;
</span><span class='bc' id='L355' title='0|2|2 - Total: 2'>        if (itsVarDescriptors != null)
</span><span class='bc' id='L356' title='0|1|1 - Total: 1'>            attributeCount++;
</span><span class='bpc' id='L357' title='0|1|1 - Total: 2'>        if (stackMapTableLength > 0) {
</span><span class='bc' id='L358' title='0|1|1 - Total: 1'>            attributeCount++;
</span>        }
<span class='bc' id='L360' title='0|5|5 - Total: 5'>        index = putInt16(attributeCount, codeAttribute, index);
</span>
<span class='bc' id='L362' title='0|2|2 - Total: 2'>        if (itsLineNumberTable != null) {
</span><span class='bc' id='L363' title='0|3|3 - Total: 3'>            int lineNumberTableAttrIndex
</span><span class='bc' id='L364' title='0|2|2 - Total: 2'>                = itsConstantPool.addUtf8("LineNumberTable");
</span><span class='bc' id='L365' title='0|5|5 - Total: 5'>            index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);
</span><span class='bc' id='L366' title='0|7|7 - Total: 7'>            int tableAttrLength = 2 + (itsLineNumberTableTop * 4);
</span><span class='bc' id='L367' title='0|5|5 - Total: 5'>            index = putInt32(tableAttrLength, codeAttribute, index);
</span><span class='bc' id='L368' title='0|6|6 - Total: 6'>            index = putInt16(itsLineNumberTableTop, codeAttribute, index);
</span><span class='bc' id='L369' title='0|2|2 - Total: 2'>            for (int i = 0; i < itsLineNumberTableTop; i++) {
</span><span class='bc' id='L370' title='0|8|8 - Total: 8'>                index = putInt32(itsLineNumberTable[i], codeAttribute, index);
</span>            }
        }

<span class='bc' id='L374' title='0|2|2 - Total: 2'>        if (itsVarDescriptors != null) {
</span><span class='bc' id='L375' title='0|3|3 - Total: 3'>            int variableTableAttrIndex
</span><span class='bc' id='L376' title='0|2|2 - Total: 2'>                = itsConstantPool.addUtf8("LocalVariableTable");
</span><span class='bc' id='L377' title='0|5|5 - Total: 5'>            index = putInt16(variableTableAttrIndex, codeAttribute, index);
</span><span class='bc' id='L378' title='0|4|4 - Total: 4'>            int varCount = itsVarDescriptors.size();
</span><span class='bc' id='L379' title='0|6|6 - Total: 6'>            int tableAttrLength = 2 + (varCount * 10);
</span><span class='bc' id='L380' title='0|5|5 - Total: 5'>            index = putInt32(tableAttrLength, codeAttribute, index);
</span><span class='bc' id='L381' title='0|5|5 - Total: 5'>            index = putInt16(varCount, codeAttribute, index);
</span><span class='bc' id='L382' title='0|2|2 - Total: 2'>            for (int i = 0; i < varCount; i++) {
</span><span class='bc' id='L383' title='0|7|7 - Total: 7'>                int[] chunk = (int[]) itsVarDescriptors.get(i);
</span><span class='bc' id='L384' title='0|4|4 - Total: 4'>                int nameIndex = chunk[0];
</span><span class='bc' id='L385' title='0|4|4 - Total: 4'>                int descriptorIndex = chunk[1];
</span><span class='bc' id='L386' title='0|4|4 - Total: 4'>                int startPC = chunk[2];
</span><span class='bc' id='L387' title='0|4|4 - Total: 4'>                int register = chunk[3];
</span><span class='bc' id='L388' title='0|5|5 - Total: 5'>                int length = itsCodeBufferTop - startPC;
</span>
<span class='bc' id='L390' title='0|5|5 - Total: 5'>                index = putInt16(startPC, codeAttribute, index);
</span><span class='bc' id='L391' title='0|5|5 - Total: 5'>                index = putInt16(length, codeAttribute, index);
</span><span class='bc' id='L392' title='0|5|5 - Total: 5'>                index = putInt16(nameIndex, codeAttribute, index);
</span><span class='bc' id='L393' title='0|5|5 - Total: 5'>                index = putInt16(descriptorIndex, codeAttribute, index);
</span><span class='bc' id='L394' title='0|5|5 - Total: 5'>                index = putInt16(register, codeAttribute, index);
</span>            }
        }

<span class='bpc' id='L398' title='0|1|1 - Total: 2'>        if (stackMapTableLength > 0) {
</span><span class='bc' id='L399' title='0|3|3 - Total: 3'>            int stackMapTableAttrIndex =
</span><span class='bc' id='L400' title='0|2|2 - Total: 2'>                itsConstantPool.addUtf8("StackMapTable");
</span><span class='bc' id='L401' title='0|2|2 - Total: 2'>            int start = index;
</span><span class='bc' id='L402' title='0|5|5 - Total: 5'>            index = putInt16(stackMapTableAttrIndex, codeAttribute, index);
</span><span class='bc' id='L403' title='0|5|5 - Total: 5'>            index = stackMap.write(codeAttribute, index);
</span>        }

<span class='bc' id='L406' title='0|4|4 - Total: 4'>        itsCurrentMethod.setCodeAttribute(codeAttribute);
</span>
<span class='bc' id='L408' title='0|3|3 - Total: 3'>        itsExceptionTable = null;
</span><span class='bc' id='L409' title='0|3|3 - Total: 3'>        itsExceptionTableTop = 0;
</span><span class='bc' id='L410' title='0|3|3 - Total: 3'>        itsLineNumberTableTop = 0;
</span><span class='bc' id='L411' title='0|3|3 - Total: 3'>        itsCodeBufferTop = 0;
</span><span class='bc' id='L412' title='0|3|3 - Total: 3'>        itsCurrentMethod = null;
</span><span class='bc' id='L413' title='0|3|3 - Total: 3'>        itsMaxStack = 0;
</span><span class='bc' id='L414' title='0|3|3 - Total: 3'>        itsStackTop = 0;
</span><span class='bc' id='L415' title='0|3|3 - Total: 3'>        itsLabelTableTop = 0;
</span><span class='bc' id='L416' title='0|3|3 - Total: 3'>        itsFixupTableTop = 0;
</span><span class='bc' id='L417' title='0|3|3 - Total: 3'>        itsVarDescriptors = null;
</span><span class='bc' id='L418' title='0|3|3 - Total: 3'>        itsSuperBlockStarts = null;
</span><span class='bc' id='L419' title='0|3|3 - Total: 3'>        itsSuperBlockStartsTop = 0;
</span><span class='bc' id='L420' title='0|3|3 - Total: 3'>        itsJumpFroms = null;
</span><span class='bc' id='L421' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Add the single-byte opcode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     */
    public void add(int theOpCode) {
<span class='bpc' id='L429' title='0|1|1 - Total: 2'>        if (opcodeCount(theOpCode) != 0)
</span><span class='nc' id='L430' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Unexpected operands");
</span><span class='bc' id='L431' title='0|6|6 - Total: 6'>        int newStack = itsStackTop + stackChange(theOpCode);
</span><span class='bpc' id='L432' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L433' title='0|0|0 - Total: 2'>            badStack(newStack);
</span>        if (DEBUGCODE)
            System.out.println("Add " + bytecodeStr(theOpCode));
<span class='bc' id='L436' title='0|3|3 - Total: 3'>        addToCodeBuffer(theOpCode);
</span><span class='bc' id='L437' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bc' id='L438' title='0|2|2 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='bc' id='L439' title='0|4|4 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
<span class='bc' id='L444' title='0|2|2 - Total: 2'>        if (theOpCode == ByteCode.ATHROW) {
</span><span class='bc' id='L445' title='0|4|4 - Total: 4'>            addSuperBlockStart(itsCodeBufferTop);
</span>        }
<span class='bc' id='L447' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Add a single-operand opcode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     * @param theOperand the operand of the bytecode
     */
    public void add(int theOpCode, int theOperand) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + Integer.toHexString(theOperand));
        }
<span class='bc' id='L460' title='0|6|6 - Total: 6'>        int newStack = itsStackTop + stackChange(theOpCode);
</span><span class='bpc' id='L461' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L462' title='0|0|0 - Total: 2'>            badStack(newStack);
</span>
<span class='bpc' id='L464' title='0|7|7 - Total: 9'>        switch (theOpCode) {
</span>            case ByteCode.GOTO:
                // This is necessary because dead code is seemingly being
                // generated and Sun's verifier is expecting type state to be
                // placed even at dead blocks of code.
<span class='bc' id='L469' title='0|6|6 - Total: 6'>                addSuperBlockStart(itsCodeBufferTop + 3);
</span>                // fallthru...
            case ByteCode.IFEQ:
            case ByteCode.IFNE:
            case ByteCode.IFLT:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPNE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.JSR:
            case ByteCode.IFNULL:
            case ByteCode.IFNONNULL: {
<span class='bpc' id='L488' title='0|1|1 - Total: 2'>                if ((theOperand & 0x80000000) != 0x80000000) {
</span><span class='nc' id='L489' title='0|0|0 - Total: 4'>                    if ((theOperand < 0) || (theOperand > 65535))
</span><span class='nc' id='L490' title='0|0|0 - Total: 5'>                        throw new IllegalArgumentException(
</span>                            "Bad label for branch");
                }
<span class='bc' id='L493' title='0|3|3 - Total: 3'>                int branchPC = itsCodeBufferTop;
</span><span class='bc' id='L494' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='bpc' id='L495' title='0|1|1 - Total: 2'>                if ((theOperand & 0x80000000) != 0x80000000) {
</span>                    // hard displacement
<span class='nc' id='L497' title='0|0|0 - Total: 3'>                    addToCodeInt16(theOperand);
</span><span class='nc' id='L498' title='0|0|0 - Total: 4'>                    int target = theOperand + branchPC;
</span><span class='nc' id='L499' title='0|0|0 - Total: 3'>                    addSuperBlockStart(target);
</span><span class='nc' id='L500' title='0|0|0 - Total: 5'>                    itsJumpFroms.put(target, branchPC);
</span><span class='nc' id='L501' title='0|0|0 - Total: 1'>                } else {  // a label
</span><span class='bc' id='L502' title='0|4|4 - Total: 4'>                    int targetPC = getLabelPC(theOperand);
</span>                    if (DEBUGLABELS) {
                        int theLabel = theOperand & 0x7FFFFFFF;
                        System.out.println("Fixing branch to " +
                            theLabel + " at " + targetPC +
                            " from " + branchPC);
                    }
<span class='bc' id='L509' title='0|2|2 - Total: 2'>                    if (targetPC != -1) {
</span><span class='bc' id='L510' title='0|4|4 - Total: 4'>                        int offset = targetPC - branchPC;
</span><span class='bc' id='L511' title='0|3|3 - Total: 3'>                        addToCodeInt16(offset);
</span><span class='bc' id='L512' title='0|3|3 - Total: 3'>                        addSuperBlockStart(targetPC);
</span><span class='bc' id='L513' title='0|5|5 - Total: 5'>                        itsJumpFroms.put(targetPC, branchPC);
</span><span class='bc' id='L514' title='0|1|1 - Total: 1'>                    } else {
</span><span class='bc' id='L515' title='0|6|6 - Total: 6'>                        addLabelFixup(theOperand, branchPC + 1);
</span><span class='bc' id='L516' title='0|3|3 - Total: 3'>                        addToCodeInt16(0);
</span>                    }
                }
            }
<span class='bc' id='L520' title='0|1|1 - Total: 1'>            break;
</span>
            case ByteCode.BIPUSH:
<span class='bpc' id='L523' title='0|1|1 - Total: 2'>                if ((byte) theOperand != theOperand)
</span><span class='nc' id='L524' title='0|0|0 - Total: 5'>                    throw new IllegalArgumentException("out of range byte");
</span><span class='bc' id='L525' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='bc' id='L526' title='0|4|4 - Total: 4'>                addToCodeBuffer((byte) theOperand);
</span><span class='bc' id='L527' title='0|1|1 - Total: 1'>                break;
</span>
            case ByteCode.SIPUSH:
<span class='bpc' id='L530' title='0|1|1 - Total: 2'>                if ((short) theOperand != theOperand)
</span><span class='nc' id='L531' title='0|0|0 - Total: 5'>                    throw new IllegalArgumentException("out of range short");
</span><span class='bc' id='L532' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='bc' id='L533' title='0|3|3 - Total: 3'>                addToCodeInt16(theOperand);
</span><span class='bc' id='L534' title='0|1|1 - Total: 1'>                break;
</span>
            case ByteCode.NEWARRAY:
<span class='bpc' id='L537' title='0|2|2 - Total: 4'>                if (!(0 <= theOperand && theOperand < 256))
</span><span class='nc' id='L538' title='0|0|0 - Total: 5'>                    throw new IllegalArgumentException("out of range index");
</span><span class='bc' id='L539' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='bc' id='L540' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOperand);
</span><span class='bc' id='L541' title='0|1|1 - Total: 1'>                break;
</span>
            case ByteCode.GETFIELD:
            case ByteCode.PUTFIELD:
<span class='nc' id='L545' title='0|0|0 - Total: 4'>                if (!(0 <= theOperand && theOperand < 65536))
</span><span class='nc' id='L546' title='0|0|0 - Total: 5'>                    throw new IllegalArgumentException("out of range field");
</span><span class='nc' id='L547' title='0|0|0 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='nc' id='L548' title='0|0|0 - Total: 3'>                addToCodeInt16(theOperand);
</span><span class='nc' id='L549' title='0|0|0 - Total: 1'>                break;
</span>
            case ByteCode.LDC:
            case ByteCode.LDC_W:
            case ByteCode.LDC2_W:
<span class='bpc' id='L554' title='0|2|2 - Total: 4'>                if (!(0 <= theOperand && theOperand < 65536))
</span><span class='nc' id='L555' title='0|0|0 - Total: 5'>                    throw new IllegalArgumentException("out of range index");
</span><span class='bpc' id='L556' title='0|5|5 - Total: 6'>                if (theOperand >= 256
</span>                    || theOpCode == ByteCode.LDC_W
                    || theOpCode == ByteCode.LDC2_W) {
<span class='bc' id='L559' title='0|2|2 - Total: 2'>                    if (theOpCode == ByteCode.LDC) {
</span><span class='bc' id='L560' title='0|4|4 - Total: 4'>                        addToCodeBuffer(ByteCode.LDC_W);
</span>                    } else {
<span class='bc' id='L562' title='0|3|3 - Total: 3'>                        addToCodeBuffer(theOpCode);
</span>                    }
<span class='bc' id='L564' title='0|4|4 - Total: 4'>                    addToCodeInt16(theOperand);
</span>                } else {
<span class='bc' id='L566' title='0|3|3 - Total: 3'>                    addToCodeBuffer(theOpCode);
</span><span class='bc' id='L567' title='0|3|3 - Total: 3'>                    addToCodeBuffer(theOperand);
</span>                }
<span class='bc' id='L569' title='0|1|1 - Total: 1'>                break;
</span>
            case ByteCode.RET:
            case ByteCode.ILOAD:
            case ByteCode.LLOAD:
            case ByteCode.FLOAD:
            case ByteCode.DLOAD:
            case ByteCode.ALOAD:
            case ByteCode.ISTORE:
            case ByteCode.LSTORE:
            case ByteCode.FSTORE:
            case ByteCode.DSTORE:
            case ByteCode.ASTORE:
<span class='bpc' id='L582' title='0|2|2 - Total: 4'>                if (!(0 <= theOperand && theOperand < 65536))
</span><span class='nc' id='L583' title='0|0|0 - Total: 5'>                    throw new ClassFileFormatException("out of range variable");
</span><span class='bc' id='L584' title='0|2|2 - Total: 2'>                if (theOperand >= 256) {
</span><span class='bc' id='L585' title='0|3|3 - Total: 3'>                    addToCodeBuffer(ByteCode.WIDE);
</span><span class='bc' id='L586' title='0|3|3 - Total: 3'>                    addToCodeBuffer(theOpCode);
</span><span class='bc' id='L587' title='0|4|4 - Total: 4'>                    addToCodeInt16(theOperand);
</span>                } else {
<span class='bc' id='L589' title='0|3|3 - Total: 3'>                    addToCodeBuffer(theOpCode);
</span><span class='bc' id='L590' title='0|3|3 - Total: 3'>                    addToCodeBuffer(theOperand);
</span>                }
<span class='bc' id='L592' title='0|1|1 - Total: 1'>                break;
</span>
            default:
<span class='nc' id='L595' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException(
</span>                    "Unexpected opcode for 1 operand");
        }

<span class='bc' id='L599' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bc' id='L600' title='0|2|2 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='bc' id='L601' title='0|4|4 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
<span class='bc' id='L606' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Generate the load constant bytecode for the given integer.
     *
     * @param k the constant
     */
    public void addLoadConstant(int k) {
<span class='bc' id='L614' title='0|7|7 - Total: 7'>        switch (k) {
</span>            case 0:
<span class='bc' id='L616' title='0|3|3 - Total: 3'>                add(ByteCode.ICONST_0);
</span><span class='bc' id='L617' title='0|1|1 - Total: 1'>                break;
</span>            case 1:
<span class='bc' id='L619' title='0|3|3 - Total: 3'>                add(ByteCode.ICONST_1);
</span><span class='bc' id='L620' title='0|1|1 - Total: 1'>                break;
</span>            case 2:
<span class='bc' id='L622' title='0|3|3 - Total: 3'>                add(ByteCode.ICONST_2);
</span><span class='bc' id='L623' title='0|1|1 - Total: 1'>                break;
</span>            case 3:
<span class='bc' id='L625' title='0|3|3 - Total: 3'>                add(ByteCode.ICONST_3);
</span><span class='bc' id='L626' title='0|1|1 - Total: 1'>                break;
</span>            case 4:
<span class='bc' id='L628' title='0|3|3 - Total: 3'>                add(ByteCode.ICONST_4);
</span><span class='bc' id='L629' title='0|1|1 - Total: 1'>                break;
</span>            case 5:
<span class='bc' id='L631' title='0|3|3 - Total: 3'>                add(ByteCode.ICONST_5);
</span><span class='bc' id='L632' title='0|1|1 - Total: 1'>                break;
</span>            default:
<span class='bc' id='L634' title='0|7|7 - Total: 7'>                add(ByteCode.LDC, itsConstantPool.addConstant(k));
</span>                break;
        }
<span class='bc' id='L637' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Generate the load constant bytecode for the given long.
     *
     * @param k the constant
     */
    public void addLoadConstant(long k) {
<span class='nc' id='L645' title='0|0|0 - Total: 7'>        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
</span><span class='nc' id='L646' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Generate the load constant bytecode for the given float.
     *
     * @param k the constant
     */
    public void addLoadConstant(float k) {
<span class='nc' id='L654' title='0|0|0 - Total: 7'>        add(ByteCode.LDC, itsConstantPool.addConstant(k));
</span><span class='nc' id='L655' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Generate the load constant bytecode for the given double.
     *
     * @param k the constant
     */
    public void addLoadConstant(double k) {
<span class='bc' id='L663' title='0|7|7 - Total: 7'>        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
</span><span class='bc' id='L664' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Generate the load constant bytecode for the given string.
     *
     * @param k the constant
     */
    public void addLoadConstant(String k) {
<span class='bc' id='L672' title='0|7|7 - Total: 7'>        add(ByteCode.LDC, itsConstantPool.addConstant(k));
</span><span class='bc' id='L673' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Add the given two-operand bytecode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     * @param theOperand1 the first operand of the bytecode
     * @param theOperand2 the second operand of the bytecode
     */
    public void add(int theOpCode, int theOperand1, int theOperand2) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + Integer.toHexString(theOperand1)
                + ", " + Integer.toHexString(theOperand2));
        }
<span class='nc' id='L688' title='0|0|0 - Total: 6'>        int newStack = itsStackTop + stackChange(theOpCode);
</span><span class='nc' id='L689' title='0|0|0 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L690' title='0|0|0 - Total: 2'>            badStack(newStack);
</span>
<span class='nc' id='L692' title='0|0|0 - Total: 2'>        if (theOpCode == ByteCode.IINC) {
</span><span class='nc' id='L693' title='0|0|0 - Total: 4'>            if (!(0 <= theOperand1 && theOperand1 < 65536))
</span><span class='nc' id='L694' title='0|0|0 - Total: 5'>                throw new ClassFileFormatException("out of range variable");
</span><span class='nc' id='L695' title='0|0|0 - Total: 4'>            if (!(0 <= theOperand2 && theOperand2 < 65536))
</span><span class='nc' id='L696' title='0|0|0 - Total: 5'>                throw new ClassFileFormatException("out of range increment");
</span>
<span class='nc' id='L698' title='0|0|0 - Total: 6'>            if (theOperand1 > 255 || theOperand2 < -128 || theOperand2 > 127) {
</span><span class='nc' id='L699' title='0|0|0 - Total: 3'>                addToCodeBuffer(ByteCode.WIDE);
</span><span class='nc' id='L700' title='0|0|0 - Total: 3'>                addToCodeBuffer(ByteCode.IINC);
</span><span class='nc' id='L701' title='0|0|0 - Total: 3'>                addToCodeInt16(theOperand1);
</span><span class='nc' id='L702' title='0|0|0 - Total: 4'>                addToCodeInt16(theOperand2);
</span>            } else {
<span class='nc' id='L704' title='0|0|0 - Total: 3'>                addToCodeBuffer(ByteCode.IINC);
</span><span class='nc' id='L705' title='0|0|0 - Total: 3'>                addToCodeBuffer(theOperand1);
</span><span class='nc' id='L706' title='0|0|0 - Total: 4'>                addToCodeBuffer(theOperand2);
</span>            }
<span class='nc' id='L708' title='0|0|0 - Total: 2'>        } else if (theOpCode == ByteCode.MULTIANEWARRAY) {
</span><span class='nc' id='L709' title='0|0|0 - Total: 4'>            if (!(0 <= theOperand1 && theOperand1 < 65536))
</span><span class='nc' id='L710' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException("out of range index");
</span><span class='nc' id='L711' title='0|0|0 - Total: 4'>            if (!(0 <= theOperand2 && theOperand2 < 256))
</span><span class='nc' id='L712' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException("out of range dimensions");
</span>
<span class='nc' id='L714' title='0|0|0 - Total: 3'>            addToCodeBuffer(ByteCode.MULTIANEWARRAY);
</span><span class='nc' id='L715' title='0|0|0 - Total: 3'>            addToCodeInt16(theOperand1);
</span><span class='nc' id='L716' title='0|0|0 - Total: 4'>            addToCodeBuffer(theOperand2);
</span>        } else {
<span class='nc' id='L718' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException(
</span>                "Unexpected opcode for 2 operands");
        }
<span class='nc' id='L721' title='0|0|0 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='nc' id='L722' title='0|0|0 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='nc' id='L723' title='0|0|0 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }

<span class='nc' id='L729' title='0|0|0 - Total: 1'>    }
</span>
    public void add(int theOpCode, String className) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + className);
        }
<span class='bc' id='L736' title='0|6|6 - Total: 6'>        int newStack = itsStackTop + stackChange(theOpCode);
</span><span class='bpc' id='L737' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L738' title='0|0|0 - Total: 2'>            badStack(newStack);
</span><span class='bpc' id='L739' title='0|1|1 - Total: 2'>        switch (theOpCode) {
</span>            case ByteCode.NEW:
            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.INSTANCEOF: {
<span class='bc' id='L744' title='0|5|5 - Total: 5'>                short classIndex = itsConstantPool.addClass(className);
</span><span class='bc' id='L745' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='bc' id='L746' title='0|3|3 - Total: 3'>                addToCodeInt16(classIndex);
</span>            }
<span class='bc' id='L748' title='0|1|1 - Total: 1'>            break;
</span>
            default:
<span class='nc' id='L751' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException(
</span>                    "bad opcode for class reference");
        }
<span class='bc' id='L754' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bc' id='L755' title='0|2|2 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='bc' id='L756' title='0|4|4 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
<span class='bc' id='L761' title='0|1|1 - Total: 1'>    }
</span>

    public void add(int theOpCode, String className, String fieldName,
        String fieldType) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + className + ", " + fieldName + ", " + fieldType);
        }
<span class='bc' id='L770' title='0|6|6 - Total: 6'>        int newStack = itsStackTop + stackChange(theOpCode);
</span><span class='bc' id='L771' title='0|4|4 - Total: 4'>        char fieldTypeChar = fieldType.charAt(0);
</span><span class='bpc' id='L772' title='0|2|2 - Total: 4'>        int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D')
</span>            ? 2 : 1;
<span class='bpc' id='L774' title='0|2|2 - Total: 3'>        switch (theOpCode) {
</span>            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
<span class='bc' id='L777' title='0|4|4 - Total: 4'>                newStack += fieldSize;
</span><span class='bc' id='L778' title='0|1|1 - Total: 1'>                break;
</span>            case ByteCode.PUTSTATIC:
            case ByteCode.PUTFIELD:
<span class='bc' id='L781' title='0|4|4 - Total: 4'>                newStack -= fieldSize;
</span><span class='bc' id='L782' title='0|1|1 - Total: 1'>                break;
</span>            default:
<span class='nc' id='L784' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException(
</span>                    "bad opcode for field reference");
        }
<span class='bpc' id='L787' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L788' title='0|0|0 - Total: 2'>            badStack(newStack);
</span><span class='bc' id='L789' title='0|7|7 - Total: 7'>        short fieldRefIndex = itsConstantPool.addFieldRef(className,
</span>            fieldName, fieldType);
<span class='bc' id='L791' title='0|3|3 - Total: 3'>        addToCodeBuffer(theOpCode);
</span><span class='bc' id='L792' title='0|3|3 - Total: 3'>        addToCodeInt16(fieldRefIndex);
</span>
<span class='bc' id='L794' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bc' id='L795' title='0|2|2 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='bc' id='L796' title='0|4|4 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
<span class='bc' id='L801' title='0|1|1 - Total: 1'>    }
</span>
    public void addInvoke(int theOpCode, String className, String methodName,
        String methodType) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(theOpCode)
                + ", " + className + ", " + methodName + ", "
                + methodType);
        }
<span class='bc' id='L810' title='0|3|3 - Total: 3'>        int parameterInfo = sizeOfParameters(methodType);
</span><span class='bc' id='L811' title='0|4|4 - Total: 4'>        int parameterCount = parameterInfo >>> 16;
</span><span class='bc' id='L812' title='0|3|3 - Total: 3'>        int stackDiff = (short) parameterInfo;
</span>
<span class='bc' id='L814' title='0|5|5 - Total: 5'>        int newStack = itsStackTop + stackDiff;
</span><span class='bc' id='L815' title='0|5|5 - Total: 5'>        newStack += stackChange(theOpCode);     // adjusts for 'this'
</span><span class='bpc' id='L816' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L817' title='0|0|0 - Total: 2'>            badStack(newStack);
</span>
<span class='bpc' id='L819' title='0|1|1 - Total: 2'>        switch (theOpCode) {
</span>            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEINTERFACE: {
<span class='bc' id='L824' title='0|3|3 - Total: 3'>                addToCodeBuffer(theOpCode);
</span><span class='bc' id='L825' title='0|2|2 - Total: 2'>                if (theOpCode == ByteCode.INVOKEINTERFACE) {
</span><span class='bc' id='L826' title='0|5|5 - Total: 5'>                    short ifMethodRefIndex
</span><span class='bc' id='L827' title='0|2|2 - Total: 2'>                        = itsConstantPool.addInterfaceMethodRef(
</span>                        className, methodName,
                        methodType);
<span class='bc' id='L830' title='0|3|3 - Total: 3'>                    addToCodeInt16(ifMethodRefIndex);
</span><span class='bc' id='L831' title='0|5|5 - Total: 5'>                    addToCodeBuffer(parameterCount + 1);
</span><span class='bc' id='L832' title='0|3|3 - Total: 3'>                    addToCodeBuffer(0);
</span><span class='bc' id='L833' title='0|1|1 - Total: 1'>                } else {
</span><span class='bc' id='L834' title='0|7|7 - Total: 7'>                    short methodRefIndex = itsConstantPool.addMethodRef(
</span>                        className, methodName,
                        methodType);
<span class='bc' id='L837' title='0|3|3 - Total: 3'>                    addToCodeInt16(methodRefIndex);
</span>                }
            }
<span class='bc' id='L840' title='0|1|1 - Total: 1'>            break;
</span>
            default:
<span class='nc' id='L843' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException(
</span>                    "bad opcode for method reference");
        }
<span class='bc' id='L846' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bc' id='L847' title='0|2|2 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='bc' id='L848' title='0|4|4 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(theOpCode)
                + " stack = " + itsStackTop);
        }
<span class='bc' id='L853' title='0|1|1 - Total: 1'>    }
</span>
    public void addInvokeDynamic(String methodName, String methodType,
        MHandle bsm, Object... bsmArgs) {
        if (DEBUGCODE) {
            System.out.println("Add invokedynamic, " + methodName + ", " + methodType);
        }
        // JDK 1.7 major class file version is required for invokedynamic
<span class='nc' id='L861' title='0|0|0 - Total: 2'>        if (MajorVersion < 51) {
</span><span class='nc' id='L862' title='0|0|0 - Total: 5'>            throw new RuntimeException(
</span>                "Please build and run with JDK 1.7 for invokedynamic support");
        }

<span class='nc' id='L866' title='0|0|0 - Total: 3'>        int parameterInfo = sizeOfParameters(methodType);
</span>        // int parameterCount = parameterInfo >>> 16;
<span class='nc' id='L868' title='0|0|0 - Total: 3'>        int stackDiff = (short) parameterInfo;
</span>
<span class='nc' id='L870' title='0|0|0 - Total: 5'>        int newStack = itsStackTop + stackDiff;
</span><span class='nc' id='L871' title='0|0|0 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L872' title='0|0|0 - Total: 2'>            badStack(newStack);
</span>
<span class='nc' id='L874' title='0|0|0 - Total: 7'>        BootstrapEntry bsmEntry = new BootstrapEntry(bsm, bsmArgs);
</span>
<span class='nc' id='L876' title='0|0|0 - Total: 2'>        if (itsBootstrapMethods == null) {
</span><span class='nc' id='L877' title='0|0|0 - Total: 5'>            itsBootstrapMethods = new ObjArray();
</span>        }
<span class='nc' id='L879' title='0|0|0 - Total: 5'>        int bootstrapIndex = itsBootstrapMethods.indexOf(bsmEntry);
</span><span class='nc' id='L880' title='0|0|0 - Total: 2'>        if (bootstrapIndex == -1) {
</span><span class='nc' id='L881' title='0|0|0 - Total: 4'>            bootstrapIndex = itsBootstrapMethods.size();
</span><span class='nc' id='L882' title='0|0|0 - Total: 4'>            itsBootstrapMethods.add(bsmEntry);
</span><span class='nc' id='L883' title='0|0|0 - Total: 8'>            itsBootstrapMethodsLength += bsmEntry.code.length;
</span>        }

<span class='nc' id='L886' title='0|0|0 - Total: 7'>        short invokedynamicIndex = itsConstantPool.addInvokeDynamic(
</span>            methodName, methodType, bootstrapIndex);

<span class='nc' id='L889' title='0|0|0 - Total: 3'>        addToCodeBuffer(ByteCode.INVOKEDYNAMIC);
</span><span class='nc' id='L890' title='0|0|0 - Total: 3'>        addToCodeInt16(invokedynamicIndex);
</span><span class='nc' id='L891' title='0|0|0 - Total: 3'>        addToCodeInt16(0);
</span>
<span class='nc' id='L893' title='0|0|0 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='nc' id='L894' title='0|0|0 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='nc' id='L895' title='0|0|0 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After invokedynamic stack = " + itsStackTop);
        }

<span class='nc' id='L900' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Generate code to load the given integer on stack.
     *
     * @param k the constant
     */
    public void addPush(int k) {
<span class='bc' id='L908' title='0|2|2 - Total: 2'>        if ((byte) k == k) {
</span><span class='bc' id='L909' title='0|2|2 - Total: 2'>            if (k == -1) {
</span><span class='bc' id='L910' title='0|4|4 - Total: 4'>                add(ByteCode.ICONST_M1);
</span><span class='bc' id='L911' title='0|4|4 - Total: 4'>            } else if (0 <= k && k <= 5) {
</span><span class='bc' id='L912' title='0|7|7 - Total: 7'>                add((byte) (ByteCode.ICONST_0 + k));
</span>            } else {
<span class='bc' id='L914' title='0|6|6 - Total: 6'>                add(ByteCode.BIPUSH, (byte) k);
</span>            }
<span class='bc' id='L916' title='0|2|2 - Total: 2'>        } else if ((short) k == k) {
</span><span class='bc' id='L917' title='0|6|6 - Total: 6'>            add(ByteCode.SIPUSH, (short) k);
</span>        } else {
<span class='bc' id='L919' title='0|3|3 - Total: 3'>            addLoadConstant(k);
</span>        }
<span class='bc' id='L921' title='0|1|1 - Total: 1'>    }
</span>
    public void addPush(boolean k) {
<span class='bc' id='L924' title='0|2|2 - Total: 2'>        add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);
</span><span class='bc' id='L925' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Generate code to load the given long on stack.
     *
     * @param k the constant
     */
    public void addPush(long k) {
<span class='bc' id='L933' title='0|3|3 - Total: 3'>        int ik = (int) k;
</span><span class='bpc' id='L934' title='0|1|1 - Total: 2'>        if (ik == k) {
</span><span class='bc' id='L935' title='0|3|3 - Total: 3'>            addPush(ik);
</span><span class='bc' id='L936' title='0|4|4 - Total: 4'>            add(ByteCode.I2L);
</span>        } else {
<span class='nc' id='L938' title='0|0|0 - Total: 3'>            addLoadConstant(k);
</span>        }
<span class='bc' id='L940' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Generate code to load the given double on stack.
     *
     * @param k the constant
     */
    public void addPush(double k) {
<span class='bc' id='L948' title='0|2|2 - Total: 2'>        if (k == 0.0) {
</span>            // zero
<span class='bc' id='L950' title='0|3|3 - Total: 3'>            add(ByteCode.DCONST_0);
</span><span class='bc' id='L951' title='0|2|2 - Total: 2'>            if (1.0 / k < 0) {
</span>                // Negative zero
<span class='bc' id='L953' title='0|4|4 - Total: 4'>                add(ByteCode.DNEG);
</span>            }
<span class='bc' id='L955' title='0|4|4 - Total: 4'>        } else if (k == 1.0 || k == -1.0) {
</span><span class='bc' id='L956' title='0|3|3 - Total: 3'>            add(ByteCode.DCONST_1);
</span><span class='bc' id='L957' title='0|2|2 - Total: 2'>            if (k < 0) {
</span><span class='bc' id='L958' title='0|4|4 - Total: 4'>                add(ByteCode.DNEG);
</span>            }
        } else {
<span class='bc' id='L961' title='0|3|3 - Total: 3'>            addLoadConstant(k);
</span>        }
<span class='bc' id='L963' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Generate the code to leave on stack the given string even if the string encoding exeeds the
     * class file limit for single string constant
     *
     * @param k the constant
     */
    public void addPush(String k) {
<span class='bc' id='L972' title='0|3|3 - Total: 3'>        int length = k.length();
</span><span class='bc' id='L973' title='0|7|7 - Total: 7'>        int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);
</span><span class='bc' id='L974' title='0|2|2 - Total: 2'>        if (limit == length) {
</span><span class='bc' id='L975' title='0|3|3 - Total: 3'>            addLoadConstant(k);
</span><span class='bc' id='L976' title='0|1|1 - Total: 1'>            return;
</span>        }
        // Split string into picies fitting the UTF limit and generate code for
        // StringBuilder sb = new StringBuilder(length);
        // sb.append(loadConstant(piece_1));
        // ...
        // sb.append(loadConstant(piece_N));
        // sb.toString();
<span class='bc' id='L984' title='0|2|2 - Total: 2'>        final String SB = "java/lang/StringBuilder";
</span><span class='bc' id='L985' title='0|4|4 - Total: 4'>        add(ByteCode.NEW, SB);
</span><span class='bc' id='L986' title='0|3|3 - Total: 3'>        add(ByteCode.DUP);
</span><span class='bc' id='L987' title='0|3|3 - Total: 3'>        addPush(length);
</span><span class='bc' id='L988' title='0|6|6 - Total: 6'>        addInvoke(ByteCode.INVOKESPECIAL, SB, "<init>", "(I)V");
</span><span class='bc' id='L989' title='0|2|2 - Total: 2'>        int cursor = 0;
</span>        for (; ; ) {
<span class='bc' id='L991' title='0|3|3 - Total: 3'>            add(ByteCode.DUP);
</span><span class='bc' id='L992' title='0|5|5 - Total: 5'>            String s = k.substring(cursor, limit);
</span><span class='bc' id='L993' title='0|3|3 - Total: 3'>            addLoadConstant(s);
</span><span class='bc' id='L994' title='0|6|6 - Total: 6'>            addInvoke(ByteCode.INVOKEVIRTUAL, SB, "append",
</span>                "(Ljava/lang/String;)Ljava/lang/StringBuilder;");
<span class='bc' id='L996' title='0|3|3 - Total: 3'>            add(ByteCode.POP);
</span><span class='bc' id='L997' title='0|2|2 - Total: 2'>            if (limit == length) {
</span><span class='bc' id='L998' title='0|1|1 - Total: 1'>                break;
</span>            }
<span class='bc' id='L1000' title='0|2|2 - Total: 2'>            cursor = limit;
</span><span class='bc' id='L1001' title='0|7|7 - Total: 7'>            limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);
</span><span class='bc' id='L1002' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L1003' title='0|6|6 - Total: 6'>        addInvoke(ByteCode.INVOKEVIRTUAL, SB, "toString",
</span>            "()Ljava/lang/String;");
<span class='bc' id='L1005' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Check if k fits limit on string constant size imposed by class file format.
     *
     * @param k the string constant
     */
    public boolean isUnderStringSizeLimit(String k) {
<span class='nc' id='L1013' title='0|0|0 - Total: 5'>        return itsConstantPool.isUnderUtfEncodingLimit(k);
</span>    }

    /**
     * Store integer from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addIStore(int local) {
<span class='bc' id='L1022' title='0|5|5 - Total: 5'>        xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);
</span><span class='bc' id='L1023' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Store long from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addLStore(int local) {
<span class='nc' id='L1031' title='0|0|0 - Total: 5'>        xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);
</span><span class='nc' id='L1032' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Store float from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addFStore(int local) {
<span class='nc' id='L1040' title='0|0|0 - Total: 5'>        xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);
</span><span class='nc' id='L1041' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Store double from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addDStore(int local) {
<span class='bc' id='L1049' title='0|5|5 - Total: 5'>        xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);
</span><span class='bc' id='L1050' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Store object from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addAStore(int local) {
<span class='bc' id='L1058' title='0|5|5 - Total: 5'>        xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);
</span><span class='bc' id='L1059' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Load integer from the given local into stack.
     *
     * @param local number of local register
     */
    public void addILoad(int local) {
<span class='bc' id='L1067' title='0|5|5 - Total: 5'>        xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);
</span><span class='bc' id='L1068' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Load long from the given local into stack.
     *
     * @param local number of local register
     */
    public void addLLoad(int local) {
<span class='nc' id='L1076' title='0|0|0 - Total: 5'>        xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);
</span><span class='nc' id='L1077' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Load float from the given local into stack.
     *
     * @param local number of local register
     */
    public void addFLoad(int local) {
<span class='bc' id='L1085' title='0|5|5 - Total: 5'>        xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);
</span><span class='bc' id='L1086' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Load double from the given local into stack.
     *
     * @param local number of local register
     */
    public void addDLoad(int local) {
<span class='bc' id='L1094' title='0|5|5 - Total: 5'>        xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);
</span><span class='bc' id='L1095' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Load object from the given local into stack.
     *
     * @param local number of local register
     */
    public void addALoad(int local) {
<span class='bc' id='L1103' title='0|5|5 - Total: 5'>        xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);
</span><span class='bc' id='L1104' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Load "this" into stack.
     */
    public void addLoadThis() {
<span class='bc' id='L1110' title='0|3|3 - Total: 3'>        add(ByteCode.ALOAD_0);
</span><span class='bc' id='L1111' title='0|1|1 - Total: 1'>    }
</span>
    private void xop(int shortOp, int op, int local) {
<span class='bc' id='L1114' title='0|5|5 - Total: 5'>        switch (local) {
</span>            case 0:
<span class='bc' id='L1116' title='0|3|3 - Total: 3'>                add(shortOp);
</span><span class='bc' id='L1117' title='0|1|1 - Total: 1'>                break;
</span>            case 1:
<span class='bc' id='L1119' title='0|5|5 - Total: 5'>                add(shortOp + 1);
</span><span class='bc' id='L1120' title='0|1|1 - Total: 1'>                break;
</span>            case 2:
<span class='bc' id='L1122' title='0|5|5 - Total: 5'>                add(shortOp + 2);
</span><span class='bc' id='L1123' title='0|1|1 - Total: 1'>                break;
</span>            case 3:
<span class='bc' id='L1125' title='0|5|5 - Total: 5'>                add(shortOp + 3);
</span><span class='bc' id='L1126' title='0|1|1 - Total: 1'>                break;
</span>            default:
<span class='bc' id='L1128' title='0|4|4 - Total: 4'>                add(op, local);
</span>        }
<span class='bc' id='L1130' title='0|1|1 - Total: 1'>    }
</span>
    public int addTableSwitch(int low, int high) {
        if (DEBUGCODE) {
            System.out.println("Add " + bytecodeStr(ByteCode.TABLESWITCH)
                + " " + low + " " + high);
        }
<span class='bpc' id='L1137' title='0|1|1 - Total: 2'>        if (low > high)
</span><span class='nc' id='L1138' title='0|0|0 - Total: 16'>            throw new ClassFileFormatException("Bad bounds: " + low + ' ' + high);
</span>
<span class='bc' id='L1140' title='0|6|6 - Total: 6'>        int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);
</span><span class='bpc' id='L1141' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L1142' title='0|0|0 - Total: 2'>            badStack(newStack);
</span>
<span class='bc' id='L1144' title='0|6|6 - Total: 6'>        int entryCount = high - low + 1;
</span><span class='bc' id='L1145' title='0|7|7 - Total: 7'>        int padSize = 3 & ~itsCodeBufferTop; // == 3 - itsCodeBufferTop % 4
</span>
<span class='bc' id='L1147' title='0|12|12 - Total: 12'>        int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));
</span><span class='bc' id='L1148' title='0|2|2 - Total: 2'>        int switchStart = N;
</span><span class='bc' id='L1149' title='0|6|6 - Total: 6'>        itsCodeBuffer[N++] = (byte) ByteCode.TABLESWITCH;
</span><span class='bc' id='L1150' title='0|2|2 - Total: 2'>        while (padSize != 0) {
</span><span class='bc' id='L1151' title='0|6|6 - Total: 6'>            itsCodeBuffer[N++] = 0;
</span><span class='bc' id='L1152' title='0|2|2 - Total: 2'>            --padSize;
</span>        }
<span class='bc' id='L1154' title='0|1|1 - Total: 1'>        N += 4; // skip default offset
</span><span class='bc' id='L1155' title='0|6|6 - Total: 6'>        N = putInt32(low, itsCodeBuffer, N);
</span><span class='bc' id='L1156' title='0|6|6 - Total: 6'>        putInt32(high, itsCodeBuffer, N);
</span>
<span class='bc' id='L1158' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bpc' id='L1159' title='0|1|1 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='nc' id='L1160' title='0|0|0 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + bytecodeStr(ByteCode.TABLESWITCH)
                + " stack = " + itsStackTop);
        }

<span class='bc' id='L1166' title='0|2|2 - Total: 2'>        return switchStart;
</span>    }

    public final void markTableSwitchDefault(int switchStart) {
<span class='bc' id='L1170' title='0|4|4 - Total: 4'>        addSuperBlockStart(itsCodeBufferTop);
</span><span class='bc' id='L1171' title='0|6|6 - Total: 6'>        itsJumpFroms.put(itsCodeBufferTop, switchStart);
</span><span class='bc' id='L1172' title='0|6|6 - Total: 6'>        setTableSwitchJump(switchStart, -1, itsCodeBufferTop);
</span><span class='bc' id='L1173' title='0|1|1 - Total: 1'>    }
</span>
    public final void markTableSwitchCase(int switchStart, int caseIndex) {
<span class='bc' id='L1176' title='0|4|4 - Total: 4'>        addSuperBlockStart(itsCodeBufferTop);
</span><span class='bc' id='L1177' title='0|6|6 - Total: 6'>        itsJumpFroms.put(itsCodeBufferTop, switchStart);
</span><span class='bc' id='L1178' title='0|6|6 - Total: 6'>        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
</span><span class='bc' id='L1179' title='0|1|1 - Total: 1'>    }
</span>
    public final void markTableSwitchCase(int switchStart, int caseIndex,
        int stackTop) {
<span class='bpc' id='L1183' title='0|2|2 - Total: 4'>        if (!(0 <= stackTop && stackTop <= itsMaxStack))
</span><span class='nc' id='L1184' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException("Bad stack index: " + stackTop);
</span><span class='bc' id='L1185' title='0|4|4 - Total: 4'>        itsStackTop = (short) stackTop;
</span><span class='bc' id='L1186' title='0|4|4 - Total: 4'>        addSuperBlockStart(itsCodeBufferTop);
</span><span class='bc' id='L1187' title='0|6|6 - Total: 6'>        itsJumpFroms.put(itsCodeBufferTop, switchStart);
</span><span class='bc' id='L1188' title='0|6|6 - Total: 6'>        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
</span><span class='bc' id='L1189' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Set a jump case for a tableswitch instruction. The jump target should be marked as a super
     * block start for stack map generation.
     */
    public void setTableSwitchJump(int switchStart, int caseIndex,
        int jumpTarget) {
<span class='bpc' id='L1197' title='0|2|2 - Total: 4'>        if (!(0 <= jumpTarget && jumpTarget <= itsCodeBufferTop))
</span><span class='nc' id='L1198' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException("Bad jump target: " + jumpTarget);
</span><span class='bpc' id='L1199' title='0|1|1 - Total: 2'>        if (!(caseIndex >= -1))
</span><span class='nc' id='L1200' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException("Bad case index: " + caseIndex);
</span>
<span class='bc' id='L1202' title='0|6|6 - Total: 6'>        int padSize = 3 & ~switchStart; // == 3 - switchStart % 4
</span>        int caseOffset;
<span class='bc' id='L1204' title='0|2|2 - Total: 2'>        if (caseIndex < 0) {
</span>            // default label
<span class='bc' id='L1206' title='0|7|7 - Total: 7'>            caseOffset = switchStart + 1 + padSize;
</span>        } else {
<span class='bc' id='L1208' title='0|12|12 - Total: 12'>            caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);
</span>        }
<span class='bpc' id='L1210' title='0|2|2 - Total: 4'>        if (!(0 <= switchStart
</span>            && switchStart <= itsCodeBufferTop - 4 * 4 - padSize - 1)) {
<span class='nc' id='L1212' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException(
</span>                switchStart + " is outside a possible range of tableswitch"
                    + " in already generated code");
        }
<span class='bpc' id='L1216' title='0|1|1 - Total: 2'>        if ((0xFF & itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {
</span><span class='nc' id='L1217' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException(
</span>                switchStart + " is not offset of tableswitch statement");
        }
<span class='bpc' id='L1220' title='0|2|2 - Total: 4'>        if (!(0 <= caseOffset && caseOffset + 4 <= itsCodeBufferTop)) {
</span>            // caseIndex >= -1 does not guarantee that caseOffset >= 0 due
            // to a possible overflow.
<span class='nc' id='L1223' title='0|0|0 - Total: 12'>            throw new ClassFileFormatException(
</span>                "Too big case index: " + caseIndex);
        }
        // ALERT: perhaps check against case bounds?
<span class='bc' id='L1227' title='0|8|8 - Total: 8'>        putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);
</span><span class='bc' id='L1228' title='0|1|1 - Total: 1'>    }
</span>
    public int acquireLabel() {
<span class='bc' id='L1231' title='0|3|3 - Total: 3'>        int top = itsLabelTableTop;
</span><span class='bc' id='L1232' title='0|4|4 - Total: 4'>        if (itsLabelTable == null || top == itsLabelTable.length) {
</span><span class='bc' id='L1233' title='0|2|2 - Total: 2'>            if (itsLabelTable == null) {
</span><span class='bc' id='L1234' title='0|5|5 - Total: 5'>                itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
</span>            } else {
<span class='bc' id='L1236' title='0|7|7 - Total: 7'>                int[] tmp = new int[itsLabelTable.length * 2];
</span><span class='bc' id='L1237' title='0|7|7 - Total: 7'>                System.arraycopy(itsLabelTable, 0, tmp, 0, top);
</span><span class='bc' id='L1238' title='0|3|3 - Total: 3'>                itsLabelTable = tmp;
</span>            }
        }
<span class='bc' id='L1241' title='0|5|5 - Total: 5'>        itsLabelTableTop = top + 1;
</span><span class='bc' id='L1242' title='0|5|5 - Total: 5'>        itsLabelTable[top] = -1;
</span><span class='bc' id='L1243' title='0|4|4 - Total: 4'>        return top | 0x80000000;
</span>    }

    public void markLabel(int label) {
<span class='bpc' id='L1247' title='0|1|1 - Total: 2'>        if (!(label < 0))
</span><span class='nc' id='L1248' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad label, no biscuit");
</span>
<span class='bc' id='L1250' title='0|4|4 - Total: 4'>        label &= 0x7FFFFFFF;
</span><span class='bpc' id='L1251' title='0|1|1 - Total: 2'>        if (label > itsLabelTableTop)
</span><span class='nc' id='L1252' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad label");
</span>
<span class='bpc' id='L1254' title='0|1|1 - Total: 2'>        if (itsLabelTable[label] != -1) {
</span><span class='nc' id='L1255' title='0|0|0 - Total: 5'>            throw new IllegalStateException("Can only mark label once");
</span>        }

<span class='bc' id='L1258' title='0|6|6 - Total: 6'>        itsLabelTable[label] = itsCodeBufferTop;
</span><span class='bc' id='L1259' title='0|1|1 - Total: 1'>    }
</span>
    public void markLabel(int label, short stackTop) {
<span class='bc' id='L1262' title='0|3|3 - Total: 3'>        markLabel(label);
</span><span class='bc' id='L1263' title='0|3|3 - Total: 3'>        itsStackTop = stackTop;
</span><span class='bc' id='L1264' title='0|1|1 - Total: 1'>    }
</span>
    public void markHandler(int theLabel) {
<span class='bc' id='L1267' title='0|3|3 - Total: 3'>        itsStackTop = 1;
</span><span class='bc' id='L1268' title='0|3|3 - Total: 3'>        markLabel(theLabel);
</span><span class='bc' id='L1269' title='0|1|1 - Total: 1'>    }
</span>
    public int getLabelPC(int label) {
<span class='bpc' id='L1272' title='0|1|1 - Total: 2'>        if (!(label < 0))
</span><span class='nc' id='L1273' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad label, no biscuit");
</span><span class='bc' id='L1274' title='0|4|4 - Total: 4'>        label &= 0x7FFFFFFF;
</span><span class='bpc' id='L1275' title='0|1|1 - Total: 2'>        if (!(label < itsLabelTableTop))
</span><span class='nc' id='L1276' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad label");
</span><span class='bc' id='L1277' title='0|5|5 - Total: 5'>        return itsLabelTable[label];
</span>    }

    private void addLabelFixup(int label, int fixupSite) {
<span class='bpc' id='L1281' title='0|1|1 - Total: 2'>        if (!(label < 0))
</span><span class='nc' id='L1282' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad label, no biscuit");
</span><span class='bc' id='L1283' title='0|4|4 - Total: 4'>        label &= 0x7FFFFFFF;
</span><span class='bpc' id='L1284' title='0|1|1 - Total: 2'>        if (!(label < itsLabelTableTop))
</span><span class='nc' id='L1285' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad label");
</span><span class='bc' id='L1286' title='0|3|3 - Total: 3'>        int top = itsFixupTableTop;
</span><span class='bc' id='L1287' title='0|4|4 - Total: 4'>        if (itsFixupTable == null || top == itsFixupTable.length) {
</span><span class='bc' id='L1288' title='0|2|2 - Total: 2'>            if (itsFixupTable == null) {
</span><span class='bc' id='L1289' title='0|5|5 - Total: 5'>                itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
</span>            } else {
<span class='bc' id='L1291' title='0|7|7 - Total: 7'>                long[] tmp = new long[itsFixupTable.length * 2];
</span><span class='bc' id='L1292' title='0|7|7 - Total: 7'>                System.arraycopy(itsFixupTable, 0, tmp, 0, top);
</span><span class='bc' id='L1293' title='0|3|3 - Total: 3'>                itsFixupTable = tmp;
</span>            }
        }
<span class='bc' id='L1296' title='0|5|5 - Total: 5'>        itsFixupTableTop = top + 1;
</span><span class='bc' id='L1297' title='0|11|11 - Total: 11'>        itsFixupTable[top] = ((long) label << 32) | fixupSite;
</span><span class='bc' id='L1298' title='0|1|1 - Total: 1'>    }
</span>
    private void fixLabelGotos() {
<span class='bc' id='L1301' title='0|3|3 - Total: 3'>        byte[] codeBuffer = itsCodeBuffer;
</span><span class='bc' id='L1302' title='0|2|2 - Total: 2'>        for (int i = 0; i < itsFixupTableTop; i++) {
</span><span class='bc' id='L1303' title='0|5|5 - Total: 5'>            long fixup = itsFixupTable[i];
</span><span class='bc' id='L1304' title='0|5|5 - Total: 5'>            int label = (int) (fixup >> 32);
</span><span class='bc' id='L1305' title='0|3|3 - Total: 3'>            int fixupSite = (int) fixup;
</span><span class='bc' id='L1306' title='0|5|5 - Total: 5'>            int pc = itsLabelTable[label];
</span><span class='bpc' id='L1307' title='0|1|1 - Total: 2'>            if (pc == -1) {
</span>                // Unlocated label
<span class='nc' id='L1309' title='0|0|0 - Total: 4'>                throw new RuntimeException();
</span>            }
            // -1 to get delta from instruction start
<span class='bc' id='L1312' title='0|3|3 - Total: 3'>            addSuperBlockStart(pc);
</span><span class='bc' id='L1313' title='0|7|7 - Total: 7'>            itsJumpFroms.put(pc, fixupSite - 1);
</span><span class='bc' id='L1314' title='0|6|6 - Total: 6'>            int offset = pc - (fixupSite - 1);
</span><span class='bpc' id='L1315' title='0|1|1 - Total: 2'>            if ((short) offset != offset) {
</span><span class='nc' id='L1316' title='0|0|0 - Total: 5'>                throw new ClassFileFormatException
</span>                    ("Program too complex: too big jump offset");
            }
<span class='bc' id='L1319' title='0|7|7 - Total: 7'>            codeBuffer[fixupSite] = (byte) (offset >> 8);
</span><span class='bc' id='L1320' title='0|7|7 - Total: 7'>            codeBuffer[fixupSite + 1] = (byte) offset;
</span>        }
<span class='bc' id='L1322' title='0|3|3 - Total: 3'>        itsFixupTableTop = 0;
</span><span class='bc' id='L1323' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Get the current offset into the code of the current method.
     *
     * @return an integer representing the offset
     */
    public int getCurrentCodeOffset() {
<span class='bc' id='L1331' title='0|3|3 - Total: 3'>        return itsCodeBufferTop;
</span>    }

    public short getStackTop() {
<span class='bc' id='L1335' title='0|3|3 - Total: 3'>        return itsStackTop;
</span>    }

    public void setStackTop(short n) {
<span class='bc' id='L1339' title='0|3|3 - Total: 3'>        itsStackTop = n;
</span><span class='bc' id='L1340' title='0|1|1 - Total: 1'>    }
</span>
    public void adjustStackTop(int delta) {
<span class='bc' id='L1343' title='0|5|5 - Total: 5'>        int newStack = itsStackTop + delta;
</span><span class='bpc' id='L1344' title='0|2|2 - Total: 4'>        if (newStack < 0 || Short.MAX_VALUE < newStack)
</span><span class='nc' id='L1345' title='0|0|0 - Total: 2'>            badStack(newStack);
</span><span class='bc' id='L1346' title='0|4|4 - Total: 4'>        itsStackTop = (short) newStack;
</span><span class='bpc' id='L1347' title='0|1|1 - Total: 2'>        if (newStack > itsMaxStack)
</span><span class='nc' id='L1348' title='0|0|0 - Total: 4'>            itsMaxStack = (short) newStack;
</span>        if (DEBUGSTACK) {
            System.out.println("After " + "adjustStackTop(" + delta + ")"
                + " stack = " + itsStackTop);
        }
<span class='bc' id='L1353' title='0|1|1 - Total: 1'>    }
</span>
    private void addToCodeBuffer(int b) {
<span class='bc' id='L1356' title='0|4|4 - Total: 4'>        int N = addReservedCodeSpace(1);
</span><span class='bc' id='L1357' title='0|6|6 - Total: 6'>        itsCodeBuffer[N] = (byte) b;
</span><span class='bc' id='L1358' title='0|1|1 - Total: 1'>    }
</span>
    private void addToCodeInt16(int value) {
<span class='bc' id='L1361' title='0|4|4 - Total: 4'>        int N = addReservedCodeSpace(2);
</span><span class='bc' id='L1362' title='0|6|6 - Total: 6'>        putInt16(value, itsCodeBuffer, N);
</span><span class='bc' id='L1363' title='0|1|1 - Total: 1'>    }
</span>
    private int addReservedCodeSpace(int size) {
<span class='bpc' id='L1366' title='0|1|1 - Total: 2'>        if (itsCurrentMethod == null)
</span><span class='nc' id='L1367' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("No method to add to");
</span><span class='bc' id='L1368' title='0|3|3 - Total: 3'>        int oldTop = itsCodeBufferTop;
</span><span class='bc' id='L1369' title='0|4|4 - Total: 4'>        int newTop = oldTop + size;
</span><span class='bc' id='L1370' title='0|2|2 - Total: 2'>        if (newTop > itsCodeBuffer.length) {
</span><span class='bc' id='L1371' title='0|6|6 - Total: 6'>            int newSize = itsCodeBuffer.length * 2;
</span><span class='bc' id='L1372' title='0|2|2 - Total: 2'>            if (newTop > newSize) {
</span><span class='bc' id='L1373' title='0|2|2 - Total: 2'>                newSize = newTop;
</span>            }
<span class='bc' id='L1375' title='0|3|3 - Total: 3'>            byte[] tmp = new byte[newSize];
</span><span class='bc' id='L1376' title='0|7|7 - Total: 7'>            System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);
</span><span class='bc' id='L1377' title='0|3|3 - Total: 3'>            itsCodeBuffer = tmp;
</span>        }
<span class='bc' id='L1379' title='0|3|3 - Total: 3'>        itsCodeBufferTop = newTop;
</span><span class='bc' id='L1380' title='0|2|2 - Total: 2'>        return oldTop;
</span>    }

    public void addExceptionHandler(int startLabel, int endLabel,
        int handlerLabel, String catchClassName) {
<span class='bpc' id='L1385' title='0|1|1 - Total: 2'>        if ((startLabel & 0x80000000) != 0x80000000)
</span><span class='nc' id='L1386' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad startLabel");
</span><span class='bpc' id='L1387' title='0|1|1 - Total: 2'>        if ((endLabel & 0x80000000) != 0x80000000)
</span><span class='nc' id='L1388' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad endLabel");
</span><span class='bpc' id='L1389' title='0|1|1 - Total: 2'>        if ((handlerLabel & 0x80000000) != 0x80000000)
</span><span class='nc' id='L1390' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("Bad handlerLabel");
</span>
        /*
         * If catchClassName is null, use 0 for the catch_type_index; which
         * means catch everything.  (Even when the verifier has let you throw
         * something other than a Throwable.)
         */
<span class='bc' id='L1397' title='0|2|2 - Total: 2'>        short catch_type_index = (catchClassName == null)
</span>            ? 0
<span class='bc' id='L1399' title='0|2|2 - Total: 2'>            : itsConstantPool.addClass(catchClassName);
</span><span class='bc' id='L1400' title='0|8|8 - Total: 8'>        ExceptionTableEntry newEntry = new ExceptionTableEntry(
</span>            startLabel,
            endLabel,
            handlerLabel,
            catch_type_index);
<span class='bc' id='L1405' title='0|3|3 - Total: 3'>        int N = itsExceptionTableTop;
</span><span class='bc' id='L1406' title='0|2|2 - Total: 2'>        if (N == 0) {
</span><span class='bc' id='L1407' title='0|5|5 - Total: 5'>            itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];
</span><span class='bc' id='L1408' title='0|2|2 - Total: 2'>        } else if (N == itsExceptionTable.length) {
</span><span class='bc' id='L1409' title='0|5|5 - Total: 5'>            ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];
</span><span class='bc' id='L1410' title='0|7|7 - Total: 7'>            System.arraycopy(itsExceptionTable, 0, tmp, 0, N);
</span><span class='bc' id='L1411' title='0|3|3 - Total: 3'>            itsExceptionTable = tmp;
</span>        }
<span class='bc' id='L1413' title='0|5|5 - Total: 5'>        itsExceptionTable[N] = newEntry;
</span><span class='bc' id='L1414' title='0|5|5 - Total: 5'>        itsExceptionTableTop = N + 1;
</span>
<span class='bc' id='L1416' title='0|1|1 - Total: 1'>    }
</span>
    public void addLineNumberEntry(short lineNumber) {
<span class='bpc' id='L1419' title='0|1|1 - Total: 2'>        if (itsCurrentMethod == null)
</span><span class='nc' id='L1420' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("No method to stop");
</span><span class='bc' id='L1421' title='0|3|3 - Total: 3'>        int N = itsLineNumberTableTop;
</span><span class='bc' id='L1422' title='0|2|2 - Total: 2'>        if (N == 0) {
</span><span class='bc' id='L1423' title='0|5|5 - Total: 5'>            itsLineNumberTable = new int[LineNumberTableSize];
</span><span class='bc' id='L1424' title='0|2|2 - Total: 2'>        } else if (N == itsLineNumberTable.length) {
</span><span class='bc' id='L1425' title='0|5|5 - Total: 5'>            int[] tmp = new int[N * 2];
</span><span class='bc' id='L1426' title='0|7|7 - Total: 7'>            System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);
</span><span class='bc' id='L1427' title='0|3|3 - Total: 3'>            itsLineNumberTable = tmp;
</span>        }
<span class='bc' id='L1429' title='0|10|10 - Total: 10'>        itsLineNumberTable[N] = (itsCodeBufferTop << 16) + lineNumber;
</span><span class='bc' id='L1430' title='0|5|5 - Total: 5'>        itsLineNumberTableTop = N + 1;
</span><span class='bc' id='L1431' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * A stack map table is a code attribute introduced in Java 6 that gives type information at key
     * points in the method body (namely, at the beginning of each super block after the first). Each
     * frame of a stack map table contains the state of local variable and operand stack for a given
     * super block.
     */
    final class StackMapTable {

        StackMapTable() {
            superBlocks = null;
            locals = stack = null;
            workList = null;
            rawStackMap = null;
            localsTop = 0;
            stackTop = 0;
            workListTop = 0;
            rawStackMapTop = 0;
            wide = false;
        }

        void generate() {
            superBlocks = new SuperBlock[itsSuperBlockStartsTop];
            int[] initialLocals = createInitialLocals();

            for (int i = 0; i < itsSuperBlockStartsTop; i++) {
                int start = itsSuperBlockStarts[i];
                int end;
                if (i == itsSuperBlockStartsTop - 1) {
                    end = itsCodeBufferTop;
                } else {
                    end = itsSuperBlockStarts[i + 1];
                }
                superBlocks[i] = new SuperBlock(i, start, end, initialLocals);
            }

            if (DEBUGSTACKMAP) {
                System.out.println("super blocks: ");
                for (int i = 0;
                    i < superBlocks.length && superBlocks[i] != null; i++) {
                    System.out.println("sb " + i + ": [" +
                        superBlocks[i].getStart() + ", " +
                        superBlocks[i].getEnd() + ")");
                }
            }

            superBlockDeps = getSuperBlockDependencies();

            verify();

            if (DEBUGSTACKMAP) {
                System.out.println("type information:");
                for (int i = 0; i < superBlocks.length; i++) {
                    SuperBlock sb = superBlocks[i];
                    System.out.println("sb " + i + ":");
                    TypeInfo.print(sb.getLocals(), sb.getStack(),
                        itsConstantPool);
                }
            }
        }

        private SuperBlock getSuperBlockFromOffset(int offset) {
            for (int i = 0; i < superBlocks.length; i++) {
                SuperBlock sb = superBlocks[i];
                if (sb == null) {
                    break;
                } else if (offset >= sb.getStart() && offset < sb.getEnd()) {
                    return sb;
                }
            }
            throw new IllegalArgumentException("bad offset: " + offset);
        }

        /**
         * Determine whether or not an opcode is an actual end to a super block. This includes any
         * returns or unconditional jumps.
         */
        private boolean isSuperBlockEnd(int opcode) {
            switch (opcode) {
                case ByteCode.ARETURN:
                case ByteCode.FRETURN:
                case ByteCode.IRETURN:
                case ByteCode.LRETURN:
                case ByteCode.RETURN:
                case ByteCode.ATHROW:
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                case ByteCode.TABLESWITCH:
                case ByteCode.LOOKUPSWITCH:
                    return true;
                default:
                    return false;
            }
        }

        /**
         * Calculate partial dependencies for super blocks.
         *
         * This is used as a workaround for dead code that is generated. Only one dependency per super
         * block is given.
         */
        private SuperBlock[] getSuperBlockDependencies() {
            SuperBlock[] deps = new SuperBlock[superBlocks.length];

            for (int i = 0; i < itsExceptionTableTop; i++) {
                ExceptionTableEntry ete = itsExceptionTable[i];
                short startPC = (short) getLabelPC(ete.itsStartLabel);
                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);
                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);
                SuperBlock dep = getSuperBlockFromOffset(startPC);
                deps[handlerSB.getIndex()] = dep;
            }
            int[] targetPCs = itsJumpFroms.getKeys();
            for (int i = 0; i < targetPCs.length; i++) {
                int targetPC = targetPCs[i];
                int branchPC = itsJumpFroms.getInt(targetPC, -1);
                SuperBlock branchSB = getSuperBlockFromOffset(branchPC);
                SuperBlock targetSB = getSuperBlockFromOffset(targetPC);
                deps[targetSB.getIndex()] = branchSB;
            }

            return deps;
        }

        /**
         * Get the target super block of a branch instruction.
         *
         * @param bci the index of the branch instruction in the code buffer
         */
        private SuperBlock getBranchTarget(int bci) {
            int target;
            if ((itsCodeBuffer[bci] & 0xFF) == ByteCode.GOTO_W) {
                target = bci + getOperand(bci + 1, 4);
            } else {
                target = bci + (short) getOperand(bci + 1, 2);
            }
            return getSuperBlockFromOffset(target);
        }

        /**
         * Determine whether or not an opcode is a conditional or unconditional jump.
         */
        private boolean isBranch(int opcode) {
            switch (opcode) {
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                case ByteCode.IFEQ:
                case ByteCode.IFGE:
                case ByteCode.IFGT:
                case ByteCode.IFLE:
                case ByteCode.IFLT:
                case ByteCode.IFNE:
                case ByteCode.IFNONNULL:
                case ByteCode.IFNULL:
                case ByteCode.IF_ACMPEQ:
                case ByteCode.IF_ACMPNE:
                case ByteCode.IF_ICMPEQ:
                case ByteCode.IF_ICMPGE:
                case ByteCode.IF_ICMPGT:
                case ByteCode.IF_ICMPLE:
                case ByteCode.IF_ICMPLT:
                case ByteCode.IF_ICMPNE:
                    return true;
                default:
                    return false;
            }
        }

        private int getOperand(int offset) {
            return getOperand(offset, 1);
        }

        /**
         * Extract a logical operand from the byte code.
         *
         * This is used, for example, to get branch offsets.
         */
        private int getOperand(int start, int size) {
            int result = 0;
            if (size > 4) {
                throw new IllegalArgumentException("bad operand size");
            }
            for (int i = 0; i < size; i++) {
                result = (result << 8) | (itsCodeBuffer[start + i] & 0xFF);
            }
            return result;
        }

        /**
         * Calculate initial local variable and op stack types for each super block in the method.
         */
        private void verify() {
            int[] initialLocals = createInitialLocals();
            superBlocks[0].merge(initialLocals, initialLocals.length,
                new int[0], 0, itsConstantPool);

            // Start from the top of the method and queue up block dependencies
            // as they come along.
            workList = new SuperBlock[]{superBlocks[0]};
            workListTop = 1;
            executeWorkList();

            // Replace dead code with no-ops.
            for (int i = 0; i < superBlocks.length; i++) {
                SuperBlock sb = superBlocks[i];
                if (!sb.isInitialized()) {
                    killSuperBlock(sb);
                }
            }
            executeWorkList();
        }

        /**
         * Replace the contents of a super block with no-ops.
         *
         * The above description is not strictly true; the last instruction is an athrow instruction.
         * This technique is borrowed from ASM's developer guide: http://asm.ow2.org/doc/developer-guide.html#deadcode
         *
         * The proposed algorithm fills a block with nop, ending it with an athrow. The stack map
         * generated would be empty locals with an exception on the stack. In theory, it shouldn't
         * matter what the locals are, as long as the stack has an exception for the athrow bit.
         * However, it turns out that if the code being modified falls into an exception handler, it
         * causes problems. Therefore, if it does, then we steal the locals from the exception block.
         *
         * If the block itself is an exception handler, we remove it from the exception table to
         * simplify block dependencies.
         */
        private void killSuperBlock(SuperBlock sb) {
            int[] locals = new int[0];
            int[] stack = new int[]{TypeInfo.OBJECT("java/lang/Throwable",
                itsConstantPool)};

            // If the super block is handled by any exception handler, use its
            // locals as the killed block's locals. Ignore uninitialized
            // handlers, because they will also be killed and removed from the
            // exception table.
            for (int i = 0; i < itsExceptionTableTop; i++) {
                ExceptionTableEntry ete = itsExceptionTable[i];
                int eteStart = getLabelPC(ete.itsStartLabel);
                int eteEnd = getLabelPC(ete.itsEndLabel);
                int handlerPC = getLabelPC(ete.itsHandlerLabel);
                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);
                if ((sb.getStart() > eteStart && sb.getStart() < eteEnd) ||
                    (eteStart > sb.getStart() && eteStart < sb.getEnd()) &&
                        handlerSB.isInitialized()) {
                    locals = handlerSB.getLocals();
                    break;
                }
            }

            // Remove any exception table entry whose handler is the killed
            // block. This removes block dependencies to make stack maps for
            // dead blocks easier to create.
            for (int i = 0; i < itsExceptionTableTop; i++) {
                ExceptionTableEntry ete = itsExceptionTable[i];
                int eteStart = getLabelPC(ete.itsStartLabel);
                if (eteStart == sb.getStart()) {
                    for (int j = i + 1; j < itsExceptionTableTop; j++) {
                        itsExceptionTable[j - 1] = itsExceptionTable[j];
                    }
                    itsExceptionTableTop--;
                    i--;
                }
            }

            sb.merge(locals, locals.length, stack, stack.length,
                itsConstantPool);

            int end = sb.getEnd() - 1;
            itsCodeBuffer[end] = (byte) ByteCode.ATHROW;
            for (int bci = sb.getStart(); bci < end; bci++) {
                itsCodeBuffer[bci] = (byte) ByteCode.NOP;
            }
        }

        private void executeWorkList() {
            while (workListTop > 0) {
                SuperBlock work = workList[--workListTop];
                work.setInQueue(false);
                locals = work.getLocals();
                stack = work.getStack();
                localsTop = locals.length;
                stackTop = stack.length;
                executeBlock(work);
            }
        }

        /**
         * Simulate the local variable and op stack for a super block.
         */
        private void executeBlock(SuperBlock work) {
            int bc = 0;
            int next = 0;

            if (DEBUGSTACKMAP) {
                System.out.println("working on sb " + work.getIndex());
                System.out.println("initial type state:");
                TypeInfo.print(locals, localsTop, stack, stackTop,
                    itsConstantPool);
            }

            for (int bci = work.getStart(); bci < work.getEnd(); bci += next) {
                bc = itsCodeBuffer[bci] & 0xFF;
                next = execute(bci);

                // If we have a branch to some super block, we need to merge
                // the current state of the local table and op stack with what's
                // currently stored as the initial state of the super block. If
                // something actually changed, we need to add it to the work
                // list.
                if (isBranch(bc)) {
                    SuperBlock targetSB = getBranchTarget(bci);
                    if (DEBUGSTACKMAP) {
                        System.out.println("sb " + work.getIndex() +
                            " points to sb " +
                            targetSB.getIndex() +
                            " (offset " + bci + " -> " +
                            targetSB.getStart() + ")");
                        System.out.println("type state at " + bci + ":");
                        TypeInfo.print(locals, localsTop, stack, stackTop,
                            itsConstantPool);
                    }
                    flowInto(targetSB);
                    if (DEBUGSTACKMAP) {
                        System.out.println("type state of " + targetSB +
                            " after merge:");
                        TypeInfo.print(targetSB.getLocals(),
                            targetSB.getStack(), itsConstantPool);
                    }
                } else if (bc == ByteCode.TABLESWITCH) {
                    int switchStart = bci + 1 + (3 & ~bci); // 3 - bci % 4
                    int defaultOffset = getOperand(switchStart, 4);
                    SuperBlock targetSB =
                        getSuperBlockFromOffset(bci + defaultOffset);
                    if (DEBUGSTACK) {
                        System.out.println("merging sb " + work.getIndex() +
                            " with sb " + targetSB.getIndex());
                    }
                    flowInto(targetSB);
                    int low = getOperand(switchStart + 4, 4);
                    int high = getOperand(switchStart + 8, 4);
                    int numCases = high - low + 1;
                    int caseBase = switchStart + 12;
                    for (int i = 0; i < numCases; i++) {
                        int label = bci + getOperand(caseBase + 4 * i, 4);
                        targetSB = getSuperBlockFromOffset(label);
                        if (DEBUGSTACKMAP) {
                            System.out.println("merging sb " +
                                work.getIndex() + " with sb " +
                                targetSB.getIndex());
                        }
                        flowInto(targetSB);
                    }
                }

                for (int i = 0; i < itsExceptionTableTop; i++) {
                    ExceptionTableEntry ete = itsExceptionTable[i];
                    short startPC = (short) getLabelPC(ete.itsStartLabel);
                    short endPC = (short) getLabelPC(ete.itsEndLabel);
                    if (bci < startPC || bci >= endPC) {
                        continue;
                    }
                    short handlerPC =
                        (short) getLabelPC(ete.itsHandlerLabel);
                    SuperBlock sb = getSuperBlockFromOffset(handlerPC);
                    int exceptionType;

                    if (ete.itsCatchType == 0) {
                        exceptionType = TypeInfo.OBJECT(
                            itsConstantPool.addClass("java/lang/Throwable"));
                    } else {
                        exceptionType = TypeInfo.OBJECT(ete.itsCatchType);
                    }
                    sb.merge(locals, localsTop, new int[]{exceptionType}, 1,
                        itsConstantPool);
                    addToWorkList(sb);
                }
            }

            if (DEBUGSTACKMAP) {
                System.out.println("end of sb " + work.getIndex() + ":");
                TypeInfo.print(locals, localsTop, stack, stackTop,
                    itsConstantPool);
            }

            // Check the last instruction to see if it is a true end of a
            // super block (ie., if the instruction is a return). If it
            // isn't, we need to continue processing the next chunk.
            if (!isSuperBlockEnd(bc)) {
                int nextIndex = work.getIndex() + 1;
                if (nextIndex < superBlocks.length) {
                    if (DEBUGSTACKMAP) {
                        System.out.println("continuing from sb " +
                            work.getIndex() + " into sb " +
                            nextIndex);
                    }
                    flowInto(superBlocks[nextIndex]);
                }
            }
        }

        /**
         * Perform a merge of type state and add the super block to the work list if the merge changed
         * anything.
         */
        private void flowInto(SuperBlock sb) {
            if (sb.merge(locals, localsTop, stack, stackTop, itsConstantPool)) {
                addToWorkList(sb);
            }
        }

        private void addToWorkList(SuperBlock sb) {
            if (!sb.isInQueue()) {
                sb.setInQueue(true);
                sb.setInitialized(true);
                if (workListTop == workList.length) {
                    SuperBlock[] tmp = new SuperBlock[workListTop * 2];
                    System.arraycopy(workList, 0, tmp, 0, workListTop);
                    workList = tmp;
                }
                workList[workListTop++] = sb;
            }
        }

        /**
         * Execute a single byte code instruction.
         *
         * @param bci the index of the byte code instruction to execute
         * @return the length of the byte code instruction
         */
        private int execute(int bci) {
            int bc = itsCodeBuffer[bci] & 0xFF;
            int type, type2, index;
            int length = 0;
            long lType, lType2;
            String className;

            switch (bc) {
                case ByteCode.NOP:
                case ByteCode.IINC:
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                    // No change
                    break;
                case ByteCode.CHECKCAST:
                    pop();
                    push(TypeInfo.OBJECT(getOperand(bci + 1, 2)));
                    break;
                case ByteCode.IASTORE: // pop; pop; pop
                case ByteCode.LASTORE:
                case ByteCode.FASTORE:
                case ByteCode.DASTORE:
                case ByteCode.AASTORE:
                case ByteCode.BASTORE:
                case ByteCode.CASTORE:
                case ByteCode.SASTORE:
                    pop();
                    // fallthru
                case ByteCode.PUTFIELD: // pop; pop
                case ByteCode.IF_ICMPEQ:
                case ByteCode.IF_ICMPNE:
                case ByteCode.IF_ICMPLT:
                case ByteCode.IF_ICMPGE:
                case ByteCode.IF_ICMPGT:
                case ByteCode.IF_ICMPLE:
                case ByteCode.IF_ACMPEQ:
                case ByteCode.IF_ACMPNE:
                    pop();
                    // fallthru
                case ByteCode.IFEQ: // pop
                case ByteCode.IFNE:
                case ByteCode.IFLT:
                case ByteCode.IFGE:
                case ByteCode.IFGT:
                case ByteCode.IFLE:
                case ByteCode.IFNULL:
                case ByteCode.IFNONNULL:
                case ByteCode.POP:
                case ByteCode.MONITORENTER:
                case ByteCode.MONITOREXIT:
                case ByteCode.PUTSTATIC:
                    pop();
                    break;
                case ByteCode.POP2:
                    pop2();
                    break;
                case ByteCode.ACONST_NULL:
                    push(TypeInfo.NULL);
                    break;
                case ByteCode.IALOAD: // pop; pop; push(INTEGER)
                case ByteCode.BALOAD:
                case ByteCode.CALOAD:
                case ByteCode.SALOAD:
                case ByteCode.IADD:
                case ByteCode.ISUB:
                case ByteCode.IMUL:
                case ByteCode.IDIV:
                case ByteCode.IREM:
                case ByteCode.ISHL:
                case ByteCode.ISHR:
                case ByteCode.IUSHR:
                case ByteCode.IAND:
                case ByteCode.IOR:
                case ByteCode.IXOR:
                case ByteCode.LCMP:
                case ByteCode.FCMPL:
                case ByteCode.FCMPG:
                case ByteCode.DCMPL:
                case ByteCode.DCMPG:
                    pop();
                    // fallthru
                case ByteCode.INEG: // pop; push(INTEGER)
                case ByteCode.L2I:
                case ByteCode.F2I:
                case ByteCode.D2I:
                case ByteCode.I2B:
                case ByteCode.I2C:
                case ByteCode.I2S:
                case ByteCode.ARRAYLENGTH:
                case ByteCode.INSTANCEOF:
                    pop();
                    // fallthru
                case ByteCode.ICONST_M1: // push(INTEGER)
                case ByteCode.ICONST_0:
                case ByteCode.ICONST_1:
                case ByteCode.ICONST_2:
                case ByteCode.ICONST_3:
                case ByteCode.ICONST_4:
                case ByteCode.ICONST_5:
                case ByteCode.ILOAD:
                case ByteCode.ILOAD_0:
                case ByteCode.ILOAD_1:
                case ByteCode.ILOAD_2:
                case ByteCode.ILOAD_3:
                case ByteCode.BIPUSH:
                case ByteCode.SIPUSH:
                    push(TypeInfo.INTEGER);
                    break;
                case ByteCode.LALOAD: // pop; pop; push(LONG)
                case ByteCode.LADD:
                case ByteCode.LSUB:
                case ByteCode.LMUL:
                case ByteCode.LDIV:
                case ByteCode.LREM:
                case ByteCode.LSHL:
                case ByteCode.LSHR:
                case ByteCode.LUSHR:
                case ByteCode.LAND:
                case ByteCode.LOR:
                case ByteCode.LXOR:
                    pop();
                    // fallthru
                case ByteCode.LNEG: // pop; push(LONG)
                case ByteCode.I2L:
                case ByteCode.F2L:
                case ByteCode.D2L:
                    pop();
                    // fallthru
                case ByteCode.LCONST_0: // push(LONG)
                case ByteCode.LCONST_1:
                case ByteCode.LLOAD:
                case ByteCode.LLOAD_0:
                case ByteCode.LLOAD_1:
                case ByteCode.LLOAD_2:
                case ByteCode.LLOAD_3:
                    push(TypeInfo.LONG);
                    break;
                case ByteCode.FALOAD: // pop; pop; push(FLOAT)
                case ByteCode.FADD:
                case ByteCode.FSUB:
                case ByteCode.FMUL:
                case ByteCode.FDIV:
                case ByteCode.FREM:
                    pop();
                    // fallthru
                case ByteCode.FNEG: // pop; push(FLOAT)
                case ByteCode.I2F:
                case ByteCode.L2F:
                case ByteCode.D2F:
                    pop();
                    // fallthru
                case ByteCode.FCONST_0: // push(FLOAT)
                case ByteCode.FCONST_1:
                case ByteCode.FCONST_2:
                case ByteCode.FLOAD:
                case ByteCode.FLOAD_0:
                case ByteCode.FLOAD_1:
                case ByteCode.FLOAD_2:
                case ByteCode.FLOAD_3:
                    push(TypeInfo.FLOAT);
                    break;
                case ByteCode.DALOAD: // pop; pop; push(DOUBLE)
                case ByteCode.DADD:
                case ByteCode.DSUB:
                case ByteCode.DMUL:
                case ByteCode.DDIV:
                case ByteCode.DREM:
                    pop();
                    // fallthru
                case ByteCode.DNEG: // pop; push(DOUBLE)
                case ByteCode.I2D:
                case ByteCode.L2D:
                case ByteCode.F2D:
                    pop();
                    // fallthru
                case ByteCode.DCONST_0: // push(DOUBLE)
                case ByteCode.DCONST_1:
                case ByteCode.DLOAD:
                case ByteCode.DLOAD_0:
                case ByteCode.DLOAD_1:
                case ByteCode.DLOAD_2:
                case ByteCode.DLOAD_3:
                    push(TypeInfo.DOUBLE);
                    break;
                case ByteCode.ISTORE:
                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.INTEGER);
                    break;
                case ByteCode.ISTORE_0:
                case ByteCode.ISTORE_1:
                case ByteCode.ISTORE_2:
                case ByteCode.ISTORE_3:
                    executeStore(bc - ByteCode.ISTORE_0, TypeInfo.INTEGER);
                    break;
                case ByteCode.LSTORE:
                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.LONG);
                    break;
                case ByteCode.LSTORE_0:
                case ByteCode.LSTORE_1:
                case ByteCode.LSTORE_2:
                case ByteCode.LSTORE_3:
                    executeStore(bc - ByteCode.LSTORE_0, TypeInfo.LONG);
                    break;
                case ByteCode.FSTORE:
                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.FLOAT);
                    break;
                case ByteCode.FSTORE_0:
                case ByteCode.FSTORE_1:
                case ByteCode.FSTORE_2:
                case ByteCode.FSTORE_3:
                    executeStore(bc - ByteCode.FSTORE_0, TypeInfo.FLOAT);
                    break;
                case ByteCode.DSTORE:
                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.DOUBLE);
                    break;
                case ByteCode.DSTORE_0:
                case ByteCode.DSTORE_1:
                case ByteCode.DSTORE_2:
                case ByteCode.DSTORE_3:
                    executeStore(bc - ByteCode.DSTORE_0, TypeInfo.DOUBLE);
                    break;
                case ByteCode.ALOAD:
                    executeALoad(getOperand(bci + 1, wide ? 2 : 1));
                    break;
                case ByteCode.ALOAD_0:
                case ByteCode.ALOAD_1:
                case ByteCode.ALOAD_2:
                case ByteCode.ALOAD_3:
                    executeALoad(bc - ByteCode.ALOAD_0);
                    break;
                case ByteCode.ASTORE:
                    executeAStore(getOperand(bci + 1, wide ? 2 : 1));
                    break;
                case ByteCode.ASTORE_0:
                case ByteCode.ASTORE_1:
                case ByteCode.ASTORE_2:
                case ByteCode.ASTORE_3:
                    executeAStore(bc - ByteCode.ASTORE_0);
                    break;
                case ByteCode.IRETURN:
                case ByteCode.LRETURN:
                case ByteCode.FRETURN:
                case ByteCode.DRETURN:
                case ByteCode.ARETURN:
                case ByteCode.RETURN:
                    clearStack();
                    break;
                case ByteCode.ATHROW:
                    type = pop();
                    clearStack();
                    push(type);
                    break;
                case ByteCode.SWAP:
                    type = pop();
                    type2 = pop();
                    push(type);
                    push(type2);
                    break;
                case ByteCode.LDC:
                case ByteCode.LDC_W:
                case ByteCode.LDC2_W:
                    if (bc == ByteCode.LDC) {
                        index = getOperand(bci + 1);
                    } else {
                        index = getOperand(bci + 1, 2);
                    }
                    byte constType = itsConstantPool.getConstantType(index);
                    switch (constType) {
                        case ConstantPool.CONSTANT_Double:
                            push(TypeInfo.DOUBLE);
                            break;
                        case ConstantPool.CONSTANT_Float:
                            push(TypeInfo.FLOAT);
                            break;
                        case ConstantPool.CONSTANT_Long:
                            push(TypeInfo.LONG);
                            break;
                        case ConstantPool.CONSTANT_Integer:
                            push(TypeInfo.INTEGER);
                            break;
                        case ConstantPool.CONSTANT_String:
                            push(TypeInfo.OBJECT("java/lang/String",
                                itsConstantPool));
                            break;
                        default:
                            throw new IllegalArgumentException(
                                "bad const type " + constType);
                    }
                    break;
                case ByteCode.NEW:
                    push(TypeInfo.UNINITIALIZED_VARIABLE(bci));
                    break;
                case ByteCode.NEWARRAY:
                    pop();
                    char componentType =
                        arrayTypeToName(itsCodeBuffer[bci + 1]);
                    index = itsConstantPool.addClass("[" + componentType);
                    push(TypeInfo.OBJECT((short) index));
                    break;
                case ByteCode.ANEWARRAY:
                    index = getOperand(bci + 1, 2);
                    className = (String) itsConstantPool.getConstantData(index);
                    pop();
                    push(TypeInfo.OBJECT("[L" + className + ';',
                        itsConstantPool));
                    break;
                case ByteCode.INVOKEVIRTUAL:
                case ByteCode.INVOKESPECIAL:
                case ByteCode.INVOKESTATIC:
                case ByteCode.INVOKEINTERFACE:
                    index = getOperand(bci + 1, 2);
                    FieldOrMethodRef m = (FieldOrMethodRef)
                        itsConstantPool.getConstantData(index);
                    String methodType = m.getType();
                    String methodName = m.getName();
                    int parameterCount = sizeOfParameters(methodType) >>> 16;
                    for (int i = 0; i < parameterCount; i++) {
                        pop();
                    }
                    if (bc != ByteCode.INVOKESTATIC) {
                        int instType = pop();
                        int tag = TypeInfo.getTag(instType);
                        if (tag == TypeInfo.UNINITIALIZED_VARIABLE(0) ||
                            tag == TypeInfo.UNINITIALIZED_THIS) {
                            if ("<init>".equals(methodName)) {
                                int newType =
                                    TypeInfo.OBJECT(itsThisClassIndex);
                                initializeTypeInfo(instType, newType);
                            } else {
                                throw new IllegalStateException("bad instance");
                            }
                        }
                    }
                    int rParen = methodType.indexOf(')');
                    String returnType = methodType.substring(rParen + 1);
                    returnType = descriptorToInternalName(returnType);
                    if (!returnType.equals("V")) {
                        push(TypeInfo.fromType(returnType, itsConstantPool));
                    }
                    break;
                case ByteCode.INVOKEDYNAMIC:
                    index = getOperand(bci + 1, 2);
                    methodType = (String) itsConstantPool.getConstantData(index);
                    parameterCount = sizeOfParameters(methodType) >>> 16;
                    for (int i = 0; i < parameterCount; i++) {
                        pop();
                    }
                    rParen = methodType.indexOf(')');
                    returnType = methodType.substring(rParen + 1);
                    returnType = descriptorToInternalName(returnType);
                    if (!returnType.equals("V")) {
                        push(TypeInfo.fromType(returnType, itsConstantPool));
                    }
                    break;
                case ByteCode.GETFIELD:
                    pop();
                    // fallthru
                case ByteCode.GETSTATIC:
                    index = getOperand(bci + 1, 2);
                    FieldOrMethodRef f = (FieldOrMethodRef)
                        itsConstantPool.getConstantData(index);
                    String fieldType = descriptorToInternalName(f.getType());
                    push(TypeInfo.fromType(fieldType, itsConstantPool));
                    break;
                case ByteCode.DUP:
                    type = pop();
                    push(type);
                    push(type);
                    break;
                case ByteCode.DUP_X1:
                    type = pop();
                    type2 = pop();
                    push(type);
                    push(type2);
                    push(type);
                    break;
                case ByteCode.DUP_X2:
                    type = pop();
                    lType = pop2();
                    push(type);
                    push2(lType);
                    push(type);
                    break;
                case ByteCode.DUP2:
                    lType = pop2();
                    push2(lType);
                    push2(lType);
                    break;
                case ByteCode.DUP2_X1:
                    lType = pop2();
                    type = pop();
                    push2(lType);
                    push(type);
                    push2(lType);
                    break;
                case ByteCode.DUP2_X2:
                    lType = pop2();
                    lType2 = pop2();
                    push2(lType);
                    push2(lType2);
                    push2(lType);
                    break;
                case ByteCode.TABLESWITCH:
                    int switchStart = bci + 1 + (3 & ~bci);
                    int low = getOperand(switchStart + 4, 4);
                    int high = getOperand(switchStart + 8, 4);
                    length = 4 * (high - low + 4) + switchStart - bci;
                    pop();
                    break;
                case ByteCode.AALOAD:
                    pop();
                    int typeIndex = pop() >>> 8;
                    className =
                        (String) itsConstantPool.getConstantData(typeIndex);
                    String arrayType = className;
                    if (arrayType.charAt(0) != '[') {
                        throw new IllegalStateException("bad array type");
                    }
                    String elementDesc = arrayType.substring(1);
                    String elementType = descriptorToInternalName(elementDesc);
                    typeIndex = itsConstantPool.addClass(elementType);
                    push(TypeInfo.OBJECT(typeIndex));
                    break;
                case ByteCode.WIDE:
                    // Alters behaviour of next instruction
                    wide = true;
                    break;
                case ByteCode.MULTIANEWARRAY:
                case ByteCode.LOOKUPSWITCH:
                    // Currently not used in any part of Rhino, so ignore it
                case ByteCode.JSR: // TODO: JSR is deprecated
                case ByteCode.RET:
                case ByteCode.JSR_W:
                default:
                    throw new IllegalArgumentException("bad opcode: " + bc);
            }

            if (length == 0) {
                length = opcodeLength(bc, wide);
            }
            if (wide && bc != ByteCode.WIDE) {
                wide = false;
            }
            return length;
        }

        private void executeALoad(int localIndex) {
            int type = getLocal(localIndex);
            int tag = TypeInfo.getTag(type);
            if (tag == TypeInfo.OBJECT_TAG ||
                tag == TypeInfo.UNINITIALIZED_THIS ||
                tag == TypeInfo.UNINITIALIZED_VAR_TAG ||
                tag == TypeInfo.NULL) {
                push(type);
            } else {
                throw new IllegalStateException("bad local variable type: " +
                    type + " at index: " +
                    localIndex);
            }
        }

        private void executeAStore(int localIndex) {
            setLocal(localIndex, pop());
        }

        private void executeStore(int localIndex, int typeInfo) {
            pop();
            setLocal(localIndex, typeInfo);
        }

        /**
         * Change an UNINITIALIZED_OBJECT or UNINITIALIZED_THIS to the proper type of the object. This
         * occurs when the proper constructor is invoked.
         */
        private void initializeTypeInfo(int prevType, int newType) {
            initializeTypeInfo(prevType, newType, locals, localsTop);
            initializeTypeInfo(prevType, newType, stack, stackTop);
        }

        private void initializeTypeInfo(int prevType, int newType, int[] data,
            int dataTop) {
            for (int i = 0; i < dataTop; i++) {
                if (data[i] == prevType) {
                    data[i] = newType;
                }
            }
        }

        private int getLocal(int localIndex) {
            if (localIndex < localsTop) {
                return locals[localIndex];
            } else {
                return TypeInfo.TOP;
            }
        }

        private void setLocal(int localIndex, int typeInfo) {
            if (localIndex >= localsTop) {
                int[] tmp = new int[localIndex + 1];
                System.arraycopy(locals, 0, tmp, 0, localsTop);
                locals = tmp;
                localsTop = localIndex + 1;
            }
            locals[localIndex] = typeInfo;
        }

        private void push(int typeInfo) {
            if (stackTop == stack.length) {
                int[] tmp = new int[Math.max(stackTop * 2, 4)];
                System.arraycopy(stack, 0, tmp, 0, stackTop);
                stack = tmp;
            }
            stack[stackTop++] = typeInfo;
        }

        private int pop() {
            return stack[--stackTop];
        }

        /**
         * Push two words onto the op stack.
         *
         * This is only meant to be used as a complement to pop2(), and both methods are helpers for the
         * more complex DUP operations.
         */
        private void push2(long typeInfo) {
            push((int) (typeInfo & 0xFFFFFF));
            typeInfo >>>= 32;
            if (typeInfo != 0) {
                push((int) (typeInfo & 0xFFFFFF));
            }
        }

        /**
         * Pop two words from the op stack.
         *
         * If the top of the stack is a DOUBLE or LONG, then the bottom 32 bits reflects the appropriate
         * type and the top 32 bits are 0. Otherwise, the top 32 bits are the first word on the stack
         * and the lower 32 bits are the second word on the stack.
         */
        private long pop2() {
            long type = pop();
            if (TypeInfo.isTwoWords((int) type)) {
                return type;
            } else {
                return type << 32 | (pop() & 0xFFFFFF);
            }
        }

        private void clearStack() {
            stackTop = 0;
        }

        /**
         * Compute the output size of the stack map table.
         *
         * Because this would share much in common with actual writing of the stack map table, we
         * instead just write the stack map table to a buffer and return the size from it. The buffer is
         * later used in the actual writing of bytecode.
         */
        int computeWriteSize() {
            // Allocate a buffer that can handle the worst case size of the
            // stack map to prevent lots of reallocations.
            int writeSize = getWorstCaseWriteSize();
            rawStackMap = new byte[writeSize];
            computeRawStackMap();
            return rawStackMapTop + 2;
        }

        int write(byte[] data, int offset) {
            offset = putInt32(rawStackMapTop + 2, data, offset);
            offset = putInt16(superBlocks.length - 1, data, offset);
            System.arraycopy(rawStackMap, 0, data, offset, rawStackMapTop);
            return offset + rawStackMapTop;
        }

        /**
         * Compute a space-optimal stack map table.
         */
        private void computeRawStackMap() {
            SuperBlock prev = superBlocks[0];
            int[] prevLocals = prev.getTrimmedLocals();
            int prevOffset = -1;
            for (int i = 1; i < superBlocks.length; i++) {
                SuperBlock current = superBlocks[i];
                int[] currentLocals = current.getTrimmedLocals();
                int[] currentStack = current.getStack();
                int offsetDelta = current.getStart() - prevOffset - 1;

                if (currentStack.length == 0) {
                    int last = prevLocals.length > currentLocals.length ?
                        currentLocals.length : prevLocals.length;
                    int delta = Math.abs(prevLocals.length -
                        currentLocals.length);
                    int j;
                    // Compare locals until one is different or the end of a
                    // local variable array is reached
                    for (j = 0; j < last; j++) {
                        if (prevLocals[j] != currentLocals[j]) {
                            break;
                        }
                    }
                    if (j == currentLocals.length && delta == 0) {
                        // All of the compared locals are equal and the local
                        // arrays are of equal size
                        writeSameFrame(currentLocals, offsetDelta);
                    } else if (j == currentLocals.length && delta <= 3) {
                        // All of the compared locals are equal and the current
                        // frame has less locals than the previous frame
                        writeChopFrame(delta, offsetDelta);
                    } else if (j == prevLocals.length && delta <= 3) {
                        // All of the compared locals are equal and the current
                        // frame has more locals than the previous frame
                        writeAppendFrame(currentLocals, delta, offsetDelta);
                    } else {
                        // Not all locals were compared were equal, so a full
                        // frame is necessary
                        writeFullFrame(currentLocals, currentStack,
                            offsetDelta);
                    }
                } else if (currentStack.length == 1) {
                    if (Arrays.equals(prevLocals, currentLocals)) {
                        writeSameLocalsOneStackItemFrame(currentLocals,
                            currentStack,
                            offsetDelta);
                    } else {
                        // Output a full frame, since no other frame types have
                        // one operand stack item.
                        writeFullFrame(currentLocals, currentStack,
                            offsetDelta);
                    }
                } else {
                    // Any stack map frame that has more than one operand stack
                    // item has to be a full frame. All other frame types have
                    // at most one item on the stack.
                    writeFullFrame(currentLocals, currentStack, offsetDelta);
                }

                prev = current;
                prevLocals = currentLocals;
                prevOffset = current.getStart();
            }
        }

        /**
         * Get the worst case write size of the stack map table.
         *
         * This computes how much full frames would take, if each full frame contained the maximum
         * number of locals and stack operands, and each verification type was 3 bytes.
         */
        private int getWorstCaseWriteSize() {
            return (superBlocks.length - 1) * (7 + itsMaxLocals * 3 +
                itsMaxStack * 3);
        }

        private void writeSameFrame(int[] locals, int offsetDelta) {
            if (offsetDelta <= 63) {
                // Output a same_frame frame. Despite the name,
                // the operand stack may differ, but the current
                // operand stack must be empty.
                rawStackMap[rawStackMapTop++] = (byte) offsetDelta;
            } else {
                // Output a same_frame_extended frame. Similar to
                // the above, except with a larger offset delta.
                rawStackMap[rawStackMapTop++] = (byte) 251;
                rawStackMapTop = putInt16(offsetDelta, rawStackMap,
                    rawStackMapTop);
            }
        }

        private void writeSameLocalsOneStackItemFrame(int[] locals,
            int[] stack,
            int offsetDelta) {
            if (offsetDelta <= 63) {
                // Output a same_locals_1_stack_item frame. Similar
                // to same_frame, only with one item on the operand
                // stack instead of zero.
                rawStackMap[rawStackMapTop++] = (byte) (64 + offsetDelta);
            } else {
                // Output a same_locals_1_stack_item_extended frame.
                // Similar to same_frame_extended, only with one
                // item on the operand stack instead of zero.
                rawStackMap[rawStackMapTop++] = (byte) 247;
                rawStackMapTop = putInt16(offsetDelta, rawStackMap,
                    rawStackMapTop);
            }
            writeType(stack[0]);
        }

        private void writeFullFrame(int[] locals, int[] stack,
            int offsetDelta) {
            rawStackMap[rawStackMapTop++] = (byte) 255;
            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);
            rawStackMapTop = putInt16(locals.length, rawStackMap,
                rawStackMapTop);
            rawStackMapTop = writeTypes(locals);
            rawStackMapTop = putInt16(stack.length, rawStackMap,
                rawStackMapTop);
            rawStackMapTop = writeTypes(stack);
        }

        private void writeAppendFrame(int[] locals, int localsDelta,
            int offsetDelta) {
            int start = locals.length - localsDelta;
            rawStackMap[rawStackMapTop++] = (byte) (251 + localsDelta);
            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);
            rawStackMapTop = writeTypes(locals, start);
        }

        private void writeChopFrame(int localsDelta, int offsetDelta) {
            rawStackMap[rawStackMapTop++] = (byte) (251 - localsDelta);
            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);
        }

        private int writeTypes(int[] types) {
            return writeTypes(types, 0);
        }

        private int writeTypes(int[] types, int start) {
            int startOffset = rawStackMapTop;
            for (int i = start; i < types.length; i++) {
                rawStackMapTop = writeType(types[i]);
            }
            return rawStackMapTop;
        }

        private int writeType(int type) {
            int tag = type & 0xFF;
            rawStackMap[rawStackMapTop++] = (byte) tag;
            if (tag == TypeInfo.OBJECT_TAG ||
                tag == TypeInfo.UNINITIALIZED_VAR_TAG) {
                rawStackMapTop = putInt16(type >>> 8, rawStackMap,
                    rawStackMapTop);
            }
            return rawStackMapTop;
        }

        // Intermediate operand stack and local variable state. During
        // execution of a block, these are initialized to copies of the initial
        // block type state and are modified by the actual stack/local
        // emulation.
        private int[] locals;
        private int localsTop;
        private int[] stack;
        private int stackTop;

        private SuperBlock[] workList;
        private int workListTop;

        private SuperBlock[] superBlocks;
        private SuperBlock[] superBlockDeps;

        private byte[] rawStackMap;
        private int rawStackMapTop;

        private boolean wide;

        static final boolean DEBUGSTACKMAP = false;
    }

    /**
     * Convert a newarray operand into an internal type.
     */
    private static char arrayTypeToName(int type) {
<span class='bpc' id='L2625' title='0|1|1 - Total: 9'>        switch (type) {
</span>            case ByteCode.T_BOOLEAN:
<span class='nc' id='L2627' title='0|0|0 - Total: 2'>                return 'Z';
</span>            case ByteCode.T_CHAR:
<span class='nc' id='L2629' title='0|0|0 - Total: 2'>                return 'C';
</span>            case ByteCode.T_FLOAT:
<span class='nc' id='L2631' title='0|0|0 - Total: 2'>                return 'F';
</span>            case ByteCode.T_DOUBLE:
<span class='nc' id='L2633' title='0|0|0 - Total: 2'>                return 'D';
</span>            case ByteCode.T_BYTE:
<span class='nc' id='L2635' title='0|0|0 - Total: 2'>                return 'B';
</span>            case ByteCode.T_SHORT:
<span class='nc' id='L2637' title='0|0|0 - Total: 2'>                return 'S';
</span>            case ByteCode.T_INT:
<span class='bc' id='L2639' title='0|2|2 - Total: 2'>                return 'I';
</span>            case ByteCode.T_LONG:
<span class='nc' id='L2641' title='0|0|0 - Total: 2'>                return 'J';
</span>            default:
<span class='nc' id='L2643' title='0|0|0 - Total: 5'>                throw new IllegalArgumentException("bad operand");
</span>        }
    }

    /**
     * Convert a class descriptor into an internal name.
     *
     * For example, descriptor Ljava/lang/Object; becomes java/lang/Object.
     */
    private static String classDescriptorToInternalName(String descriptor) {
<span class='bc' id='L2653' title='0|8|8 - Total: 8'>        return descriptor.substring(1, descriptor.length() - 1);
</span>    }

    /**
     * Convert a non-method type descriptor into an internal type.
     *
     * @param descriptor the simple type descriptor to convert
     */
    private static String descriptorToInternalName(String descriptor) {
<span class='bpc' id='L2662' title='0|2|2 - Total: 3'>        switch (descriptor.charAt(0)) {
</span>            case 'B':
            case 'C':
            case 'D':
            case 'F':
            case 'I':
            case 'J':
            case 'S':
            case 'Z':
            case 'V':
            case '[':
<span class='bc' id='L2673' title='0|2|2 - Total: 2'>                return descriptor;
</span>            case 'L':
<span class='bc' id='L2675' title='0|3|3 - Total: 3'>                return classDescriptorToInternalName(descriptor);
</span>            default:
<span class='nc' id='L2677' title='0|0|0 - Total: 12'>                throw new IllegalArgumentException("bad descriptor:" +
</span>                    descriptor);
        }
    }

    /**
     * Compute the initial local variable array for the current method.
     *
     * Creates an array of the size of the method's max locals, regardless of the number of parameters
     * in the method.
     */
    private int[] createInitialLocals() {
<span class='bc' id='L2689' title='0|4|4 - Total: 4'>        int[] initialLocals = new int[itsMaxLocals];
</span><span class='bc' id='L2690' title='0|2|2 - Total: 2'>        int localsTop = 0;
</span>        // Instance methods require the first local variable in the array
        // to be "this". However, if the method being created is a
        // constructor, aka the method is <init>, then the type of "this"
        // should be StackMapTable.UNINITIALIZED_THIS
<span class='bc' id='L2695' title='0|2|2 - Total: 2'>        if ((itsCurrentMethod.getFlags() & ACC_STATIC) == 0) {
</span><span class='bc' id='L2696' title='0|2|2 - Total: 2'>            if ("<init>".equals(itsCurrentMethod.getName())) {
</span><span class='bc' id='L2697' title='0|6|6 - Total: 6'>                initialLocals[localsTop++] = TypeInfo.UNINITIALIZED_THIS;
</span>            } else {
<span class='bc' id='L2699' title='0|7|7 - Total: 7'>                initialLocals[localsTop++] = TypeInfo.OBJECT(itsThisClassIndex);
</span>            }
        }

        // No error checking should be necessary, sizeOfParameters does this
<span class='bc' id='L2704' title='0|4|4 - Total: 4'>        String type = itsCurrentMethod.getType();
</span><span class='bc' id='L2705' title='0|4|4 - Total: 4'>        int lParenIndex = type.indexOf('(');
</span><span class='bc' id='L2706' title='0|4|4 - Total: 4'>        int rParenIndex = type.indexOf(')');
</span><span class='bpc' id='L2707' title='0|2|2 - Total: 4'>        if (lParenIndex != 0 || rParenIndex < 0) {
</span><span class='nc' id='L2708' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("bad method type");
</span>        }
<span class='bc' id='L2710' title='0|4|4 - Total: 4'>        int start = lParenIndex + 1;
</span><span class='bc' id='L2711' title='0|4|4 - Total: 4'>        StringBuilder paramType = new StringBuilder();
</span><span class='bc' id='L2712' title='0|2|2 - Total: 2'>        while (start < rParenIndex) {
</span><span class='bpc' id='L2713' title='0|3|3 - Total: 4'>            switch (type.charAt(start)) {
</span>                case 'B':
                case 'C':
                case 'D':
                case 'F':
                case 'I':
                case 'J':
                case 'S':
                case 'Z':
<span class='bc' id='L2722' title='0|6|6 - Total: 6'>                    paramType.append(type.charAt(start));
</span><span class='bc' id='L2723' title='0|1|1 - Total: 1'>                    ++start;
</span><span class='bc' id='L2724' title='0|1|1 - Total: 1'>                    break;
</span>                case 'L':
<span class='bc' id='L2726' title='0|7|7 - Total: 7'>                    int end = type.indexOf(';', start) + 1;
</span><span class='bc' id='L2727' title='0|5|5 - Total: 5'>                    String name = type.substring(start, end);
</span><span class='bc' id='L2728' title='0|4|4 - Total: 4'>                    paramType.append(name);
</span><span class='bc' id='L2729' title='0|2|2 - Total: 2'>                    start = end;
</span><span class='bc' id='L2730' title='0|1|1 - Total: 1'>                    break;
</span>                case '[':
<span class='bc' id='L2732' title='0|4|4 - Total: 4'>                    paramType.append('[');
</span><span class='bc' id='L2733' title='0|1|1 - Total: 1'>                    ++start;
</span><span class='bc' id='L2734' title='0|1|1 - Total: 1'>                    continue;
</span>            }
<span class='bc' id='L2736' title='0|1|1 - Total: 1'>            String internalType =
</span><span class='bc' id='L2737' title='0|3|3 - Total: 3'>                descriptorToInternalName(paramType.toString());
</span><span class='bc' id='L2738' title='0|5|5 - Total: 5'>            int typeInfo = TypeInfo.fromType(internalType, itsConstantPool);
</span><span class='bc' id='L2739' title='0|5|5 - Total: 5'>            initialLocals[localsTop++] = typeInfo;
</span><span class='bc' id='L2740' title='0|2|2 - Total: 2'>            if (TypeInfo.isTwoWords(typeInfo)) {
</span><span class='bc' id='L2741' title='0|1|1 - Total: 1'>                localsTop++;
</span>            }
<span class='bc' id='L2743' title='0|3|3 - Total: 3'>            paramType.setLength(0);
</span><span class='bc' id='L2744' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2745' title='0|2|2 - Total: 2'>        return initialLocals;
</span>    }

    /**
     * Write the class file to the OutputStream.
     *
     * @param oStream the stream to write to
     * @throws IOException if writing to the stream produces an exception
     */
    public void write(OutputStream oStream)
        throws IOException {
<span class='nc' id='L2756' title='0|0|0 - Total: 3'>        byte[] array = toByteArray();
</span><span class='nc' id='L2757' title='0|0|0 - Total: 3'>        oStream.write(array);
</span><span class='nc' id='L2758' title='0|0|0 - Total: 1'>    }
</span>
    private int getWriteSize() {
<span class='bc' id='L2761' title='0|2|2 - Total: 2'>        int size = 0;
</span>
<span class='bc' id='L2763' title='0|2|2 - Total: 2'>        if (itsSourceFileNameIndex != 0) {
</span><span class='bc' id='L2764' title='0|5|5 - Total: 5'>            itsConstantPool.addUtf8("SourceFile");
</span>        }

<span class='bc' id='L2767' title='0|1|1 - Total: 1'>        size += 8; //writeLong(FileHeaderConstant);
</span><span class='bc' id='L2768' title='0|6|6 - Total: 6'>        size += itsConstantPool.getWriteSize();
</span><span class='bc' id='L2769' title='0|1|1 - Total: 1'>        size += 2; //writeShort(itsFlags);
</span><span class='bc' id='L2770' title='0|1|1 - Total: 1'>        size += 2; //writeShort(itsThisClassIndex);
</span><span class='bc' id='L2771' title='0|1|1 - Total: 1'>        size += 2; //writeShort(itsSuperClassIndex);
</span><span class='bc' id='L2772' title='0|1|1 - Total: 1'>        size += 2; //writeShort(itsInterfaces.size());
</span><span class='bc' id='L2773' title='0|8|8 - Total: 8'>        size += 2 * itsInterfaces.size();
</span>
<span class='bc' id='L2775' title='0|1|1 - Total: 1'>        size += 2; //writeShort(itsFields.size());
</span><span class='bc' id='L2776' title='0|2|2 - Total: 2'>        for (int i = 0; i < itsFields.size(); i++) {
</span><span class='bc' id='L2777' title='0|10|10 - Total: 10'>            size += ((ClassFileField) (itsFields.get(i))).getWriteSize();
</span>        }

<span class='bc' id='L2780' title='0|1|1 - Total: 1'>        size += 2; //writeShort(itsMethods.size());
</span><span class='bc' id='L2781' title='0|2|2 - Total: 2'>        for (int i = 0; i < itsMethods.size(); i++) {
</span><span class='bc' id='L2782' title='0|10|10 - Total: 10'>            size += ((ClassFileMethod) (itsMethods.get(i))).getWriteSize();
</span>        }

<span class='bc' id='L2785' title='0|1|1 - Total: 1'>        size += 2; //writeShort(1);  attributes count, could be zero
</span><span class='bc' id='L2786' title='0|2|2 - Total: 2'>        if (itsSourceFileNameIndex != 0) {
</span><span class='bc' id='L2787' title='0|1|1 - Total: 1'>            size += 2; //writeShort(sourceFileAttributeNameIndex);
</span><span class='bc' id='L2788' title='0|1|1 - Total: 1'>            size += 4; //writeInt(2);
</span><span class='bc' id='L2789' title='0|1|1 - Total: 1'>            size += 2; //writeShort(itsSourceFileNameIndex);
</span>        }
<span class='bpc' id='L2791' title='0|1|1 - Total: 2'>        if (itsBootstrapMethods != null) {
</span><span class='nc' id='L2792' title='0|0|0 - Total: 1'>            size += 2; //writeShort(bootstrapMethodsAttrNameIndex);
</span><span class='nc' id='L2793' title='0|0|0 - Total: 1'>            size += 4; //writeInt(itsBootstrapMethodsLength);
</span><span class='nc' id='L2794' title='0|0|0 - Total: 1'>            size += 2; //writeShort(bootstrapMethods.size());
</span><span class='nc' id='L2795' title='0|0|0 - Total: 5'>            size += itsBootstrapMethodsLength;
</span>        }

<span class='bc' id='L2798' title='0|2|2 - Total: 2'>        return size;
</span>    }

    /**
     * Get the class file as array of bytesto the OutputStream.
     */
    public byte[] toByteArray() {
<span class='bc' id='L2805' title='0|2|2 - Total: 2'>        short bootstrapMethodsAttrNameIndex = 0;
</span><span class='bc' id='L2806' title='0|2|2 - Total: 2'>        int attributeCount = 0;
</span>
<span class='bc' id='L2808' title='0|2|2 - Total: 2'>        short sourceFileAttributeNameIndex = 0;
</span><span class='bpc' id='L2809' title='0|1|1 - Total: 2'>        if (itsBootstrapMethods != null) {
</span><span class='nc' id='L2810' title='0|0|0 - Total: 1'>            ++attributeCount;
</span><span class='nc' id='L2811' title='0|0|0 - Total: 5'>            bootstrapMethodsAttrNameIndex = itsConstantPool.addUtf8("BootstrapMethods");
</span>        }

<span class='bc' id='L2814' title='0|2|2 - Total: 2'>        if (itsSourceFileNameIndex != 0) {
</span><span class='bc' id='L2815' title='0|1|1 - Total: 1'>            ++attributeCount;
</span><span class='bc' id='L2816' title='0|5|5 - Total: 5'>            sourceFileAttributeNameIndex = itsConstantPool.addUtf8(
</span>                "SourceFile");
        }

        // Don't calculate the data size until we know how many bootstrap
        // methods there will be.
<span class='bc' id='L2822' title='0|2|2 - Total: 2'>        int offset = 0;
</span><span class='bc' id='L2823' title='0|3|3 - Total: 3'>        int dataSize = getWriteSize();
</span><span class='bc' id='L2824' title='0|3|3 - Total: 3'>        byte[] data = new byte[dataSize];
</span>
<span class='bc' id='L2826' title='0|5|5 - Total: 5'>        offset = putInt32(FileHeaderConstant, data, offset);
</span><span class='bc' id='L2827' title='0|5|5 - Total: 5'>        offset = putInt16(MinorVersion, data, offset);
</span><span class='bc' id='L2828' title='0|5|5 - Total: 5'>        offset = putInt16(MajorVersion, data, offset);
</span><span class='bc' id='L2829' title='0|6|6 - Total: 6'>        offset = itsConstantPool.write(data, offset);
</span><span class='bc' id='L2830' title='0|6|6 - Total: 6'>        offset = putInt16(itsFlags, data, offset);
</span><span class='bc' id='L2831' title='0|6|6 - Total: 6'>        offset = putInt16(itsThisClassIndex, data, offset);
</span><span class='bc' id='L2832' title='0|6|6 - Total: 6'>        offset = putInt16(itsSuperClassIndex, data, offset);
</span><span class='bc' id='L2833' title='0|7|7 - Total: 7'>        offset = putInt16(itsInterfaces.size(), data, offset);
</span><span class='bc' id='L2834' title='0|2|2 - Total: 2'>        for (int i = 0; i < itsInterfaces.size(); i++) {
</span><span class='bc' id='L2835' title='0|8|8 - Total: 8'>            int interfaceIndex = ((Short) (itsInterfaces.get(i))).shortValue();
</span><span class='bc' id='L2836' title='0|5|5 - Total: 5'>            offset = putInt16(interfaceIndex, data, offset);
</span>        }
<span class='bc' id='L2838' title='0|7|7 - Total: 7'>        offset = putInt16(itsFields.size(), data, offset);
</span><span class='bc' id='L2839' title='0|2|2 - Total: 2'>        for (int i = 0; i < itsFields.size(); i++) {
</span><span class='bc' id='L2840' title='0|6|6 - Total: 6'>            ClassFileField field = (ClassFileField) itsFields.get(i);
</span><span class='bc' id='L2841' title='0|5|5 - Total: 5'>            offset = field.write(data, offset);
</span>        }
<span class='bc' id='L2843' title='0|7|7 - Total: 7'>        offset = putInt16(itsMethods.size(), data, offset);
</span><span class='bc' id='L2844' title='0|2|2 - Total: 2'>        for (int i = 0; i < itsMethods.size(); i++) {
</span><span class='bc' id='L2845' title='0|6|6 - Total: 6'>            ClassFileMethod method = (ClassFileMethod) itsMethods.get(i);
</span><span class='bc' id='L2846' title='0|5|5 - Total: 5'>            offset = method.write(data, offset);
</span>        }
<span class='bc' id='L2848' title='0|5|5 - Total: 5'>        offset = putInt16(attributeCount, data, offset); // attributes count
</span><span class='bpc' id='L2849' title='0|1|1 - Total: 2'>        if (itsBootstrapMethods != null) {
</span><span class='nc' id='L2850' title='0|0|0 - Total: 5'>            offset = putInt16(bootstrapMethodsAttrNameIndex, data, offset);
</span><span class='nc' id='L2851' title='0|0|0 - Total: 8'>            offset = putInt32(itsBootstrapMethodsLength + 2, data, offset);
</span><span class='nc' id='L2852' title='0|0|0 - Total: 7'>            offset = putInt16(itsBootstrapMethods.size(), data, offset);
</span><span class='nc' id='L2853' title='0|0|0 - Total: 2'>            for (int i = 0; i < itsBootstrapMethods.size(); i++) {
</span><span class='nc' id='L2854' title='0|0|0 - Total: 6'>                BootstrapEntry entry = (BootstrapEntry) itsBootstrapMethods.get(i);
</span><span class='nc' id='L2855' title='0|0|0 - Total: 9'>                System.arraycopy(entry.code, 0, data, offset, entry.code.length);
</span><span class='nc' id='L2856' title='0|0|0 - Total: 6'>                offset += entry.code.length;
</span>            }
        }
<span class='bc' id='L2859' title='0|2|2 - Total: 2'>        if (itsSourceFileNameIndex != 0) {
</span><span class='bc' id='L2860' title='0|5|5 - Total: 5'>            offset = putInt16(sourceFileAttributeNameIndex, data, offset);
</span><span class='bc' id='L2861' title='0|5|5 - Total: 5'>            offset = putInt32(2, data, offset);
</span><span class='bc' id='L2862' title='0|6|6 - Total: 6'>            offset = putInt16(itsSourceFileNameIndex, data, offset);
</span>        }

<span class='bpc' id='L2865' title='0|1|1 - Total: 2'>        if (offset != dataSize) {
</span>            // Check getWriteSize is consistent with write!
<span class='nc' id='L2867' title='0|0|0 - Total: 4'>            throw new RuntimeException();
</span>        }

<span class='bc' id='L2870' title='0|2|2 - Total: 2'>        return data;
</span>    }

    static int putInt64(long value, byte[] array, int offset) {
<span class='bc' id='L2874' title='0|8|8 - Total: 8'>        offset = putInt32((int) (value >>> 32), array, offset);
</span><span class='bc' id='L2875' title='0|6|6 - Total: 6'>        return putInt32((int) value, array, offset);
</span>    }

    private static void badStack(int value) {
        String s;
<span class='nc' id='L2880' title='0|0|0 - Total: 2'>        if (value < 0) {
</span><span class='nc' id='L2881' title='0|0|0 - Total: 10'>            s = "Stack underflow: " + value;
</span>        } else {
<span class='nc' id='L2883' title='0|0|0 - Total: 9'>            s = "Too big stack: " + value;
</span>        }
<span class='nc' id='L2885' title='0|0|0 - Total: 5'>        throw new IllegalStateException(s);
</span>    }

    /*
        Really weird. Returns an int with # parameters in hi 16 bits, and
        stack difference removal of parameters from stack and pushing the
        result (it does not take into account removal of this in case of
        non-static methods).
        If Java really supported references we wouldn't have to be this
        perverted.
    */
    private static int sizeOfParameters(String pString) {
<span class='bc' id='L2897' title='0|3|3 - Total: 3'>        int length = pString.length();
</span><span class='bc' id='L2898' title='0|4|4 - Total: 4'>        int rightParenthesis = pString.lastIndexOf(')');
</span><span class='bpc' id='L2899' title='0|1|1 - Total: 2'>        if (3 <= length /* minimal signature takes at least 3 chars: ()V */
</span><span class='bpc' id='L2900' title='0|3|3 - Total: 6'>            && pString.charAt(0) == '('
</span>            && 1 <= rightParenthesis && rightParenthesis + 1 < length) {
<span class='bc' id='L2902' title='0|2|2 - Total: 2'>            boolean ok = true;
</span><span class='bc' id='L2903' title='0|2|2 - Total: 2'>            int index = 1;
</span><span class='bc' id='L2904' title='0|2|2 - Total: 2'>            int stackDiff = 0;
</span><span class='bc' id='L2905' title='0|2|2 - Total: 2'>            int count = 0;
</span>            stringLoop:
<span class='bc' id='L2907' title='0|2|2 - Total: 2'>            while (index != rightParenthesis) {
</span><span class='bpc' id='L2908' title='0|4|4 - Total: 5'>                switch (pString.charAt(index)) {
</span>                    default:
<span class='nc' id='L2910' title='0|0|0 - Total: 2'>                        ok = false;
</span><span class='nc' id='L2911' title='0|0|0 - Total: 1'>                        break stringLoop;
</span>                    case 'J':
                    case 'D':
<span class='bc' id='L2914' title='0|1|1 - Total: 1'>                        --stackDiff;
</span>                        // fallthru
                    case 'B':
                    case 'S':
                    case 'C':
                    case 'I':
                    case 'Z':
                    case 'F':
<span class='bc' id='L2922' title='0|1|1 - Total: 1'>                        --stackDiff;
</span><span class='bc' id='L2923' title='0|1|1 - Total: 1'>                        ++count;
</span><span class='bc' id='L2924' title='0|1|1 - Total: 1'>                        ++index;
</span><span class='bc' id='L2925' title='0|1|1 - Total: 1'>                        continue;
</span>                    case '[':
<span class='bc' id='L2927' title='0|1|1 - Total: 1'>                        ++index;
</span><span class='bc' id='L2928' title='0|4|4 - Total: 4'>                        int c = pString.charAt(index);
</span><span class='bpc' id='L2929' title='0|1|1 - Total: 2'>                        while (c == '[') {
</span><span class='nc' id='L2930' title='0|0|0 - Total: 1'>                            ++index;
</span><span class='nc' id='L2931' title='0|0|0 - Total: 5'>                            c = pString.charAt(index);
</span>                        }
<span class='bpc' id='L2933' title='0|2|2 - Total: 3'>                        switch (c) {
</span>                            default:
<span class='nc' id='L2935' title='0|0|0 - Total: 2'>                                ok = false;
</span><span class='nc' id='L2936' title='0|0|0 - Total: 1'>                                break stringLoop;
</span>                            case 'J':
                            case 'D':
                            case 'B':
                            case 'S':
                            case 'C':
                            case 'I':
                            case 'Z':
                            case 'F':
<span class='bc' id='L2945' title='0|1|1 - Total: 1'>                                --stackDiff;
</span><span class='bc' id='L2946' title='0|1|1 - Total: 1'>                                ++count;
</span><span class='bc' id='L2947' title='0|1|1 - Total: 1'>                                ++index;
</span><span class='bc' id='L2948' title='0|1|1 - Total: 1'>                                continue;
</span>                            case 'L':
                                // fallthru
                        }
                        // fallthru
                    case 'L': {
<span class='bc' id='L2954' title='0|1|1 - Total: 1'>                        --stackDiff;
</span><span class='bc' id='L2955' title='0|1|1 - Total: 1'>                        ++count;
</span><span class='bc' id='L2956' title='0|1|1 - Total: 1'>                        ++index;
</span><span class='bc' id='L2957' title='0|5|5 - Total: 5'>                        int semicolon = pString.indexOf(';', index);
</span><span class='bpc' id='L2958' title='0|2|2 - Total: 4'>                        if (!(index + 1 <= semicolon
</span>                            && semicolon < rightParenthesis)) {
<span class='nc' id='L2960' title='0|0|0 - Total: 2'>                            ok = false;
</span><span class='nc' id='L2961' title='0|0|0 - Total: 1'>                            break stringLoop;
</span>                        }
<span class='bc' id='L2963' title='0|4|4 - Total: 4'>                        index = semicolon + 1;
</span><span class='bc' id='L2964' title='0|1|1 - Total: 1'>                        continue;
</span>                    }
                }
            }
<span class='bpc' id='L2968' title='0|1|1 - Total: 2'>            if (ok) {
</span><span class='bpc' id='L2969' title='0|3|3 - Total: 4'>                switch (pString.charAt(rightParenthesis + 1)) {
</span>                    default:
<span class='nc' id='L2971' title='0|0|0 - Total: 2'>                        ok = false;
</span><span class='nc' id='L2972' title='0|0|0 - Total: 1'>                        break;
</span>                    case 'J':
                    case 'D':
<span class='bc' id='L2975' title='0|1|1 - Total: 1'>                        ++stackDiff;
</span>                        // fallthru
                    case 'B':
                    case 'S':
                    case 'C':
                    case 'I':
                    case 'Z':
                    case 'F':
                    case 'L':
                    case '[':
<span class='bc' id='L2985' title='0|1|1 - Total: 1'>                        ++stackDiff;
</span>                        // fallthru
                    case 'V':
                        break;
                }
<span class='bpc' id='L2990' title='0|1|1 - Total: 2'>                if (ok) {
</span><span class='bc' id='L2991' title='0|8|8 - Total: 8'>                    return ((count << 16) | (0xFFFF & stackDiff));
</span>                }
            }
        }
<span class='nc' id='L2995' title='0|0|0 - Total: 12'>        throw new IllegalArgumentException(
</span>            "Bad parameter signature: " + pString);
    }

    static int putInt16(int value, byte[] array, int offset) {
<span class='bc' id='L3000' title='0|9|9 - Total: 9'>        array[offset + 0] = (byte) (value >>> 8);
</span><span class='bc' id='L3001' title='0|7|7 - Total: 7'>        array[offset + 1] = (byte) value;
</span><span class='bc' id='L3002' title='0|4|4 - Total: 4'>        return offset + 2;
</span>    }

    static int putInt32(int value, byte[] array, int offset) {
<span class='bc' id='L3006' title='0|9|9 - Total: 9'>        array[offset + 0] = (byte) (value >>> 24);
</span><span class='bc' id='L3007' title='0|9|9 - Total: 9'>        array[offset + 1] = (byte) (value >>> 16);
</span><span class='bc' id='L3008' title='0|9|9 - Total: 9'>        array[offset + 2] = (byte) (value >>> 8);
</span><span class='bc' id='L3009' title='0|7|7 - Total: 7'>        array[offset + 3] = (byte) value;
</span><span class='bc' id='L3010' title='0|4|4 - Total: 4'>        return offset + 4;
</span>    }

    /**
     * Size of a bytecode instruction, counting the opcode and its operands.
     *
     * This is different from opcodeCount, since opcodeCount counts logical operands.
     */
    private static int opcodeLength(int opcode, boolean wide) {
<span class='bpc' id='L3019' title='0|5|5 - Total: 8'>        switch (opcode) {
</span>            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP:
            case ByteCode.POP2:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
<span class='bc' id='L3171' title='0|2|2 - Total: 2'>                return 1;
</span>            case ByteCode.BIPUSH:
            case ByteCode.LDC:
            case ByteCode.NEWARRAY:
<span class='bc' id='L3175' title='0|2|2 - Total: 2'>                return 2;
</span>            case ByteCode.ALOAD:
            case ByteCode.ASTORE:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.ILOAD:
            case ByteCode.ISTORE:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.RET:
<span class='bc' id='L3187' title='0|2|2 - Total: 2'>                return wide ? 3 : 2;
</span>
            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.JSR:
            case ByteCode.LDC_W:
            case ByteCode.LDC2_W:
            case ByteCode.NEW:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.SIPUSH:
<span class='bc' id='L3221' title='0|2|2 - Total: 2'>                return 3;
</span>
            case ByteCode.IINC:
<span class='nc' id='L3224' title='0|0|0 - Total: 2'>                return wide ? 5 : 3;
</span>
            case ByteCode.MULTIANEWARRAY:
<span class='nc' id='L3227' title='0|0|0 - Total: 2'>                return 4;
</span>
            case ByteCode.GOTO_W:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKEDYNAMIC:
            case ByteCode.JSR_W:
<span class='bc' id='L3233' title='0|2|2 - Total: 2'>                return 5;
</span>
            /*
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.TABLESWITCH:
                return -1;
            */
        }
<span class='nc' id='L3241' title='0|0|0 - Total: 12'>        throw new IllegalArgumentException("Bad opcode: " + opcode);
</span>    }

    /**
     * Number of operands accompanying the opcode.
     */
    private static int opcodeCount(int opcode) {
<span class='bpc' id='L3248' title='0|1|1 - Total: 5'>        switch (opcode) {
</span>            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP:
            case ByteCode.POP2:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
<span class='bc' id='L3400' title='0|2|2 - Total: 2'>                return 0;
</span>            case ByteCode.ALOAD:
            case ByteCode.ANEWARRAY:
            case ByteCode.ASTORE:
            case ByteCode.BIPUSH:
            case ByteCode.CHECKCAST:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.GOTO_W:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.ILOAD:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.ISTORE:
            case ByteCode.JSR:
            case ByteCode.JSR_W:
            case ByteCode.LDC:
            case ByteCode.LDC2_W:
            case ByteCode.LDC_W:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.NEW:
            case ByteCode.NEWARRAY:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.RET:
            case ByteCode.SIPUSH:
<span class='nc' id='L3450' title='0|0|0 - Total: 2'>                return 1;
</span>
            case ByteCode.IINC:
            case ByteCode.MULTIANEWARRAY:
<span class='nc' id='L3454' title='0|0|0 - Total: 2'>                return 2;
</span>
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.TABLESWITCH:
<span class='nc' id='L3458' title='0|0|0 - Total: 2'>                return -1;
</span>        }
<span class='nc' id='L3460' title='0|0|0 - Total: 12'>        throw new IllegalArgumentException("Bad opcode: " + opcode);
</span>    }

    /**
     * The effect on the operand stack of a given opcode.
     */
    private static int stackChange(int opcode) {
        // For INVOKE... accounts only for popping this (unless static),
        // ignoring parameters and return type
<span class='bpc' id='L3469' title='0|6|6 - Total: 8'>        switch (opcode) {
</span>            case ByteCode.DASTORE:
            case ByteCode.LASTORE:
<span class='nc' id='L3472' title='0|0|0 - Total: 2'>                return -4;
</span>
            case ByteCode.AASTORE:
            case ByteCode.BASTORE:
            case ByteCode.CASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.FASTORE:
            case ByteCode.IASTORE:
            case ByteCode.LCMP:
            case ByteCode.SASTORE:
<span class='bc' id='L3483' title='0|2|2 - Total: 2'>                return -3;
</span>
            case ByteCode.DADD:
            case ByteCode.DDIV:
            case ByteCode.DMUL:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.LADD:
            case ByteCode.LAND:
            case ByteCode.LDIV:
            case ByteCode.LMUL:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSTORE:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LXOR:
            case ByteCode.POP2:
<span class='bc' id='L3519' title='0|2|2 - Total: 2'>                return -2;
</span>
            case ByteCode.AALOAD:
            case ByteCode.ARETURN:
            case ByteCode.ASTORE:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.CALOAD:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FDIV:
            case ByteCode.FMUL:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.GETFIELD:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IDIV:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IMUL:
            case ByteCode.INVOKEINTERFACE:       //
            case ByteCode.INVOKESPECIAL:         // but needs to account for
            case ByteCode.INVOKEVIRTUAL:         // pops 'this' (unless static)
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LUSHR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.POP:
            case ByteCode.PUTFIELD:
            case ByteCode.SALOAD:
            case ByteCode.TABLESWITCH:
<span class='bc' id='L3589' title='0|2|2 - Total: 2'>                return -1;
</span>
            case ByteCode.ANEWARRAY:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.BREAKPOINT:
            case ByteCode.CHECKCAST:
            case ByteCode.D2L:
            case ByteCode.DALOAD:
            case ByteCode.DNEG:
            case ByteCode.F2I:
            case ByteCode.FNEG:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.GOTO_W:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2F:
            case ByteCode.I2S:
            case ByteCode.IINC:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.INEG:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEDYNAMIC:
            case ByteCode.L2D:
            case ByteCode.LALOAD:
            case ByteCode.LNEG:
            case ByteCode.NEWARRAY:
            case ByteCode.NOP:
            case ByteCode.PUTSTATIC:
            case ByteCode.RET:
            case ByteCode.RETURN:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
<span class='bc' id='L3624' title='0|2|2 - Total: 2'>                return 0;
</span>
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.BIPUSH:
            case ByteCode.DUP:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2L:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FLOAD:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.I2D:
            case ByteCode.I2L:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.ILOAD:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.JSR:
            case ByteCode.JSR_W:
            case ByteCode.LDC:
            case ByteCode.LDC_W:
            case ByteCode.MULTIANEWARRAY:
            case ByteCode.NEW:
            case ByteCode.SIPUSH:
<span class='bc' id='L3667' title='0|2|2 - Total: 2'>                return 1;
</span>
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DLOAD:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDC2_W:
            case ByteCode.LLOAD:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
<span class='bc' id='L3687' title='0|2|2 - Total: 2'>                return 2;
</span>        }
<span class='nc' id='L3689' title='0|0|0 - Total: 12'>        throw new IllegalArgumentException("Bad opcode: " + opcode);
</span>    }

        /*
         * Number of bytes of operands generated after the opcode.
         * Not in use currently.
         */
/*
    int extra(int opcode)
    {
        switch (opcode) {
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP2:
            case ByteCode.POP:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
                return 0;

            case ByteCode.ALOAD:
            case ByteCode.ASTORE:
            case ByteCode.BIPUSH:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.ILOAD:
            case ByteCode.ISTORE:
            case ByteCode.LDC:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.NEWARRAY:
            case ByteCode.RET:
                return 1;

            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.IINC:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.JSR:
            case ByteCode.LDC2_W:
            case ByteCode.LDC_W:
            case ByteCode.NEW:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.SIPUSH:
                return 2;

            case ByteCode.MULTIANEWARRAY:
                return 3;

            case ByteCode.GOTO_W:
            case ByteCode.JSR_W:
                return 4;

            case ByteCode.LOOKUPSWITCH:    // depends on alignment
            case ByteCode.TABLESWITCH: // depends on alignment
                return -1;
        }
        throw new IllegalArgumentException("Bad opcode: "+opcode);
    }
*/

    @SuppressWarnings("unused")
    private static String bytecodeStr(int code) {
        if (DEBUGSTACK || DEBUGCODE) {
            switch (code) {
                case ByteCode.NOP:
                    return "nop";
                case ByteCode.ACONST_NULL:
                    return "aconst_null";
                case ByteCode.ICONST_M1:
                    return "iconst_m1";
                case ByteCode.ICONST_0:
                    return "iconst_0";
                case ByteCode.ICONST_1:
                    return "iconst_1";
                case ByteCode.ICONST_2:
                    return "iconst_2";
                case ByteCode.ICONST_3:
                    return "iconst_3";
                case ByteCode.ICONST_4:
                    return "iconst_4";
                case ByteCode.ICONST_5:
                    return "iconst_5";
                case ByteCode.LCONST_0:
                    return "lconst_0";
                case ByteCode.LCONST_1:
                    return "lconst_1";
                case ByteCode.FCONST_0:
                    return "fconst_0";
                case ByteCode.FCONST_1:
                    return "fconst_1";
                case ByteCode.FCONST_2:
                    return "fconst_2";
                case ByteCode.DCONST_0:
                    return "dconst_0";
                case ByteCode.DCONST_1:
                    return "dconst_1";
                case ByteCode.BIPUSH:
                    return "bipush";
                case ByteCode.SIPUSH:
                    return "sipush";
                case ByteCode.LDC:
                    return "ldc";
                case ByteCode.LDC_W:
                    return "ldc_w";
                case ByteCode.LDC2_W:
                    return "ldc2_w";
                case ByteCode.ILOAD:
                    return "iload";
                case ByteCode.LLOAD:
                    return "lload";
                case ByteCode.FLOAD:
                    return "fload";
                case ByteCode.DLOAD:
                    return "dload";
                case ByteCode.ALOAD:
                    return "aload";
                case ByteCode.ILOAD_0:
                    return "iload_0";
                case ByteCode.ILOAD_1:
                    return "iload_1";
                case ByteCode.ILOAD_2:
                    return "iload_2";
                case ByteCode.ILOAD_3:
                    return "iload_3";
                case ByteCode.LLOAD_0:
                    return "lload_0";
                case ByteCode.LLOAD_1:
                    return "lload_1";
                case ByteCode.LLOAD_2:
                    return "lload_2";
                case ByteCode.LLOAD_3:
                    return "lload_3";
                case ByteCode.FLOAD_0:
                    return "fload_0";
                case ByteCode.FLOAD_1:
                    return "fload_1";
                case ByteCode.FLOAD_2:
                    return "fload_2";
                case ByteCode.FLOAD_3:
                    return "fload_3";
                case ByteCode.DLOAD_0:
                    return "dload_0";
                case ByteCode.DLOAD_1:
                    return "dload_1";
                case ByteCode.DLOAD_2:
                    return "dload_2";
                case ByteCode.DLOAD_3:
                    return "dload_3";
                case ByteCode.ALOAD_0:
                    return "aload_0";
                case ByteCode.ALOAD_1:
                    return "aload_1";
                case ByteCode.ALOAD_2:
                    return "aload_2";
                case ByteCode.ALOAD_3:
                    return "aload_3";
                case ByteCode.IALOAD:
                    return "iaload";
                case ByteCode.LALOAD:
                    return "laload";
                case ByteCode.FALOAD:
                    return "faload";
                case ByteCode.DALOAD:
                    return "daload";
                case ByteCode.AALOAD:
                    return "aaload";
                case ByteCode.BALOAD:
                    return "baload";
                case ByteCode.CALOAD:
                    return "caload";
                case ByteCode.SALOAD:
                    return "saload";
                case ByteCode.ISTORE:
                    return "istore";
                case ByteCode.LSTORE:
                    return "lstore";
                case ByteCode.FSTORE:
                    return "fstore";
                case ByteCode.DSTORE:
                    return "dstore";
                case ByteCode.ASTORE:
                    return "astore";
                case ByteCode.ISTORE_0:
                    return "istore_0";
                case ByteCode.ISTORE_1:
                    return "istore_1";
                case ByteCode.ISTORE_2:
                    return "istore_2";
                case ByteCode.ISTORE_3:
                    return "istore_3";
                case ByteCode.LSTORE_0:
                    return "lstore_0";
                case ByteCode.LSTORE_1:
                    return "lstore_1";
                case ByteCode.LSTORE_2:
                    return "lstore_2";
                case ByteCode.LSTORE_3:
                    return "lstore_3";
                case ByteCode.FSTORE_0:
                    return "fstore_0";
                case ByteCode.FSTORE_1:
                    return "fstore_1";
                case ByteCode.FSTORE_2:
                    return "fstore_2";
                case ByteCode.FSTORE_3:
                    return "fstore_3";
                case ByteCode.DSTORE_0:
                    return "dstore_0";
                case ByteCode.DSTORE_1:
                    return "dstore_1";
                case ByteCode.DSTORE_2:
                    return "dstore_2";
                case ByteCode.DSTORE_3:
                    return "dstore_3";
                case ByteCode.ASTORE_0:
                    return "astore_0";
                case ByteCode.ASTORE_1:
                    return "astore_1";
                case ByteCode.ASTORE_2:
                    return "astore_2";
                case ByteCode.ASTORE_3:
                    return "astore_3";
                case ByteCode.IASTORE:
                    return "iastore";
                case ByteCode.LASTORE:
                    return "lastore";
                case ByteCode.FASTORE:
                    return "fastore";
                case ByteCode.DASTORE:
                    return "dastore";
                case ByteCode.AASTORE:
                    return "aastore";
                case ByteCode.BASTORE:
                    return "bastore";
                case ByteCode.CASTORE:
                    return "castore";
                case ByteCode.SASTORE:
                    return "sastore";
                case ByteCode.POP:
                    return "pop";
                case ByteCode.POP2:
                    return "pop2";
                case ByteCode.DUP:
                    return "dup";
                case ByteCode.DUP_X1:
                    return "dup_x1";
                case ByteCode.DUP_X2:
                    return "dup_x2";
                case ByteCode.DUP2:
                    return "dup2";
                case ByteCode.DUP2_X1:
                    return "dup2_x1";
                case ByteCode.DUP2_X2:
                    return "dup2_x2";
                case ByteCode.SWAP:
                    return "swap";
                case ByteCode.IADD:
                    return "iadd";
                case ByteCode.LADD:
                    return "ladd";
                case ByteCode.FADD:
                    return "fadd";
                case ByteCode.DADD:
                    return "dadd";
                case ByteCode.ISUB:
                    return "isub";
                case ByteCode.LSUB:
                    return "lsub";
                case ByteCode.FSUB:
                    return "fsub";
                case ByteCode.DSUB:
                    return "dsub";
                case ByteCode.IMUL:
                    return "imul";
                case ByteCode.LMUL:
                    return "lmul";
                case ByteCode.FMUL:
                    return "fmul";
                case ByteCode.DMUL:
                    return "dmul";
                case ByteCode.IDIV:
                    return "idiv";
                case ByteCode.LDIV:
                    return "ldiv";
                case ByteCode.FDIV:
                    return "fdiv";
                case ByteCode.DDIV:
                    return "ddiv";
                case ByteCode.IREM:
                    return "irem";
                case ByteCode.LREM:
                    return "lrem";
                case ByteCode.FREM:
                    return "frem";
                case ByteCode.DREM:
                    return "drem";
                case ByteCode.INEG:
                    return "ineg";
                case ByteCode.LNEG:
                    return "lneg";
                case ByteCode.FNEG:
                    return "fneg";
                case ByteCode.DNEG:
                    return "dneg";
                case ByteCode.ISHL:
                    return "ishl";
                case ByteCode.LSHL:
                    return "lshl";
                case ByteCode.ISHR:
                    return "ishr";
                case ByteCode.LSHR:
                    return "lshr";
                case ByteCode.IUSHR:
                    return "iushr";
                case ByteCode.LUSHR:
                    return "lushr";
                case ByteCode.IAND:
                    return "iand";
                case ByteCode.LAND:
                    return "land";
                case ByteCode.IOR:
                    return "ior";
                case ByteCode.LOR:
                    return "lor";
                case ByteCode.IXOR:
                    return "ixor";
                case ByteCode.LXOR:
                    return "lxor";
                case ByteCode.IINC:
                    return "iinc";
                case ByteCode.I2L:
                    return "i2l";
                case ByteCode.I2F:
                    return "i2f";
                case ByteCode.I2D:
                    return "i2d";
                case ByteCode.L2I:
                    return "l2i";
                case ByteCode.L2F:
                    return "l2f";
                case ByteCode.L2D:
                    return "l2d";
                case ByteCode.F2I:
                    return "f2i";
                case ByteCode.F2L:
                    return "f2l";
                case ByteCode.F2D:
                    return "f2d";
                case ByteCode.D2I:
                    return "d2i";
                case ByteCode.D2L:
                    return "d2l";
                case ByteCode.D2F:
                    return "d2f";
                case ByteCode.I2B:
                    return "i2b";
                case ByteCode.I2C:
                    return "i2c";
                case ByteCode.I2S:
                    return "i2s";
                case ByteCode.LCMP:
                    return "lcmp";
                case ByteCode.FCMPL:
                    return "fcmpl";
                case ByteCode.FCMPG:
                    return "fcmpg";
                case ByteCode.DCMPL:
                    return "dcmpl";
                case ByteCode.DCMPG:
                    return "dcmpg";
                case ByteCode.IFEQ:
                    return "ifeq";
                case ByteCode.IFNE:
                    return "ifne";
                case ByteCode.IFLT:
                    return "iflt";
                case ByteCode.IFGE:
                    return "ifge";
                case ByteCode.IFGT:
                    return "ifgt";
                case ByteCode.IFLE:
                    return "ifle";
                case ByteCode.IF_ICMPEQ:
                    return "if_icmpeq";
                case ByteCode.IF_ICMPNE:
                    return "if_icmpne";
                case ByteCode.IF_ICMPLT:
                    return "if_icmplt";
                case ByteCode.IF_ICMPGE:
                    return "if_icmpge";
                case ByteCode.IF_ICMPGT:
                    return "if_icmpgt";
                case ByteCode.IF_ICMPLE:
                    return "if_icmple";
                case ByteCode.IF_ACMPEQ:
                    return "if_acmpeq";
                case ByteCode.IF_ACMPNE:
                    return "if_acmpne";
                case ByteCode.GOTO:
                    return "goto";
                case ByteCode.JSR:
                    return "jsr";
                case ByteCode.RET:
                    return "ret";
                case ByteCode.TABLESWITCH:
                    return "tableswitch";
                case ByteCode.LOOKUPSWITCH:
                    return "lookupswitch";
                case ByteCode.IRETURN:
                    return "ireturn";
                case ByteCode.LRETURN:
                    return "lreturn";
                case ByteCode.FRETURN:
                    return "freturn";
                case ByteCode.DRETURN:
                    return "dreturn";
                case ByteCode.ARETURN:
                    return "areturn";
                case ByteCode.RETURN:
                    return "return";
                case ByteCode.GETSTATIC:
                    return "getstatic";
                case ByteCode.PUTSTATIC:
                    return "putstatic";
                case ByteCode.GETFIELD:
                    return "getfield";
                case ByteCode.PUTFIELD:
                    return "putfield";
                case ByteCode.INVOKEVIRTUAL:
                    return "invokevirtual";
                case ByteCode.INVOKESPECIAL:
                    return "invokespecial";
                case ByteCode.INVOKESTATIC:
                    return "invokestatic";
                case ByteCode.INVOKEINTERFACE:
                    return "invokeinterface";
                case ByteCode.INVOKEDYNAMIC:
                    return "invokedynamic";
                case ByteCode.NEW:
                    return "new";
                case ByteCode.NEWARRAY:
                    return "newarray";
                case ByteCode.ANEWARRAY:
                    return "anewarray";
                case ByteCode.ARRAYLENGTH:
                    return "arraylength";
                case ByteCode.ATHROW:
                    return "athrow";
                case ByteCode.CHECKCAST:
                    return "checkcast";
                case ByteCode.INSTANCEOF:
                    return "instanceof";
                case ByteCode.MONITORENTER:
                    return "monitorenter";
                case ByteCode.MONITOREXIT:
                    return "monitorexit";
                case ByteCode.WIDE:
                    return "wide";
                case ByteCode.MULTIANEWARRAY:
                    return "multianewarray";
                case ByteCode.IFNULL:
                    return "ifnull";
                case ByteCode.IFNONNULL:
                    return "ifnonnull";
                case ByteCode.GOTO_W:
                    return "goto_w";
                case ByteCode.JSR_W:
                    return "jsr_w";
                case ByteCode.BREAKPOINT:
                    return "breakpoint";

                case ByteCode.IMPDEP1:
                    return "impdep1";
                case ByteCode.IMPDEP2:
                    return "impdep2";
            }
        }
<span class='nc' id='L4337' title='0|0|0 - Total: 2'>        return "";
</span>    }

    final char[] getCharBuffer(int minimalSize) {
<span class='bc' id='L4341' title='0|2|2 - Total: 2'>        if (minimalSize > tmpCharBuffer.length) {
</span><span class='bc' id='L4342' title='0|6|6 - Total: 6'>            int newSize = tmpCharBuffer.length * 2;
</span><span class='bc' id='L4343' title='0|2|2 - Total: 2'>            if (minimalSize > newSize) {
</span><span class='bc' id='L4344' title='0|2|2 - Total: 2'>                newSize = minimalSize;
</span>            }
<span class='bc' id='L4346' title='0|4|4 - Total: 4'>            tmpCharBuffer = new char[newSize];
</span>        }
<span class='bc' id='L4348' title='0|3|3 - Total: 3'>        return tmpCharBuffer;
</span>    }

    /**
     * Add a pc as the start of super block.
     *
     * A pc is the beginning of a super block if: - pc == 0 - it is the target of a branch instruction
     * - it is the beginning of an exception handler - it is directly after an unconditional jump
     */
    private void addSuperBlockStart(int pc) {
<span class='bpc' id='L4358' title='0|1|1 - Total: 2'>        if (GenerateStackMap) {
</span><span class='bc' id='L4359' title='0|2|2 - Total: 2'>            if (itsSuperBlockStarts == null) {
</span><span class='bc' id='L4360' title='0|5|5 - Total: 5'>                itsSuperBlockStarts = new int[SuperBlockStartsSize];
</span><span class='bc' id='L4361' title='0|2|2 - Total: 2'>            } else if (itsSuperBlockStarts.length == itsSuperBlockStartsTop) {
</span><span class='bc' id='L4362' title='0|6|6 - Total: 6'>                int[] tmp = new int[itsSuperBlockStartsTop * 2];
</span><span class='bc' id='L4363' title='0|8|8 - Total: 8'>                System.arraycopy(itsSuperBlockStarts, 0, tmp, 0,
</span>                    itsSuperBlockStartsTop);
<span class='bc' id='L4365' title='0|3|3 - Total: 3'>                itsSuperBlockStarts = tmp;
</span>            }
<span class='bc' id='L4367' title='0|11|11 - Total: 11'>            itsSuperBlockStarts[itsSuperBlockStartsTop++] = pc;
</span>        }
<span class='bc' id='L4369' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Sort the list of recorded super block starts and remove duplicates.
     *
     * Also adds exception handling blocks as block starts, since there is no explicit control flow to
     * these. Used for stack map table generation.
     */
    private void finalizeSuperBlockStarts() {
<span class='bpc' id='L4378' title='0|1|1 - Total: 2'>        if (GenerateStackMap) {
</span><span class='bc' id='L4379' title='0|2|2 - Total: 2'>            for (int i = 0; i < itsExceptionTableTop; i++) {
</span><span class='bc' id='L4380' title='0|5|5 - Total: 5'>                ExceptionTableEntry ete = itsExceptionTable[i];
</span><span class='bc' id='L4381' title='0|6|6 - Total: 6'>                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);
</span><span class='bc' id='L4382' title='0|3|3 - Total: 3'>                addSuperBlockStart(handlerPC);
</span>            }
<span class='bc' id='L4384' title='0|6|6 - Total: 6'>            Arrays.sort(itsSuperBlockStarts, 0, itsSuperBlockStartsTop);
</span><span class='bc' id='L4385' title='0|5|5 - Total: 5'>            int prev = itsSuperBlockStarts[0];
</span><span class='bc' id='L4386' title='0|2|2 - Total: 2'>            int copyTo = 1;
</span><span class='bc' id='L4387' title='0|2|2 - Total: 2'>            for (int i = 1; i < itsSuperBlockStartsTop; i++) {
</span><span class='bc' id='L4388' title='0|5|5 - Total: 5'>                int curr = itsSuperBlockStarts[i];
</span><span class='bc' id='L4389' title='0|2|2 - Total: 2'>                if (prev != curr) {
</span><span class='bc' id='L4390' title='0|2|2 - Total: 2'>                    if (copyTo != i) {
</span><span class='bc' id='L4391' title='0|5|5 - Total: 5'>                        itsSuperBlockStarts[copyTo] = curr;
</span>                    }
<span class='bc' id='L4393' title='0|1|1 - Total: 1'>                    copyTo++;
</span><span class='bc' id='L4394' title='0|2|2 - Total: 2'>                    prev = curr;
</span>                }
            }
<span class='bc' id='L4397' title='0|3|3 - Total: 3'>            itsSuperBlockStartsTop = copyTo;
</span><span class='bc' id='L4398' title='0|2|2 - Total: 2'>            if (itsSuperBlockStarts[copyTo - 1] == itsCodeBufferTop) {
</span><span class='bc' id='L4399' title='0|6|6 - Total: 6'>                itsSuperBlockStartsTop--;
</span>            }
        }
<span class='bc' id='L4402' title='0|1|1 - Total: 1'>    }
</span>
<span class='bc' id='L4404' title='0|3|3 - Total: 3'>    private int[] itsSuperBlockStarts = null;
</span><span class='bc' id='L4405' title='0|3|3 - Total: 3'>    private int itsSuperBlockStartsTop = 0;
</span>    private static final int SuperBlockStartsSize = 4;

    // Used to find blocks of code with no dependencies (aka dead code).
    // Necessary for generating type information for dead code, which is
    // expected by the Sun verifier. It is only necessary to store a single
    // jump source to determine if a block is reachable or not.
<span class='bc' id='L4412' title='0|3|3 - Total: 3'>    private UintMap itsJumpFroms = null;
</span>
    private static final int LineNumberTableSize = 16;
    private static final int ExceptionTableSize = 4;

    private static final int MajorVersion;
    private static final int MinorVersion;
    private static final boolean GenerateStackMap;

    static {
        // Figure out which classfile version should be generated. This assumes
        // that the runtime used to compile the JavaScript files is the same as
        // the one used to run them. This is important because there are cases
        // when bytecode is generated at runtime, where it is not easy to pass
        // along what version is necessary. Instead, we grab the version numbers
        // from the bytecode of this class and use that.
        //
        // Based on the version numbers we scrape, we can also determine what
        // bytecode features we need. For example, Java 6 bytecode (classfile
        // version 50) should have stack maps generated.
<span class='bc' id='L4432' title='0|2|2 - Total: 2'>        InputStream is = null;
</span><span class='bc' id='L4433' title='0|4|4 - Total: 4'>        int major = 48, minor = 0;
</span>        try {
<span class='bc' id='L4435' title='0|4|4 - Total: 4'>            is = ClassFileWriter.class.getResourceAsStream("ClassFileWriter.class");
</span><span class='bpc' id='L4436' title='0|1|1 - Total: 2'>            if (is == null) {
</span><span class='nc' id='L4437' title='0|0|0 - Total: 3'>                is = ClassLoader.getSystemResourceAsStream(
</span>                    "org/mozilla/classfile/ClassFileWriter.class");
            }
<span class='bc' id='L4440' title='0|3|3 - Total: 3'>            byte[] header = new byte[8];
</span>            // read loop is required since JDK7 will only provide 2 bytes
            // on the first read() - see bug #630111
<span class='bc' id='L4443' title='0|2|2 - Total: 2'>            int read = 0;
</span><span class='bc' id='L4444' title='0|2|2 - Total: 2'>            while (read < 8) {
</span><span class='bc' id='L4445' title='0|8|8 - Total: 8'>                int c = is.read(header, read, 8 - read);
</span><span class='bpc' id='L4446' title='0|1|1 - Total: 2'>                if (c < 0)
</span><span class='nc' id='L4447' title='0|0|0 - Total: 4'>                    throw new IOException();
</span><span class='bc' id='L4448' title='0|4|4 - Total: 4'>                read += c;
</span><span class='bc' id='L4449' title='0|1|1 - Total: 1'>            }
</span><span class='bc' id='L4450' title='0|12|12 - Total: 12'>            minor = (header[4] << 8) | (header[5] & 0xff);
</span><span class='bc' id='L4451' title='0|12|12 - Total: 12'>            major = (header[6] << 8) | (header[7] & 0xff);
</span><span class='nc' id='L4452' title='0|0|0 - Total: 1'>        } catch (Exception e) {
</span>            // Unable to get class file, use default bytecode version
        } finally {
<span class='bpc' id='L4455' title='0|2|2 - Total: 7'>            MinorVersion = minor;
</span><span class='bpc' id='L4456' title='0|2|2 - Total: 6'>            MajorVersion = major;
</span><span class='bpc' id='L4457' title='0|1|1 - Total: 6'>            GenerateStackMap = major >= 50;
</span><span class='bpc' id='L4458' title='0|1|1 - Total: 6'>            if (is != null) {
</span>                try {
<span class='bpc' id='L4460' title='0|2|2 - Total: 6'>                    is.close();
</span><span class='nc' id='L4461' title='0|0|0 - Total: 3'>                } catch (IOException e) {
</span><span class='bpc' id='L4462' title='0|1|1 - Total: 5'>                }
</span>            }
<span class='nc' id='L4464' title='0|0|0 - Total: 2'>        }
</span><span class='bc' id='L4465' title='0|1|1 - Total: 1'>    }
</span>
    final class BootstrapEntry {

        final byte[] code;

        BootstrapEntry(ClassFileWriter.MHandle bsm, Object... bsmArgs) {
            int length = 2 + 2 + bsmArgs.length * 2;
            code = new byte[length];
            putInt16(itsConstantPool.addMethodHandle(bsm), code, 0);
            putInt16(bsmArgs.length, code, 2);
            for (int i = 0; i < bsmArgs.length; i++) {
                putInt16(itsConstantPool.addConstant(bsmArgs[i]), code, 4 + i * 2);
            }
        }

        @Override
        public boolean equals(Object obj) {
            return obj instanceof BootstrapEntry
                && Arrays.equals(code, ((BootstrapEntry) obj).code);
        }

        @Override
        public int hashCode() {
            return ~Arrays.hashCode(code);
        }
    }

    public static final class MHandle {

        final byte tag;
        final String owner;
        final String name;
        final String desc;

        public MHandle(byte tag, String owner, String name, String desc) {
            this.tag = tag;
            this.owner = owner;
            this.name = name;
            this.desc = desc;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof MHandle)) {
                return false;
            }
            MHandle mh = (MHandle) obj;
            return tag == mh.tag && owner.equals(mh.owner)
                && name.equals(mh.name) && desc.equals(mh.desc);
        }

        @Override
        public int hashCode() {
            return tag + owner.hashCode() * name.hashCode() * desc.hashCode();
        }

        @Override
        public String toString() {
            return owner + '.' + name + desc + " (" + tag + ')';
        }
    }

    private final static int FileHeaderConstant = 0xCAFEBABE;
    // Set DEBUG flags to true to get better checking and progress info.
    private static final boolean DEBUGSTACK = false;
    private static final boolean DEBUGLABELS = false;
    private static final boolean DEBUGCODE = false;

    private String generatedClassName;

    private ExceptionTableEntry itsExceptionTable[];
    private int itsExceptionTableTop;

    private int itsLineNumberTable[];   // pack start_pc & line_number together
    private int itsLineNumberTableTop;

<span class='bc' id='L4545' title='0|4|4 - Total: 4'>    private byte[] itsCodeBuffer = new byte[256];
</span>    private int itsCodeBufferTop;

    private ConstantPool itsConstantPool;

    private ClassFileMethod itsCurrentMethod;
    private short itsStackTop;

    private short itsMaxStack;
    private short itsMaxLocals;

<span class='bc' id='L4556' title='0|5|5 - Total: 5'>    private ObjArray itsMethods = new ObjArray();
</span><span class='bc' id='L4557' title='0|5|5 - Total: 5'>    private ObjArray itsFields = new ObjArray();
</span><span class='bc' id='L4558' title='0|5|5 - Total: 5'>    private ObjArray itsInterfaces = new ObjArray();
</span>
    private short itsFlags;
    private short itsThisClassIndex;
    private short itsSuperClassIndex;
    private short itsSourceFileNameIndex;

    private static final int MIN_LABEL_TABLE_SIZE = 32;
    private int[] itsLabelTable;
    private int itsLabelTableTop;

    // itsFixupTable[i] = (label_index << 32) | fixup_site
    private static final int MIN_FIXUP_TABLE_SIZE = 40;
    private long[] itsFixupTable;
    private int itsFixupTableTop;
    private ObjArray itsVarDescriptors;
    private ObjArray itsBootstrapMethods;
<span class='bc' id='L4575' title='0|3|3 - Total: 3'>    private int itsBootstrapMethodsLength = 0;
</span>
<span class='bc' id='L4577' title='0|4|4 - Total: 4'>    private char[] tmpCharBuffer = new char[64];
</span>}

</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>