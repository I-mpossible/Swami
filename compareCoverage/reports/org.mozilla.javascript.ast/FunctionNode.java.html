<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.ast.FunctionNode.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.ast.FunctionNode.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.ast;

import org.mozilla.javascript.Node;
import org.mozilla.javascript.Token;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * A JavaScript function declaration or expression.<p>
 * Node type is {@link Token#FUNCTION}.<p>
 *
 * <pre><i>FunctionDeclaration</i> :
 *        <b>function</b> Identifier ( FormalParameterListopt ) { FunctionBody }
 * <i>FunctionExpression</i> :
 *        <b>function</b> Identifieropt ( FormalParameterListopt ) { FunctionBody }
 * <i>FormalParameterList</i> :
 *        Identifier
 *        FormalParameterList , Identifier
 * <i>FunctionBody</i> :
 *        SourceElements
 * <i>Program</i> :
 *        SourceElements
 * <i>SourceElements</i> :
 *        SourceElement
 *        SourceElements SourceElement
 * <i>SourceElement</i> :
 *        Statement
 *        FunctionDeclaration</pre>
 *
 * JavaScript 1.8 introduces "function closures" of the form
 *  <pre>function ([params] ) Expression</pre>
 *
 * In this case the FunctionNode node will have no body but will have an
 * expression.
 */
public class FunctionNode extends ScriptNode {

    /**
     * There are three types of functions that can be defined. The first
     * is a function statement. This is a function appearing as a top-level
     * statement (i.e., not nested inside some other statement) in either a
     * script or a function.<p>
     *
     * The second is a function expression, which is a function appearing in
     * an expression except for the third type, which is...<p>
     *
     * The third type is a function expression where the expression is the
     * top-level expression in an expression statement.<p>
     *
     * The three types of functions have different treatment and must be
     * distinguished.<p>
     */
    public static final int FUNCTION_STATEMENT            = 1;
    public static final int FUNCTION_EXPRESSION           = 2;
    public static final int FUNCTION_EXPRESSION_STATEMENT = 3;
    public static final int ARROW_FUNCTION                = 4;

    public static enum Form { FUNCTION, GETTER, SETTER, METHOD }

<span class='uc' id='L70' title='4|4|4 - Total: 4'>    private static final List<AstNode> NO_PARAMS =
</span><span class='uc' id='L71' title='2|2|2 - Total: 2'>        Collections.unmodifiableList(new ArrayList<AstNode>());
</span>
    private Name functionName;
    private List<AstNode> params;
    private AstNode body;
    private boolean isExpressionClosure;
<span class='uc' id='L77' title='9|9|9 - Total: 9'>    private Form functionForm = Form.FUNCTION;
</span><span class='uc' id='L78' title='9|9|9 - Total: 9'>    private int lp = -1;
</span><span class='uc' id='L79' title='9|9|9 - Total: 9'>    private int rp = -1;
</span>
    // codegen variables
    private int functionType;
    private boolean needsActivation;
    private boolean isGenerator;
    private List<Node> generatorResumePoints;
    private Map<Node,int[]> liveLocals;
    private AstNode memberExprNode;

    {
<span class='uc' id='L90' title='9|9|9 - Total: 9'>        type = Token.FUNCTION;
</span>    }

<span class='uc' id='L93' title='2|2|2 - Total: 2'>    public FunctionNode() {
</span><span class='uc' id='L94' title='1|1|1 - Total: 1'>    }
</span>
    public FunctionNode(int pos) {
<span class='uc' id='L97' title='3|3|3 - Total: 3'>        super(pos);
</span><span class='uc' id='L98' title='1|1|1 - Total: 1'>    }
</span>
    public FunctionNode(int pos, Name name) {
<span class='uc' id='L101' title='3|3|3 - Total: 3'>        super(pos);
</span><span class='uc' id='L102' title='3|3|3 - Total: 3'>        setFunctionName(name);
</span><span class='uc' id='L103' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns function name
     * @return function name, {@code null} for anonymous functions
     */
    public Name getFunctionName() {
<span class='uc' id='L110' title='3|3|3 - Total: 3'>        return functionName;
</span>    }

    /**
     * Sets function name, and sets its parent to this node.
     * @param name function name, {@code null} for anonymous functions
     */
    public void setFunctionName(Name name) {
<span class='uc' id='L118' title='3|3|3 - Total: 3'>        functionName = name;
</span><span class='uc' id='L119' title='2|2|2 - Total: 2'>        if (name != null)
</span><span class='uc' id='L120' title='3|3|3 - Total: 3'>            name.setParent(this);
</span><span class='uc' id='L121' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns the function name as a string
     * @return the function name, {@code ""} if anonymous
     */
    public String getName() {
<span class='uc' id='L128' title='2|2|2 - Total: 2'>        return functionName != null ? functionName.getIdentifier() : "";
</span>    }

    /**
     * Returns the function parameter list
     * @return the function parameter list.  Returns an immutable empty
     *         list if there are no parameters.
     */
    public List<AstNode> getParams() {
<span class='uc' id='L137' title='2|2|2 - Total: 2'>        return params != null ? params : NO_PARAMS;
</span>    }

    /**
     * Sets the function parameter list, and sets the parent for
     * each element of the list.
     * @param params the function parameter list, or {@code null} if no params
     */
    public void setParams(List<AstNode> params) {
<span class='nc' id='L146' title='0|0|0 - Total: 2'>        if (params == null) {
</span><span class='nc' id='L147' title='0|0|0 - Total: 4'>            this.params = null;
</span>        } else {
<span class='nc' id='L149' title='0|0|0 - Total: 2'>            if (this.params != null)
</span><span class='nc' id='L150' title='0|0|0 - Total: 3'>                this.params.clear();
</span><span class='nc' id='L151' title='0|0|0 - Total: 2'>            for (AstNode param : params)
</span><span class='nc' id='L152' title='0|0|0 - Total: 4'>                addParam(param);
</span>        }
<span class='nc' id='L154' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Adds a parameter to the function parameter list.
     * Sets the parent of the param node to this node.
     * @param param the parameter
     * @throws IllegalArgumentException if param is {@code null}
     */
    public void addParam(AstNode param) {
<span class='uc' id='L163' title='3|3|3 - Total: 3'>        assertNotNull(param);
</span><span class='uc' id='L164' title='2|2|2 - Total: 2'>        if (params == null) {
</span><span class='uc' id='L165' title='5|5|5 - Total: 5'>            params = new ArrayList<AstNode>();
</span>        }
<span class='uc' id='L167' title='5|5|5 - Total: 5'>        params.add(param);
</span><span class='uc' id='L168' title='3|3|3 - Total: 3'>        param.setParent(this);
</span><span class='uc' id='L169' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns true if the specified {@link AstNode} node is a parameter
     * of this Function node.  This provides a way during AST traversal
     * to disambiguate the function name node from the parameter nodes.
     */
    public boolean isParam(AstNode node) {
<span class='nc' id='L177' title='0|0|0 - Total: 2'>        return params == null ? false : params.contains(node);
</span>    }

    /**
     * Returns function body.  Normally a {@link Block}, but can be a plain
     * {@link AstNode} if it's a function closure.
     *
     * @return the body.  Can be {@code null} only if the AST is malformed.
     */
    public AstNode getBody() {
<span class='uc' id='L187' title='3|3|3 - Total: 3'>        return body;
</span>    }

    /**
     * Sets function body, and sets its parent to this node.
     * Also sets the encoded source bounds based on the body bounds.
     * Assumes the function node absolute position has already been set,
     * and the body node's absolute position and length are set.<p>
     *
     * @param body function body.  Its parent is set to this node, and its
     * position is updated to be relative to this node.
     *
     * @throws IllegalArgumentException if body is {@code null}
     */
    public void setBody(AstNode body) {
<span class='uc' id='L202' title='3|3|3 - Total: 3'>        assertNotNull(body);
</span><span class='uc' id='L203' title='3|3|3 - Total: 3'>        this.body = body;
</span><span class='uc' id='L204' title='2|2|2 - Total: 2'>        if (Boolean.TRUE.equals(body.getProp(Node.EXPRESSION_CLOSURE_PROP))) {
</span><span class='uc' id='L205' title='3|3|3 - Total: 3'>            setIsExpressionClosure(true);
</span>        }
<span class='uc' id='L207' title='6|6|6 - Total: 6'>        int absEnd = body.getPosition() + body.getLength();
</span><span class='uc' id='L208' title='3|3|3 - Total: 3'>        body.setParent(this);
</span><span class='uc' id='L209' title='6|6|6 - Total: 6'>        this.setLength(absEnd - this.position);
</span><span class='uc' id='L210' title='5|5|5 - Total: 5'>        setEncodedSourceBounds(this.position, absEnd);
</span><span class='uc' id='L211' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns left paren position, -1 if missing
     */
    public int getLp() {
<span class='uc' id='L217' title='3|3|3 - Total: 3'>        return lp;
</span>    }

    /**
     * Sets left paren position
     */
    public void setLp(int lp) {
<span class='uc' id='L224' title='3|3|3 - Total: 3'>        this.lp = lp;
</span><span class='uc' id='L225' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns right paren position, -1 if missing
     */
    public int getRp() {
<span class='nc' id='L231' title='0|0|0 - Total: 3'>        return rp;
</span>    }

    /**
     * Sets right paren position
     */
    public void setRp(int rp) {
<span class='uc' id='L238' title='3|3|3 - Total: 3'>        this.rp = rp;
</span><span class='uc' id='L239' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Sets both paren positions
     */
    public void setParens(int lp, int rp) {
<span class='uc' id='L245' title='3|3|3 - Total: 3'>        this.lp = lp;
</span><span class='uc' id='L246' title='3|3|3 - Total: 3'>        this.rp = rp;
</span><span class='uc' id='L247' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns whether this is a 1.8 function closure
     */
    public boolean isExpressionClosure() {
<span class='uc' id='L253' title='3|3|3 - Total: 3'>        return isExpressionClosure;
</span>    }

    /**
     * Sets whether this is a 1.8 function closure
     */
    public void setIsExpressionClosure(boolean isExpressionClosure) {
<span class='uc' id='L260' title='3|3|3 - Total: 3'>        this.isExpressionClosure = isExpressionClosure;
</span><span class='uc' id='L261' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Return true if this function requires an Ecma-262 Activation object.
     * The Activation object is implemented by
     * {@link org.mozilla.javascript.NativeCall}, and is fairly expensive
     * to create, so when possible, the interpreter attempts to use a plain
     * call frame instead.
     *
     * @return true if this function needs activation.  It could be needed
     * if there is a lexical closure, or in a number of other situations.
     */
    public boolean requiresActivation() {
<span class='uc' id='L274' title='3|3|3 - Total: 3'>        return needsActivation;
</span>    }

    public void setRequiresActivation() {
<span class='uc' id='L278' title='3|3|3 - Total: 3'>        needsActivation = true;
</span><span class='uc' id='L279' title='1|1|1 - Total: 1'>    }
</span>
    public boolean isGenerator() {
<span class='uc' id='L282' title='3|3|3 - Total: 3'>      return isGenerator;
</span>    }

    public void setIsGenerator() {
<span class='uc' id='L286' title='3|3|3 - Total: 3'>        isGenerator = true;
</span><span class='uc' id='L287' title='1|1|1 - Total: 1'>    }
</span>
    public void addResumptionPoint(Node target) {
<span class='uc' id='L290' title='2|2|2 - Total: 2'>        if (generatorResumePoints == null)
</span><span class='uc' id='L291' title='5|5|5 - Total: 5'>            generatorResumePoints = new ArrayList<Node>();
</span><span class='uc' id='L292' title='5|5|5 - Total: 5'>        generatorResumePoints.add(target);
</span><span class='uc' id='L293' title='1|1|1 - Total: 1'>    }
</span>
    public List<Node> getResumptionPoints() {
<span class='uc' id='L296' title='3|3|3 - Total: 3'>        return generatorResumePoints;
</span>    }

    public Map<Node,int[]> getLiveLocals() {
<span class='uc' id='L300' title='3|3|3 - Total: 3'>        return liveLocals;
</span>    }

    public void addLiveLocals(Node node, int[] locals) {
<span class='uc' id='L304' title='2|2|2 - Total: 2'>        if (liveLocals == null)
</span><span class='uc' id='L305' title='5|5|5 - Total: 5'>            liveLocals = new HashMap<Node,int[]>();
</span><span class='uc' id='L306' title='6|6|6 - Total: 6'>        liveLocals.put(node, locals);
</span><span class='uc' id='L307' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public int addFunction(FunctionNode fnNode) {
<span class='uc' id='L311' title='4|4|4 - Total: 4'>        int result = super.addFunction(fnNode);
</span><span class='upc' id='L312' title='1|1|1 - Total: 2'>        if (getFunctionCount() > 0) {
</span><span class='uc' id='L313' title='3|3|3 - Total: 3'>            needsActivation = true;
</span>        }
<span class='uc' id='L315' title='2|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Returns the function type (statement, expr, statement expr)
     */
    public int getFunctionType() {
<span class='uc' id='L322' title='3|3|3 - Total: 3'>        return functionType;
</span>    }

    public void setFunctionType(int type) {
<span class='uc' id='L326' title='3|3|3 - Total: 3'>        functionType = type;
</span><span class='uc' id='L327' title='1|1|1 - Total: 1'>    }
</span>
    public boolean isMethod() {
<span class='upc' id='L330' title='5|5|5 - Total: 6'>        return functionForm == Form.GETTER || functionForm == Form.SETTER || functionForm == Form.METHOD;
</span>    }

    public boolean isGetterMethod() {
<span class='nc' id='L334' title='0|0|0 - Total: 2'>        return functionForm == Form.GETTER;
</span>    }

    public boolean isSetterMethod() {
<span class='nc' id='L338' title='0|0|0 - Total: 2'>        return functionForm == Form.SETTER;
</span>    }

    public boolean isNormalMethod() {
<span class='nc' id='L342' title='0|0|0 - Total: 2'>        return functionForm == Form.METHOD;
</span>    }

    public void setFunctionIsGetterMethod() {
<span class='uc' id='L346' title='3|3|3 - Total: 3'>        functionForm = Form.GETTER;
</span><span class='uc' id='L347' title='1|1|1 - Total: 1'>    }
</span>
    public void setFunctionIsSetterMethod() {
<span class='uc' id='L350' title='3|3|3 - Total: 3'>        functionForm = Form.SETTER;
</span><span class='uc' id='L351' title='1|1|1 - Total: 1'>    }
</span>
    public void setFunctionIsNormalMethod() {
<span class='uc' id='L354' title='3|3|3 - Total: 3'>        functionForm = Form.METHOD;
</span><span class='uc' id='L355' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Rhino supports a nonstandard Ecma extension that allows you to
     * say, for instance, function a.b.c(arg1, arg) {...}, and it will
     * be rewritten at codegen time to:  a.b.c = function(arg1, arg2) {...}
     * If we detect an expression other than a simple Name in the position
     * where a function name was expected, we record that expression here.
     * <p>
     * This extension is only available by setting the CompilerEnv option
     * "isAllowMemberExprAsFunctionName" in the Parser.
     */
    public void setMemberExprNode(AstNode node) {
<span class='nc' id='L368' title='0|0|0 - Total: 3'>        memberExprNode = node;
</span><span class='nc' id='L369' title='0|0|0 - Total: 2'>        if (node != null)
</span><span class='nc' id='L370' title='0|0|0 - Total: 3'>            node.setParent(this);
</span><span class='nc' id='L371' title='0|0|0 - Total: 1'>    }
</span>
    public AstNode getMemberExprNode() {
<span class='uc' id='L374' title='3|3|3 - Total: 3'>        return memberExprNode;
</span>    }

    @Override
    public String toSource(int depth) {
<span class='uc' id='L379' title='4|4|4 - Total: 4'>        StringBuilder sb = new StringBuilder();
</span><span class='uc' id='L380' title='2|2|2 - Total: 2'>        boolean isArrow = functionType == ARROW_FUNCTION;
</span><span class='uc' id='L381' title='2|2|2 - Total: 2'>        if (!isMethod()) {
</span><span class='uc' id='L382' title='6|6|6 - Total: 6'>            sb.append(makeIndent(depth));
</span><span class='uc' id='L383' title='2|2|2 - Total: 2'>            if (!isArrow) {
</span><span class='uc' id='L384' title='4|4|4 - Total: 4'>                sb.append("function");
</span>            }
        }
<span class='uc' id='L387' title='2|2|2 - Total: 2'>        if (functionName != null) {
</span><span class='uc' id='L388' title='4|4|4 - Total: 4'>            sb.append(" ");
</span><span class='uc' id='L389' title='7|7|7 - Total: 7'>            sb.append(functionName.toSource(0));
</span>        }
<span class='uc' id='L391' title='2|2|2 - Total: 2'>        if (params == null) {
</span><span class='uc' id='L392' title='5|5|5 - Total: 5'>            sb.append("() ");
</span><span class='upc' id='L393' title='3|3|3 - Total: 4'>        } else if (isArrow && lp == -1) {
</span>            // no paren
<span class='uc' id='L395' title='5|5|5 - Total: 5'>            printList(params, sb);
</span><span class='uc' id='L396' title='5|5|5 - Total: 5'>            sb.append(" ");
</span>        } else {
<span class='uc' id='L398' title='4|4|4 - Total: 4'>            sb.append("(");
</span><span class='uc' id='L399' title='5|5|5 - Total: 5'>            printList(params, sb);
</span><span class='uc' id='L400' title='4|4|4 - Total: 4'>            sb.append(") ");
</span>        }
<span class='uc' id='L402' title='2|2|2 - Total: 2'>        if (isArrow) {
</span><span class='uc' id='L403' title='4|4|4 - Total: 4'>            sb.append("=> ");
</span>        }
<span class='uc' id='L405' title='2|2|2 - Total: 2'>        if (isExpressionClosure) {
</span><span class='uc' id='L406' title='3|3|3 - Total: 3'>            AstNode body = getBody();
</span><span class='upc' id='L407' title='1|1|1 - Total: 2'>            if (body.getLastChild() instanceof ReturnStatement) {
</span>                // omit "return" keyword, just print the expression
<span class='uc' id='L409' title='5|5|5 - Total: 5'>                body = ((ReturnStatement) body.getLastChild()).getReturnValue();
</span><span class='uc' id='L410' title='6|6|6 - Total: 6'>                sb.append(body.toSource(0));
</span><span class='uc' id='L411' title='2|2|2 - Total: 2'>                if (functionType == FUNCTION_STATEMENT) {
</span><span class='uc' id='L412' title='5|5|5 - Total: 5'>                    sb.append(";");
</span>                }
            } else {
                // should never happen
<span class='nc' id='L416' title='0|0|0 - Total: 4'>                sb.append(" ");
</span><span class='nc' id='L417' title='0|0|0 - Total: 6'>                sb.append(body.toSource(0));
</span>            }
<span class='uc' id='L419' title='1|1|1 - Total: 1'>        } else {
</span><span class='uc' id='L420' title='8|8|8 - Total: 8'>            sb.append(getBody().toSource(depth).trim());
</span>        }
<span class='uc' id='L422' title='4|4|4 - Total: 4'>        if (functionType == FUNCTION_STATEMENT || isMethod()) {
</span><span class='uc' id='L423' title='4|4|4 - Total: 4'>            sb.append("\n");
</span>        }
<span class='uc' id='L425' title='3|3|3 - Total: 3'>        return sb.toString();
</span>    }

    /**
     * Visits this node, the function name node if supplied,
     * the parameters, and the body.  If there is a member-expr node,
     * it is visited last.
     */
    @Override
    public void visit(NodeVisitor v) {
<span class='upc' id='L435' title='1|1|1 - Total: 2'>        if (v.visit(this)) {
</span><span class='nc' id='L436' title='0|0|0 - Total: 2'>            if (functionName != null) {
</span><span class='nc' id='L437' title='0|0|0 - Total: 4'>                functionName.visit(v);
</span>            }
<span class='nc' id='L439' title='0|0|0 - Total: 2'>            for (AstNode param : getParams()) {
</span><span class='nc' id='L440' title='0|0|0 - Total: 3'>                param.visit(v);
</span><span class='nc' id='L441' title='0|0|0 - Total: 1'>            }
</span><span class='nc' id='L442' title='0|0|0 - Total: 4'>            getBody().visit(v);
</span><span class='nc' id='L443' title='0|0|0 - Total: 2'>            if (!isExpressionClosure) {
</span><span class='nc' id='L444' title='0|0|0 - Total: 2'>                if (memberExprNode != null) {
</span><span class='nc' id='L445' title='0|0|0 - Total: 4'>                    memberExprNode.visit(v);
</span>                }
            }
        }
<span class='uc' id='L449' title='1|1|1 - Total: 1'>    }
</span>}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>