<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.ast.AstNode.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.ast.AstNode.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.ast;

import org.mozilla.javascript.Kit;
import org.mozilla.javascript.Node;
import org.mozilla.javascript.Token;

import java.io.Serializable;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Base class for AST node types.  The goal of the AST is to represent the
 * physical source code, to make it useful for code-processing tools such
 * as IDEs or pretty-printers.  The parser must not rewrite the parse tree
 * when producing this representation. <p>
 *
 * The {@code AstNode} hierarchy sits atop the older {@link Node} class,
 * which was designed for code generation.  The {@code Node} class is a
 * flexible, weakly-typed class suitable for creating and rewriting code
 * trees, but using it requires you to remember the exact ordering of the
 * child nodes, which are kept in a linked list.  The {@code AstNode}
 * hierarchy is a strongly-typed facade with named accessors for children
 * and common properties, but under the hood it's still using a linked list
 * of child nodes.  It isn't a very good idea to use the child list directly
 * unless you know exactly what you're doing.</p>
 *
 * Note that {@code AstNode} records additional information, including
 * the node's position, length, and parent node.  Also, some {@code AstNode}
 * subclasses record some of their child nodes in instance members, since
 * they are not needed for code generation.  In a nutshell, only the code
 * generator should be mixing and matching {@code AstNode} and {@code Node}
 * objects.<p>
 *
 * All offset fields in all subclasses of AstNode are relative to their
 * parent.  For things like paren, bracket and keyword positions, the
 * position is relative to the current node.  The node start position is
 * relative to the parent node. <p>
 *
 * During the actual parsing, node positions are absolute; adding the node to
 * its parent fixes up the offsets to be relative.  By the time you see the AST
 * (e.g. using the {@code Visitor} interface), the offsets are relative. <p>
 *
 * {@code AstNode} objects have property lists accessible via the
 * {@link #getProp} and {@link #putProp} methods.  The property lists are
 * integer-keyed with arbitrary {@code Object} values.  For the most part the
 * parser generating the AST avoids using properties, preferring fields for
 * elements that are always set.  Property lists are intended for user-defined
 * annotations to the tree.  The Rhino code generator acts as a client and
 * uses node properties extensively.  You are welcome to use the property-list
 * API for anything your client needs.<p>
 *
 * This hierarchy does not have separate branches for expressions and
 * statements, as the distinction in JavaScript is not as clear-cut as in
 * Java or C++. <p>
 */
public abstract class AstNode extends Node implements Comparable<AstNode> {

<span class='uc' id='L66' title='3|3|3 - Total: 3'>    protected int position = -1;
</span><span class='uc' id='L67' title='3|3|3 - Total: 3'>    protected int length = 1;
</span>    protected AstNode parent;

<span class='uc' id='L70' title='4|4|4 - Total: 4'>    private static Map<Integer,String> operatorNames =
</span>            new HashMap<Integer,String>();

    static {
<span class='uc' id='L74' title='6|6|6 - Total: 6'>        operatorNames.put(Token.IN, "in");
</span><span class='uc' id='L75' title='6|6|6 - Total: 6'>        operatorNames.put(Token.TYPEOF, "typeof");
</span><span class='uc' id='L76' title='6|6|6 - Total: 6'>        operatorNames.put(Token.INSTANCEOF, "instanceof");
</span><span class='uc' id='L77' title='6|6|6 - Total: 6'>        operatorNames.put(Token.DELPROP, "delete");
</span><span class='uc' id='L78' title='6|6|6 - Total: 6'>        operatorNames.put(Token.COMMA, ",");
</span><span class='uc' id='L79' title='6|6|6 - Total: 6'>        operatorNames.put(Token.COLON, ":");
</span><span class='uc' id='L80' title='6|6|6 - Total: 6'>        operatorNames.put(Token.OR, "||");
</span><span class='uc' id='L81' title='6|6|6 - Total: 6'>        operatorNames.put(Token.AND, "&&");
</span><span class='uc' id='L82' title='6|6|6 - Total: 6'>        operatorNames.put(Token.INC, "++");
</span><span class='uc' id='L83' title='6|6|6 - Total: 6'>        operatorNames.put(Token.DEC, "--");
</span><span class='uc' id='L84' title='6|6|6 - Total: 6'>        operatorNames.put(Token.BITOR, "|");
</span><span class='uc' id='L85' title='6|6|6 - Total: 6'>        operatorNames.put(Token.BITXOR, "^");
</span><span class='uc' id='L86' title='6|6|6 - Total: 6'>        operatorNames.put(Token.BITAND, "&");
</span><span class='uc' id='L87' title='6|6|6 - Total: 6'>        operatorNames.put(Token.EQ, "==");
</span><span class='uc' id='L88' title='6|6|6 - Total: 6'>        operatorNames.put(Token.NE, "!=");
</span><span class='uc' id='L89' title='6|6|6 - Total: 6'>        operatorNames.put(Token.LT, "<");
</span><span class='uc' id='L90' title='6|6|6 - Total: 6'>        operatorNames.put(Token.GT, ">");
</span><span class='uc' id='L91' title='6|6|6 - Total: 6'>        operatorNames.put(Token.LE, "<=");
</span><span class='uc' id='L92' title='6|6|6 - Total: 6'>        operatorNames.put(Token.GE, ">=");
</span><span class='uc' id='L93' title='6|6|6 - Total: 6'>        operatorNames.put(Token.LSH, "<<");
</span><span class='uc' id='L94' title='6|6|6 - Total: 6'>        operatorNames.put(Token.RSH, ">>");
</span><span class='uc' id='L95' title='6|6|6 - Total: 6'>        operatorNames.put(Token.URSH, ">>>");
</span><span class='uc' id='L96' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ADD, "+");
</span><span class='uc' id='L97' title='6|6|6 - Total: 6'>        operatorNames.put(Token.SUB, "-");
</span><span class='uc' id='L98' title='6|6|6 - Total: 6'>        operatorNames.put(Token.MUL, "*");
</span><span class='uc' id='L99' title='6|6|6 - Total: 6'>        operatorNames.put(Token.DIV, "/");
</span><span class='uc' id='L100' title='6|6|6 - Total: 6'>        operatorNames.put(Token.MOD, "%");
</span><span class='uc' id='L101' title='6|6|6 - Total: 6'>        operatorNames.put(Token.NOT, "!");
</span><span class='uc' id='L102' title='6|6|6 - Total: 6'>        operatorNames.put(Token.BITNOT, "~");
</span><span class='uc' id='L103' title='6|6|6 - Total: 6'>        operatorNames.put(Token.POS, "+");
</span><span class='uc' id='L104' title='6|6|6 - Total: 6'>        operatorNames.put(Token.NEG, "-");
</span><span class='uc' id='L105' title='6|6|6 - Total: 6'>        operatorNames.put(Token.SHEQ, "===");
</span><span class='uc' id='L106' title='6|6|6 - Total: 6'>        operatorNames.put(Token.SHNE, "!==");
</span><span class='uc' id='L107' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN, "=");
</span><span class='uc' id='L108' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_BITOR, "|=");
</span><span class='uc' id='L109' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_BITAND, "&=");
</span><span class='uc' id='L110' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_LSH, "<<=");
</span><span class='uc' id='L111' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_RSH, ">>=");
</span><span class='uc' id='L112' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_URSH, ">>>=");
</span><span class='uc' id='L113' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_ADD, "+=");
</span><span class='uc' id='L114' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_SUB, "-=");
</span><span class='uc' id='L115' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_MUL, "*=");
</span><span class='uc' id='L116' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_DIV, "/=");
</span><span class='uc' id='L117' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_MOD, "%=");
</span><span class='uc' id='L118' title='6|6|6 - Total: 6'>        operatorNames.put(Token.ASSIGN_BITXOR, "^=");
</span><span class='uc' id='L119' title='6|6|6 - Total: 6'>        operatorNames.put(Token.VOID, "void");
</span><span class='uc' id='L120' title='1|1|1 - Total: 1'>    }
</span>
    public static class PositionComparator implements Comparator<AstNode>, Serializable {
        private static final long serialVersionUID = 1L;

        /**
         * Sorts nodes by (relative) start position.  The start positions are
         * relative to their parent, so this comparator is only meaningful for
         * comparing siblings.
         */
        public int compare(AstNode n1, AstNode n2) {
            return n1.position - n2.position;
        }
    }

    public AstNode() {
<span class='uc' id='L136' title='3|3|3 - Total: 3'>        super(Token.ERROR);
</span><span class='uc' id='L137' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Constructs a new AstNode
     * @param pos the start position
     */
    public AstNode(int pos) {
<span class='uc' id='L144' title='2|2|2 - Total: 2'>        this();
</span><span class='uc' id='L145' title='3|3|3 - Total: 3'>        position = pos;
</span><span class='uc' id='L146' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Constructs a new AstNode
     * @param pos the start position
     * @param len the number of characters spanned by the node in the source
     * text
     */
    public AstNode(int pos, int len) {
<span class='uc' id='L155' title='2|2|2 - Total: 2'>        this();
</span><span class='uc' id='L156' title='3|3|3 - Total: 3'>        position = pos;
</span><span class='uc' id='L157' title='3|3|3 - Total: 3'>        length = len;
</span><span class='uc' id='L158' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns relative position in parent
     */
    public int getPosition() {
<span class='uc' id='L164' title='3|3|3 - Total: 3'>        return position;
</span>    }

    /**
     * Sets relative position in parent
     */
    public void setPosition(int position) {
<span class='uc' id='L171' title='3|3|3 - Total: 3'>        this.position = position;
</span><span class='uc' id='L172' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns the absolute document position of the node.
     * Computes it by adding the node's relative position
     * to the relative positions of all its parents.
     */
    public int getAbsolutePosition() {
<span class='uc' id='L180' title='3|3|3 - Total: 3'>        int pos = position;
</span><span class='uc' id='L181' title='3|3|3 - Total: 3'>        AstNode parent = this.parent;
</span><span class='uc' id='L182' title='2|2|2 - Total: 2'>        while (parent != null) {
</span><span class='uc' id='L183' title='5|5|5 - Total: 5'>            pos += parent.getPosition();
</span><span class='uc' id='L184' title='4|4|4 - Total: 4'>            parent = parent.getParent();
</span>        }
<span class='uc' id='L186' title='2|2|2 - Total: 2'>        return pos;
</span>    }

    /**
     * Returns node length
     */
    public int getLength() {
<span class='uc' id='L193' title='3|3|3 - Total: 3'>        return length;
</span>    }

    /**
     * Sets node length
     */
    public void setLength(int length) {
<span class='uc' id='L200' title='3|3|3 - Total: 3'>        this.length = length;
</span><span class='uc' id='L201' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Sets the node start and end positions.
     * Computes the length as ({@code end} - {@code position}).
     */
    public void setBounds(int position, int end) {
<span class='uc' id='L208' title='3|3|3 - Total: 3'>        setPosition(position);
</span><span class='uc' id='L209' title='5|5|5 - Total: 5'>        setLength(end - position);
</span><span class='uc' id='L210' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Make this node's position relative to a parent.
     * Typically only used by the parser when constructing the node.
     * @param parentPosition the absolute parent position; the
     * current node position is assumed to be absolute and is
     * decremented by parentPosition.
     */
    public void setRelative(int parentPosition) {
<span class='uc' id='L220' title='6|6|6 - Total: 6'>        this.position -= parentPosition;
</span><span class='uc' id='L221' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns the node parent, or {@code null} if it has none
     */
    public AstNode getParent() {
<span class='uc' id='L227' title='3|3|3 - Total: 3'>        return parent;
</span>    }

    /**
     * Sets the node parent.  This method automatically adjusts the
     * current node's start position to be relative to the new parent.
     * @param parent the new parent. Can be {@code null}.
     */
    public void setParent(AstNode parent) {
<span class='uc' id='L236' title='2|2|2 - Total: 2'>        if (parent == this.parent) {
</span><span class='uc' id='L237' title='1|1|1 - Total: 1'>            return;
</span>        }

        // Convert position back to absolute.
<span class='uc' id='L241' title='2|2|2 - Total: 2'>        if (this.parent != null) {
</span><span class='uc' id='L242' title='6|6|6 - Total: 6'>            setRelative(-this.parent.getPosition());
</span>        }

<span class='uc' id='L245' title='3|3|3 - Total: 3'>        this.parent = parent;
</span><span class='upc' id='L246' title='1|1|1 - Total: 2'>        if (parent != null) {
</span><span class='uc' id='L247' title='4|4|4 - Total: 4'>            setRelative(parent.getPosition());
</span>        }
<span class='uc' id='L249' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Adds a child or function to the end of the block.
     * Sets the parent of the child to this node, and fixes up
     * the start position of the child to be relative to this node.
     * Sets the length of this node to include the new child.
     * @param kid the child
     * @throws IllegalArgumentException if kid is {@code null}
     */
    public void addChild(AstNode kid) {
<span class='uc' id='L260' title='3|3|3 - Total: 3'>        assertNotNull(kid);
</span><span class='uc' id='L261' title='6|6|6 - Total: 6'>        int end = kid.getPosition() + kid.getLength();
</span><span class='uc' id='L262' title='6|6|6 - Total: 6'>        setLength(end - this.getPosition());
</span><span class='uc' id='L263' title='3|3|3 - Total: 3'>        addChildToBack(kid);
</span><span class='uc' id='L264' title='3|3|3 - Total: 3'>        kid.setParent(this);
</span><span class='uc' id='L265' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns the root of the tree containing this node.
     * @return the {@link AstRoot} at the root of this node's parent
     * chain, or {@code null} if the topmost parent is not an {@code AstRoot}.
     */
    public AstRoot getAstRoot() {
<span class='nc' id='L273' title='0|0|0 - Total: 2'>        AstNode parent = this;  // this node could be the AstRoot
</span><span class='nc' id='L274' title='0|0|0 - Total: 4'>        while (parent != null && !(parent instanceof AstRoot)) {
</span><span class='nc' id='L275' title='0|0|0 - Total: 4'>            parent = parent.getParent();
</span>        }
<span class='nc' id='L277' title='0|0|0 - Total: 3'>        return (AstRoot)parent;
</span>    }

    /**
     * Emits source code for this node.  Callee is responsible for calling this
     * function recursively on children, incrementing indent as appropriate.<p>
     *
     * Note: if the parser was in error-recovery mode, some AST nodes may have
     * {@code null} children that are expected to be non-{@code null}
     * when no errors are present.  In this situation, the behavior of the
     * {@code toSource} method is undefined: {@code toSource}
     * implementations may assume that the AST node is error-free, since it is
     * intended to be invoked only at runtime after a successful parse.<p>
     *
     * @param depth the current recursion depth, typically beginning at 0
     * when called on the root node.
     */
    public abstract String toSource(int depth);

    /**
     * Prints the source indented to depth 0.
     */
    public String toSource() {
<span class='uc' id='L300' title='4|4|4 - Total: 4'>        return this.toSource(0);
</span>    }

    /**
     * Constructs an indentation string.
     * @param indent the number of indentation steps
     */
    public String makeIndent(int indent) {
<span class='uc' id='L308' title='4|4|4 - Total: 4'>        StringBuilder sb = new StringBuilder();
</span><span class='uc' id='L309' title='2|2|2 - Total: 2'>        for (int i = 0; i < indent; i++) {
</span><span class='uc' id='L310' title='4|4|4 - Total: 4'>            sb.append("  ");
</span>        }
<span class='uc' id='L312' title='3|3|3 - Total: 3'>        return sb.toString();
</span>    }

    /**
     * Returns a short, descriptive name for the node, such as
     * "ArrayComprehension".
     */
    public String shortName() {
<span class='nc' id='L320' title='0|0|0 - Total: 4'>        String classname = getClass().getName();
</span><span class='nc' id='L321' title='0|0|0 - Total: 4'>        int last = classname.lastIndexOf(".");
</span><span class='nc' id='L322' title='0|0|0 - Total: 6'>        return classname.substring(last + 1);
</span>    }

    /**
     * Returns the string name for this operator.
     * @param op the token type, e.g. {@link Token#ADD} or {@link Token#TYPEOF}
     * @return the source operator string, such as "+" or "typeof"
     */
    public static String operatorToString(int op) {
<span class='uc' id='L331' title='6|6|6 - Total: 6'>        String result = operatorNames.get(op);
</span><span class='upc' id='L332' title='1|1|1 - Total: 2'>        if (result == null)
</span><span class='nc' id='L333' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException("Invalid operator: " + op);
</span><span class='uc' id='L334' title='2|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Visits this node and its children in an arbitrary order. <p>
     *
     * It's up to each node subclass to decide the order for processing
     * its children.  The subclass also decides (and should document)
     * which child nodes are not passed to the {@code NodeVisitor}.
     * For instance, nodes representing keywords like {@code each} or
     * {@code in} may not be passed to the visitor object.  The visitor
     * can simply query the current node for these children if desired.<p>
     *
     * Generally speaking, the order will be deterministic; the order is
     * whatever order is decided by each child node.  Normally child nodes
     * will try to visit their children in lexical order, but there may
     * be exceptions to this rule.<p>
     *
     * @param visitor the object to call with this node and its children
     */
    public abstract void visit(NodeVisitor visitor);

    // subclasses with potential side effects should override this
    @Override
    public boolean hasSideEffects()
    {
<span class='upc' id='L360' title='1|1|1 - Total: 2'>        switch (getType()) {
</span>          case Token.ASSIGN:
          case Token.ASSIGN_ADD:
          case Token.ASSIGN_BITAND:
          case Token.ASSIGN_BITOR:
          case Token.ASSIGN_BITXOR:
          case Token.ASSIGN_DIV:
          case Token.ASSIGN_LSH:
          case Token.ASSIGN_MOD:
          case Token.ASSIGN_MUL:
          case Token.ASSIGN_RSH:
          case Token.ASSIGN_SUB:
          case Token.ASSIGN_URSH:
          case Token.BLOCK:
          case Token.BREAK:
          case Token.CALL:
          case Token.CATCH:
          case Token.CATCH_SCOPE:
          case Token.CONST:
          case Token.CONTINUE:
          case Token.DEC:
          case Token.DELPROP:
          case Token.DEL_REF:
          case Token.DO:
          case Token.ELSE:
          case Token.ENTERWITH:
          case Token.ERROR:         // Avoid cascaded error messages
          case Token.EXPORT:
          case Token.EXPR_RESULT:
          case Token.FINALLY:
          case Token.FUNCTION:
          case Token.FOR:
          case Token.GOTO:
          case Token.IF:
          case Token.IFEQ:
          case Token.IFNE:
          case Token.IMPORT:
          case Token.INC:
          case Token.JSR:
          case Token.LABEL:
          case Token.LEAVEWITH:
          case Token.LET:
          case Token.LETEXPR:
          case Token.LOCAL_BLOCK:
          case Token.LOOP:
          case Token.NEW:
          case Token.REF_CALL:
          case Token.RETHROW:
          case Token.RETURN:
          case Token.RETURN_RESULT:
          case Token.SEMI:
          case Token.SETELEM:
          case Token.SETELEM_OP:
          case Token.SETNAME:
          case Token.SETPROP:
          case Token.SETPROP_OP:
          case Token.SETVAR:
          case Token.SET_REF:
          case Token.SET_REF_OP:
          case Token.SWITCH:
          case Token.TARGET:
          case Token.THROW:
          case Token.TRY:
          case Token.VAR:
          case Token.WHILE:
          case Token.WITH:
          case Token.WITHEXPR:
          case Token.YIELD:
<span class='uc' id='L428' title='2|2|2 - Total: 2'>            return true;
</span>
          default:
<span class='nc' id='L431' title='0|0|0 - Total: 2'>            return false;
</span>        }
    }

    /**
     * Bounces an IllegalArgumentException up if arg is {@code null}.
     * @param arg any method argument
     * @throws IllegalArgumentException if the argument is {@code null}
     */
    protected void assertNotNull(Object arg) {
<span class='upc' id='L441' title='1|1|1 - Total: 2'>        if (arg == null)
</span><span class='nc' id='L442' title='0|0|0 - Total: 5'>            throw new IllegalArgumentException("arg cannot be null");
</span><span class='uc' id='L443' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Prints a comma-separated item list into a {@link StringBuilder}.
     * @param items a list to print
     * @param sb a {@link StringBuilder} into which to print
     */
    protected <T extends AstNode> void printList(List<T> items,
                                                 StringBuilder sb) {
<span class='uc' id='L452' title='3|3|3 - Total: 3'>        int max = items.size();
</span><span class='uc' id='L453' title='2|2|2 - Total: 2'>        int count = 0;
</span><span class='uc' id='L454' title='2|2|2 - Total: 2'>        for (AstNode item : items) {
</span><span class='uc' id='L455' title='6|6|6 - Total: 6'>            sb.append(item.toSource(0));
</span><span class='uc' id='L456' title='2|2|2 - Total: 2'>            if (count++ < max-1) {
</span><span class='uc' id='L457' title='5|5|5 - Total: 5'>                sb.append(", ");
</span><span class='uc' id='L458' title='2|2|2 - Total: 2'>            } else if (item instanceof EmptyExpression) {
</span><span class='uc' id='L459' title='4|4|4 - Total: 4'>                sb.append(",");
</span>            }
<span class='uc' id='L461' title='1|1|1 - Total: 1'>        }
</span><span class='uc' id='L462' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * @see Kit#codeBug
     */
    public static RuntimeException codeBug()
        throws RuntimeException
    {
<span class='nc' id='L470' title='0|0|0 - Total: 2'>        throw Kit.codeBug();
</span>    }

    // TODO(stevey):  think of a way to have polymorphic toString
    // methods while keeping the ability to use Node.toString for
    // dumping the IR with Token.printTrees.  Most likely:  change
    // Node.toString to be Node.dumpTree and change callers to use that.
    // For now, need original toString, to compare output to old Rhino's.

//     @Override
//     public String toString() {
//         return this.getClass().getName() + ": " +
//             Token.typeToName(getType());
//     }

    /**
     * Returns the innermost enclosing function, or {@code null} if not in a
     * function.  Begins the search with this node's parent.
     * @return the {@link FunctionNode} enclosing this node, else {@code null}
     */
    public FunctionNode getEnclosingFunction() {
<span class='nc' id='L491' title='0|0|0 - Total: 3'>        AstNode parent = this.getParent();
</span><span class='nc' id='L492' title='0|0|0 - Total: 4'>        while (parent != null && !(parent instanceof FunctionNode)) {
</span><span class='nc' id='L493' title='0|0|0 - Total: 4'>            parent = parent.getParent();
</span>        }
<span class='nc' id='L495' title='0|0|0 - Total: 3'>        return (FunctionNode)parent;
</span>    }

    /**
     * Returns the innermost enclosing {@link Scope} node, or {@code null}
     * if we're not nested in a scope.  Begins the search with this node's parent.
     * Note that this is not the same as the defining scope for a {@link Name}.
     *
     * @return the {@link Scope} enclosing this node, else {@code null}
     */
    public Scope getEnclosingScope() {
<span class='nc' id='L506' title='0|0|0 - Total: 3'>        AstNode parent = this.getParent();
</span><span class='nc' id='L507' title='0|0|0 - Total: 4'>        while (parent != null && !(parent instanceof Scope)) {
</span><span class='nc' id='L508' title='0|0|0 - Total: 4'>            parent = parent.getParent();
</span>        }
<span class='nc' id='L510' title='0|0|0 - Total: 3'>        return (Scope)parent;
</span>    }

    /**
     * Permits AST nodes to be sorted based on start position and length.
     * This makes it easy to sort Comment and Error nodes into a set of
     * other AST nodes:  just put them all into a {@link java.util.SortedSet},
     * for instance.
     * @param other another node
     * @return -1 if this node's start position is less than {@code other}'s
     * start position.  If tied, -1 if this node's length is less than
     * {@code other}'s length.  If the lengths are equal, sorts abitrarily
     * on hashcode unless the nodes are the same per {@link #equals}.
     */
    public int compareTo(AstNode other) {
<span class='nc' id='L525' title='0|0|0 - Total: 2'>        if (this.equals(other)) return 0;
</span><span class='nc' id='L526' title='0|0|0 - Total: 3'>        int abs1 = this.getAbsolutePosition();
</span><span class='nc' id='L527' title='0|0|0 - Total: 3'>        int abs2 = other.getAbsolutePosition();
</span><span class='nc' id='L528' title='0|0|0 - Total: 2'>        if (abs1 < abs2) return -1;
</span><span class='nc' id='L529' title='0|0|0 - Total: 2'>        if (abs2 < abs1) return 1;
</span><span class='nc' id='L530' title='0|0|0 - Total: 3'>        int len1 = this.getLength();
</span><span class='nc' id='L531' title='0|0|0 - Total: 3'>        int len2 = other.getLength();
</span><span class='nc' id='L532' title='0|0|0 - Total: 2'>        if (len1 < len2) return -1;
</span><span class='nc' id='L533' title='0|0|0 - Total: 2'>        if (len2 < len1) return 1;
</span><span class='nc' id='L534' title='0|0|0 - Total: 6'>        return this.hashCode() - other.hashCode();
</span>    }

    /**
     * Returns the depth of this node.  The root is depth 0, its
     * children are depth 1, and so on.
     * @return the node depth in the tree
     */
    public int depth() {
<span class='nc' id='L543' title='0|0|0 - Total: 2'>        return parent == null ? 0 : 1 + parent.depth();
</span>    }

    protected static class DebugPrintVisitor implements NodeVisitor {
        private StringBuilder buffer;
        private static final int DEBUG_INDENT = 2;
        public DebugPrintVisitor(StringBuilder buf) {
            buffer = buf;
        }
        @Override
        public String toString() {
            return buffer.toString();
        }
        private String makeIndent(int depth) {
            StringBuilder sb = new StringBuilder(DEBUG_INDENT * depth);
            for (int i = 0; i < (DEBUG_INDENT * depth); i++) {
                sb.append(" ");
            }
            return sb.toString();
        }
        public boolean visit(AstNode node) {
            int tt = node.getType();
            String name = Token.typeToName(tt);
            buffer.append(node.getAbsolutePosition()).append("\t");
            buffer.append(makeIndent(node.depth()));
            buffer.append(name).append(" ");
            buffer.append(node.getPosition()).append(" ");
            buffer.append(node.getLength());
            if (tt == Token.NAME) {
                buffer.append(" ").append(((Name)node).getIdentifier());
            }
            buffer.append("\n");
            return true;  // process kids
        }
    }

    /**
     * Return the line number recorded for this node.
     * If no line number was recorded, searches the parent chain.
     * @return the nearest line number, or -1 if none was found
     */
    @Override
    public int getLineno() {
<span class='uc' id='L586' title='2|2|2 - Total: 2'>        if (lineno != -1)
</span><span class='uc' id='L587' title='3|3|3 - Total: 3'>            return lineno;
</span><span class='uc' id='L588' title='2|2|2 - Total: 2'>        if (parent != null)
</span><span class='uc' id='L589' title='4|4|4 - Total: 4'>            return parent.getLineno();
</span><span class='uc' id='L590' title='2|2|2 - Total: 2'>        return -1;
</span>    }

    /**
     * Returns a debugging representation of the parse tree
     * starting at this node.
     * @return a very verbose indented printout of the tree.
     * The format of each line is:  abs-pos  name position length [identifier]
     */
    public String debugPrint() {
<span class='nc' id='L600' title='0|0|0 - Total: 8'>        DebugPrintVisitor dpv = new DebugPrintVisitor(new StringBuilder(1000));
</span><span class='nc' id='L601' title='0|0|0 - Total: 3'>        visit(dpv);
</span><span class='nc' id='L602' title='0|0|0 - Total: 3'>        return dpv.toString();
</span>    }
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>