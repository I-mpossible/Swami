<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.regexp.NativeRegExp.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.regexp.NativeRegExp.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.regexp;

import java.io.Serializable;

import org.mozilla.javascript.Context;
import org.mozilla.javascript.Function;
import org.mozilla.javascript.IdFunctionObject;
import org.mozilla.javascript.IdScriptableObject;
import org.mozilla.javascript.Kit;
import org.mozilla.javascript.ScriptRuntime;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ScriptableObject;
import org.mozilla.javascript.TopLevel;
import org.mozilla.javascript.Undefined;

/**
 * This class implements the RegExp native object.
 *
 * Revision History:
 * Implementation in C by Brendan Eich
 * Initial port to Java by Norris Boyd from jsregexp.c version 1.36
 * Merged up to version 1.38, which included Unicode support.
 * Merged bug fixes in version 1.39.
 * Merged JSFUN13_BRANCH changes up to 1.32.2.13
 *
 * @author Brendan Eich
 * @author Norris Boyd
 */



<span class='upc' id='L38' title='1|1|1 - Total: 2'>public class NativeRegExp extends IdScriptableObject implements Function
</span>{
    static final long serialVersionUID = 4965263491464903264L;

<span class='uc' id='L42' title='5|5|5 - Total: 5'>    private static final Object REGEXP_TAG = new Object();
</span>
    public static final int JSREG_GLOB = 0x1;       // 'g' flag: global
    public static final int JSREG_FOLD = 0x2;       // 'i' flag: fold
    public static final int JSREG_MULTILINE = 0x4;  // 'm' flag: multiline

    //type of match to perform
    public static final int TEST = 0;
    public static final int MATCH = 1;
    public static final int PREFIX = 2;

    private static final boolean debug = false;

    private static final byte REOP_SIMPLE_START  = 1;  /* start of 'simple opcodes' */
    private static final byte REOP_EMPTY         = 1;  /* match rest of input against rest of r.e. */
    private static final byte REOP_BOL           = 2;  /* beginning of input (or line if multiline) */
    private static final byte REOP_EOL           = 3;  /* end of input (or line if multiline) */
    private static final byte REOP_WBDRY         = 4;  /* match "" at word boundary */
    private static final byte REOP_WNONBDRY      = 5;  /* match "" at word non-boundary */
    private static final byte REOP_DOT           = 6;  /* stands for any character */
    private static final byte REOP_DIGIT         = 7;  /* match a digit char: [0-9] */
    private static final byte REOP_NONDIGIT      = 8;  /* match a non-digit char: [^0-9] */
    private static final byte REOP_ALNUM         = 9;  /* match an alphanumeric char: [0-9a-z_A-Z] */
    private static final byte REOP_NONALNUM      = 10; /* match a non-alphanumeric char: [^0-9a-z_A-Z] */
    private static final byte REOP_SPACE         = 11; /* match a whitespace char */
    private static final byte REOP_NONSPACE      = 12; /* match a non-whitespace char */
    private static final byte REOP_BACKREF       = 13; /* back-reference (e.g., \1) to a parenthetical */
    private static final byte REOP_FLAT          = 14; /* match a flat string */
    private static final byte REOP_FLAT1         = 15; /* match a single char */
    private static final byte REOP_FLATi         = 16; /* case-independent REOP_FLAT */
    private static final byte REOP_FLAT1i        = 17; /* case-independent REOP_FLAT1 */
    private static final byte REOP_UCFLAT1       = 18; /* single Unicode char */
    private static final byte REOP_UCFLAT1i      = 19; /* case-independent REOP_UCFLAT1 */
//    private static final byte REOP_UCFLAT        = 20; /* flat Unicode string; len immediate counts chars */
//    private static final byte REOP_UCFLATi       = 21; /* case-independent REOP_UCFLAT */
    private static final byte REOP_CLASS         = 22; /* character class with index */
    private static final byte REOP_NCLASS        = 23; /* negated character class with index */
    private static final byte REOP_SIMPLE_END    = 23; /* end of 'simple opcodes' */
    private static final byte REOP_QUANT         = 25; /* quantified atom: atom{1,2} */
    private static final byte REOP_STAR          = 26; /* zero or more occurrences of kid */
    private static final byte REOP_PLUS          = 27; /* one or more occurrences of kid */
    private static final byte REOP_OPT           = 28; /* optional subexpression in kid */
    private static final byte REOP_LPAREN        = 29; /* left paren bytecode: kid is u.num'th sub-regexp */
    private static final byte REOP_RPAREN        = 30; /* right paren bytecode */
    private static final byte REOP_ALT           = 31; /* alternative subexpressions in kid and next */
    private static final byte REOP_JUMP          = 32; /* for deoptimized closure loops */
//    private static final byte REOP_DOTSTAR       = 33; /* optimize .* to use a single opcode */
//    private static final byte REOP_ANCHOR        = 34; /* like .* but skips left context to unanchored r.e. */
//    private static final byte REOP_EOLONLY       = 35; /* $ not preceded by any pattern */
//    private static final byte REOP_BACKREFi      = 37; /* case-independent REOP_BACKREF */
//    private static final byte REOP_LPARENNON     = 40; /* non-capturing version of REOP_LPAREN */
    private static final byte REOP_ASSERT        = 41; /* zero width positive lookahead assertion */
    private static final byte REOP_ASSERT_NOT    = 42; /* zero width negative lookahead assertion */
    private static final byte REOP_ASSERTTEST    = 43; /* sentinel at end of assertion child */
    private static final byte REOP_ASSERTNOTTEST = 44; /* sentinel at end of !assertion child */
    private static final byte REOP_MINIMALSTAR   = 45; /* non-greedy version of * */
    private static final byte REOP_MINIMALPLUS   = 46; /* non-greedy version of + */
    private static final byte REOP_MINIMALOPT    = 47; /* non-greedy version of ? */
    private static final byte REOP_MINIMALQUANT  = 48; /* non-greedy version of {} */
    private static final byte REOP_ENDCHILD      = 49; /* sentinel at end of quantifier child */
    private static final byte REOP_REPEAT        = 51; /* directs execution of greedy quantifier */
    private static final byte REOP_MINIMALREPEAT = 52; /* directs execution of non-greedy quantifier */
    private static final byte REOP_ALTPREREQ     = 53; /* prerequisite for ALT, either of two chars */
    private static final byte REOP_ALTPREREQi    = 54; /* case-independent REOP_ALTPREREQ */
    private static final byte REOP_ALTPREREQ2    = 55; /* prerequisite for ALT, a char or a class */
//    private static final byte REOP_ENDALT        = 56; /* end of final alternate */
    private static final byte REOP_END           = 57;

    private static final int ANCHOR_BOL = -2;


    public static void init(Context cx, Scriptable scope, boolean sealed)
    {

<span class='uc' id='L116' title='4|4|4 - Total: 4'>        NativeRegExp proto = new NativeRegExp();
</span><span class='uc' id='L117' title='7|7|7 - Total: 7'>        proto.re = compileRE(cx, "", null, false);
</span><span class='uc' id='L118' title='3|3|3 - Total: 3'>        proto.activatePrototypeMap(MAX_PROTOTYPE_ID);
</span><span class='uc' id='L119' title='3|3|3 - Total: 3'>        proto.setParentScope(scope);
</span><span class='uc' id='L120' title='4|4|4 - Total: 4'>        proto.setPrototype(getObjectPrototype(scope));
</span>
<span class='uc' id='L122' title='4|4|4 - Total: 4'>        NativeRegExpCtor ctor = new NativeRegExpCtor();
</span>        // Bug #324006: ECMA-262 15.10.6.1 says "The initial value of
        // RegExp.prototype.constructor is the builtin RegExp constructor."
<span class='uc' id='L125' title='5|5|5 - Total: 5'>        proto.defineProperty("constructor", ctor, ScriptableObject.DONTENUM);
</span>
<span class='uc' id='L127' title='3|3|3 - Total: 3'>        ScriptRuntime.setFunctionProtoAndParent(ctor, scope);
</span>
<span class='uc' id='L129' title='3|3|3 - Total: 3'>        ctor.setImmunePrototypeProperty(proto);
</span>
<span class='uc' id='L131' title='2|2|2 - Total: 2'>        if (sealed) {
</span><span class='uc' id='L132' title='2|2|2 - Total: 2'>            proto.sealObject();
</span><span class='uc' id='L133' title='2|2|2 - Total: 2'>            ctor.sealObject();
</span>        }

<span class='uc' id='L136' title='5|5|5 - Total: 5'>        defineProperty(scope, "RegExp", ctor, ScriptableObject.DONTENUM);
</span><span class='uc' id='L137' title='1|1|1 - Total: 1'>    }
</span>
    NativeRegExp(Scriptable scope, RECompiled regexpCompiled)
<span class='uc' id='L140' title='2|2|2 - Total: 2'>    {
</span><span class='uc' id='L141' title='3|3|3 - Total: 3'>        this.re = regexpCompiled;
</span><span class='uc' id='L142' title='4|4|4 - Total: 4'>        this.lastIndex = 0d;
</span><span class='uc' id='L143' title='4|4|4 - Total: 4'>        ScriptRuntime.setBuiltinProtoAndParent(this, scope, TopLevel.Builtins.RegExp);
</span><span class='uc' id='L144' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public String getClassName()
    {
<span class='uc' id='L149' title='2|2|2 - Total: 2'>        return "RegExp";
</span>    }

    /**
     * Gets the value to be returned by the typeof operator called on this object.
     * @see org.mozilla.javascript.ScriptableObject#getTypeOf()
     * @return "object"
     */
    @Override
    public String getTypeOf()
    {
<span class='uc' id='L160' title='2|2|2 - Total: 2'>        return "object";
</span>    }

    public Object call(Context cx, Scriptable scope, Scriptable thisObj,
                       Object[] args)
    {
<span class='uc' id='L166' title='7|7|7 - Total: 7'>        return execSub(cx, scope, args, MATCH);
</span>    }

    public Scriptable construct(Context cx, Scriptable scope, Object[] args)
    {
<span class='nc' id='L171' title='0|0|0 - Total: 8'>        return (Scriptable)execSub(cx, scope, args, MATCH);
</span>    }

    Scriptable compile(Context cx, Scriptable scope, Object[] args)
    {
<span class='uc' id='L176' title='4|4|4 - Total: 4'>        if (args.length > 0 && args[0] instanceof NativeRegExp) {
</span><span class='uc' id='L177' title='4|4|4 - Total: 4'>            if (args.length > 1 && args[1] != Undefined.instance) {
</span>                // report error
<span class='uc' id='L179' title='3|3|3 - Total: 3'>                throw ScriptRuntime.typeError0("msg.bad.regexp.compile");
</span>            }
<span class='uc' id='L181' title='5|5|5 - Total: 5'>            NativeRegExp thatObj = (NativeRegExp) args[0];
</span><span class='uc' id='L182' title='4|4|4 - Total: 4'>            this.re = thatObj.re;
</span><span class='uc' id='L183' title='4|4|4 - Total: 4'>            this.lastIndex = thatObj.lastIndex;
</span><span class='uc' id='L184' title='2|2|2 - Total: 2'>            return this;
</span>        }
<span class='uc' id='L186' title='4|4|4 - Total: 4'>        String s = args.length == 0 || args[0] instanceof Undefined ? "" : escapeRegExp(args[0]);
</span><span class='uc' id='L187' title='4|4|4 - Total: 4'>        String global = args.length > 1 && args[1] != Undefined.instance
</span><span class='uc' id='L188' title='4|4|4 - Total: 4'>            ? ScriptRuntime.toString(args[1])
</span>            : null;
<span class='uc' id='L190' title='7|7|7 - Total: 7'>        this.re = compileRE(cx, s, global, false);
</span><span class='uc' id='L191' title='4|4|4 - Total: 4'>        this.lastIndex = 0d;
</span><span class='uc' id='L192' title='2|2|2 - Total: 2'>        return this;
</span>    }

    @Override
    public String toString()
    {
<span class='uc' id='L198' title='4|4|4 - Total: 4'>        StringBuilder buf = new StringBuilder();
</span><span class='uc' id='L199' title='4|4|4 - Total: 4'>        buf.append('/');
</span><span class='uc' id='L200' title='2|2|2 - Total: 2'>        if (re.source.length != 0) {
</span><span class='uc' id='L201' title='7|7|7 - Total: 7'>            buf.append(re.source);
</span>        } else {
            // See bugzilla 226045
<span class='uc' id='L204' title='4|4|4 - Total: 4'>            buf.append("(?:)");
</span>        }
<span class='uc' id='L206' title='4|4|4 - Total: 4'>        buf.append('/');
</span><span class='uc' id='L207' title='2|2|2 - Total: 2'>        if ((re.flags & JSREG_GLOB) != 0)
</span><span class='uc' id='L208' title='4|4|4 - Total: 4'>            buf.append('g');
</span><span class='uc' id='L209' title='2|2|2 - Total: 2'>        if ((re.flags & JSREG_FOLD) != 0)
</span><span class='uc' id='L210' title='4|4|4 - Total: 4'>            buf.append('i');
</span><span class='uc' id='L211' title='2|2|2 - Total: 2'>        if ((re.flags & JSREG_MULTILINE) != 0)
</span><span class='uc' id='L212' title='4|4|4 - Total: 4'>            buf.append('m');
</span><span class='uc' id='L213' title='3|3|3 - Total: 3'>        return buf.toString();
</span>    }

<span class='uc' id='L216' title='3|3|3 - Total: 3'>    NativeRegExp() {  }
</span>
    private static RegExpImpl getImpl(Context cx)
    {
<span class='uc' id='L220' title='4|4|4 - Total: 4'>        return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);
</span>    }

    private static String escapeRegExp(Object src) {
<span class='uc' id='L224' title='3|3|3 - Total: 3'>        String s = ScriptRuntime.toString(src);
</span>        // Escape any naked slashes in regexp source, see bug #510265
<span class='uc' id='L226' title='2|2|2 - Total: 2'>        StringBuilder sb = null; // instantiated only if necessary
</span><span class='uc' id='L227' title='2|2|2 - Total: 2'>        int start = 0;
</span><span class='uc' id='L228' title='4|4|4 - Total: 4'>        int slash = s.indexOf('/');
</span><span class='uc' id='L229' title='2|2|2 - Total: 2'>        while (slash > -1) {
</span><span class='uc' id='L230' title='4|4|4 - Total: 4'>            if (slash == start || s.charAt(slash - 1) != '\\') {
</span><span class='uc' id='L231' title='2|2|2 - Total: 2'>                if (sb == null) {
</span><span class='uc' id='L232' title='4|4|4 - Total: 4'>                    sb = new StringBuilder();
</span>                }
<span class='uc' id='L234' title='6|6|6 - Total: 6'>                sb.append(s, start, slash);
</span><span class='uc' id='L235' title='4|4|4 - Total: 4'>                sb.append("\\/");
</span><span class='uc' id='L236' title='4|4|4 - Total: 4'>                start = slash + 1;
</span>            }
<span class='uc' id='L238' title='8|8|8 - Total: 8'>            slash = s.indexOf('/', slash + 1);
</span>        }
<span class='uc' id='L240' title='2|2|2 - Total: 2'>        if (sb != null) {
</span><span class='uc' id='L241' title='7|7|7 - Total: 7'>            sb.append(s, start, s.length());
</span><span class='uc' id='L242' title='3|3|3 - Total: 3'>            s = sb.toString();
</span>        }
<span class='uc' id='L244' title='2|2|2 - Total: 2'>        return s;
</span>    }

    private Object execSub(Context cx, Scriptable scopeObj,
                           Object[] args, int matchType)
    {
<span class='uc' id='L250' title='3|3|3 - Total: 3'>        RegExpImpl reImpl = getImpl(cx);
</span>        String str;
<span class='uc' id='L252' title='2|2|2 - Total: 2'>        if (args.length == 0) {
</span><span class='uc' id='L253' title='3|3|3 - Total: 3'>            str = reImpl.input;
</span><span class='upc' id='L254' title='1|1|1 - Total: 2'>            if (str == null) {
</span><span class='nc' id='L255' title='0|0|0 - Total: 4'>                str = ScriptRuntime.toString(Undefined.instance);
</span>            }
        } else {
<span class='uc' id='L258' title='5|5|5 - Total: 5'>            str = ScriptRuntime.toString(args[0]);
</span>        }
<span class='uc' id='L260' title='2|2|2 - Total: 2'>        double d = 0;
</span><span class='uc' id='L261' title='2|2|2 - Total: 2'>        if ((re.flags & JSREG_GLOB) != 0) {
</span><span class='uc' id='L262' title='4|4|4 - Total: 4'>            d = ScriptRuntime.toInteger(lastIndex);
</span>        }

        Object rval;
<span class='uc' id='L266' title='4|4|4 - Total: 4'>        if (d < 0 || str.length() < d) {
</span><span class='uc' id='L267' title='4|4|4 - Total: 4'>            lastIndex = 0d;
</span><span class='uc' id='L268' title='3|3|3 - Total: 3'>            rval = null;
</span>        }
        else {
<span class='uc' id='L271' title='8|8|8 - Total: 8'>            int indexp[] = { (int)d };
</span><span class='uc' id='L272' title='9|9|9 - Total: 9'>            rval = executeRegExp(cx, scopeObj, reImpl, str, indexp, matchType);
</span><span class='uc' id='L273' title='2|2|2 - Total: 2'>            if ((re.flags & JSREG_GLOB) != 0) {
</span><span class='upc' id='L274' title='3|3|3 - Total: 4'>                lastIndex = (rval == null || rval == Undefined.instance)
</span>                            ? 0d : (double)indexp[0];
            }
        }
<span class='uc' id='L278' title='2|2|2 - Total: 2'>        return rval;
</span>    }

    static RECompiled compileRE(Context cx, String str, String global, boolean flat)
    {
<span class='uc' id='L283' title='5|5|5 - Total: 5'>        RECompiled regexp = new RECompiled(str);
</span><span class='uc' id='L284' title='3|3|3 - Total: 3'>        int length = str.length();
</span><span class='uc' id='L285' title='2|2|2 - Total: 2'>        int flags = 0;
</span><span class='uc' id='L286' title='2|2|2 - Total: 2'>        if (global != null) {
</span><span class='uc' id='L287' title='2|2|2 - Total: 2'>            for (int i = 0; i < global.length(); i++) {
</span><span class='uc' id='L288' title='4|4|4 - Total: 4'>                char c = global.charAt(i);
</span><span class='uc' id='L289' title='2|2|2 - Total: 2'>                int f = 0;
</span><span class='uc' id='L290' title='2|2|2 - Total: 2'>                if (c == 'g') {
</span><span class='uc' id='L291' title='3|3|3 - Total: 3'>                    f = JSREG_GLOB;
</span><span class='uc' id='L292' title='2|2|2 - Total: 2'>                } else if (c == 'i') {
</span><span class='uc' id='L293' title='3|3|3 - Total: 3'>                    f = JSREG_FOLD;
</span><span class='upc' id='L294' title='1|1|1 - Total: 2'>                } else if (c == 'm') {
</span><span class='uc' id='L295' title='3|3|3 - Total: 3'>                    f = JSREG_MULTILINE;
</span>                } else {
<span class='nc' id='L297' title='0|0|0 - Total: 4'>                    reportError("msg.invalid.re.flag", String.valueOf(c));
</span>                }
<span class='upc' id='L299' title='1|1|1 - Total: 2'>                if ((flags & f) != 0) {
</span><span class='nc' id='L300' title='0|0|0 - Total: 4'>                    reportError("msg.invalid.re.flag", String.valueOf(c));
</span>                }
<span class='uc' id='L302' title='4|4|4 - Total: 4'>                flags |= f;
</span>            }
        }
<span class='uc' id='L305' title='3|3|3 - Total: 3'>        regexp.flags = flags;
</span>
<span class='uc' id='L307' title='9|9|9 - Total: 9'>        CompilerState state = new CompilerState(cx, regexp.source, length, flags);
</span><span class='upc' id='L308' title='3|3|3 - Total: 4'>        if (flat && length > 0) {
</span>            if (debug) {
                System.out.println("flat = \"" + str + "\"");
            }
<span class='uc' id='L312' title='6|6|6 - Total: 6'>            state.result = new RENode(REOP_FLAT);
</span><span class='uc' id='L313' title='7|7|7 - Total: 7'>            state.result.chr = state.cpbegin[0];
</span><span class='uc' id='L314' title='4|4|4 - Total: 4'>            state.result.length = length;
</span><span class='uc' id='L315' title='4|4|4 - Total: 4'>            state.result.flatIndex = 0;
</span><span class='uc' id='L316' title='7|7|7 - Total: 7'>            state.progLength += 5;
</span>        } else {
<span class='upc' id='L318' title='1|1|1 - Total: 2'>            if (!parseDisjunction(state))
</span><span class='nc' id='L319' title='0|0|0 - Total: 2'>                return null;
</span>            // Need to reparse if pattern contains invalid backreferences:
            // "Note: if the number of left parentheses is less than the number
            // specified in \#, the \# is taken as an octal escape"
<span class='uc' id='L323' title='2|2|2 - Total: 2'>            if (state.maxBackReference > state.parenCount) {
</span><span class='uc' id='L324' title='9|9|9 - Total: 9'>                state = new CompilerState(cx, regexp.source, length, flags);
</span><span class='uc' id='L325' title='4|4|4 - Total: 4'>                state.backReferenceLimit = state.parenCount;
</span><span class='upc' id='L326' title='1|1|1 - Total: 2'>                if (!parseDisjunction(state))
</span><span class='nc' id='L327' title='0|0|0 - Total: 2'>                    return null;
</span>            }
        }

<span class='uc' id='L331' title='7|7|7 - Total: 7'>        regexp.program = new byte[state.progLength + 1];
</span><span class='uc' id='L332' title='2|2|2 - Total: 2'>        if (state.classCount != 0) {
</span><span class='uc' id='L333' title='5|5|5 - Total: 5'>            regexp.classList = new RECharSet[state.classCount];
</span><span class='uc' id='L334' title='4|4|4 - Total: 4'>            regexp.classCount = state.classCount;
</span>        }
<span class='uc' id='L336' title='7|7|7 - Total: 7'>        int endPC = emitREBytecode(state, regexp, 0, state.result);
</span><span class='uc' id='L337' title='6|6|6 - Total: 6'>        regexp.program[endPC++] = REOP_END;
</span>
        if (debug) {
            System.out.println("Prog. length = " + endPC);
            for (int i = 0; i < endPC; i++) {
                System.out.print(regexp.program[i]);
                if (i < (endPC - 1)) System.out.print(", ");
            }
            System.out.println();
        }
<span class='uc' id='L347' title='4|4|4 - Total: 4'>        regexp.parenCount = state.parenCount;
</span>
        // If re starts with literal, init anchorCh accordingly
<span class='upc' id='L350' title='5|5|5 - Total: 6'>        switch (regexp.program[0]) {
</span>            case REOP_UCFLAT1:
            case REOP_UCFLAT1i:
<span class='nc' id='L353' title='0|0|0 - Total: 7'>                regexp.anchorCh = (char)getIndex(regexp.program, 1);
</span><span class='nc' id='L354' title='0|0|0 - Total: 1'>                break;
</span>            case REOP_FLAT1:
            case REOP_FLAT1i:
<span class='uc' id='L357' title='9|9|9 - Total: 9'>                regexp.anchorCh = (char)(regexp.program[1] & 0xFF);
</span><span class='uc' id='L358' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_FLAT:
            case REOP_FLATi:
<span class='uc' id='L361' title='5|5|5 - Total: 5'>                int k = getIndex(regexp.program, 1);
</span><span class='uc' id='L362' title='6|6|6 - Total: 6'>                regexp.anchorCh = regexp.source[k];
</span><span class='uc' id='L363' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_BOL:
<span class='uc' id='L365' title='3|3|3 - Total: 3'>                regexp.anchorCh = ANCHOR_BOL;
</span><span class='uc' id='L366' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_ALT:
<span class='uc' id='L368' title='3|3|3 - Total: 3'>                RENode n = state.result;
</span><span class='upc' id='L369' title='3|3|3 - Total: 4'>                if (n.kid.op == REOP_BOL && n.kid2.op == REOP_BOL) {
</span><span class='nc' id='L370' title='0|0|0 - Total: 3'>                    regexp.anchorCh = ANCHOR_BOL;
</span>                }
                break;
        }

        if (debug) {
            if (regexp.anchorCh >= 0) {
                System.out.println("Anchor ch = '" + (char)regexp.anchorCh + "'");
            }
        }
<span class='uc' id='L380' title='2|2|2 - Total: 2'>        return regexp;
</span>    }

    static boolean isDigit(char c)
    {
<span class='uc' id='L385' title='4|4|4 - Total: 4'>        return '0' <= c && c <= '9';
</span>    }

    private static boolean isWord(char c)
    {
<span class='uc' id='L390' title='12|12|12 - Total: 12'>        return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || isDigit(c) || c == '_';
</span>    }

    private static boolean isControlLetter(char c)
    {
<span class='upc' id='L395' title='6|6|6 - Total: 8'>        return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
</span>    }

    private static boolean isLineTerm(char c)
    {
<span class='uc' id='L400' title='3|3|3 - Total: 3'>        return ScriptRuntime.isJSLineTerminator(c);
</span>    }

    private static boolean isREWhiteSpace(int c)
    {
<span class='uc' id='L405' title='3|3|3 - Total: 3'>        return ScriptRuntime.isJSWhitespaceOrLineTerminator(c);
</span>    }

    /*
     *
     * 1. If IgnoreCase is false, return ch.
     * 2. Let u be ch converted to upper case as if by calling
     *    String.prototype.toUpperCase on the one-character string ch.
     * 3. If u does not consist of a single character, return ch.
     * 4. Let cu be u's character.
     * 5. If ch's code point value is greater than or equal to decimal 128 and cu's
     *    code point value is less than decimal 128, then return ch.
     * 6. Return cu.
     */
    private static char upcase(char ch)
    {
<span class='uc' id='L421' title='2|2|2 - Total: 2'>        if (ch < 128) {
</span><span class='uc' id='L422' title='4|4|4 - Total: 4'>            if ('a' <= ch && ch <= 'z') {
</span><span class='uc' id='L423' title='5|5|5 - Total: 5'>                return (char)(ch + ('A' - 'a'));
</span>            }
<span class='uc' id='L425' title='2|2|2 - Total: 2'>            return ch;
</span>        }
<span class='uc' id='L427' title='3|3|3 - Total: 3'>        char cu = Character.toUpperCase(ch);
</span><span class='uc' id='L428' title='2|2|2 - Total: 2'>        return (cu < 128) ? ch : cu;
</span>    }

    private static char downcase(char ch)
    {
<span class='uc' id='L433' title='2|2|2 - Total: 2'>        if (ch < 128) {
</span><span class='uc' id='L434' title='4|4|4 - Total: 4'>            if ('A' <= ch && ch <= 'Z') {
</span><span class='uc' id='L435' title='5|5|5 - Total: 5'>                return (char)(ch + ('a' - 'A'));
</span>            }
<span class='uc' id='L437' title='2|2|2 - Total: 2'>            return ch;
</span>        }
<span class='uc' id='L439' title='3|3|3 - Total: 3'>        char cl = Character.toLowerCase(ch);
</span><span class='uc' id='L440' title='2|2|2 - Total: 2'>        return (cl < 128) ? ch : cl;
</span>
    }

/*
 * Validates and converts hex ascii value.
 */
    private static int toASCIIHexDigit(int c)
    {
<span class='upc' id='L449' title='1|1|1 - Total: 2'>        if (c < '0')
</span><span class='nc' id='L450' title='0|0|0 - Total: 2'>            return -1;
</span><span class='uc' id='L451' title='2|2|2 - Total: 2'>        if (c <= '9') {
</span><span class='uc' id='L452' title='4|4|4 - Total: 4'>            return c - '0';
</span>        }
<span class='uc' id='L454' title='4|4|4 - Total: 4'>        c |= 0x20;
</span><span class='upc' id='L455' title='2|2|2 - Total: 4'>        if ('a' <= c && c <= 'f') {
</span><span class='uc' id='L456' title='6|6|6 - Total: 6'>            return c - 'a' + 10;
</span>        }
<span class='nc' id='L458' title='0|0|0 - Total: 2'>        return -1;
</span>    }

/*
 * Top-down regular expression grammar, based closely on Perl4.
 *
 *  regexp:     altern                  A regular expression is one or more
 *              altern '|' regexp       alternatives separated by vertical bar.
 */
    private static boolean parseDisjunction(CompilerState state)
    {
<span class='upc' id='L469' title='1|1|1 - Total: 2'>        if (!parseAlternative(state))
</span><span class='nc' id='L470' title='0|0|0 - Total: 2'>            return false;
</span><span class='uc' id='L471' title='3|3|3 - Total: 3'>        char[] source = state.cpbegin;
</span><span class='uc' id='L472' title='3|3|3 - Total: 3'>        int index = state.cp;
</span><span class='uc' id='L473' title='4|4|4 - Total: 4'>        if (index != source.length && source[index] == '|') {
</span>            RENode result;
<span class='uc' id='L475' title='6|6|6 - Total: 6'>            ++state.cp;
</span><span class='uc' id='L476' title='5|5|5 - Total: 5'>            result = new RENode(REOP_ALT);
</span><span class='uc' id='L477' title='4|4|4 - Total: 4'>            result.kid = state.result;
</span><span class='upc' id='L478' title='1|1|1 - Total: 2'>            if (!parseDisjunction(state))
</span><span class='nc' id='L479' title='0|0|0 - Total: 2'>                return false;
</span><span class='uc' id='L480' title='4|4|4 - Total: 4'>            result.kid2 = state.result;
</span><span class='uc' id='L481' title='3|3|3 - Total: 3'>            state.result = result;
</span>            /*
             * Look at both alternates to see if there's a FLAT or a CLASS at
             * the start of each. If so, use a prerequisite match.
             */
<span class='uc' id='L486' title='4|4|4 - Total: 4'>            if (result.kid.op == REOP_FLAT && result.kid2.op == REOP_FLAT) {
</span><span class='uc' id='L487' title='2|2|2 - Total: 2'>                result.op = (state.flags & JSREG_FOLD) == 0 ?
</span>                        REOP_ALTPREREQ : REOP_ALTPREREQi;
<span class='uc' id='L489' title='5|5|5 - Total: 5'>                result.chr = result.kid.chr;
</span><span class='uc' id='L490' title='5|5|5 - Total: 5'>                result.index = result.kid2.chr;
</span>                /* ALTPREREQ, uch1, uch2, <next>, ...,
                                            JUMP, <end> ... JUMP, <end> */
<span class='uc' id='L493' title='7|7|7 - Total: 7'>                state.progLength += 13;
</span><span class='upc' id='L494' title='6|6|6 - Total: 8'>            } else if (result.kid.op == REOP_CLASS && result.kid.index < 256
</span>                    && result.kid2.op == REOP_FLAT && (state.flags & JSREG_FOLD) == 0) {
<span class='uc' id='L496' title='3|3|3 - Total: 3'>                result.op = REOP_ALTPREREQ2;
</span><span class='uc' id='L497' title='5|5|5 - Total: 5'>                result.chr = result.kid2.chr;
</span><span class='uc' id='L498' title='5|5|5 - Total: 5'>                result.index = result.kid.index;
</span>                /* ALTPREREQ2, uch1, uch2, <next>, ...,
                                            JUMP, <end> ... JUMP, <end> */
<span class='uc' id='L501' title='7|7|7 - Total: 7'>                state.progLength += 13;
</span><span class='upc' id='L502' title='6|6|6 - Total: 8'>            } else if (result.kid.op == REOP_FLAT && result.kid2.op == REOP_CLASS
</span>                    && result.kid2.index < 256 && (state.flags & JSREG_FOLD) == 0) {
<span class='uc' id='L504' title='3|3|3 - Total: 3'>                result.op = REOP_ALTPREREQ2;
</span><span class='uc' id='L505' title='5|5|5 - Total: 5'>                result.chr = result.kid.chr;
</span><span class='uc' id='L506' title='5|5|5 - Total: 5'>                result.index = result.kid2.index;
</span>                /* ALTPREREQ2, uch1, uch2, <next>, ...,
                                            JUMP, <end> ... JUMP, <end> */
<span class='uc' id='L509' title='7|7|7 - Total: 7'>                state.progLength += 13;
</span>            } else {
                /* ALT, <next>, ..., JUMP, <end> ... JUMP, <end> */
<span class='uc' id='L512' title='6|6|6 - Total: 6'>                state.progLength += 9;
</span>            }
        }
<span class='uc' id='L515' title='2|2|2 - Total: 2'>        return true;
</span>    }

/*
 *  altern:     item                    An alternative is one or more items,
 *              item altern             concatenated together.
 */
    private static boolean parseAlternative(CompilerState state)
    {
<span class='uc' id='L524' title='2|2|2 - Total: 2'>        RENode headTerm = null;
</span><span class='uc' id='L525' title='2|2|2 - Total: 2'>        RENode tailTerm = null;
</span><span class='uc' id='L526' title='3|3|3 - Total: 3'>        char[] source = state.cpbegin;
</span>        while (true) {
<span class='uc' id='L528' title='8|8|8 - Total: 8'>            if (state.cp == state.cpend || source[state.cp] == '|'
</span>                || (state.parenNesting != 0 && source[state.cp] == ')'))
            {
<span class='uc' id='L531' title='2|2|2 - Total: 2'>                if (headTerm == null) {
</span><span class='uc' id='L532' title='7|7|7 - Total: 7'>                    state.result = new RENode(REOP_EMPTY);
</span>                }
                else
<span class='uc' id='L535' title='3|3|3 - Total: 3'>                    state.result = headTerm;
</span><span class='uc' id='L536' title='2|2|2 - Total: 2'>                return true;
</span>            }
<span class='upc' id='L538' title='1|1|1 - Total: 2'>            if (!parseTerm(state))
</span><span class='nc' id='L539' title='0|0|0 - Total: 2'>                return false;
</span><span class='uc' id='L540' title='2|2|2 - Total: 2'>            if (headTerm == null) {
</span><span class='uc' id='L541' title='3|3|3 - Total: 3'>                headTerm = state.result;
</span><span class='uc' id='L542' title='3|3|3 - Total: 3'>                tailTerm = headTerm;
</span>            }
            else
<span class='uc' id='L545' title='4|4|4 - Total: 4'>                tailTerm.next = state.result;
</span><span class='uc' id='L546' title='2|2|2 - Total: 2'>            while (tailTerm.next != null) tailTerm = tailTerm.next;
</span>        }
    }

    /* calculate the total size of the bitmap required for a class expression */
    private static boolean
    calculateBitmapSize(CompilerState state, RENode target, char[] src,
                        int index, int end)
    {
<span class='uc' id='L555' title='2|2|2 - Total: 2'>        char rangeStart = 0;
</span>        char c;
        int n;
        int nDigits;
        int i;
<span class='uc' id='L560' title='2|2|2 - Total: 2'>        int max = 0;
</span><span class='uc' id='L561' title='2|2|2 - Total: 2'>        boolean inRange = false;
</span>
<span class='uc' id='L563' title='3|3|3 - Total: 3'>        target.bmsize = 0;
</span><span class='uc' id='L564' title='3|3|3 - Total: 3'>        target.sense = true;
</span>
<span class='uc' id='L566' title='2|2|2 - Total: 2'>        if (index == end)
</span><span class='uc' id='L567' title='2|2|2 - Total: 2'>            return true;
</span>
<span class='uc' id='L569' title='2|2|2 - Total: 2'>        if (src[index] == '^') {
</span><span class='uc' id='L570' title='1|1|1 - Total: 1'>            ++index;
</span><span class='uc' id='L571' title='3|3|3 - Total: 3'>            target.sense = false;
</span>        }

<span class='uc' id='L574' title='2|2|2 - Total: 2'>        while (index != end) {
</span><span class='uc' id='L575' title='2|2|2 - Total: 2'>            int localMax = 0;
</span><span class='uc' id='L576' title='2|2|2 - Total: 2'>            nDigits = 2;
</span><span class='uc' id='L577' title='2|2|2 - Total: 2'>            switch (src[index]) {
</span>            case '\\':
<span class='uc' id='L579' title='1|1|1 - Total: 1'>                ++index;
</span><span class='uc' id='L580' title='5|5|5 - Total: 5'>                c = src[index++];
</span><span class='upc' id='L581' title='11|11|11 - Total: 13'>                switch (c) {
</span>                case 'b':
<span class='uc' id='L583' title='2|2|2 - Total: 2'>                    localMax = 0x8;
</span><span class='uc' id='L584' title='1|1|1 - Total: 1'>                    break;
</span>                case 'f':
<span class='nc' id='L586' title='0|0|0 - Total: 2'>                    localMax = 0xC;
</span><span class='nc' id='L587' title='0|0|0 - Total: 1'>                    break;
</span>                case 'n':
<span class='uc' id='L589' title='2|2|2 - Total: 2'>                    localMax = 0xA;
</span><span class='uc' id='L590' title='1|1|1 - Total: 1'>                    break;
</span>                case 'r':
<span class='uc' id='L592' title='2|2|2 - Total: 2'>                    localMax = 0xD;
</span><span class='uc' id='L593' title='1|1|1 - Total: 1'>                    break;
</span>                case 't':
<span class='uc' id='L595' title='2|2|2 - Total: 2'>                    localMax = 0x9;
</span><span class='uc' id='L596' title='1|1|1 - Total: 1'>                    break;
</span>                case 'v':
<span class='nc' id='L598' title='0|0|0 - Total: 2'>                    localMax = 0xB;
</span><span class='nc' id='L599' title='0|0|0 - Total: 1'>                    break;
</span>                case 'c':
<span class='upc' id='L601' title='2|2|2 - Total: 4'>                    if ((index < end) && isControlLetter(src[index]))
</span><span class='uc' id='L602' title='9|9|9 - Total: 9'>                        localMax = (char)(src[index++] & 0x1F);
</span>                    else
<span class='nc' id='L604' title='0|0|0 - Total: 1'>                        --index;
</span><span class='uc' id='L605' title='2|2|2 - Total: 2'>                        localMax = '\\';
</span><span class='uc' id='L606' title='1|1|1 - Total: 1'>                    break;
</span>                case 'u':
<span class='uc' id='L608' title='1|1|1 - Total: 1'>                    nDigits += 2;
</span>                    // fallthru
                case 'x':
<span class='uc' id='L611' title='2|2|2 - Total: 2'>                    n = 0;
</span><span class='upc' id='L612' title='3|3|3 - Total: 4'>                    for (i = 0; (i < nDigits) && (index < end); i++) {
</span><span class='uc' id='L613' title='5|5|5 - Total: 5'>                        c = src[index++];
</span><span class='uc' id='L614' title='4|4|4 - Total: 4'>                        n = Kit.xDigitToInt(c, n);
</span><span class='upc' id='L615' title='1|1|1 - Total: 2'>                        if (n < 0) {
</span>                            // Back off to accepting the original
                            // '\' as a literal
<span class='nc' id='L618' title='0|0|0 - Total: 6'>                            index -= (i + 1);
</span><span class='nc' id='L619' title='0|0|0 - Total: 2'>                            n = '\\';
</span><span class='nc' id='L620' title='0|0|0 - Total: 1'>                            break;
</span>                        }
                    }
<span class='uc' id='L623' title='2|2|2 - Total: 2'>                    localMax = n;
</span><span class='uc' id='L624' title='1|1|1 - Total: 1'>                    break;
</span>                case 'd':
<span class='upc' id='L626' title='1|1|1 - Total: 2'>                    if (inRange) {
</span><span class='nc' id='L627' title='0|0|0 - Total: 3'>                        reportError("msg.bad.range", "");
</span><span class='nc' id='L628' title='0|0|0 - Total: 2'>                        return false;
</span>                    }
<span class='uc' id='L630' title='2|2|2 - Total: 2'>                    localMax = '9';
</span><span class='uc' id='L631' title='1|1|1 - Total: 1'>                    break;
</span>                case 'D':
                case 's':
                case 'S':
                case 'w':
                case 'W':
<span class='upc' id='L637' title='1|1|1 - Total: 2'>                    if (inRange) {
</span><span class='nc' id='L638' title='0|0|0 - Total: 3'>                        reportError("msg.bad.range", "");
</span><span class='nc' id='L639' title='0|0|0 - Total: 2'>                        return false;
</span>                    }
<span class='uc' id='L641' title='3|3|3 - Total: 3'>                    target.bmsize = 65536;
</span><span class='uc' id='L642' title='2|2|2 - Total: 2'>                    return true;
</span>                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    /*
                     *  This is a non-ECMA extension - decimal escapes (in this
                     *  case, octal!) are supposed to be an error inside class
                     *  ranges, but supported here for backwards compatibility.
                     *
                     */
<span class='uc' id='L657' title='4|4|4 - Total: 4'>                    n = (c - '0');
</span><span class='uc' id='L658' title='4|4|4 - Total: 4'>                    c = src[index];
</span><span class='upc' id='L659' title='2|2|2 - Total: 4'>                    if ('0' <= c && c <= '7') {
</span><span class='uc' id='L660' title='1|1|1 - Total: 1'>                        index++;
</span><span class='uc' id='L661' title='8|8|8 - Total: 8'>                        n = 8 * n + (c - '0');
</span><span class='uc' id='L662' title='4|4|4 - Total: 4'>                        c = src[index];
</span><span class='upc' id='L663' title='2|2|2 - Total: 4'>                        if ('0' <= c && c <= '7') {
</span><span class='uc' id='L664' title='1|1|1 - Total: 1'>                            index++;
</span><span class='uc' id='L665' title='8|8|8 - Total: 8'>                            i = 8 * n + (c - '0');
</span><span class='upc' id='L666' title='1|1|1 - Total: 2'>                            if (i <= 0377)
</span><span class='uc' id='L667' title='3|3|3 - Total: 3'>                                n = i;
</span>                            else
<span class='nc' id='L669' title='0|0|0 - Total: 1'>                                index--;
</span>                        }
                    }
<span class='uc' id='L672' title='2|2|2 - Total: 2'>                    localMax = n;
</span><span class='uc' id='L673' title='1|1|1 - Total: 1'>                    break;
</span>
                default:
<span class='uc' id='L676' title='2|2|2 - Total: 2'>                    localMax = c;
</span><span class='uc' id='L677' title='1|1|1 - Total: 1'>                    break;
</span>                }
                break;
            default:
<span class='uc' id='L681' title='5|5|5 - Total: 5'>                localMax = src[index++];
</span>                break;
            }
<span class='uc' id='L684' title='2|2|2 - Total: 2'>            if (inRange) {
</span><span class='upc' id='L685' title='1|1|1 - Total: 2'>                if (rangeStart > localMax) {
</span><span class='nc' id='L686' title='0|0|0 - Total: 3'>                    reportError("msg.bad.range", "");
</span><span class='nc' id='L687' title='0|0|0 - Total: 2'>                    return false;
</span>                }
<span class='uc' id='L689' title='3|3|3 - Total: 3'>                inRange = false;
</span>            }
            else {
<span class='uc' id='L692' title='2|2|2 - Total: 2'>                if (index < (end - 1)) {
</span><span class='uc' id='L693' title='2|2|2 - Total: 2'>                    if (src[index] == '-') {
</span><span class='uc' id='L694' title='1|1|1 - Total: 1'>                        ++index;
</span><span class='uc' id='L695' title='2|2|2 - Total: 2'>                        inRange = true;
</span><span class='uc' id='L696' title='3|3|3 - Total: 3'>                        rangeStart = (char)localMax;
</span><span class='uc' id='L697' title='1|1|1 - Total: 1'>                        continue;
</span>                    }
                }
            }
<span class='uc' id='L701' title='2|2|2 - Total: 2'>            if ((state.flags & JSREG_FOLD) != 0){
</span><span class='uc' id='L702' title='4|4|4 - Total: 4'>                char cu = upcase((char)localMax);
</span><span class='uc' id='L703' title='4|4|4 - Total: 4'>                char cd = downcase((char)localMax);
</span><span class='uc' id='L704' title='2|2|2 - Total: 2'>                localMax = (cu >= cd) ? cu : cd;
</span>            }
<span class='uc' id='L706' title='2|2|2 - Total: 2'>            if (localMax > max)
</span><span class='uc' id='L707' title='2|2|2 - Total: 2'>                max = localMax;
</span><span class='uc' id='L708' title='1|1|1 - Total: 1'>        }
</span><span class='uc' id='L709' title='5|5|5 - Total: 5'>        target.bmsize = max + 1;
</span><span class='uc' id='L710' title='2|2|2 - Total: 2'>        return true;
</span>    }

    /*
     *  item:       assertion               An item is either an assertion or
     *              quantatom               a quantified atom.
     *
     *  assertion:  '^'                     Assertions match beginning of string
     *                                      (or line if the class static property
     *                                      RegExp.multiline is true).
     *              '$'                     End of string (or line if the class
     *                                      static property RegExp.multiline is
     *                                      true).
     *              '\b'                    Word boundary (between \w and \W).
     *              '\B'                    Word non-boundary.
     *
     *  quantatom:  atom                    An unquantified atom.
     *              quantatom '{' n ',' m '}'
     *                                      Atom must occur between n and m times.
     *              quantatom '{' n ',' '}' Atom must occur at least n times.
     *              quantatom '{' n '}'     Atom must occur exactly n times.
     *              quantatom '*'           Zero or more times (same as {0,}).
     *              quantatom '+'           One or more times (same as {1,}).
     *              quantatom '?'           Zero or one time (same as {0,1}).
     *
     *              any of which can be optionally followed by '?' for ungreedy
     *
     *  atom:       '(' regexp ')'          A parenthesized regexp (what matched
     *                                      can be addressed using a backreference,
     *                                      see '\' n below).
     *              '.'                     Matches any char except '\n'.
     *              '[' classlist ']'       A character class.
     *              '[' '^' classlist ']'   A negated character class.
     *              '\f'                    Form Feed.
     *              '\n'                    Newline (Line Feed).
     *              '\r'                    Carriage Return.
     *              '\t'                    Horizontal Tab.
     *              '\v'                    Vertical Tab.
     *              '\d'                    A digit (same as [0-9]).
     *              '\D'                    A non-digit.
     *              '\w'                    A word character, [0-9a-z_A-Z].
     *              '\W'                    A non-word character.
     *              '\s'                    A whitespace character, [ \b\f\n\r\t\v].
     *              '\S'                    A non-whitespace character.
     *              '\' n                   A backreference to the nth (n decimal
     *                                      and positive) parenthesized expression.
     *              '\' octal               An octal escape sequence (octal must be
     *                                      two or three digits long, unless it is
     *                                      0 for the null character).
     *              '\x' hex                A hex escape (hex must be two digits).
     *              '\c' ctrl               A control character, ctrl is a letter.
     *              '\' literalatomchar     Any character except one of the above
     *                                      that follow '\' in an atom.
     *              otheratomchar           Any character not first among the other
     *                                      atom right-hand sides.
     */

    private static void doFlat(CompilerState state, char c)
    {
<span class='uc' id='L769' title='6|6|6 - Total: 6'>        state.result = new RENode(REOP_FLAT);
</span><span class='uc' id='L770' title='4|4|4 - Total: 4'>        state.result.chr = c;
</span><span class='uc' id='L771' title='4|4|4 - Total: 4'>        state.result.length = 1;
</span><span class='uc' id='L772' title='4|4|4 - Total: 4'>        state.result.flatIndex = -1;
</span><span class='uc' id='L773' title='6|6|6 - Total: 6'>        state.progLength += 3;
</span><span class='uc' id='L774' title='1|1|1 - Total: 1'>    }
</span>
    private static int
    getDecimalValue(char c, CompilerState state, int maxValue,
                    String overflowMessageId)
    {
<span class='uc' id='L780' title='2|2|2 - Total: 2'>        boolean overflow = false;
</span><span class='uc' id='L781' title='3|3|3 - Total: 3'>        int start = state.cp;
</span><span class='uc' id='L782' title='3|3|3 - Total: 3'>        char[] src = state.cpbegin;
</span><span class='uc' id='L783' title='4|4|4 - Total: 4'>        int value = c - '0';
</span><span class='uc' id='L784' title='2|2|2 - Total: 2'>        for (; state.cp != state.cpend; ++state.cp) {
</span><span class='uc' id='L785' title='5|5|5 - Total: 5'>            c = src[state.cp];
</span><span class='uc' id='L786' title='2|2|2 - Total: 2'>            if (!isDigit(c)) {
</span><span class='uc' id='L787' title='1|1|1 - Total: 1'>                break;
</span>            }
<span class='uc' id='L789' title='2|2|2 - Total: 2'>            if (!overflow) {
</span><span class='uc' id='L790' title='8|8|8 - Total: 8'>                int v = value * 10 + (c - '0');
</span><span class='uc' id='L791' title='2|2|2 - Total: 2'>                if (v < maxValue) {
</span><span class='uc' id='L792' title='3|3|3 - Total: 3'>                    value = v;
</span>                } else {
<span class='uc' id='L794' title='2|2|2 - Total: 2'>                    overflow = true;
</span><span class='uc' id='L795' title='2|2|2 - Total: 2'>                    value = maxValue;
</span>                }
            }
        }
<span class='uc' id='L799' title='2|2|2 - Total: 2'>        if (overflow) {
</span><span class='upc' id='L800' title='7|7|7 - Total: 8'>            reportError(overflowMessageId,
</span><span class='uc' id='L801' title='1|1|1 - Total: 1'>                        String.valueOf(src, start, state.cp - start));
</span>        }
<span class='uc' id='L803' title='2|2|2 - Total: 2'>        return value;
</span>    }

    private static boolean
    parseTerm(CompilerState state)
    {
<span class='uc' id='L809' title='3|3|3 - Total: 3'>        char[] src = state.cpbegin;
</span><span class='uc' id='L810' title='10|10|10 - Total: 10'>        char c = src[state.cp++];
</span><span class='uc' id='L811' title='2|2|2 - Total: 2'>        int nDigits = 2;
</span><span class='uc' id='L812' title='3|3|3 - Total: 3'>        int parenBaseCount = state.parenCount;
</span>        int num;
        RENode term;
        int termStart;

<span class='upc' id='L817' title='7|7|7 - Total: 9'>        switch (c) {
</span>        /* assertions and atoms */
        case '^':
<span class='uc' id='L820' title='6|6|6 - Total: 6'>            state.result = new RENode(REOP_BOL);
</span><span class='uc' id='L821' title='6|6|6 - Total: 6'>            state.progLength++;
</span><span class='uc' id='L822' title='2|2|2 - Total: 2'>            return true;
</span>        case '$':
<span class='uc' id='L824' title='6|6|6 - Total: 6'>            state.result = new RENode(REOP_EOL);
</span><span class='uc' id='L825' title='6|6|6 - Total: 6'>            state.progLength++;
</span><span class='uc' id='L826' title='2|2|2 - Total: 2'>            return true;
</span>        case '\\':
<span class='upc' id='L828' title='1|1|1 - Total: 2'>            if (state.cp < state.cpend) {
</span><span class='uc' id='L829' title='10|10|10 - Total: 10'>                c = src[state.cp++];
</span><span class='uc' id='L830' title='19|19|19 - Total: 19'>                switch (c) {
</span>                /* assertion escapes */
                case 'b' :
<span class='uc' id='L833' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_WBDRY);
</span><span class='uc' id='L834' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L835' title='2|2|2 - Total: 2'>                    return true;
</span>                case 'B':
<span class='uc' id='L837' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_WNONBDRY);
</span><span class='uc' id='L838' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L839' title='2|2|2 - Total: 2'>                    return true;
</span>                /* Decimal escape */
                case '0':
/*
 * We're deliberately violating the ECMA 5.1 specification and allow octal
 * escapes to follow spidermonkey and general 'web reality':
 * http://wiki.ecmascript.org/doku.php?id=harmony:regexp_match_web_reality
 * http://wiki.ecmascript.org/doku.php?id=strawman:match_web_reality_spec
 */
<span class='uc' id='L848' title='5|5|5 - Total: 5'>                    reportWarning(state.cx, "msg.bad.backref", "");
</span>                    /* octal escape */
<span class='uc' id='L850' title='2|2|2 - Total: 2'>                    num = 0;
</span>                    // follow spidermonkey and allow multiple leading zeros,
                    // e.g. let /\0000/ match the string "\0"
<span class='uc' id='L853' title='4|4|4 - Total: 4'>                    while (num < 040 && state.cp < state.cpend) {
</span><span class='uc' id='L854' title='5|5|5 - Total: 5'>                        c = src[state.cp];
</span><span class='upc' id='L855' title='3|3|3 - Total: 4'>                        if ((c >= '0') && (c <= '7')) {
</span><span class='uc' id='L856' title='6|6|6 - Total: 6'>                            state.cp++;
</span><span class='uc' id='L857' title='9|9|9 - Total: 9'>                            num = 8 * num + (c - '0');
</span>                        }
                        else
                            break;
                    }
<span class='uc' id='L862' title='3|3|3 - Total: 3'>                    c = (char)(num);
</span><span class='uc' id='L863' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L864' title='1|1|1 - Total: 1'>                    break;
</span>                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
<span class='uc' id='L874' title='5|5|5 - Total: 5'>                    termStart = state.cp - 1;
</span><span class='uc' id='L875' title='6|6|6 - Total: 6'>                    num = getDecimalValue(c, state, 0xFFFF,
</span>                                          "msg.overlarge.backref");
<span class='uc' id='L877' title='2|2|2 - Total: 2'>                    if (num > state.backReferenceLimit)
</span><span class='uc' id='L878' title='5|5|5 - Total: 5'>                        reportWarning(state.cx, "msg.bad.backref", "");
</span>                    /*
                     * n > count of parentheses, then treat as octal instead.
                     * Also see note above concerning 'web reality'
                     */
<span class='uc' id='L883' title='2|2|2 - Total: 2'>                    if (num > state.backReferenceLimit) {
</span><span class='uc' id='L884' title='3|3|3 - Total: 3'>                        state.cp = termStart;
</span><span class='uc' id='L885' title='2|2|2 - Total: 2'>                        if (c >= '8') {
</span>                            // invalid octal escape, follow spidermonkey and
                            // treat as \\8 resp. \\9
<span class='uc' id='L888' title='2|2|2 - Total: 2'>                            c = '\\';
</span><span class='uc' id='L889' title='3|3|3 - Total: 3'>                            doFlat(state, c);
</span><span class='uc' id='L890' title='1|1|1 - Total: 1'>                            break;
</span>                        }
<span class='uc' id='L892' title='6|6|6 - Total: 6'>                        state.cp++;
</span><span class='uc' id='L893' title='4|4|4 - Total: 4'>                        num = c - '0';
</span><span class='uc' id='L894' title='4|4|4 - Total: 4'>                        while (num < 040 && state.cp < state.cpend) {
</span><span class='uc' id='L895' title='5|5|5 - Total: 5'>                            c = src[state.cp];
</span><span class='upc' id='L896' title='3|3|3 - Total: 4'>                            if ((c >= '0') && (c <= '7')) {
</span><span class='uc' id='L897' title='6|6|6 - Total: 6'>                                state.cp++;
</span><span class='uc' id='L898' title='9|9|9 - Total: 9'>                                num = 8 * num + (c - '0');
</span>                            }
                            else
                                break;
                        }
<span class='uc' id='L903' title='3|3|3 - Total: 3'>                        c = (char)(num);
</span><span class='uc' id='L904' title='3|3|3 - Total: 3'>                        doFlat(state, c);
</span><span class='uc' id='L905' title='1|1|1 - Total: 1'>                        break;
</span>                    }
                    /* otherwise, it's a back-reference */
<span class='uc' id='L908' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_BACKREF);
</span><span class='uc' id='L909' title='6|6|6 - Total: 6'>                    state.result.parenIndex = num - 1;
</span><span class='uc' id='L910' title='6|6|6 - Total: 6'>                    state.progLength += 3;
</span><span class='uc' id='L911' title='2|2|2 - Total: 2'>                    if (state.maxBackReference < num) {
</span><span class='uc' id='L912' title='4|4|4 - Total: 4'>                        state.maxBackReference = num;
</span>                    }
                    break;
                /* Control escape */
                case 'f':
<span class='uc' id='L917' title='2|2|2 - Total: 2'>                    c = 0xC;
</span><span class='uc' id='L918' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L919' title='1|1|1 - Total: 1'>                    break;
</span>                case 'n':
<span class='uc' id='L921' title='2|2|2 - Total: 2'>                    c = 0xA;
</span><span class='uc' id='L922' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L923' title='1|1|1 - Total: 1'>                    break;
</span>                case 'r':
<span class='uc' id='L925' title='2|2|2 - Total: 2'>                    c = 0xD;
</span><span class='uc' id='L926' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L927' title='1|1|1 - Total: 1'>                    break;
</span>                case 't':
<span class='uc' id='L929' title='2|2|2 - Total: 2'>                    c = 0x9;
</span><span class='uc' id='L930' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L931' title='1|1|1 - Total: 1'>                    break;
</span>                case 'v':
<span class='uc' id='L933' title='2|2|2 - Total: 2'>                    c = 0xB;
</span><span class='uc' id='L934' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L935' title='1|1|1 - Total: 1'>                    break;
</span>                /* Control letter */
                case 'c':
<span class='upc' id='L938' title='1|1|1 - Total: 2'>                    if ((state.cp < state.cpend) &&
</span><span class='uc' id='L939' title='2|2|2 - Total: 2'>                                        isControlLetter(src[state.cp]))
</span><span class='uc' id='L940' title='14|14|14 - Total: 14'>                        c = (char)(src[state.cp++] & 0x1F);
</span>                    else {
                        /* back off to accepting the original '\' as a literal */
<span class='uc' id='L943' title='6|6|6 - Total: 6'>                        --state.cp;
</span><span class='uc' id='L944' title='2|2|2 - Total: 2'>                        c = '\\';
</span>                    }
<span class='uc' id='L946' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L947' title='1|1|1 - Total: 1'>                    break;
</span>                /* UnicodeEscapeSequence */
                case 'u':
<span class='uc' id='L950' title='1|1|1 - Total: 1'>                    nDigits += 2;
</span>                /* fallthru */ case 'x':  /* HexEscapeSequence */
                    {
<span class='uc' id='L953' title='2|2|2 - Total: 2'>                        int n = 0;
</span>                        int i;
<span class='uc' id='L955' title='2|2|2 - Total: 2'>                        for (i = 0; (i < nDigits)
</span><span class='upc' id='L956' title='3|3|3 - Total: 4'>                                && (state.cp < state.cpend); i++) {
</span><span class='uc' id='L957' title='10|10|10 - Total: 10'>                            c = src[state.cp++];
</span><span class='uc' id='L958' title='4|4|4 - Total: 4'>                            n = Kit.xDigitToInt(c, n);
</span><span class='uc' id='L959' title='2|2|2 - Total: 2'>                            if (n < 0) {
</span>                                // Back off to accepting the original
                                // 'u' or 'x' as a literal
<span class='uc' id='L962' title='8|8|8 - Total: 8'>                                state.cp -= (i + 2);
</span><span class='uc' id='L963' title='10|10|10 - Total: 10'>                                n = src[state.cp++];
</span><span class='uc' id='L964' title='1|1|1 - Total: 1'>                                break;
</span>                            }
                        }
<span class='uc' id='L967' title='3|3|3 - Total: 3'>                        c = (char)(n);
</span>                    }
<span class='uc' id='L969' title='3|3|3 - Total: 3'>                    doFlat(state, c);
</span><span class='uc' id='L970' title='1|1|1 - Total: 1'>                    break;
</span>                /* Character class escapes */
                case 'd':
<span class='uc' id='L973' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_DIGIT);
</span><span class='uc' id='L974' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L975' title='1|1|1 - Total: 1'>                    break;
</span>                case 'D':
<span class='uc' id='L977' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_NONDIGIT);
</span><span class='uc' id='L978' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L979' title='1|1|1 - Total: 1'>                    break;
</span>                case 's':
<span class='uc' id='L981' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_SPACE);
</span><span class='uc' id='L982' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L983' title='1|1|1 - Total: 1'>                    break;
</span>                case 'S':
<span class='uc' id='L985' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_NONSPACE);
</span><span class='uc' id='L986' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L987' title='1|1|1 - Total: 1'>                    break;
</span>                case 'w':
<span class='uc' id='L989' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_ALNUM);
</span><span class='uc' id='L990' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L991' title='1|1|1 - Total: 1'>                    break;
</span>                case 'W':
<span class='uc' id='L993' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_NONALNUM);
</span><span class='uc' id='L994' title='6|6|6 - Total: 6'>                    state.progLength++;
</span><span class='uc' id='L995' title='1|1|1 - Total: 1'>                    break;
</span>                /* IdentityEscape */
                default:
<span class='uc' id='L998' title='6|6|6 - Total: 6'>                    state.result = new RENode(REOP_FLAT);
</span><span class='uc' id='L999' title='4|4|4 - Total: 4'>                    state.result.chr = c;
</span><span class='uc' id='L1000' title='4|4|4 - Total: 4'>                    state.result.length = 1;
</span><span class='uc' id='L1001' title='7|7|7 - Total: 7'>                    state.result.flatIndex = state.cp - 1;
</span><span class='uc' id='L1002' title='6|6|6 - Total: 6'>                    state.progLength += 3;
</span><span class='uc' id='L1003' title='1|1|1 - Total: 1'>                    break;
</span>                }
                break;
            }
            else {
                /* a trailing '\' is an error */
<span class='nc' id='L1009' title='0|0|0 - Total: 3'>                reportError("msg.trail.backslash", "");
</span><span class='nc' id='L1010' title='0|0|0 - Total: 2'>                return false;
</span>            }
        case '(': {
<span class='uc' id='L1013' title='2|2|2 - Total: 2'>            RENode result = null;
</span><span class='uc' id='L1014' title='3|3|3 - Total: 3'>            termStart = state.cp;
</span><span class='uc' id='L1015' title='10|10|10 - Total: 10'>            if (state.cp + 1 < state.cpend && src[state.cp] == '?'
</span>                && ((c = src[state.cp + 1]) == '=' || c == '!' || c == ':'))
            {
<span class='uc' id='L1018' title='6|6|6 - Total: 6'>                state.cp += 2;
</span><span class='uc' id='L1019' title='2|2|2 - Total: 2'>                if (c == '=') {
</span><span class='uc' id='L1020' title='5|5|5 - Total: 5'>                    result = new RENode(REOP_ASSERT);
</span>                    /* ASSERT, <next>, ... ASSERTTEST */
<span class='uc' id='L1022' title='7|7|7 - Total: 7'>                    state.progLength += 4;
</span><span class='uc' id='L1023' title='2|2|2 - Total: 2'>                } else if (c == '!') {
</span><span class='uc' id='L1024' title='5|5|5 - Total: 5'>                    result = new RENode(REOP_ASSERT_NOT);
</span>                    /* ASSERTNOT, <next>, ... ASSERTNOTTEST */
<span class='uc' id='L1026' title='7|7|7 - Total: 7'>                    state.progLength += 4;
</span>                }
            } else {
<span class='uc' id='L1029' title='5|5|5 - Total: 5'>                result = new RENode(REOP_LPAREN);
</span>                /* LPAREN, <index>, ... RPAREN, <index> */
<span class='uc' id='L1031' title='6|6|6 - Total: 6'>                state.progLength += 6;
</span><span class='uc' id='L1032' title='9|9|9 - Total: 9'>                result.parenIndex = state.parenCount++;
</span>            }
<span class='uc' id='L1034' title='6|6|6 - Total: 6'>            ++state.parenNesting;
</span><span class='upc' id='L1035' title='1|1|1 - Total: 2'>            if (!parseDisjunction(state))
</span><span class='nc' id='L1036' title='0|0|0 - Total: 2'>                return false;
</span><span class='upc' id='L1037' title='3|3|3 - Total: 4'>            if (state.cp == state.cpend || src[state.cp] != ')') {
</span><span class='nc' id='L1038' title='0|0|0 - Total: 3'>                reportError("msg.unterm.paren", "");
</span><span class='nc' id='L1039' title='0|0|0 - Total: 2'>                return false;
</span>            }
<span class='uc' id='L1041' title='6|6|6 - Total: 6'>            ++state.cp;
</span><span class='uc' id='L1042' title='6|6|6 - Total: 6'>            --state.parenNesting;
</span><span class='uc' id='L1043' title='2|2|2 - Total: 2'>            if (result != null) {
</span><span class='uc' id='L1044' title='4|4|4 - Total: 4'>                result.kid = state.result;
</span><span class='uc' id='L1045' title='4|4|4 - Total: 4'>                state.result = result;
</span>            }
            break;
        }
        case ')':
<span class='nc' id='L1050' title='0|0|0 - Total: 3'>          reportError("msg.re.unmatched.right.paren", "");
</span><span class='nc' id='L1051' title='0|0|0 - Total: 2'>          return false;
</span>        case '[':
<span class='uc' id='L1053' title='6|6|6 - Total: 6'>            state.result = new RENode(REOP_CLASS);
</span><span class='uc' id='L1054' title='3|3|3 - Total: 3'>            termStart = state.cp;
</span><span class='uc' id='L1055' title='4|4|4 - Total: 4'>            state.result.startIndex = termStart;
</span>            while (true) {
<span class='upc' id='L1057' title='1|1|1 - Total: 2'>                if (state.cp == state.cpend) {
</span><span class='nc' id='L1058' title='0|0|0 - Total: 3'>                    reportError("msg.unterm.class", "");
</span><span class='nc' id='L1059' title='0|0|0 - Total: 2'>                    return false;
</span>                }
<span class='uc' id='L1061' title='2|2|2 - Total: 2'>                if (src[state.cp] == '\\')
</span><span class='uc' id='L1062' title='7|7|7 - Total: 7'>                    state.cp++;
</span>                else {
<span class='uc' id='L1064' title='2|2|2 - Total: 2'>                    if (src[state.cp] == ']') {
</span><span class='uc' id='L1065' title='7|7|7 - Total: 7'>                        state.result.kidlen = state.cp - termStart;
</span><span class='uc' id='L1066' title='1|1|1 - Total: 1'>                        break;
</span>                    }
                }
<span class='uc' id='L1069' title='7|7|7 - Total: 7'>                state.cp++;
</span>            }
<span class='uc' id='L1071' title='10|10|10 - Total: 10'>            state.result.index = state.classCount++;
</span>            /*
             * Call calculateBitmapSize now as we want any errors it finds
             * to be reported during the parse phase, not at execution.
             */
<span class='upc' id='L1076' title='1|1|1 - Total: 2'>            if (!calculateBitmapSize(state, state.result, src, termStart, state.cp++))
</span><span class='nc' id='L1077' title='0|0|0 - Total: 2'>                return false;
</span><span class='uc' id='L1078' title='6|6|6 - Total: 6'>            state.progLength += 3; /* CLASS, <index> */
</span><span class='uc' id='L1079' title='1|1|1 - Total: 1'>            break;
</span>
        case '.':
<span class='uc' id='L1082' title='6|6|6 - Total: 6'>            state.result = new RENode(REOP_DOT);
</span><span class='uc' id='L1083' title='6|6|6 - Total: 6'>            state.progLength++;
</span><span class='uc' id='L1084' title='1|1|1 - Total: 1'>            break;
</span>        case '*':
        case '+':
        case '?':
<span class='nc' id='L1088' title='0|0|0 - Total: 9'>            reportError("msg.bad.quant", String.valueOf(src[state.cp - 1]));
</span><span class='nc' id='L1089' title='0|0|0 - Total: 2'>            return false;
</span>        default:
<span class='uc' id='L1091' title='6|6|6 - Total: 6'>            state.result = new RENode(REOP_FLAT);
</span><span class='uc' id='L1092' title='4|4|4 - Total: 4'>            state.result.chr = c;
</span><span class='uc' id='L1093' title='4|4|4 - Total: 4'>            state.result.length = 1;
</span><span class='uc' id='L1094' title='7|7|7 - Total: 7'>            state.result.flatIndex = state.cp - 1;
</span><span class='uc' id='L1095' title='6|6|6 - Total: 6'>            state.progLength += 3;
</span>            break;
        }

<span class='uc' id='L1099' title='3|3|3 - Total: 3'>        term = state.result;
</span><span class='uc' id='L1100' title='2|2|2 - Total: 2'>        if (state.cp == state.cpend) {
</span><span class='uc' id='L1101' title='2|2|2 - Total: 2'>            return true;
</span>        }
<span class='uc' id='L1103' title='2|2|2 - Total: 2'>        boolean hasQ = false;
</span><span class='uc' id='L1104' title='5|5|5 - Total: 5'>        switch (src[state.cp]) {
</span>            case '+':
<span class='uc' id='L1106' title='6|6|6 - Total: 6'>                state.result = new RENode(REOP_QUANT);
</span><span class='uc' id='L1107' title='4|4|4 - Total: 4'>                state.result.min = 1;
</span><span class='uc' id='L1108' title='4|4|4 - Total: 4'>                state.result.max = -1;
</span>                /* <PLUS>, <parencount>, <parenindex>, <next> ... <ENDCHILD> */
<span class='uc' id='L1110' title='6|6|6 - Total: 6'>                state.progLength += 8;
</span><span class='uc' id='L1111' title='2|2|2 - Total: 2'>                hasQ = true;
</span><span class='uc' id='L1112' title='1|1|1 - Total: 1'>                break;
</span>            case '*':
<span class='uc' id='L1114' title='6|6|6 - Total: 6'>                state.result = new RENode(REOP_QUANT);
</span><span class='uc' id='L1115' title='4|4|4 - Total: 4'>                state.result.min = 0;
</span><span class='uc' id='L1116' title='4|4|4 - Total: 4'>                state.result.max = -1;
</span>                /* <STAR>, <parencount>, <parenindex>, <next> ... <ENDCHILD> */
<span class='uc' id='L1118' title='6|6|6 - Total: 6'>                state.progLength += 8;
</span><span class='uc' id='L1119' title='2|2|2 - Total: 2'>                hasQ = true;
</span><span class='uc' id='L1120' title='1|1|1 - Total: 1'>                break;
</span>            case '?':
<span class='uc' id='L1122' title='6|6|6 - Total: 6'>                state.result = new RENode(REOP_QUANT);
</span><span class='uc' id='L1123' title='4|4|4 - Total: 4'>                state.result.min = 0;
</span><span class='uc' id='L1124' title='4|4|4 - Total: 4'>                state.result.max = 1;
</span>                /* <OPT>, <parencount>, <parenindex>, <next> ... <ENDCHILD> */
<span class='uc' id='L1126' title='6|6|6 - Total: 6'>                state.progLength += 8;
</span><span class='uc' id='L1127' title='2|2|2 - Total: 2'>                hasQ = true;
</span><span class='uc' id='L1128' title='1|1|1 - Total: 1'>                break;
</span>            case '{':  /* balance '}' */
            {
<span class='uc' id='L1131' title='2|2|2 - Total: 2'>                int min = 0;
</span><span class='uc' id='L1132' title='2|2|2 - Total: 2'>                int max = -1;
</span><span class='uc' id='L1133' title='3|3|3 - Total: 3'>                int leftCurl = state.cp;
</span>
               /* For Perl etc. compatibility, if quntifier does not match
                * \{\d+(,\d*)?\} exactly back off from it
                * being a quantifier, and chew it up as a literal
                * atom next time instead.
                */

<span class='upc' id='L1141' title='3|3|3 - Total: 4'>                if (++state.cp < src.length && isDigit(c = src[state.cp])) {
</span><span class='uc' id='L1142' title='6|6|6 - Total: 6'>                    ++state.cp;
</span><span class='uc' id='L1143' title='6|6|6 - Total: 6'>                    min = getDecimalValue(c, state, 0xFFFF,
</span>                                          "msg.overlarge.min");
<span class='uc' id='L1145' title='2|2|2 - Total: 2'>                    if (state.cp < src.length) {
</span><span class='uc' id='L1146' title='5|5|5 - Total: 5'>                        c = src[state.cp];
</span><span class='upc' id='L1147' title='3|3|3 - Total: 4'>                        if (c == ',' && ++state.cp < src.length) {
</span><span class='uc' id='L1148' title='5|5|5 - Total: 5'>                            c = src[state.cp];
</span><span class='upc' id='L1149' title='3|3|3 - Total: 4'>                            if (isDigit(c) && ++state.cp < src.length) {
</span><span class='uc' id='L1150' title='6|6|6 - Total: 6'>                                max = getDecimalValue(c, state, 0xFFFF,
</span>                                                      "msg.overlarge.max");
<span class='uc' id='L1152' title='5|5|5 - Total: 5'>                                c = src[state.cp];
</span><span class='upc' id='L1153' title='1|1|1 - Total: 2'>                                if (min > max) {
</span><span class='nc' id='L1154' title='0|0|0 - Total: 6'>                                    reportError("msg.max.lt.min",
</span><span class='nc' id='L1155' title='0|0|0 - Total: 1'>                                                String.valueOf(src[state.cp]));
</span><span class='nc' id='L1156' title='0|0|0 - Total: 2'>                                    return false;
</span>                                }
                            }
                        } else {
<span class='uc' id='L1160' title='2|2|2 - Total: 2'>                            max = min;
</span>                        }
                        /* balance '{' */
<span class='uc' id='L1163' title='2|2|2 - Total: 2'>                        if (c == '}') {
</span><span class='uc' id='L1164' title='6|6|6 - Total: 6'>                            state.result = new RENode(REOP_QUANT);
</span><span class='uc' id='L1165' title='4|4|4 - Total: 4'>                            state.result.min = min;
</span><span class='uc' id='L1166' title='4|4|4 - Total: 4'>                            state.result.max = max;
</span>                            // QUANT, <min>, <max>, <parencount>,
                            // <parenindex>, <next> ... <ENDCHILD>
<span class='uc' id='L1169' title='6|6|6 - Total: 6'>                            state.progLength += 12;
</span><span class='uc' id='L1170' title='2|2|2 - Total: 2'>                            hasQ = true;
</span>                        }
                    }
                }
<span class='uc' id='L1174' title='2|2|2 - Total: 2'>                if (!hasQ) {
</span><span class='uc' id='L1175' title='4|4|4 - Total: 4'>                    state.cp = leftCurl;
</span>                }
                break;
            }
        }
<span class='uc' id='L1180' title='2|2|2 - Total: 2'>        if (!hasQ)
</span><span class='uc' id='L1181' title='2|2|2 - Total: 2'>            return true;
</span>
<span class='uc' id='L1183' title='6|6|6 - Total: 6'>        ++state.cp;
</span><span class='uc' id='L1184' title='4|4|4 - Total: 4'>        state.result.kid = term;
</span><span class='uc' id='L1185' title='4|4|4 - Total: 4'>        state.result.parenIndex = parenBaseCount;
</span><span class='uc' id='L1186' title='7|7|7 - Total: 7'>        state.result.parenCount = state.parenCount - parenBaseCount;
</span><span class='uc' id='L1187' title='4|4|4 - Total: 4'>        if ((state.cp < state.cpend) && (src[state.cp] == '?')) {
</span><span class='uc' id='L1188' title='6|6|6 - Total: 6'>            ++state.cp;
</span><span class='uc' id='L1189' title='5|5|5 - Total: 5'>            state.result.greedy = false;
</span>        }
        else
<span class='uc' id='L1192' title='4|4|4 - Total: 4'>            state.result.greedy = true;
</span><span class='uc' id='L1193' title='2|2|2 - Total: 2'>        return true;
</span>    }

    private static void resolveForwardJump(byte[] array, int from, int pc)
    {
<span class='upc' id='L1198' title='1|1|1 - Total: 2'>        if (from > pc) throw Kit.codeBug();
</span><span class='uc' id='L1199' title='7|7|7 - Total: 7'>        addIndex(array, from, pc - from);
</span><span class='uc' id='L1200' title='1|1|1 - Total: 1'>    }
</span>
    private static int getOffset(byte[] array, int pc)
    {
<span class='uc' id='L1204' title='4|4|4 - Total: 4'>        return getIndex(array, pc);
</span>    }

    private static int addIndex(byte[] array, int pc, int index)
    {
<span class='upc' id='L1209' title='1|1|1 - Total: 2'>        if (index < 0) throw Kit.codeBug();
</span><span class='uc' id='L1210' title='2|2|2 - Total: 2'>        if (index > 0xFFFF)
</span><span class='uc' id='L1211' title='3|3|3 - Total: 3'>            throw Context.reportRuntimeError("Too complex regexp");
</span><span class='uc' id='L1212' title='7|7|7 - Total: 7'>        array[pc] = (byte)(index >> 8);
</span><span class='uc' id='L1213' title='7|7|7 - Total: 7'>        array[pc + 1] = (byte)(index);
</span><span class='uc' id='L1214' title='4|4|4 - Total: 4'>        return pc + 2;
</span>    }

    private static int getIndex(byte[] array, int pc)
    {
<span class='uc' id='L1219' title='16|16|16 - Total: 16'>        return ((array[pc] & 0xFF) << 8) | (array[pc + 1] & 0xFF);
</span>    }

    private static final int INDEX_LEN  = 2;

    private static int
    emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t)
    {
        RENode nextAlt;
        int nextAltFixup, nextTermFixup;
<span class='uc' id='L1229' title='3|3|3 - Total: 3'>        byte[] program = re.program;
</span>
<span class='uc' id='L1231' title='2|2|2 - Total: 2'>        while (t != null) {
</span><span class='uc' id='L1232' title='6|6|6 - Total: 6'>            program[pc++] = t.op;
</span><span class='uc' id='L1233' title='11|11|11 - Total: 11'>            switch (t.op) {
</span>            case REOP_EMPTY:
<span class='uc' id='L1235' title='1|1|1 - Total: 1'>                --pc;
</span><span class='uc' id='L1236' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_ALTPREREQ:
            case REOP_ALTPREREQi:
            case REOP_ALTPREREQ2:
<span class='uc' id='L1240' title='2|2|2 - Total: 2'>                boolean ignoreCase = t.op == REOP_ALTPREREQi;
</span><span class='uc' id='L1241' title='2|2|2 - Total: 2'>                addIndex(program, pc, ignoreCase ? upcase(t.chr) : t.chr);
</span><span class='uc' id='L1242' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1243' title='2|2|2 - Total: 2'>                addIndex(program, pc, ignoreCase ? upcase((char)t.index) : t.index);
</span><span class='uc' id='L1244' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span>                // fall through to REOP_ALT
            case REOP_ALT:
<span class='uc' id='L1247' title='3|3|3 - Total: 3'>                nextAlt = t.kid2;
</span><span class='uc' id='L1248' title='2|2|2 - Total: 2'>                nextAltFixup = pc;    /* address of next alternate */
</span><span class='uc' id='L1249' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1250' title='7|7|7 - Total: 7'>                pc = emitREBytecode(state, re, pc, t.kid);
</span><span class='uc' id='L1251' title='5|5|5 - Total: 5'>                program[pc++] = REOP_JUMP;
</span><span class='uc' id='L1252' title='2|2|2 - Total: 2'>                nextTermFixup = pc;    /* address of following term */
</span><span class='uc' id='L1253' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1254' title='4|4|4 - Total: 4'>                resolveForwardJump(program, nextAltFixup, pc);
</span><span class='uc' id='L1255' title='6|6|6 - Total: 6'>                pc = emitREBytecode(state, re, pc, nextAlt);
</span>
<span class='uc' id='L1257' title='5|5|5 - Total: 5'>                program[pc++] = REOP_JUMP;
</span><span class='uc' id='L1258' title='2|2|2 - Total: 2'>                nextAltFixup = pc;
</span><span class='uc' id='L1259' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span>
<span class='uc' id='L1261' title='4|4|4 - Total: 4'>                resolveForwardJump(program, nextTermFixup, pc);
</span><span class='uc' id='L1262' title='4|4|4 - Total: 4'>                resolveForwardJump(program, nextAltFixup, pc);
</span><span class='uc' id='L1263' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_FLAT:
                /*
                 * Consecutize FLAT's if possible.
                 */
<span class='uc' id='L1268' title='2|2|2 - Total: 2'>                if (t.flatIndex != -1) {
</span><span class='uc' id='L1269' title='6|6|6 - Total: 6'>                    while ((t.next != null) && (t.next.op == REOP_FLAT)
</span>                            && ((t.flatIndex + t.length)
                                            == t.next.flatIndex)) {
<span class='uc' id='L1272' title='8|8|8 - Total: 8'>                        t.length += t.next.length;
</span><span class='uc' id='L1273' title='6|6|6 - Total: 6'>                        t.next = t.next.next;
</span>                    }
                }
<span class='uc' id='L1276' title='4|4|4 - Total: 4'>                if ((t.flatIndex != -1) && (t.length > 1)) {
</span><span class='uc' id='L1277' title='2|2|2 - Total: 2'>                    if ((state.flags & JSREG_FOLD) != 0)
</span><span class='uc' id='L1278' title='7|7|7 - Total: 7'>                        program[pc - 1] = REOP_FLATi;
</span>                    else
<span class='uc' id='L1280' title='6|6|6 - Total: 6'>                        program[pc - 1] = REOP_FLAT;
</span><span class='uc' id='L1281' title='6|6|6 - Total: 6'>                    pc = addIndex(program, pc, t.flatIndex);
</span><span class='uc' id='L1282' title='7|7|7 - Total: 7'>                    pc = addIndex(program, pc, t.length);
</span>                }
                else {
<span class='upc' id='L1285' title='1|1|1 - Total: 2'>                    if (t.chr < 256) {
</span><span class='uc' id='L1286' title='2|2|2 - Total: 2'>                        if ((state.flags & JSREG_FOLD) != 0)
</span><span class='uc' id='L1287' title='7|7|7 - Total: 7'>                            program[pc - 1] = REOP_FLAT1i;
</span>                        else
<span class='uc' id='L1289' title='6|6|6 - Total: 6'>                            program[pc - 1] = REOP_FLAT1;
</span><span class='uc' id='L1290' title='8|8|8 - Total: 8'>                        program[pc++] = (byte)(t.chr);
</span>                    }
                    else {
<span class='nc' id='L1293' title='0|0|0 - Total: 2'>                        if ((state.flags & JSREG_FOLD) != 0)
</span><span class='nc' id='L1294' title='0|0|0 - Total: 7'>                            program[pc - 1] = REOP_UCFLAT1i;
</span>                        else
<span class='nc' id='L1296' title='0|0|0 - Total: 6'>                            program[pc - 1] = REOP_UCFLAT1;
</span><span class='nc' id='L1297' title='0|0|0 - Total: 6'>                        pc = addIndex(program, pc, t.chr);
</span>                    }
                }
<span class='nc' id='L1300' title='0|0|0 - Total: 1'>                break;
</span>            case REOP_LPAREN:
<span class='uc' id='L1302' title='6|6|6 - Total: 6'>                pc = addIndex(program, pc, t.parenIndex);
</span><span class='uc' id='L1303' title='7|7|7 - Total: 7'>                pc = emitREBytecode(state, re, pc, t.kid);
</span><span class='uc' id='L1304' title='5|5|5 - Total: 5'>                program[pc++] = REOP_RPAREN;
</span><span class='uc' id='L1305' title='6|6|6 - Total: 6'>                pc = addIndex(program, pc, t.parenIndex);
</span><span class='uc' id='L1306' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_BACKREF:
<span class='uc' id='L1308' title='6|6|6 - Total: 6'>                pc = addIndex(program, pc, t.parenIndex);
</span><span class='uc' id='L1309' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_ASSERT:
<span class='uc' id='L1311' title='2|2|2 - Total: 2'>                nextTermFixup = pc;
</span><span class='uc' id='L1312' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1313' title='7|7|7 - Total: 7'>                pc = emitREBytecode(state, re, pc, t.kid);
</span><span class='uc' id='L1314' title='5|5|5 - Total: 5'>                program[pc++] = REOP_ASSERTTEST;
</span><span class='uc' id='L1315' title='4|4|4 - Total: 4'>                resolveForwardJump(program, nextTermFixup, pc);
</span><span class='uc' id='L1316' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_ASSERT_NOT:
<span class='uc' id='L1318' title='2|2|2 - Total: 2'>                nextTermFixup = pc;
</span><span class='uc' id='L1319' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1320' title='7|7|7 - Total: 7'>                pc = emitREBytecode(state, re, pc, t.kid);
</span><span class='uc' id='L1321' title='5|5|5 - Total: 5'>                program[pc++] = REOP_ASSERTNOTTEST;
</span><span class='uc' id='L1322' title='4|4|4 - Total: 4'>                resolveForwardJump(program, nextTermFixup, pc);
</span><span class='uc' id='L1323' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_QUANT:
<span class='uc' id='L1325' title='4|4|4 - Total: 4'>                if ((t.min == 0) && (t.max == -1))
</span><span class='uc' id='L1326' title='2|2|2 - Total: 2'>                    program[pc - 1] = (t.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
</span>                else
<span class='uc' id='L1328' title='4|4|4 - Total: 4'>                if ((t.min == 0) && (t.max == 1))
</span><span class='uc' id='L1329' title='2|2|2 - Total: 2'>                    program[pc - 1] = (t.greedy) ? REOP_OPT : REOP_MINIMALOPT;
</span>                else
<span class='uc' id='L1331' title='4|4|4 - Total: 4'>                if ((t.min == 1) && (t.max == -1))
</span><span class='uc' id='L1332' title='2|2|2 - Total: 2'>                    program[pc - 1] = (t.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
</span>                else {
<span class='uc' id='L1334' title='2|2|2 - Total: 2'>                    if (!t.greedy) program[pc - 1] = REOP_MINIMALQUANT;
</span><span class='uc' id='L1335' title='6|6|6 - Total: 6'>                    pc = addIndex(program, pc, t.min);
</span>                    // max can be -1 which addIndex does not accept
<span class='uc' id='L1337' title='8|8|8 - Total: 8'>                    pc = addIndex(program, pc, t.max + 1);
</span>                }
<span class='uc' id='L1339' title='6|6|6 - Total: 6'>                pc = addIndex(program, pc, t.parenCount);
</span><span class='uc' id='L1340' title='6|6|6 - Total: 6'>                pc = addIndex(program, pc, t.parenIndex);
</span><span class='uc' id='L1341' title='2|2|2 - Total: 2'>                nextTermFixup = pc;
</span><span class='uc' id='L1342' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1343' title='7|7|7 - Total: 7'>                pc = emitREBytecode(state, re, pc, t.kid);
</span><span class='uc' id='L1344' title='5|5|5 - Total: 5'>                program[pc++] = REOP_ENDCHILD;
</span><span class='uc' id='L1345' title='4|4|4 - Total: 4'>                resolveForwardJump(program, nextTermFixup, pc);
</span><span class='uc' id='L1346' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_CLASS:
<span class='uc' id='L1348' title='2|2|2 - Total: 2'>                if (!t.sense)
</span><span class='uc' id='L1349' title='6|6|6 - Total: 6'>                    program[pc - 1] = REOP_NCLASS;
</span><span class='uc' id='L1350' title='6|6|6 - Total: 6'>                pc = addIndex(program, pc, t.index);
</span><span class='uc' id='L1351' title='16|16|16 - Total: 16'>                re.classList[t.index] = new RECharSet(t.bmsize, t.startIndex,
</span>                                                      t.kidlen, t.sense);
<span class='uc' id='L1353' title='1|1|1 - Total: 1'>                break;
</span>            default:
                break;
            }
<span class='uc' id='L1357' title='4|4|4 - Total: 4'>            t = t.next;
</span>        }
<span class='uc' id='L1359' title='2|2|2 - Total: 2'>        return pc;
</span>    }

    private static void
    pushProgState(REGlobalData gData, int min, int max, int cp,
                  REBackTrackData backTrackLastToSave,
                  int continuationOp, int continuationPc)
    {
<span class='uc' id='L1367' title='13|13|13 - Total: 13'>        gData.stateStackTop = new REProgState(gData.stateStackTop, min, max,
</span>                                              cp, backTrackLastToSave,
                                              continuationOp, continuationPc);
<span class='uc' id='L1370' title='1|1|1 - Total: 1'>    }
</span>
    private static REProgState
    popProgState(REGlobalData gData)
    {
<span class='uc' id='L1375' title='3|3|3 - Total: 3'>        REProgState state = gData.stateStackTop;
</span><span class='uc' id='L1376' title='4|4|4 - Total: 4'>        gData.stateStackTop = state.previous;
</span><span class='uc' id='L1377' title='2|2|2 - Total: 2'>        return state;
</span>    }

    private static void
    pushBackTrackState(REGlobalData gData, byte op, int pc)
    {
<span class='uc' id='L1383' title='3|3|3 - Total: 3'>        REProgState state = gData.stateStackTop;
</span><span class='uc' id='L1384' title='14|14|14 - Total: 14'>        gData.backTrackStackTop = new REBackTrackData(gData, op, pc,
</span>                gData.cp, state.continuationOp, state.continuationPc);
<span class='uc' id='L1386' title='1|1|1 - Total: 1'>    }
</span>
    private static void
    pushBackTrackState(REGlobalData gData, byte op, int pc,
                       int cp, int continuationOp, int continuationPc)
    {
<span class='uc' id='L1392' title='11|11|11 - Total: 11'>        gData.backTrackStackTop = new REBackTrackData(gData, op, pc,
</span>                cp, continuationOp, continuationPc);
<span class='uc' id='L1394' title='1|1|1 - Total: 1'>    }
</span>
    /*
     *   Consecutive literal characters.
     */
    private static boolean
    flatNMatcher(REGlobalData gData, int matchChars,
                 int length, String input, int end)
    {
<span class='uc' id='L1403' title='2|2|2 - Total: 2'>        if ((gData.cp + length) > end)
</span><span class='uc' id='L1404' title='2|2|2 - Total: 2'>            return false;
</span><span class='uc' id='L1405' title='2|2|2 - Total: 2'>        for (int i = 0; i < length; i++) {
</span><span class='uc' id='L1406' title='2|2|2 - Total: 2'>            if (gData.regexp.source[matchChars + i] != input.charAt(gData.cp + i)) {
</span><span class='uc' id='L1407' title='2|2|2 - Total: 2'>                return false;
</span>            }
        }
<span class='uc' id='L1410' title='6|6|6 - Total: 6'>        gData.cp += length;
</span><span class='uc' id='L1411' title='2|2|2 - Total: 2'>        return true;
</span>    }

    private static boolean
    flatNIMatcher(REGlobalData gData, int matchChars,
                  int length, String input, int end)
    {
<span class='uc' id='L1418' title='2|2|2 - Total: 2'>        if ((gData.cp + length) > end)
</span><span class='uc' id='L1419' title='2|2|2 - Total: 2'>            return false;
</span><span class='uc' id='L1420' title='4|4|4 - Total: 4'>        char[] source = gData.regexp.source;
</span><span class='uc' id='L1421' title='2|2|2 - Total: 2'>        for (int i = 0; i < length; i++) {
</span><span class='uc' id='L1422' title='6|6|6 - Total: 6'>            char c1 = source[matchChars + i];
</span><span class='uc' id='L1423' title='7|7|7 - Total: 7'>            char c2 = input.charAt(gData.cp + i);
</span><span class='uc' id='L1424' title='4|4|4 - Total: 4'>            if (c1 != c2 && upcase(c1) != upcase(c2)) {
</span><span class='uc' id='L1425' title='2|2|2 - Total: 2'>                return false;
</span>            }
        }
<span class='uc' id='L1428' title='6|6|6 - Total: 6'>        gData.cp += length;
</span><span class='uc' id='L1429' title='2|2|2 - Total: 2'>        return true;
</span>    }

    /*
    1. Evaluate DecimalEscape to obtain an EscapeValue E.
    2. If E is not a character then go to step 6.
    3. Let ch be E's character.
    4. Let A be a one-element RECharSet containing the character ch.
    5. Call CharacterSetMatcher(A, false) and return its Matcher result.
    6. E must be an integer. Let n be that integer.
    7. If n=0 or n>NCapturingParens then throw a SyntaxError exception.
    8. Return an internal Matcher closure that takes two arguments, a State x
       and a Continuation c, and performs the following:
        1. Let cap be x's captures internal array.
        2. Let s be cap[n].
        3. If s is undefined, then call c(x) and return its result.
        4. Let e be x's endIndex.
        5. Let len be s's length.
        6. Let f be e+len.
        7. If f>InputLength, return failure.
        8. If there exists an integer i between 0 (inclusive) and len (exclusive)
           such that Canonicalize(s[i]) is not the same character as
           Canonicalize(Input [e+i]), then return failure.
        9. Let y be the State (f, cap).
        10. Call c(y) and return its result.
    */
    private static boolean
    backrefMatcher(REGlobalData gData, int parenIndex,
                   String input, int end)
    {
        int len;
        int i;
<span class='upc' id='L1461' title='2|2|2 - Total: 4'>        if (gData.parens == null || parenIndex >= gData.parens.length)
</span><span class='nc' id='L1462' title='0|0|0 - Total: 2'>            return false;
</span><span class='uc' id='L1463' title='4|4|4 - Total: 4'>        int parenContent = gData.parensIndex(parenIndex);
</span><span class='uc' id='L1464' title='2|2|2 - Total: 2'>        if (parenContent == -1)
</span><span class='uc' id='L1465' title='2|2|2 - Total: 2'>            return true;
</span>
<span class='uc' id='L1467' title='4|4|4 - Total: 4'>        len = gData.parensLength(parenIndex);
</span><span class='uc' id='L1468' title='2|2|2 - Total: 2'>        if ((gData.cp + len) > end)
</span><span class='uc' id='L1469' title='2|2|2 - Total: 2'>            return false;
</span>
<span class='uc' id='L1471' title='2|2|2 - Total: 2'>        if ((gData.regexp.flags & JSREG_FOLD) != 0) {
</span><span class='uc' id='L1472' title='2|2|2 - Total: 2'>            for (i = 0; i < len; i++) {
</span><span class='uc' id='L1473' title='6|6|6 - Total: 6'>                char c1 = input.charAt(parenContent + i);
</span><span class='uc' id='L1474' title='7|7|7 - Total: 7'>                char c2 = input.charAt(gData.cp + i);
</span><span class='upc' id='L1475' title='3|3|3 - Total: 4'>                if (c1 != c2 && upcase(c1) != upcase(c2))
</span><span class='nc' id='L1476' title='0|0|0 - Total: 2'>                    return false;
</span>            }
        }
<span class='uc' id='L1479' title='2|2|2 - Total: 2'>        else if (!input.regionMatches(parenContent, input, gData.cp, len)) {
</span><span class='uc' id='L1480' title='2|2|2 - Total: 2'>            return false;
</span>        }
<span class='uc' id='L1482' title='6|6|6 - Total: 6'>        gData.cp += len;
</span><span class='uc' id='L1483' title='2|2|2 - Total: 2'>        return true;
</span>    }


    /* Add a single character to the RECharSet */
    private static void
    addCharacterToCharSet(RECharSet cs, char c)
    {
<span class='uc' id='L1491' title='4|4|4 - Total: 4'>        int byteIndex = (c / 8);
</span><span class='upc' id='L1492' title='1|1|1 - Total: 2'>        if (c >= cs.length) {
</span><span class='nc' id='L1493' title='0|0|0 - Total: 4'>            throw ScriptRuntime.constructError("SyntaxError",
</span>                    "invalid range in character class");
        }
<span class='uc' id='L1496' title='13|13|13 - Total: 13'>        cs.bits[byteIndex] |= 1 << (c & 0x7);
</span><span class='uc' id='L1497' title='1|1|1 - Total: 1'>    }
</span>

    /* Add a character range, c1 to c2 (inclusive) to the RECharSet */
    private static void
    addCharacterRangeToCharSet(RECharSet cs, char c1, char c2)
    {
        int i;

<span class='uc' id='L1506' title='4|4|4 - Total: 4'>        int byteIndex1 = (c1 / 8);
</span><span class='uc' id='L1507' title='4|4|4 - Total: 4'>        int byteIndex2 = (c2 / 8);
</span>
<span class='upc' id='L1509' title='3|3|3 - Total: 4'>        if ((c2 >= cs.length) || (c1 > c2)) {
</span><span class='uc' id='L1510' title='4|4|4 - Total: 4'>            throw ScriptRuntime.constructError("SyntaxError",
</span>                    "invalid range in character class");
        }

<span class='uc' id='L1514' title='5|5|5 - Total: 5'>        c1 &= 0x7;
</span><span class='uc' id='L1515' title='5|5|5 - Total: 5'>        c2 &= 0x7;
</span>
<span class='uc' id='L1517' title='2|2|2 - Total: 2'>        if (byteIndex1 == byteIndex2) {
</span><span class='uc' id='L1518' title='18|18|18 - Total: 18'>            cs.bits[byteIndex1] |= ((0xFF) >> (7 - (c2 - c1))) << c1;
</span>        }
        else {
<span class='uc' id='L1521' title='11|11|11 - Total: 11'>            cs.bits[byteIndex1] |= 0xFF << c1;
</span><span class='uc' id='L1522' title='2|2|2 - Total: 2'>            for (i = byteIndex1 + 1; i < byteIndex2; i++)
</span><span class='uc' id='L1523' title='5|5|5 - Total: 5'>                cs.bits[i] = (byte)0xFF;
</span><span class='uc' id='L1524' title='13|13|13 - Total: 13'>            cs.bits[byteIndex2] |= (0xFF) >> (7 - c2);
</span>        }
<span class='uc' id='L1526' title='1|1|1 - Total: 1'>    }
</span>
    /* Compile the source of the class into a RECharSet */
    private static void
    processCharSet(REGlobalData gData, RECharSet charSet)
    {
<span class='uc' id='L1532' title='4|4|4 - Total: 4'>        synchronized (charSet) {
</span><span class='upc' id='L1533' title='1|1|1 - Total: 2'>            if (!charSet.converted) {
</span><span class='uc' id='L1534' title='3|3|3 - Total: 3'>                processCharSetImpl(gData, charSet);
</span><span class='uc' id='L1535' title='3|3|3 - Total: 3'>                charSet.converted = true;
</span>            }
<span class='uc' id='L1537' title='8|8|8 - Total: 8'>        }
</span><span class='uc' id='L1538' title='1|1|1 - Total: 1'>    }
</span>

    private static void
    processCharSetImpl(REGlobalData gData, RECharSet charSet)
    {
<span class='uc' id='L1544' title='3|3|3 - Total: 3'>        int src = charSet.startIndex;
</span><span class='uc' id='L1545' title='5|5|5 - Total: 5'>        int end = src + charSet.strlength;
</span>
<span class='uc' id='L1547' title='2|2|2 - Total: 2'>        char rangeStart = 0, thisCh;
</span>        int byteLength;
        char c;
        int n;
        int nDigits;
        int i;
<span class='uc' id='L1553' title='2|2|2 - Total: 2'>        boolean inRange = false;
</span>
<span class='uc' id='L1555' title='7|7|7 - Total: 7'>        byteLength = (charSet.length + 7) / 8;
</span><span class='uc' id='L1556' title='4|4|4 - Total: 4'>        charSet.bits = new byte[byteLength];
</span>
<span class='uc' id='L1558' title='2|2|2 - Total: 2'>        if (src == end)
</span><span class='uc' id='L1559' title='1|1|1 - Total: 1'>            return;
</span>
<span class='uc' id='L1561' title='2|2|2 - Total: 2'>        if (gData.regexp.source[src] == '^') {
</span><span class='upc' id='L1562' title='2|2|2 - Total: 4'>            assert (!charSet.sense);
</span><span class='uc' id='L1563' title='2|2|2 - Total: 2'>            ++src;
</span>        } else {
<span class='upc' id='L1565' title='2|2|2 - Total: 4'>            assert (charSet.sense);
</span>        }

<span class='uc' id='L1568' title='2|2|2 - Total: 2'>        while (src != end) {
</span><span class='uc' id='L1569' title='2|2|2 - Total: 2'>            nDigits = 2;
</span><span class='uc' id='L1570' title='2|2|2 - Total: 2'>            switch (gData.regexp.source[src]) {
</span>            case '\\':
<span class='uc' id='L1572' title='1|1|1 - Total: 1'>                ++src;
</span><span class='uc' id='L1573' title='7|7|7 - Total: 7'>                c = gData.regexp.source[src++];
</span><span class='upc' id='L1574' title='15|15|15 - Total: 17'>                switch (c) {
</span>                case 'b':
<span class='uc' id='L1576' title='2|2|2 - Total: 2'>                    thisCh = 0x8;
</span><span class='uc' id='L1577' title='1|1|1 - Total: 1'>                    break;
</span>                case 'f':
<span class='nc' id='L1579' title='0|0|0 - Total: 2'>                    thisCh = 0xC;
</span><span class='nc' id='L1580' title='0|0|0 - Total: 1'>                    break;
</span>                case 'n':
<span class='uc' id='L1582' title='2|2|2 - Total: 2'>                    thisCh = 0xA;
</span><span class='uc' id='L1583' title='1|1|1 - Total: 1'>                    break;
</span>                case 'r':
<span class='uc' id='L1585' title='2|2|2 - Total: 2'>                    thisCh = 0xD;
</span><span class='uc' id='L1586' title='1|1|1 - Total: 1'>                    break;
</span>                case 't':
<span class='uc' id='L1588' title='2|2|2 - Total: 2'>                    thisCh = 0x9;
</span><span class='uc' id='L1589' title='1|1|1 - Total: 1'>                    break;
</span>                case 'v':
<span class='nc' id='L1591' title='0|0|0 - Total: 2'>                    thisCh = 0xB;
</span><span class='nc' id='L1592' title='0|0|0 - Total: 1'>                    break;
</span>                case 'c':
<span class='upc' id='L1594' title='2|2|2 - Total: 4'>                    if ((src < end) && isControlLetter(gData.regexp.source[src]))
</span><span class='uc' id='L1595' title='11|11|11 - Total: 11'>                        thisCh = (char)(gData.regexp.source[src++] & 0x1F);
</span>                    else {
<span class='nc' id='L1597' title='0|0|0 - Total: 1'>                        --src;
</span><span class='nc' id='L1598' title='0|0|0 - Total: 2'>                        thisCh = '\\';
</span>                    }
<span class='nc' id='L1600' title='0|0|0 - Total: 1'>                    break;
</span>                case 'u':
<span class='uc' id='L1602' title='1|1|1 - Total: 1'>                    nDigits += 2;
</span>                    // fallthru
                case 'x':
<span class='uc' id='L1605' title='2|2|2 - Total: 2'>                    n = 0;
</span><span class='upc' id='L1606' title='3|3|3 - Total: 4'>                    for (i = 0; (i < nDigits) && (src < end); i++) {
</span><span class='uc' id='L1607' title='7|7|7 - Total: 7'>                        c = gData.regexp.source[src++];
</span><span class='uc' id='L1608' title='3|3|3 - Total: 3'>                        int digit = toASCIIHexDigit(c);
</span><span class='upc' id='L1609' title='1|1|1 - Total: 2'>                        if (digit < 0) {
</span>                            /* back off to accepting the original '\'
                             * as a literal
                             */
<span class='nc' id='L1613' title='0|0|0 - Total: 6'>                            src -= (i + 1);
</span><span class='nc' id='L1614' title='0|0|0 - Total: 2'>                            n = '\\';
</span><span class='nc' id='L1615' title='0|0|0 - Total: 1'>                            break;
</span>                        }
<span class='uc' id='L1617' title='6|6|6 - Total: 6'>                        n = (n << 4) | digit;
</span>                    }
<span class='uc' id='L1619' title='3|3|3 - Total: 3'>                    thisCh = (char)(n);
</span><span class='uc' id='L1620' title='1|1|1 - Total: 1'>                    break;
</span>                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    /*
                     *  This is a non-ECMA extension - decimal escapes (in this
                     *  case, octal!) are supposed to be an error inside class
                     *  ranges, but supported here for backwards compatibility.
                     *
                     */
<span class='uc' id='L1635' title='4|4|4 - Total: 4'>                    n = (c - '0');
</span><span class='uc' id='L1636' title='6|6|6 - Total: 6'>                    c = gData.regexp.source[src];
</span><span class='upc' id='L1637' title='2|2|2 - Total: 4'>                    if ('0' <= c && c <= '7') {
</span><span class='uc' id='L1638' title='1|1|1 - Total: 1'>                        src++;
</span><span class='uc' id='L1639' title='8|8|8 - Total: 8'>                        n = 8 * n + (c - '0');
</span><span class='uc' id='L1640' title='6|6|6 - Total: 6'>                        c = gData.regexp.source[src];
</span><span class='upc' id='L1641' title='2|2|2 - Total: 4'>                        if ('0' <= c && c <= '7') {
</span><span class='uc' id='L1642' title='1|1|1 - Total: 1'>                            src++;
</span><span class='uc' id='L1643' title='8|8|8 - Total: 8'>                            i = 8 * n + (c - '0');
</span><span class='upc' id='L1644' title='1|1|1 - Total: 2'>                            if (i <= 0377)
</span><span class='uc' id='L1645' title='3|3|3 - Total: 3'>                                n = i;
</span>                            else
<span class='nc' id='L1647' title='0|0|0 - Total: 1'>                                src--;
</span>                        }
                    }
<span class='uc' id='L1650' title='3|3|3 - Total: 3'>                    thisCh = (char)(n);
</span><span class='uc' id='L1651' title='1|1|1 - Total: 1'>                    break;
</span>
                case 'd':
<span class='uc' id='L1654' title='4|4|4 - Total: 4'>                    addCharacterRangeToCharSet(charSet, '0', '9');
</span><span class='uc' id='L1655' title='1|1|1 - Total: 1'>                    continue;   /* don't need range processing */
</span>                case 'D':
<span class='uc' id='L1657' title='4|4|4 - Total: 4'>                    addCharacterRangeToCharSet(charSet, (char)0, (char)('0' - 1));
</span><span class='uc' id='L1658' title='8|8|8 - Total: 8'>                    addCharacterRangeToCharSet(charSet, (char)('9' + 1),
</span>                                                (char)(charSet.length - 1));
<span class='uc' id='L1660' title='1|1|1 - Total: 1'>                    continue;
</span>                case 's':
<span class='uc' id='L1662' title='2|2|2 - Total: 2'>                    for (i = (charSet.length - 1); i >= 0; i--)
</span><span class='uc' id='L1663' title='2|2|2 - Total: 2'>                        if (isREWhiteSpace(i))
</span><span class='uc' id='L1664' title='4|4|4 - Total: 4'>                            addCharacterToCharSet(charSet, (char)(i));
</span>                    continue;
                case 'S':
<span class='uc' id='L1667' title='2|2|2 - Total: 2'>                    for (i = (charSet.length - 1); i >= 0; i--)
</span><span class='uc' id='L1668' title='2|2|2 - Total: 2'>                        if (!isREWhiteSpace(i))
</span><span class='uc' id='L1669' title='4|4|4 - Total: 4'>                            addCharacterToCharSet(charSet, (char)(i));
</span>                    continue;
                case 'w':
<span class='uc' id='L1672' title='2|2|2 - Total: 2'>                    for (i = (charSet.length - 1); i >= 0; i--)
</span><span class='uc' id='L1673' title='2|2|2 - Total: 2'>                        if (isWord((char)i))
</span><span class='uc' id='L1674' title='4|4|4 - Total: 4'>                            addCharacterToCharSet(charSet, (char)(i));
</span>                    continue;
                case 'W':
<span class='uc' id='L1677' title='2|2|2 - Total: 2'>                    for (i = (charSet.length - 1); i >= 0; i--)
</span><span class='uc' id='L1678' title='2|2|2 - Total: 2'>                        if (!isWord((char)i))
</span><span class='uc' id='L1679' title='4|4|4 - Total: 4'>                            addCharacterToCharSet(charSet, (char)(i));
</span>                    continue;
                default:
<span class='uc' id='L1682' title='2|2|2 - Total: 2'>                    thisCh = c;
</span><span class='uc' id='L1683' title='1|1|1 - Total: 1'>                    break;
</span>
                }
                break;

            default:
<span class='uc' id='L1689' title='7|7|7 - Total: 7'>                thisCh = gData.regexp.source[src++];
</span>                break;

            }
<span class='uc' id='L1693' title='2|2|2 - Total: 2'>            if (inRange) {
</span><span class='uc' id='L1694' title='2|2|2 - Total: 2'>                if ((gData.regexp.flags & JSREG_FOLD) != 0) {
</span><span class='upc' id='L1695' title='2|2|2 - Total: 4'>                    assert(rangeStart <= thisCh);
</span><span class='uc' id='L1696' title='2|2|2 - Total: 2'>                    for (c = rangeStart; c <= thisCh;) {
</span><span class='uc' id='L1697' title='3|3|3 - Total: 3'>                        addCharacterToCharSet(charSet, c);
</span><span class='uc' id='L1698' title='3|3|3 - Total: 3'>                        char uch = upcase(c);
</span><span class='uc' id='L1699' title='3|3|3 - Total: 3'>                        char dch = downcase(c);
</span><span class='uc' id='L1700' title='2|2|2 - Total: 2'>                        if (c != uch)
</span><span class='uc' id='L1701' title='3|3|3 - Total: 3'>                            addCharacterToCharSet(charSet, uch);
</span><span class='uc' id='L1702' title='2|2|2 - Total: 2'>                        if (c != dch)
</span><span class='uc' id='L1703' title='3|3|3 - Total: 3'>                            addCharacterToCharSet(charSet, dch);
</span><span class='uc' id='L1704' title='2|2|2 - Total: 2'>                        if (++c == 0)
</span><span class='uc' id='L1705' title='1|1|1 - Total: 1'>                            break; // overflow
</span><span class='uc' id='L1706' title='1|1|1 - Total: 1'>                    }
</span>                } else {
<span class='uc' id='L1708' title='4|4|4 - Total: 4'>                    addCharacterRangeToCharSet(charSet, rangeStart, thisCh);
</span>                }
<span class='uc' id='L1710' title='3|3|3 - Total: 3'>                inRange = false;
</span>            }
            else {
<span class='uc' id='L1713' title='2|2|2 - Total: 2'>                if ((gData.regexp.flags & JSREG_FOLD) != 0) {
</span><span class='uc' id='L1714' title='4|4|4 - Total: 4'>                    addCharacterToCharSet(charSet, upcase(thisCh));
</span><span class='uc' id='L1715' title='5|5|5 - Total: 5'>                    addCharacterToCharSet(charSet, downcase(thisCh));
</span>                } else {
<span class='uc' id='L1717' title='3|3|3 - Total: 3'>                    addCharacterToCharSet(charSet, thisCh);
</span>                }
<span class='uc' id='L1719' title='2|2|2 - Total: 2'>                if (src < (end - 1)) {
</span><span class='uc' id='L1720' title='2|2|2 - Total: 2'>                    if (gData.regexp.source[src] == '-') {
</span><span class='uc' id='L1721' title='1|1|1 - Total: 1'>                        ++src;
</span><span class='uc' id='L1722' title='2|2|2 - Total: 2'>                        inRange = true;
</span><span class='uc' id='L1723' title='3|3|3 - Total: 3'>                        rangeStart = thisCh;
</span>                    }
                }
            }
        }
<span class='uc' id='L1728' title='1|1|1 - Total: 1'>    }
</span>

    /*
     *   Initialize the character set if it this is the first call.
     *   Test the bit - if the ^ flag was specified, non-inclusion is a success
     */
    private static boolean
    classMatcher(REGlobalData gData, RECharSet charSet, char ch)
    {
<span class='uc' id='L1738' title='2|2|2 - Total: 2'>        if (!charSet.converted) {
</span><span class='uc' id='L1739' title='3|3|3 - Total: 3'>            processCharSet(gData, charSet);
</span>        }

<span class='uc' id='L1742' title='4|4|4 - Total: 4'>        int byteIndex = ch >> 3;
</span><span class='uc' id='L1743' title='6|6|6 - Total: 6'>        return (charSet.length == 0 ||
</span>                ch >= charSet.length ||
                (charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) ^ charSet.sense;
    }

    private static boolean reopIsSimple(int op) {
<span class='upc' id='L1749' title='3|3|3 - Total: 4'>        return op >= REOP_SIMPLE_START && op <= REOP_SIMPLE_END;
</span>    }

    /*
     *   Apply the current op against the given input to see if
     *   it's going to match or fail. Return false if we don't
     *   get a match, true if we do and update the state of the
     *   input and pc if the update flag is true.
     */
    private static int simpleMatch(REGlobalData gData, String input, int op,
                                   byte[] program, int pc, int end, boolean updatecp)
    {
<span class='uc' id='L1761' title='2|2|2 - Total: 2'>        boolean result = false;
</span>        char matchCh;
        int parenIndex;
        int offset, length, index;
<span class='uc' id='L1765' title='3|3|3 - Total: 3'>        int startcp = gData.cp;
</span>
<span class='upc' id='L1767' title='17|17|17 - Total: 21'>        switch (op) {
</span>            case REOP_EMPTY:
<span class='nc' id='L1769' title='0|0|0 - Total: 2'>                result = true;
</span><span class='nc' id='L1770' title='0|0|0 - Total: 1'>                break;
</span>            case REOP_BOL:
<span class='uc' id='L1772' title='2|2|2 - Total: 2'>                if (gData.cp != 0) {
</span><span class='uc' id='L1773' title='4|4|4 - Total: 4'>                    if (!gData.multiline || !isLineTerm(input.charAt(gData.cp - 1))) {
</span><span class='uc' id='L1774' title='1|1|1 - Total: 1'>                        break;
</span>                    }
                }
<span class='uc' id='L1777' title='2|2|2 - Total: 2'>                result = true;
</span><span class='uc' id='L1778' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_EOL:
<span class='uc' id='L1780' title='2|2|2 - Total: 2'>                if (gData.cp != end) {
</span><span class='uc' id='L1781' title='4|4|4 - Total: 4'>                    if (!gData.multiline || !isLineTerm(input.charAt(gData.cp))) {
</span><span class='uc' id='L1782' title='1|1|1 - Total: 1'>                        break;
</span>                    }
                }
<span class='uc' id='L1785' title='2|2|2 - Total: 2'>                result = true;
</span><span class='uc' id='L1786' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_WBDRY:
<span class='uc' id='L1788' title='6|6|6 - Total: 6'>                result = ((gData.cp == 0 || !isWord(input.charAt(gData.cp - 1)))
</span><span class='uc' id='L1789' title='2|2|2 - Total: 2'>                        ^ !((gData.cp < end) && isWord(input.charAt(gData.cp))));
</span><span class='uc' id='L1790' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_WNONBDRY:
<span class='uc' id='L1792' title='6|6|6 - Total: 6'>                result = ((gData.cp == 0 || !isWord(input.charAt(gData.cp - 1)))
</span><span class='uc' id='L1793' title='2|2|2 - Total: 2'>                        ^ ((gData.cp < end) && isWord(input.charAt(gData.cp))));
</span><span class='uc' id='L1794' title='1|1|1 - Total: 1'>                break;
</span>            case REOP_DOT:
<span class='uc' id='L1796' title='4|4|4 - Total: 4'>                if (gData.cp != end && !isLineTerm(input.charAt(gData.cp))) {
</span><span class='uc' id='L1797' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1798' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_DIGIT:
<span class='uc' id='L1802' title='4|4|4 - Total: 4'>                if (gData.cp != end && isDigit(input.charAt(gData.cp))) {
</span><span class='uc' id='L1803' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1804' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_NONDIGIT:
<span class='uc' id='L1808' title='4|4|4 - Total: 4'>                if (gData.cp != end && !isDigit(input.charAt(gData.cp))) {
</span><span class='uc' id='L1809' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1810' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_ALNUM:
<span class='uc' id='L1814' title='4|4|4 - Total: 4'>                if (gData.cp != end && isWord(input.charAt(gData.cp))) {
</span><span class='uc' id='L1815' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1816' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_NONALNUM:
<span class='uc' id='L1820' title='4|4|4 - Total: 4'>                if (gData.cp != end && !isWord(input.charAt(gData.cp))) {
</span><span class='uc' id='L1821' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1822' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_SPACE:
<span class='uc' id='L1826' title='4|4|4 - Total: 4'>                if (gData.cp != end && isREWhiteSpace(input.charAt(gData.cp))) {
</span><span class='uc' id='L1827' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1828' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_NONSPACE:
<span class='uc' id='L1832' title='4|4|4 - Total: 4'>                if (gData.cp != end && !isREWhiteSpace(input.charAt(gData.cp))) {
</span><span class='uc' id='L1833' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1834' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
                break;
            case REOP_BACKREF:
            {
<span class='uc' id='L1839' title='4|4|4 - Total: 4'>                parenIndex = getIndex(program, pc);
</span><span class='uc' id='L1840' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1841' title='6|6|6 - Total: 6'>                result = backrefMatcher(gData, parenIndex, input, end);
</span>            }
<span class='uc' id='L1843' title='1|1|1 - Total: 1'>            break;
</span>            case REOP_FLAT:
            {
<span class='uc' id='L1846' title='4|4|4 - Total: 4'>                offset = getIndex(program, pc);
</span><span class='uc' id='L1847' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1848' title='4|4|4 - Total: 4'>                length = getIndex(program, pc);
</span><span class='uc' id='L1849' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1850' title='7|7|7 - Total: 7'>                result = flatNMatcher(gData, offset, length, input, end);
</span>            }
<span class='uc' id='L1852' title='1|1|1 - Total: 1'>            break;
</span>            case REOP_FLAT1:
            {
<span class='uc' id='L1855' title='8|8|8 - Total: 8'>                matchCh = (char)(program[pc++] & 0xFF);
</span><span class='uc' id='L1856' title='4|4|4 - Total: 4'>                if (gData.cp != end && input.charAt(gData.cp) == matchCh) {
</span><span class='uc' id='L1857' title='2|2|2 - Total: 2'>                    result = true;
</span><span class='uc' id='L1858' title='7|7|7 - Total: 7'>                    gData.cp++;
</span>                }
            }
            break;
            case REOP_FLATi:
            {
<span class='uc' id='L1864' title='4|4|4 - Total: 4'>                offset = getIndex(program, pc);
</span><span class='uc' id='L1865' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1866' title='4|4|4 - Total: 4'>                length = getIndex(program, pc);
</span><span class='uc' id='L1867' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1868' title='7|7|7 - Total: 7'>                result = flatNIMatcher(gData, offset, length, input, end);
</span>            }
<span class='uc' id='L1870' title='1|1|1 - Total: 1'>            break;
</span>            case REOP_FLAT1i:
            {
<span class='uc' id='L1873' title='8|8|8 - Total: 8'>                matchCh = (char)(program[pc++] & 0xFF);
</span><span class='uc' id='L1874' title='2|2|2 - Total: 2'>                if (gData.cp != end) {
</span><span class='uc' id='L1875' title='5|5|5 - Total: 5'>                    char c = input.charAt(gData.cp);
</span><span class='uc' id='L1876' title='4|4|4 - Total: 4'>                    if (matchCh == c || upcase(matchCh) == upcase(c)) {
</span><span class='uc' id='L1877' title='2|2|2 - Total: 2'>                        result = true;
</span><span class='uc' id='L1878' title='6|6|6 - Total: 6'>                        gData.cp++;
</span>                    }
<span class='uc' id='L1880' title='1|1|1 - Total: 1'>                }
</span>            }
            break;
            case REOP_UCFLAT1:
            {
<span class='nc' id='L1885' title='0|0|0 - Total: 5'>                matchCh = (char)getIndex(program, pc);
</span><span class='nc' id='L1886' title='0|0|0 - Total: 1'>                pc += INDEX_LEN;
</span><span class='nc' id='L1887' title='0|0|0 - Total: 4'>                if (gData.cp != end && input.charAt(gData.cp) == matchCh) {
</span><span class='nc' id='L1888' title='0|0|0 - Total: 2'>                    result = true;
</span><span class='nc' id='L1889' title='0|0|0 - Total: 7'>                    gData.cp++;
</span>                }
            }
            break;
            case REOP_UCFLAT1i:
            {
<span class='nc' id='L1895' title='0|0|0 - Total: 5'>                matchCh = (char)getIndex(program, pc);
</span><span class='nc' id='L1896' title='0|0|0 - Total: 1'>                pc += INDEX_LEN;
</span><span class='nc' id='L1897' title='0|0|0 - Total: 2'>                if (gData.cp != end) {
</span><span class='nc' id='L1898' title='0|0|0 - Total: 5'>                    char c = input.charAt(gData.cp);
</span><span class='nc' id='L1899' title='0|0|0 - Total: 4'>                    if (matchCh == c || upcase(matchCh) == upcase(c)) {
</span><span class='nc' id='L1900' title='0|0|0 - Total: 2'>                        result = true;
</span><span class='nc' id='L1901' title='0|0|0 - Total: 6'>                        gData.cp++;
</span>                    }
<span class='nc' id='L1903' title='0|0|0 - Total: 1'>                }
</span>            }
            break;

            case REOP_CLASS:
            case REOP_NCLASS:
            {
<span class='uc' id='L1910' title='4|4|4 - Total: 4'>                index = getIndex(program, pc);
</span><span class='uc' id='L1911' title='1|1|1 - Total: 1'>                pc += INDEX_LEN;
</span><span class='uc' id='L1912' title='2|2|2 - Total: 2'>                if (gData.cp != end) {
</span><span class='uc' id='L1913' title='2|2|2 - Total: 2'>                    if (classMatcher(gData, gData.regexp.classList[index],
</span><span class='uc' id='L1914' title='1|1|1 - Total: 1'>                            input.charAt(gData.cp)))
</span>                    {
<span class='uc' id='L1916' title='6|6|6 - Total: 6'>                        gData.cp++;
</span><span class='uc' id='L1917' title='2|2|2 - Total: 2'>                        result = true;
</span><span class='uc' id='L1918' title='1|1|1 - Total: 1'>                        break;
</span>                    }
                }
            }
            break;

            default:
<span class='nc' id='L1925' title='0|0|0 - Total: 2'>                throw Kit.codeBug();
</span>        }
<span class='uc' id='L1927' title='2|2|2 - Total: 2'>        if (result) {
</span><span class='uc' id='L1928' title='2|2|2 - Total: 2'>            if (!updatecp)
</span><span class='uc' id='L1929' title='3|3|3 - Total: 3'>                gData.cp = startcp;
</span><span class='uc' id='L1930' title='2|2|2 - Total: 2'>            return pc;
</span>        }
<span class='uc' id='L1932' title='3|3|3 - Total: 3'>        gData.cp = startcp;
</span><span class='uc' id='L1933' title='2|2|2 - Total: 2'>        return -1;
</span>    }


    private static boolean
    executeREBytecode(REGlobalData gData, String input, int end)
    {
<span class='uc' id='L1940' title='2|2|2 - Total: 2'>        int pc = 0;
</span><span class='uc' id='L1941' title='4|4|4 - Total: 4'>        byte program[] = gData.regexp.program;
</span><span class='uc' id='L1942' title='2|2|2 - Total: 2'>        int continuationOp = REOP_END;
</span><span class='uc' id='L1943' title='2|2|2 - Total: 2'>        int continuationPc = 0;
</span><span class='uc' id='L1944' title='2|2|2 - Total: 2'>        boolean result = false;
</span>
<span class='uc' id='L1946' title='5|5|5 - Total: 5'>        int op = program[pc++];
</span>
        /*
         * If the first node is a simple match, step the index into the string
         * until that match is made, or fail if it can't be found at all.
         */
<span class='uc' id='L1952' title='4|4|4 - Total: 4'>        if (gData.regexp.anchorCh < 0 && reopIsSimple(op)) {
</span><span class='uc' id='L1953' title='2|2|2 - Total: 2'>            boolean anchor = false;
</span><span class='uc' id='L1954' title='2|2|2 - Total: 2'>            while (gData.cp <= end) {
</span><span class='uc' id='L1955' title='9|9|9 - Total: 9'>                int match = simpleMatch(gData, input, op, program, pc, end, true);
</span><span class='uc' id='L1956' title='2|2|2 - Total: 2'>                if (match >= 0) {
</span><span class='uc' id='L1957' title='2|2|2 - Total: 2'>                    anchor = true;
</span><span class='uc' id='L1958' title='2|2|2 - Total: 2'>                    pc = match;    /* accept skip to next opcode */
</span><span class='uc' id='L1959' title='5|5|5 - Total: 5'>                    op = program[pc++];
</span><span class='uc' id='L1960' title='1|1|1 - Total: 1'>                    break;
</span>                }
<span class='uc' id='L1962' title='6|6|6 - Total: 6'>                gData.skipped++;
</span><span class='uc' id='L1963' title='6|6|6 - Total: 6'>                gData.cp++;
</span><span class='uc' id='L1964' title='1|1|1 - Total: 1'>            }
</span><span class='uc' id='L1965' title='2|2|2 - Total: 2'>            if (!anchor)
</span><span class='uc' id='L1966' title='2|2|2 - Total: 2'>                return false;
</span>        }

        for (;;) {

<span class='uc' id='L1971' title='2|2|2 - Total: 2'>            if (reopIsSimple(op)) {
</span><span class='uc' id='L1972' title='9|9|9 - Total: 9'>                int match = simpleMatch(gData, input, op, program, pc, end, true);
</span><span class='uc' id='L1973' title='2|2|2 - Total: 2'>                result = match >= 0;
</span><span class='uc' id='L1974' title='2|2|2 - Total: 2'>                if (result)
</span><span class='uc' id='L1975' title='2|2|2 - Total: 2'>                    pc = match;    /* accept skip to next opcode */
</span><span class='uc' id='L1976' title='1|1|1 - Total: 1'>            } else {
</span>                switchStatement:
<span class='upc' id='L1978' title='13|13|13 - Total: 14'>                switch (op) {
</span>                    case REOP_ALTPREREQ:
                    case REOP_ALTPREREQi:
                    case REOP_ALTPREREQ2:
                    {
<span class='uc' id='L1983' title='5|5|5 - Total: 5'>                        char matchCh1 = (char)getIndex(program, pc);
</span><span class='uc' id='L1984' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;
</span><span class='uc' id='L1985' title='5|5|5 - Total: 5'>                        char matchCh2 = (char)getIndex(program, pc);
</span><span class='uc' id='L1986' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;
</span>
<span class='uc' id='L1988' title='2|2|2 - Total: 2'>                        if (gData.cp == end) {
</span><span class='uc' id='L1989' title='2|2|2 - Total: 2'>                            result = false;
</span><span class='uc' id='L1990' title='1|1|1 - Total: 1'>                            break;
</span>                        }
<span class='uc' id='L1992' title='5|5|5 - Total: 5'>                        char c = input.charAt(gData.cp);
</span><span class='uc' id='L1993' title='2|2|2 - Total: 2'>                        if (op == REOP_ALTPREREQ2) {
</span><span class='uc' id='L1994' title='2|2|2 - Total: 2'>                            if (c != matchCh1 &&
</span><span class='uc' id='L1995' title='2|2|2 - Total: 2'>                                !classMatcher(gData, gData.regexp.classList[matchCh2], c)) {
</span><span class='uc' id='L1996' title='2|2|2 - Total: 2'>                                result = false;
</span><span class='uc' id='L1997' title='1|1|1 - Total: 1'>                                break;
</span>                            }
                        } else {
<span class='uc' id='L2000' title='2|2|2 - Total: 2'>                            if (op == REOP_ALTPREREQi)
</span><span class='uc' id='L2001' title='3|3|3 - Total: 3'>                                c = upcase(c);
</span><span class='uc' id='L2002' title='4|4|4 - Total: 4'>                            if (c != matchCh1 && c != matchCh2) {
</span><span class='uc' id='L2003' title='2|2|2 - Total: 2'>                                result = false;
</span><span class='uc' id='L2004' title='1|1|1 - Total: 1'>                                break;
</span>                            }
                        }
                    }
                    /* else false thru... */
                    // fallthru
                    case REOP_ALT:
                    {
<span class='uc' id='L2012' title='6|6|6 - Total: 6'>                        int nextpc = pc + getOffset(program, pc);
</span><span class='uc' id='L2013' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;
</span><span class='uc' id='L2014' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span><span class='uc' id='L2015' title='3|3|3 - Total: 3'>                        int startcp = gData.cp;
</span><span class='uc' id='L2016' title='2|2|2 - Total: 2'>                        if (reopIsSimple(op)) {
</span><span class='uc' id='L2017' title='9|9|9 - Total: 9'>                            int match = simpleMatch(gData, input, op, program, pc, end, true);
</span><span class='uc' id='L2018' title='2|2|2 - Total: 2'>                            if (match < 0) {
</span><span class='uc' id='L2019' title='5|5|5 - Total: 5'>                                op = program[nextpc++];
</span><span class='uc' id='L2020' title='2|2|2 - Total: 2'>                                pc = nextpc;
</span><span class='uc' id='L2021' title='1|1|1 - Total: 1'>                                continue;
</span>                            }
<span class='uc' id='L2023' title='2|2|2 - Total: 2'>                            result = true;
</span><span class='uc' id='L2024' title='2|2|2 - Total: 2'>                            pc = match;
</span><span class='uc' id='L2025' title='5|5|5 - Total: 5'>                            op = program[pc++];
</span>                        }
<span class='uc' id='L2027' title='5|5|5 - Total: 5'>                        byte nextop = program[nextpc++];
</span><span class='uc' id='L2028' title='7|7|7 - Total: 7'>                        pushBackTrackState(gData, nextop, nextpc, startcp,
</span>                                continuationOp, continuationPc);
                    }
<span class='uc' id='L2031' title='1|1|1 - Total: 1'>                    continue;
</span>
                    case REOP_JUMP:
                    {
<span class='uc' id='L2035' title='4|4|4 - Total: 4'>                        int offset = getOffset(program, pc);
</span><span class='uc' id='L2036' title='4|4|4 - Total: 4'>                        pc += offset;
</span><span class='uc' id='L2037' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span>                    }
<span class='uc' id='L2039' title='1|1|1 - Total: 1'>                    continue;
</span>

                    case REOP_LPAREN:
                    {
<span class='uc' id='L2044' title='4|4|4 - Total: 4'>                        int parenIndex = getIndex(program, pc);
</span><span class='uc' id='L2045' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;
</span><span class='uc' id='L2046' title='6|6|6 - Total: 6'>                        gData.setParens(parenIndex, gData.cp, 0);
</span><span class='uc' id='L2047' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span>                    }
<span class='uc' id='L2049' title='1|1|1 - Total: 1'>                    continue;
</span>                    case REOP_RPAREN:
                    {
<span class='uc' id='L2052' title='4|4|4 - Total: 4'>                        int parenIndex = getIndex(program, pc);
</span><span class='uc' id='L2053' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;
</span><span class='uc' id='L2054' title='4|4|4 - Total: 4'>                        int cap_index = gData.parensIndex(parenIndex);
</span><span class='uc' id='L2055' title='8|8|8 - Total: 8'>                        gData.setParens(parenIndex, cap_index,
</span>                                gData.cp - cap_index);
<span class='uc' id='L2057' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span>                    }
<span class='uc' id='L2059' title='1|1|1 - Total: 1'>                    continue;
</span>
                    case REOP_ASSERT:
                    {
<span class='uc' id='L2063' title='6|6|6 - Total: 6'>                        int nextpc = pc + getIndex(program, pc); /* start of term after ASSERT */
</span><span class='uc' id='L2064' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;                         /* start of ASSERT child */
</span><span class='uc' id='L2065' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span><span class='uc' id='L2066' title='4|4|4 - Total: 4'>                        if (reopIsSimple(op) && simpleMatch(gData, input, op, program, pc, end, false) < 0) {
</span><span class='uc' id='L2067' title='2|2|2 - Total: 2'>                            result = false;
</span><span class='uc' id='L2068' title='1|1|1 - Total: 1'>                            break;
</span>                        }
<span class='uc' id='L2070' title='10|10|10 - Total: 10'>                        pushProgState(gData, 0, 0, gData.cp, gData.backTrackStackTop,
</span>                                continuationOp, continuationPc);
<span class='uc' id='L2072' title='4|4|4 - Total: 4'>                        pushBackTrackState(gData, REOP_ASSERTTEST, nextpc);
</span>                    }
<span class='uc' id='L2074' title='1|1|1 - Total: 1'>                    continue;
</span>                    case REOP_ASSERT_NOT:
                    {
<span class='uc' id='L2077' title='6|6|6 - Total: 6'>                        int nextpc = pc + getIndex(program, pc); /* start of term after ASSERT */
</span><span class='uc' id='L2078' title='1|1|1 - Total: 1'>                        pc += INDEX_LEN;                         /* start of ASSERT child */
</span><span class='uc' id='L2079' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span><span class='uc' id='L2080' title='2|2|2 - Total: 2'>                        if (reopIsSimple(op)) {
</span><span class='uc' id='L2081' title='9|9|9 - Total: 9'>                            int match = simpleMatch(gData, input, op, program, pc, end, false);
</span><span class='uc' id='L2082' title='4|4|4 - Total: 4'>                            if (match >= 0 && program[match] == REOP_ASSERTNOTTEST) {
</span><span class='uc' id='L2083' title='2|2|2 - Total: 2'>                                result = false;
</span><span class='uc' id='L2084' title='1|1|1 - Total: 1'>                                break;
</span>                            }
                        }
<span class='uc' id='L2087' title='10|10|10 - Total: 10'>                        pushProgState(gData, 0, 0, gData.cp, gData.backTrackStackTop,
</span>                                continuationOp, continuationPc);
<span class='uc' id='L2089' title='4|4|4 - Total: 4'>                        pushBackTrackState(gData, REOP_ASSERTNOTTEST, nextpc);
</span>                    }
<span class='uc' id='L2091' title='1|1|1 - Total: 1'>                    continue;
</span>
                    case REOP_ASSERTTEST:
                    case REOP_ASSERTNOTTEST:
                    {
<span class='uc' id='L2096' title='3|3|3 - Total: 3'>                        REProgState state = popProgState(gData);
</span><span class='uc' id='L2097' title='4|4|4 - Total: 4'>                        gData.cp = state.index;
</span><span class='uc' id='L2098' title='4|4|4 - Total: 4'>                        gData.backTrackStackTop = state.backTrack;
</span><span class='uc' id='L2099' title='3|3|3 - Total: 3'>                        continuationPc = state.continuationPc;
</span><span class='uc' id='L2100' title='3|3|3 - Total: 3'>                        continuationOp = state.continuationOp;
</span><span class='uc' id='L2101' title='2|2|2 - Total: 2'>                        if (op == REOP_ASSERTNOTTEST) {
</span><span class='uc' id='L2102' title='2|2|2 - Total: 2'>                            result = !result;
</span>                        }
                    }
<span class='uc' id='L2105' title='1|1|1 - Total: 1'>                    break;
</span>
                    case REOP_STAR:
                    case REOP_PLUS:
                    case REOP_OPT:
                    case REOP_QUANT:
                    case REOP_MINIMALSTAR:
                    case REOP_MINIMALPLUS:
                    case REOP_MINIMALOPT:
                    case REOP_MINIMALQUANT:
                    {
                        int min, max;
<span class='uc' id='L2117' title='2|2|2 - Total: 2'>                        boolean greedy = false;
</span><span class='upc' id='L2118' title='8|8|8 - Total: 9'>                        switch (op) {
</span>                            case REOP_STAR:
<span class='uc' id='L2120' title='2|2|2 - Total: 2'>                                greedy = true;
</span>                                // fallthrough
                            case REOP_MINIMALSTAR:
<span class='uc' id='L2123' title='2|2|2 - Total: 2'>                                min = 0;
</span><span class='uc' id='L2124' title='2|2|2 - Total: 2'>                                max = -1;
</span><span class='uc' id='L2125' title='1|1|1 - Total: 1'>                                break;
</span>                            case REOP_PLUS:
<span class='uc' id='L2127' title='2|2|2 - Total: 2'>                                greedy = true;
</span>                                // fallthrough
                            case REOP_MINIMALPLUS:
<span class='uc' id='L2130' title='2|2|2 - Total: 2'>                                min = 1;
</span><span class='uc' id='L2131' title='2|2|2 - Total: 2'>                                max = -1;
</span><span class='uc' id='L2132' title='1|1|1 - Total: 1'>                                break;
</span>                            case REOP_OPT:
<span class='uc' id='L2134' title='2|2|2 - Total: 2'>                                greedy = true;
</span>                                // fallthrough
                            case REOP_MINIMALOPT:
<span class='uc' id='L2137' title='2|2|2 - Total: 2'>                                min = 0;
</span><span class='uc' id='L2138' title='2|2|2 - Total: 2'>                                max = 1;
</span><span class='uc' id='L2139' title='1|1|1 - Total: 1'>                                break;
</span>                            case REOP_QUANT:
<span class='uc' id='L2141' title='2|2|2 - Total: 2'>                                greedy = true;
</span>                                // fallthrough
                            case REOP_MINIMALQUANT:
<span class='uc' id='L2144' title='4|4|4 - Total: 4'>                                min = getOffset(program, pc);
</span><span class='uc' id='L2145' title='1|1|1 - Total: 1'>                                pc += INDEX_LEN;
</span>                                // See comments in emitREBytecode for " - 1" reason
<span class='uc' id='L2147' title='6|6|6 - Total: 6'>                                max = getOffset(program, pc) - 1;
</span><span class='uc' id='L2148' title='1|1|1 - Total: 1'>                                pc += INDEX_LEN;
</span><span class='uc' id='L2149' title='1|1|1 - Total: 1'>                                break;
</span>                            default:
<span class='nc' id='L2151' title='0|0|0 - Total: 2'>                                throw Kit.codeBug();
</span>                        }
<span class='uc' id='L2153' title='9|9|9 - Total: 9'>                        pushProgState(gData, min, max, gData.cp, null,
</span>                                continuationOp, continuationPc);
<span class='uc' id='L2155' title='2|2|2 - Total: 2'>                        if (greedy) {
</span><span class='uc' id='L2156' title='4|4|4 - Total: 4'>                            pushBackTrackState(gData, REOP_REPEAT, pc);
</span><span class='uc' id='L2157' title='2|2|2 - Total: 2'>                            continuationOp = REOP_REPEAT;
</span><span class='uc' id='L2158' title='2|2|2 - Total: 2'>                            continuationPc = pc;
</span>                            /* Step over <parencount>, <parenindex> & <next> */
<span class='uc' id='L2160' title='1|1|1 - Total: 1'>                            pc += 3 * INDEX_LEN;
</span><span class='uc' id='L2161' title='6|6|6 - Total: 6'>                            op = program[pc++];
</span>                        } else {
<span class='uc' id='L2163' title='2|2|2 - Total: 2'>                            if (min != 0) {
</span><span class='uc' id='L2164' title='2|2|2 - Total: 2'>                                continuationOp = REOP_MINIMALREPEAT;
</span><span class='uc' id='L2165' title='2|2|2 - Total: 2'>                                continuationPc = pc;
</span>                                /* <parencount> <parenindex> & <next> */
<span class='uc' id='L2167' title='1|1|1 - Total: 1'>                                pc += 3 * INDEX_LEN;
</span><span class='uc' id='L2168' title='6|6|6 - Total: 6'>                                op = program[pc++];
</span>                            } else {
<span class='uc' id='L2170' title='4|4|4 - Total: 4'>                                pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
</span><span class='uc' id='L2171' title='3|3|3 - Total: 3'>                                popProgState(gData);
</span><span class='uc' id='L2172' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;  // <parencount> & <parenindex>
</span><span class='uc' id='L2173' title='6|6|6 - Total: 6'>                                pc = pc + getOffset(program, pc);
</span><span class='uc' id='L2174' title='5|5|5 - Total: 5'>                                op = program[pc++];
</span>                            }
                        }
                    }
<span class='uc' id='L2178' title='1|1|1 - Total: 1'>                    continue;
</span>
                    case REOP_ENDCHILD: /* marks the end of a quantifier child */
                        // If we have not gotten a result here, it is because of an
                        // empty match.  Do the same thing REOP_EMPTY would do.
<span class='uc' id='L2183' title='2|2|2 - Total: 2'>                        result = true;
</span>                        // Use the current continuation.
<span class='uc' id='L2185' title='2|2|2 - Total: 2'>                        pc = continuationPc;
</span><span class='uc' id='L2186' title='2|2|2 - Total: 2'>                        op = continuationOp;
</span><span class='uc' id='L2187' title='1|1|1 - Total: 1'>                        continue;
</span>
                    case REOP_REPEAT:
                    {
                        int nextpc, nextop;
                        do {
<span class='uc' id='L2193' title='3|3|3 - Total: 3'>                            REProgState state = popProgState(gData);
</span><span class='uc' id='L2194' title='2|2|2 - Total: 2'>                            if (!result) {
</span>                                // Failed, see if we have enough children.
<span class='uc' id='L2196' title='2|2|2 - Total: 2'>                                if (state.min == 0)
</span><span class='uc' id='L2197' title='2|2|2 - Total: 2'>                                    result = true;
</span><span class='uc' id='L2198' title='3|3|3 - Total: 3'>                                continuationPc = state.continuationPc;
</span><span class='uc' id='L2199' title='3|3|3 - Total: 3'>                                continuationOp = state.continuationOp;
</span><span class='uc' id='L2200' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;  /* <parencount> & <parenindex> */
</span><span class='uc' id='L2201' title='6|6|6 - Total: 6'>                                pc += getOffset(program, pc);
</span><span class='uc' id='L2202' title='1|1|1 - Total: 1'>                                break switchStatement;
</span>                            }
<span class='uc' id='L2204' title='4|4|4 - Total: 4'>                            if (state.min == 0 && gData.cp == state.index) {
</span>                                // matched an empty string, that'll get us nowhere
<span class='uc' id='L2206' title='2|2|2 - Total: 2'>                                result = false;
</span><span class='uc' id='L2207' title='3|3|3 - Total: 3'>                                continuationPc = state.continuationPc;
</span><span class='uc' id='L2208' title='3|3|3 - Total: 3'>                                continuationOp = state.continuationOp;
</span><span class='uc' id='L2209' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;
</span><span class='uc' id='L2210' title='6|6|6 - Total: 6'>                                pc += getOffset(program, pc);
</span><span class='uc' id='L2211' title='1|1|1 - Total: 1'>                                break switchStatement;
</span>                            }
<span class='uc' id='L2213' title='6|6|6 - Total: 6'>                            int new_min = state.min, new_max = state.max;
</span><span class='uc' id='L2214' title='2|2|2 - Total: 2'>                            if (new_min != 0) new_min--;
</span><span class='uc' id='L2215' title='2|2|2 - Total: 2'>                            if (new_max != -1) new_max--;
</span><span class='uc' id='L2216' title='2|2|2 - Total: 2'>                            if (new_max == 0) {
</span><span class='uc' id='L2217' title='2|2|2 - Total: 2'>                                result = true;
</span><span class='uc' id='L2218' title='3|3|3 - Total: 3'>                                continuationPc = state.continuationPc;
</span><span class='uc' id='L2219' title='3|3|3 - Total: 3'>                                continuationOp = state.continuationOp;
</span><span class='uc' id='L2220' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;
</span><span class='uc' id='L2221' title='6|6|6 - Total: 6'>                                pc += getOffset(program, pc);
</span><span class='uc' id='L2222' title='1|1|1 - Total: 1'>                                break switchStatement;
</span>                            }
<span class='uc' id='L2224' title='4|4|4 - Total: 4'>                            nextpc = pc + 3 * INDEX_LEN;
</span><span class='uc' id='L2225' title='4|4|4 - Total: 4'>                            nextop = program[nextpc];
</span><span class='uc' id='L2226' title='3|3|3 - Total: 3'>                            int startcp = gData.cp;
</span><span class='uc' id='L2227' title='2|2|2 - Total: 2'>                            if (reopIsSimple(nextop)) {
</span><span class='uc' id='L2228' title='1|1|1 - Total: 1'>                                nextpc++;
</span><span class='uc' id='L2229' title='9|9|9 - Total: 9'>                                int match = simpleMatch(gData, input, nextop, program, nextpc, end, true);
</span><span class='uc' id='L2230' title='2|2|2 - Total: 2'>                                if (match < 0) {
</span><span class='uc' id='L2231' title='2|2|2 - Total: 2'>                                    result = (new_min == 0);
</span><span class='uc' id='L2232' title='3|3|3 - Total: 3'>                                    continuationPc = state.continuationPc;
</span><span class='uc' id='L2233' title='3|3|3 - Total: 3'>                                    continuationOp = state.continuationOp;
</span><span class='uc' id='L2234' title='1|1|1 - Total: 1'>                                    pc += 2 * INDEX_LEN;  /* <parencount> & <parenindex> */
</span><span class='uc' id='L2235' title='6|6|6 - Total: 6'>                                    pc += getOffset(program, pc);
</span><span class='uc' id='L2236' title='1|1|1 - Total: 1'>                                    break switchStatement;
</span>                                }
<span class='uc' id='L2238' title='2|2|2 - Total: 2'>                                result = true;
</span><span class='uc' id='L2239' title='2|2|2 - Total: 2'>                                nextpc = match;
</span>                            }
<span class='uc' id='L2241' title='2|2|2 - Total: 2'>                            continuationOp = REOP_REPEAT;
</span><span class='uc' id='L2242' title='2|2|2 - Total: 2'>                            continuationPc = pc;
</span><span class='uc' id='L2243' title='10|10|10 - Total: 10'>                            pushProgState(gData, new_min, new_max, startcp, null,
</span>                                    state.continuationOp, state.continuationPc);
<span class='uc' id='L2245' title='2|2|2 - Total: 2'>                            if (new_min == 0) {
</span><span class='uc' id='L2246' title='9|9|9 - Total: 9'>                                pushBackTrackState(gData, REOP_REPEAT, pc, startcp,
</span>                                        state.continuationOp, state.continuationPc);
<span class='uc' id='L2248' title='4|4|4 - Total: 4'>                                int parenCount = getIndex(program, pc);
</span><span class='uc' id='L2249' title='6|6|6 - Total: 6'>                                int parenIndex = getIndex(program, pc + INDEX_LEN);
</span><span class='uc' id='L2250' title='2|2|2 - Total: 2'>                                for (int k = 0; k < parenCount; k++) {
</span><span class='uc' id='L2251' title='7|7|7 - Total: 7'>                                    gData.setParens(parenIndex + k, -1, 0);
</span>                                }
                            }
<span class='uc' id='L2254' title='2|2|2 - Total: 2'>                        } while (program[nextpc] == REOP_ENDCHILD);
</span>
<span class='uc' id='L2256' title='2|2|2 - Total: 2'>                        pc = nextpc;
</span><span class='uc' id='L2257' title='5|5|5 - Total: 5'>                        op = program[pc++];
</span>                    }
<span class='uc' id='L2259' title='1|1|1 - Total: 1'>                    continue;
</span>
                    case REOP_MINIMALREPEAT:
                    {
<span class='uc' id='L2263' title='3|3|3 - Total: 3'>                        REProgState state = popProgState(gData);
</span><span class='uc' id='L2264' title='2|2|2 - Total: 2'>                        if (!result) {
</span>                            //
                            // Non-greedy failure - try to consume another child.
                            //
<span class='uc' id='L2268' title='4|4|4 - Total: 4'>                            if (state.max == -1 || state.max > 0) {
</span><span class='uc' id='L2269' title='13|13|13 - Total: 13'>                                pushProgState(gData, state.min, state.max, gData.cp, null,
</span>                                        state.continuationOp, state.continuationPc);
<span class='uc' id='L2271' title='2|2|2 - Total: 2'>                                continuationOp = REOP_MINIMALREPEAT;
</span><span class='uc' id='L2272' title='2|2|2 - Total: 2'>                                continuationPc = pc;
</span><span class='uc' id='L2273' title='4|4|4 - Total: 4'>                                int parenCount = getIndex(program, pc);
</span><span class='uc' id='L2274' title='1|1|1 - Total: 1'>                                pc += INDEX_LEN;
</span><span class='uc' id='L2275' title='4|4|4 - Total: 4'>                                int parenIndex = getIndex(program, pc);
</span><span class='uc' id='L2276' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;
</span><span class='uc' id='L2277' title='2|2|2 - Total: 2'>                                for (int k = 0; k < parenCount; k++) {
</span><span class='uc' id='L2278' title='7|7|7 - Total: 7'>                                    gData.setParens(parenIndex + k, -1, 0);
</span>                                }
<span class='uc' id='L2280' title='5|5|5 - Total: 5'>                                op = program[pc++];
</span><span class='uc' id='L2281' title='1|1|1 - Total: 1'>                                continue;
</span>                            } else {
                                // Don't need to adjust pc since we're going to pop.
<span class='uc' id='L2284' title='3|3|3 - Total: 3'>                                continuationPc = state.continuationPc;
</span><span class='uc' id='L2285' title='3|3|3 - Total: 3'>                                continuationOp = state.continuationOp;
</span><span class='uc' id='L2286' title='1|1|1 - Total: 1'>                                break;
</span>                            }
                        } else {
<span class='uc' id='L2289' title='4|4|4 - Total: 4'>                            if (state.min == 0 && gData.cp == state.index) {
</span>                                // Matched an empty string, that'll get us nowhere.
<span class='uc' id='L2291' title='2|2|2 - Total: 2'>                                result = false;
</span><span class='uc' id='L2292' title='3|3|3 - Total: 3'>                                continuationPc = state.continuationPc;
</span><span class='uc' id='L2293' title='3|3|3 - Total: 3'>                                continuationOp = state.continuationOp;
</span><span class='uc' id='L2294' title='1|1|1 - Total: 1'>                                break;
</span>                            }
<span class='uc' id='L2296' title='6|6|6 - Total: 6'>                            int new_min = state.min, new_max = state.max;
</span><span class='uc' id='L2297' title='2|2|2 - Total: 2'>                            if (new_min != 0) new_min--;
</span><span class='uc' id='L2298' title='2|2|2 - Total: 2'>                            if (new_max != -1) new_max--;
</span><span class='uc' id='L2299' title='11|11|11 - Total: 11'>                            pushProgState(gData, new_min, new_max, gData.cp, null,
</span>                                    state.continuationOp, state.continuationPc);
<span class='uc' id='L2301' title='2|2|2 - Total: 2'>                            if (new_min != 0) {
</span><span class='uc' id='L2302' title='2|2|2 - Total: 2'>                                continuationOp = REOP_MINIMALREPEAT;
</span><span class='uc' id='L2303' title='2|2|2 - Total: 2'>                                continuationPc = pc;
</span><span class='uc' id='L2304' title='4|4|4 - Total: 4'>                                int parenCount = getIndex(program, pc);
</span><span class='uc' id='L2305' title='1|1|1 - Total: 1'>                                pc += INDEX_LEN;
</span><span class='uc' id='L2306' title='4|4|4 - Total: 4'>                                int parenIndex = getIndex(program, pc);
</span><span class='uc' id='L2307' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;
</span><span class='uc' id='L2308' title='2|2|2 - Total: 2'>                                for (int k = 0; k < parenCount; k++) {
</span><span class='uc' id='L2309' title='7|7|7 - Total: 7'>                                    gData.setParens(parenIndex + k, -1, 0);
</span>                                }
<span class='uc' id='L2311' title='5|5|5 - Total: 5'>                                op = program[pc++];
</span><span class='uc' id='L2312' title='1|1|1 - Total: 1'>                            } else {
</span><span class='uc' id='L2313' title='3|3|3 - Total: 3'>                                continuationPc = state.continuationPc;
</span><span class='uc' id='L2314' title='3|3|3 - Total: 3'>                                continuationOp = state.continuationOp;
</span><span class='uc' id='L2315' title='4|4|4 - Total: 4'>                                pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
</span><span class='uc' id='L2316' title='3|3|3 - Total: 3'>                                popProgState(gData);
</span><span class='uc' id='L2317' title='1|1|1 - Total: 1'>                                pc += 2 * INDEX_LEN;
</span><span class='uc' id='L2318' title='6|6|6 - Total: 6'>                                pc = pc + getOffset(program, pc);
</span><span class='uc' id='L2319' title='5|5|5 - Total: 5'>                                op = program[pc++];
</span>                            }
<span class='uc' id='L2321' title='1|1|1 - Total: 1'>                            continue;
</span>                        }
                    }

                    case REOP_END:
<span class='uc' id='L2326' title='2|2|2 - Total: 2'>                        return true;
</span>
                    default:
<span class='nc' id='L2329' title='0|0|0 - Total: 3'>                        throw Kit.codeBug("invalid bytecode");
</span>
                }
            }
            /*
             *  If the match failed and there's a backtrack option, take it.
             *  Otherwise this is a complete and utter failure.
             */
<span class='uc' id='L2337' title='2|2|2 - Total: 2'>            if (!result) {
</span><span class='uc' id='L2338' title='3|3|3 - Total: 3'>                REBackTrackData backTrackData = gData.backTrackStackTop;
</span><span class='uc' id='L2339' title='2|2|2 - Total: 2'>                if (backTrackData != null) {
</span><span class='uc' id='L2340' title='4|4|4 - Total: 4'>                    gData.backTrackStackTop = backTrackData.previous;
</span><span class='uc' id='L2341' title='4|4|4 - Total: 4'>                    gData.parens = backTrackData.parens;
</span><span class='uc' id='L2342' title='4|4|4 - Total: 4'>                    gData.cp = backTrackData.cp;
</span><span class='uc' id='L2343' title='4|4|4 - Total: 4'>                    gData.stateStackTop = backTrackData.stateStackTop;
</span><span class='uc' id='L2344' title='3|3|3 - Total: 3'>                    continuationOp = backTrackData.continuationOp;
</span><span class='uc' id='L2345' title='3|3|3 - Total: 3'>                    continuationPc = backTrackData.continuationPc;
</span><span class='uc' id='L2346' title='3|3|3 - Total: 3'>                    pc = backTrackData.pc;
</span><span class='uc' id='L2347' title='3|3|3 - Total: 3'>                    op = backTrackData.op;
</span><span class='uc' id='L2348' title='1|1|1 - Total: 1'>                    continue;
</span>                }
                else
<span class='uc' id='L2351' title='2|2|2 - Total: 2'>                    return false;
</span>            }

<span class='uc' id='L2354' title='6|6|6 - Total: 6'>            op = program[pc++];
</span>        }

    }

    private static boolean
    matchRegExp(REGlobalData gData, RECompiled re,
                String input, int start, int end, boolean multiline)
    {
<span class='uc' id='L2363' title='2|2|2 - Total: 2'>        if (re.parenCount != 0) {
</span><span class='uc' id='L2364' title='6|6|6 - Total: 6'>            gData.parens = new long[re.parenCount];
</span>        } else {
<span class='uc' id='L2366' title='3|3|3 - Total: 3'>            gData.parens = null;
</span>        }

<span class='uc' id='L2369' title='3|3|3 - Total: 3'>        gData.backTrackStackTop = null;
</span><span class='uc' id='L2370' title='3|3|3 - Total: 3'>        gData.stateStackTop = null;
</span>
<span class='uc' id='L2372' title='4|4|4 - Total: 4'>        gData.multiline = multiline || (re.flags & JSREG_MULTILINE) != 0;
</span><span class='uc' id='L2373' title='3|3|3 - Total: 3'>        gData.regexp = re;
</span>
<span class='uc' id='L2375' title='4|4|4 - Total: 4'>        int anchorCh = gData.regexp.anchorCh;
</span>        //
        // have to include the position beyond the last character
        //  in order to detect end-of-input/line condition
        //
<span class='uc' id='L2380' title='2|2|2 - Total: 2'>        for (int i = start; i <= end; ++i) {
</span>            //
            // If the first node is a literal match, step the index into
            // the string until that match is made, or fail if it can't be
            // found at all.
            //
<span class='uc' id='L2386' title='2|2|2 - Total: 2'>            if (anchorCh >= 0) {
</span>                for (;;) {
<span class='uc' id='L2388' title='2|2|2 - Total: 2'>                    if (i == end) {
</span><span class='uc' id='L2389' title='2|2|2 - Total: 2'>                        return false;
</span>                    }
<span class='uc' id='L2391' title='4|4|4 - Total: 4'>                    char matchCh = input.charAt(i);
</span><span class='uc' id='L2392' title='4|4|4 - Total: 4'>                    if (matchCh == anchorCh ||
</span>                            ((gData.regexp.flags & JSREG_FOLD) != 0
<span class='uc' id='L2394' title='2|2|2 - Total: 2'>                             && upcase(matchCh) == upcase((char)anchorCh)))
</span>                    {
<span class='uc' id='L2396' title='1|1|1 - Total: 1'>                        break;
</span>                    }
<span class='uc' id='L2398' title='1|1|1 - Total: 1'>                    ++i;
</span><span class='uc' id='L2399' title='1|1|1 - Total: 1'>                }
</span>            }
<span class='uc' id='L2401' title='3|3|3 - Total: 3'>            gData.cp = i;
</span><span class='uc' id='L2402' title='5|5|5 - Total: 5'>            gData.skipped = i - start;
</span><span class='uc' id='L2403' title='2|2|2 - Total: 2'>            for (int j = 0; j < re.parenCount; j++) {
</span><span class='uc' id='L2404' title='5|5|5 - Total: 5'>                gData.parens[j] = -1L;
</span>            }
<span class='uc' id='L2406' title='5|5|5 - Total: 5'>            boolean result = executeREBytecode(gData, input, end);
</span>
<span class='uc' id='L2408' title='3|3|3 - Total: 3'>            gData.backTrackStackTop = null;
</span><span class='uc' id='L2409' title='3|3|3 - Total: 3'>            gData.stateStackTop = null;
</span><span class='uc' id='L2410' title='2|2|2 - Total: 2'>            if (result) {
</span><span class='uc' id='L2411' title='2|2|2 - Total: 2'>                return true;
</span>            }
<span class='uc' id='L2413' title='4|4|4 - Total: 4'>            if (anchorCh == ANCHOR_BOL && !gData.multiline) {
</span><span class='uc' id='L2414' title='3|3|3 - Total: 3'>                gData.skipped = end;
</span><span class='uc' id='L2415' title='2|2|2 - Total: 2'>                return false;
</span>            }
<span class='uc' id='L2417' title='5|5|5 - Total: 5'>            i = start + gData.skipped;
</span>        }
<span class='uc' id='L2419' title='2|2|2 - Total: 2'>        return false;
</span>    }

    /*
     * indexp is assumed to be an array of length 1
     */
    Object executeRegExp(Context cx, Scriptable scope, RegExpImpl res,
                         String str, int indexp[], int matchType)
    {
<span class='uc' id='L2428' title='4|4|4 - Total: 4'>        REGlobalData gData = new REGlobalData();
</span>
<span class='uc' id='L2430' title='4|4|4 - Total: 4'>        int start = indexp[0];
</span><span class='uc' id='L2431' title='3|3|3 - Total: 3'>        int end = str.length();
</span><span class='upc' id='L2432' title='1|1|1 - Total: 2'>        if (start > end)
</span><span class='nc' id='L2433' title='0|0|0 - Total: 2'>            start = end;
</span>        //
        // Call the recursive matcher to do the real work.
        //
<span class='uc' id='L2437' title='10|10|10 - Total: 10'>        boolean matches = matchRegExp(gData, re, str, start, end,
</span>                                      res.multiline);
<span class='uc' id='L2439' title='2|2|2 - Total: 2'>        if (!matches) {
</span><span class='upc' id='L2440' title='1|1|1 - Total: 2'>            if (matchType != PREFIX) return null;
</span><span class='nc' id='L2441' title='0|0|0 - Total: 2'>            return Undefined.instance;
</span>        }
<span class='uc' id='L2443' title='3|3|3 - Total: 3'>        int index = gData.cp;
</span><span class='uc' id='L2444' title='6|6|6 - Total: 6'>        int ep = indexp[0] = index;
</span><span class='uc' id='L2445' title='7|7|7 - Total: 7'>        int matchlen = ep - (start + gData.skipped);
</span><span class='uc' id='L2446' title='4|4|4 - Total: 4'>        index -= matchlen;
</span>        Object result;
        Scriptable obj;

<span class='uc' id='L2450' title='2|2|2 - Total: 2'>        if (matchType == TEST) {
</span>            /*
             * Testing for a match and updating cx.regExpImpl: don't allocate
             * an array object, do return true.
             */
<span class='uc' id='L2455' title='2|2|2 - Total: 2'>            result = Boolean.TRUE;
</span><span class='uc' id='L2456' title='3|3|3 - Total: 3'>            obj = null;
</span>        }
        else {
            /*
             * The array returned on match has element 0 bound to the matched
             * string, elements 1 through re.parenCount bound to the paren
             * matches, an index property telling the length of the left context,
             * and an input property referring to the input string.
             */
<span class='uc' id='L2465' title='5|5|5 - Total: 5'>            result = cx.newArray(scope, 0);
</span><span class='uc' id='L2466' title='3|3|3 - Total: 3'>            obj = (Scriptable) result;
</span>
<span class='uc' id='L2468' title='7|7|7 - Total: 7'>            String matchstr = str.substring(index, index + matchlen);
</span><span class='uc' id='L2469' title='5|5|5 - Total: 5'>            obj.put(0, obj, matchstr);
</span>        }

<span class='uc' id='L2472' title='2|2|2 - Total: 2'>        if (re.parenCount == 0) {
</span><span class='uc' id='L2473' title='3|3|3 - Total: 3'>            res.parens = null;
</span><span class='uc' id='L2474' title='6|6|6 - Total: 6'>            res.lastParen = new SubString();
</span>        } else {
<span class='uc' id='L2476' title='2|2|2 - Total: 2'>            SubString parsub = null;
</span>            int num;
<span class='uc' id='L2478' title='6|6|6 - Total: 6'>            res.parens = new SubString[re.parenCount];
</span><span class='uc' id='L2479' title='2|2|2 - Total: 2'>            for (num = 0; num < re.parenCount; num++) {
</span><span class='uc' id='L2480' title='4|4|4 - Total: 4'>                int cap_index = gData.parensIndex(num);
</span><span class='uc' id='L2481' title='2|2|2 - Total: 2'>                if (cap_index != -1) {
</span><span class='uc' id='L2482' title='4|4|4 - Total: 4'>                    int cap_length = gData.parensLength(num);
</span><span class='uc' id='L2483' title='7|7|7 - Total: 7'>                    parsub = new SubString(str, cap_index, cap_length);
</span><span class='uc' id='L2484' title='5|5|5 - Total: 5'>                    res.parens[num] = parsub;
</span><span class='uc' id='L2485' title='2|2|2 - Total: 2'>                    if (matchType != TEST)
</span><span class='uc' id='L2486' title='8|8|8 - Total: 8'>                        obj.put(num+1, obj, parsub.toString());
</span><span class='uc' id='L2487' title='1|1|1 - Total: 1'>                }
</span>                else {
<span class='uc' id='L2489' title='2|2|2 - Total: 2'>                    if (matchType != TEST)
</span><span class='uc' id='L2490' title='7|7|7 - Total: 7'>                        obj.put(num+1, obj, Undefined.instance);
</span>                }
            }
<span class='uc' id='L2493' title='3|3|3 - Total: 3'>            res.lastParen = parsub;
</span>        }

<span class='uc' id='L2496' title='2|2|2 - Total: 2'>        if (! (matchType == TEST)) {
</span>            /*
             * Define the index and input properties last for better for/in loop
             * order (so they come after the elements).
             */
<span class='uc' id='L2501' title='9|9|9 - Total: 9'>            obj.put("index", obj, Integer.valueOf(start + gData.skipped));
</span><span class='uc' id='L2502' title='5|5|5 - Total: 5'>            obj.put("input", obj, str);
</span>        }

<span class='uc' id='L2505' title='2|2|2 - Total: 2'>        if (res.lastMatch == null) {
</span><span class='uc' id='L2506' title='5|5|5 - Total: 5'>            res.lastMatch = new SubString();
</span><span class='uc' id='L2507' title='5|5|5 - Total: 5'>            res.leftContext = new SubString();
</span><span class='uc' id='L2508' title='5|5|5 - Total: 5'>            res.rightContext = new SubString();
</span>        }
<span class='uc' id='L2510' title='4|4|4 - Total: 4'>        res.lastMatch.str = str;
</span><span class='uc' id='L2511' title='4|4|4 - Total: 4'>        res.lastMatch.index = index;
</span><span class='uc' id='L2512' title='4|4|4 - Total: 4'>        res.lastMatch.length = matchlen;
</span>
<span class='uc' id='L2514' title='4|4|4 - Total: 4'>        res.leftContext.str = str;
</span><span class='uc' id='L2515' title='2|2|2 - Total: 2'>        if (cx.getLanguageVersion() == Context.VERSION_1_2) {
</span>            /*
             * JS1.2 emulated Perl4.0.1.8 (patch level 36) for global regexps used
             * in scalar contexts, and unintentionally for the string.match "list"
             * psuedo-context.  On "hi there bye", the following would result:
             *
             * Language     while(/ /g){print("$`");}   s/ /$`/g
             * perl4.036    "hi", "there"               "hihitherehi therebye"
             * perl5        "hi", "hi there"            "hihitherehi therebye"
             * js1.2        "hi", "there"               "hihitheretherebye"
             *
             * Insofar as JS1.2 always defined $` as "left context from the last
             * match" for global regexps, it was more consistent than perl4.
             */
<span class='uc' id='L2529' title='4|4|4 - Total: 4'>            res.leftContext.index = start;
</span><span class='uc' id='L2530' title='6|6|6 - Total: 6'>            res.leftContext.length = gData.skipped;
</span>        } else {
            /*
             * For JS1.3 and ECMAv2, emulate Perl5 exactly:
             *
             * js1.3        "hi", "hi there"            "hihitherehi therebye"
             */
<span class='uc' id='L2537' title='4|4|4 - Total: 4'>            res.leftContext.index = 0;
</span><span class='uc' id='L2538' title='7|7|7 - Total: 7'>            res.leftContext.length = start + gData.skipped;
</span>        }

<span class='uc' id='L2541' title='4|4|4 - Total: 4'>        res.rightContext.str = str;
</span><span class='uc' id='L2542' title='4|4|4 - Total: 4'>        res.rightContext.index = ep;
</span><span class='uc' id='L2543' title='6|6|6 - Total: 6'>        res.rightContext.length = end - ep;
</span>
<span class='uc' id='L2545' title='2|2|2 - Total: 2'>        return result;
</span>    }

    int getFlags()
    {
<span class='uc' id='L2550' title='4|4|4 - Total: 4'>        return re.flags;
</span>    }

    private static void reportWarning(Context cx, String messageId, String arg)
    {
<span class='upc' id='L2555' title='1|1|1 - Total: 2'>        if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {
</span><span class='nc' id='L2556' title='0|0|0 - Total: 4'>            String msg = ScriptRuntime.getMessage1(messageId, arg);
</span><span class='nc' id='L2557' title='0|0|0 - Total: 2'>            Context.reportWarning(msg);
</span>        }
<span class='uc' id='L2559' title='1|1|1 - Total: 1'>    }
</span>
    private static void reportError(String messageId, String arg)
    {
<span class='uc' id='L2563' title='4|4|4 - Total: 4'>        String msg = ScriptRuntime.getMessage1(messageId, arg);
</span><span class='uc' id='L2564' title='4|4|4 - Total: 4'>        throw ScriptRuntime.constructError("SyntaxError", msg);
</span>    }

// #string_id_map#

    private static final int
        Id_lastIndex    = 1,
        Id_source       = 2,
        Id_global       = 3,
        Id_ignoreCase   = 4,
        Id_multiline    = 5,

        MAX_INSTANCE_ID = 5;

    @Override
    protected int getMaxInstanceId()
    {
<span class='uc' id='L2581' title='2|2|2 - Total: 2'>        return MAX_INSTANCE_ID;
</span>    }

    @Override
    protected int findInstanceIdInfo(String s)
    {
        int id;
// #generated# Last update: 2007-05-09 08:16:24 EDT
<span class='uc' id='L2589' title='4|4|4 - Total: 4'>        L0: { id = 0; String X = null; int c;
</span><span class='uc' id='L2590' title='3|3|3 - Total: 3'>            int s_length = s.length();
</span><span class='uc' id='L2591' title='2|2|2 - Total: 2'>            if (s_length==6) {
</span><span class='uc' id='L2592' title='4|4|4 - Total: 4'>                c=s.charAt(0);
</span><span class='uc' id='L2593' title='2|2|2 - Total: 2'>                if (c=='g') { X="global";id=Id_global; }
</span><span class='uc' id='L2594' title='2|2|2 - Total: 2'>                else if (c=='s') { X="source";id=Id_source; }
</span>            }
<span class='uc' id='L2596' title='2|2|2 - Total: 2'>            else if (s_length==9) {
</span><span class='uc' id='L2597' title='4|4|4 - Total: 4'>                c=s.charAt(0);
</span><span class='uc' id='L2598' title='2|2|2 - Total: 2'>                if (c=='l') { X="lastIndex";id=Id_lastIndex; }
</span><span class='upc' id='L2599' title='1|1|1 - Total: 2'>                else if (c=='m') { X="multiline";id=Id_multiline; }
</span>            }
<span class='uc' id='L2601' title='2|2|2 - Total: 2'>            else if (s_length==10) { X="ignoreCase";id=Id_ignoreCase; }
</span><span class='upc' id='L2602' title='5|5|5 - Total: 6'>            if (X!=null && X!=s && !X.equals(s)) id = 0;
</span>            break L0;
        }
// #/generated#
// #/string_id_map#

<span class='uc' id='L2608' title='2|2|2 - Total: 2'>        if (id == 0) return super.findInstanceIdInfo(s);
</span>
        int attr;
<span class='upc' id='L2611' title='2|2|2 - Total: 3'>        switch (id) {
</span>          case Id_lastIndex:
<span class='uc' id='L2613' title='3|3|3 - Total: 3'>            attr = lastIndexAttr;
</span><span class='uc' id='L2614' title='1|1|1 - Total: 1'>            break;
</span>          case Id_source:
          case Id_global:
          case Id_ignoreCase:
          case Id_multiline:
<span class='uc' id='L2619' title='2|2|2 - Total: 2'>            attr = PERMANENT | READONLY | DONTENUM;
</span><span class='uc' id='L2620' title='1|1|1 - Total: 1'>            break;
</span>          default:
<span class='nc' id='L2622' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span>        }
<span class='uc' id='L2624' title='4|4|4 - Total: 4'>        return instanceIdInfo(attr, id);
</span>    }

    @Override
    protected String getInstanceIdName(int id)
    {
<span class='upc' id='L2630' title='5|5|5 - Total: 6'>        switch (id) {
</span><span class='uc' id='L2631' title='2|2|2 - Total: 2'>            case Id_lastIndex:  return "lastIndex";
</span><span class='uc' id='L2632' title='2|2|2 - Total: 2'>            case Id_source:     return "source";
</span><span class='uc' id='L2633' title='2|2|2 - Total: 2'>            case Id_global:     return "global";
</span><span class='uc' id='L2634' title='2|2|2 - Total: 2'>            case Id_ignoreCase: return "ignoreCase";
</span><span class='uc' id='L2635' title='2|2|2 - Total: 2'>            case Id_multiline:  return "multiline";
</span>        }
<span class='nc' id='L2637' title='0|0|0 - Total: 4'>        return super.getInstanceIdName(id);
</span>    }

    @Override
    protected Object getInstanceIdValue(int id)
    {
<span class='upc' id='L2643' title='5|5|5 - Total: 6'>        switch (id) {
</span>          case Id_lastIndex:
<span class='uc' id='L2645' title='3|3|3 - Total: 3'>            return lastIndex;
</span>          case Id_source:
<span class='uc' id='L2647' title='7|7|7 - Total: 7'>            return new String(re.source);
</span>          case Id_global:
<span class='uc' id='L2649' title='2|2|2 - Total: 2'>            return ScriptRuntime.wrapBoolean((re.flags & JSREG_GLOB) != 0);
</span>          case Id_ignoreCase:
<span class='uc' id='L2651' title='2|2|2 - Total: 2'>            return ScriptRuntime.wrapBoolean((re.flags & JSREG_FOLD) != 0);
</span>          case Id_multiline:
<span class='uc' id='L2653' title='2|2|2 - Total: 2'>            return ScriptRuntime.wrapBoolean((re.flags & JSREG_MULTILINE) != 0);
</span>        }
<span class='nc' id='L2655' title='0|0|0 - Total: 4'>        return super.getInstanceIdValue(id);
</span>    }

    @Override
    protected void setInstanceIdValue(int id, Object value)
    {
<span class='upc' id='L2661' title='1|1|1 - Total: 3'>        switch (id) {
</span>          case Id_lastIndex:
<span class='uc' id='L2663' title='3|3|3 - Total: 3'>            lastIndex = value;
</span><span class='uc' id='L2664' title='1|1|1 - Total: 1'>            return;
</span>          case Id_source:
          case Id_global:
          case Id_ignoreCase:
          case Id_multiline:
<span class='nc' id='L2669' title='0|0|0 - Total: 1'>            return;
</span>        }
<span class='nc' id='L2671' title='0|0|0 - Total: 4'>        super.setInstanceIdValue(id, value);
</span><span class='nc' id='L2672' title='0|0|0 - Total: 1'>    }
</span>
    @Override
    protected void setInstanceIdAttributes(int id, int attr) {
<span class='nc' id='L2676' title='0|0|0 - Total: 2'>        switch (id) {
</span>          case Id_lastIndex:
<span class='nc' id='L2678' title='0|0|0 - Total: 3'>            lastIndexAttr = attr;
</span><span class='nc' id='L2679' title='0|0|0 - Total: 1'>            return;
</span>        }
<span class='nc' id='L2681' title='0|0|0 - Total: 4'>        super.setInstanceIdAttributes(id, attr);
</span><span class='nc' id='L2682' title='0|0|0 - Total: 1'>    }
</span>
    @Override
    protected void initPrototypeId(int id)
    {
        String s;
        int arity;
<span class='upc' id='L2689' title='6|6|6 - Total: 7'>        switch (id) {
</span><span class='uc' id='L2690' title='5|5|5 - Total: 5'>          case Id_compile:  arity=2; s="compile";  break;
</span><span class='uc' id='L2691' title='5|5|5 - Total: 5'>          case Id_toString: arity=0; s="toString"; break;
</span><span class='uc' id='L2692' title='5|5|5 - Total: 5'>          case Id_toSource: arity=0; s="toSource"; break;
</span><span class='uc' id='L2693' title='5|5|5 - Total: 5'>          case Id_exec:     arity=1; s="exec";     break;
</span><span class='uc' id='L2694' title='5|5|5 - Total: 5'>          case Id_test:     arity=1; s="test";     break;
</span><span class='uc' id='L2695' title='5|5|5 - Total: 5'>          case Id_prefix:   arity=1; s="prefix";   break;
</span><span class='nc' id='L2696' title='0|0|0 - Total: 6'>          default: throw new IllegalArgumentException(String.valueOf(id));
</span>        }
<span class='uc' id='L2698' title='7|7|7 - Total: 7'>        initPrototypeMethod(REGEXP_TAG, id, s, arity);
</span><span class='uc' id='L2699' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,
                             Scriptable thisObj, Object[] args)
    {
<span class='upc' id='L2705' title='1|1|1 - Total: 2'>        if (!f.hasTag(REGEXP_TAG)) {
</span><span class='nc' id='L2706' title='0|0|0 - Total: 8'>            return super.execIdCall(f, cx, scope, thisObj, args);
</span>        }
<span class='uc' id='L2708' title='3|3|3 - Total: 3'>        int id = f.methodId();
</span><span class='upc' id='L2709' title='4|4|4 - Total: 6'>        switch (id) {
</span>          case Id_compile:
<span class='uc' id='L2711' title='8|8|8 - Total: 8'>            return realThis(thisObj, f).compile(cx, scope, args);
</span>
          case Id_toString:
          case Id_toSource:
<span class='uc' id='L2715' title='5|5|5 - Total: 5'>            return realThis(thisObj, f).toString();
</span>
          case Id_exec:
<span class='uc' id='L2718' title='9|9|9 - Total: 9'>            return realThis(thisObj, f).execSub(cx, scope, args, MATCH);
</span>
          case Id_test: {
<span class='uc' id='L2721' title='9|9|9 - Total: 9'>            Object x = realThis(thisObj, f).execSub(cx, scope, args, TEST);
</span><span class='uc' id='L2722' title='2|2|2 - Total: 2'>            return Boolean.TRUE.equals(x) ? Boolean.TRUE : Boolean.FALSE;
</span>          }

          case Id_prefix:
<span class='nc' id='L2726' title='0|0|0 - Total: 9'>            return realThis(thisObj, f).execSub(cx, scope, args, PREFIX);
</span>        }
<span class='nc' id='L2728' title='0|0|0 - Total: 6'>        throw new IllegalArgumentException(String.valueOf(id));
</span>    }

    private static NativeRegExp realThis(Scriptable thisObj, IdFunctionObject f)
    {
<span class='upc' id='L2733' title='1|1|1 - Total: 2'>        if (!(thisObj instanceof NativeRegExp))
</span><span class='nc' id='L2734' title='0|0|0 - Total: 3'>            throw incompatibleCallError(f);
</span><span class='uc' id='L2735' title='3|3|3 - Total: 3'>        return (NativeRegExp)thisObj;
</span>    }

// #string_id_map#
    @Override
    protected int findPrototypeId(String s)
    {
        int id;
// #generated# Last update: 2007-05-09 08:16:24 EDT
<span class='uc' id='L2744' title='4|4|4 - Total: 4'>        L0: { id = 0; String X = null; int c;
</span><span class='uc' id='L2745' title='5|5|5 - Total: 5'>            L: switch (s.length()) {
</span><span class='uc' id='L2746' title='4|4|4 - Total: 4'>            case 4: c=s.charAt(0);
</span><span class='uc' id='L2747' title='2|2|2 - Total: 2'>                if (c=='e') { X="exec";id=Id_exec; }
</span><span class='upc' id='L2748' title='1|1|1 - Total: 2'>                else if (c=='t') { X="test";id=Id_test; }
</span>                break L;
<span class='uc' id='L2750' title='5|5|5 - Total: 5'>            case 6: X="prefix";id=Id_prefix; break L;
</span><span class='uc' id='L2751' title='5|5|5 - Total: 5'>            case 7: X="compile";id=Id_compile; break L;
</span><span class='uc' id='L2752' title='4|4|4 - Total: 4'>            case 8: c=s.charAt(3);
</span><span class='uc' id='L2753' title='2|2|2 - Total: 2'>                if (c=='o') { X="toSource";id=Id_toSource; }
</span><span class='upc' id='L2754' title='1|1|1 - Total: 2'>                else if (c=='t') { X="toString";id=Id_toString; }
</span>                break L;
            }
<span class='uc' id='L2757' title='6|6|6 - Total: 6'>            if (X!=null && X!=s && !X.equals(s)) id = 0;
</span>            break L0;
        }
// #/generated#
<span class='uc' id='L2761' title='2|2|2 - Total: 2'>        return id;
</span>    }

    private static final int
        Id_compile       = 1,
        Id_toString      = 2,
        Id_toSource      = 3,
        Id_exec          = 4,
        Id_test          = 5,
        Id_prefix        = 6,

        MAX_PROTOTYPE_ID = 6;

// #/string_id_map#

    private RECompiled re;
<span class='uc' id='L2777' title='8|8|8 - Total: 8'>    Object lastIndex = 0d;     /* index after last match, for //g iterator */
</span><span class='uc' id='L2778' title='6|6|6 - Total: 6'>    private int lastIndexAttr = DONTENUM | PERMANENT;
</span>
}       // class NativeRegExp

class RECompiled implements Serializable
{
    static final long serialVersionUID = -6144956577595844213L;

    final char[] source;    /* locked source string, sans // */
    int parenCount;         /* number of parenthesized submatches */
    int flags;              /* flags  */
    byte[] program;         /* regular expression bytecode */
    int classCount;         /* count [...] bitmaps */
    RECharSet[] classList;  /* list of [...] bitmaps */
    int anchorCh = -1;      /* if >= 0, then re starts with this literal char */

    RECompiled(String str) {
        this.source = str.toCharArray();
    }
}

class RENode {

    RENode(byte op)
    {
        this.op = op;
    }

    byte            op;         /* r.e. op bytecode */
    RENode          next;       /* next in concatenation order */
    RENode          kid;        /* first operand */

    RENode          kid2;       /* second operand */
    int             parenIndex; /* or a parenthesis index */

                                /* or a range */
    int             min;
    int             max;
    int             parenCount;
    boolean         greedy;

                                /* or a character class */
    int             startIndex;
    int             kidlen;     /* length of string at kid, in chars */
    int             bmsize;     /* bitmap size, based on max char code */
    int             index;      /* index into class list */
    boolean         sense;

                                /* or a literal sequence */
    char            chr;        /* of one character */
    int             length;     /* or many (via the index) */
    int             flatIndex;  /* which is -1 if not sourced */

}

class CompilerState {

    CompilerState(Context cx, char[] source, int length, int flags)
    {
        this.cx = cx;
        this.cpbegin = source;
        this.cp = 0;
        this.cpend = length;
        this.flags = flags;
        this.backReferenceLimit = Integer.MAX_VALUE;
        this.maxBackReference = 0;
        this.parenCount = 0;
        this.classCount = 0;
        this.progLength = 0;
    }

    Context     cx;
    char        cpbegin[];
    int         cpend;
    int         cp;
    int         flags;
    int         backReferenceLimit;
    int         maxBackReference;
    int         parenCount;
    int         parenNesting;
    int         classCount;   /* number of [] encountered */
    int         progLength;   /* estimated bytecode length */
    RENode      result;
}

class REProgState
{
    REProgState(REProgState previous, int min, int max, int index,
                REBackTrackData backTrack,
                int continuationOp, int continuationPc)
    {
        this.previous = previous;
        this.min = min;
        this.max = max;
        this.index = index;
        this.continuationOp = continuationOp;
        this.continuationPc = continuationPc;
        this.backTrack = backTrack;
    }

    final REProgState previous; // previous state in stack

    final int min;                      /* current quantifier min */
    final int max;                      /* current quantifier max */
    final int index;                    /* progress in text */
    final int continuationOp;
    final int continuationPc;
    final REBackTrackData backTrack; // used by ASSERT_  to recover state
}

class REBackTrackData {

    REBackTrackData(REGlobalData gData, int op, int pc, int cp,
                    int continuationOp, int continuationPc)
    {
        previous = gData.backTrackStackTop;
        this.op = op;
        this.pc = pc;
        this.cp = cp;
        this.continuationOp = continuationOp;
        this.continuationPc = continuationPc;
        parens = gData.parens;
        stateStackTop = gData.stateStackTop;
    }

    final REBackTrackData previous;

    final int op;                             /* operator */
    final int pc;                             /* bytecode pointer */
    final int cp;                             /* char buffer index */
    final int continuationOp;                 /* continuation op */
    final int continuationPc;                 /* continuation pc */
    final long[] parens;                      /* parenthesis captures */
    final REProgState stateStackTop;          /* state of op that backtracked */
}

class REGlobalData {
    boolean multiline;
    RECompiled regexp;              /* the RE in execution */
    int skipped;                    /* chars skipped anchoring this r.e. */

    int cp;                         /* char buffer index */
    long[] parens;                  /* parens captures */

    REProgState stateStackTop;       /* stack of state of current ancestors */

    REBackTrackData backTrackStackTop;  /* last matched-so-far position */


    /**
     * Get start of parenthesis capture contents, -1 for empty.
     */
    int parensIndex(int i)
    {
        return (int)(parens[i]);
    }

    /**
     * Get length of parenthesis capture contents.
     */
    int parensLength(int i)
    {
        return (int)(parens[i] >>> 32);
    }

    void setParens(int i, int index, int length)
    {
        // clone parens array if it is shared with backtrack state
        if (backTrackStackTop != null && backTrackStackTop.parens == parens) {
            parens = parens.clone();
        }
        parens[i] = (index & 0xffffffffL) | ((long)length << 32);
    }

}

/*
 * This struct holds a bitmap representation of a class from a regexp.
 * There's a list of these referenced by the classList field in the NativeRegExp
 * struct below. The initial state has startIndex set to the offset in the
 * original regexp source of the beginning of the class contents. The first
 * use of the class converts the source representation into a bitmap.
 *
 */
final class RECharSet implements Serializable
{
    static final long serialVersionUID = 7931787979395898394L;

    RECharSet(int length, int startIndex, int strlength, boolean sense)
    {
        this.length = length;
        this.startIndex = startIndex;
        this.strlength = strlength;
        this.sense = sense;
    }

    final int length;
    final int startIndex;
    final int strlength;
    final boolean sense;

    volatile transient boolean converted;
    volatile transient byte[] bits;
}


</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>