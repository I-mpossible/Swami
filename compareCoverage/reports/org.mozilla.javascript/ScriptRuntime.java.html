<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.ScriptRuntime.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.ScriptRuntime.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.ResourceBundle;

import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.v8dtoa.DoubleConversion;
import org.mozilla.javascript.v8dtoa.FastDtoa;
import org.mozilla.javascript.xml.XMLObject;
import org.mozilla.javascript.xml.XMLLib;

/**
 * This is the class that implements the runtime.
 *
 * @author Norris Boyd
 */

public class ScriptRuntime {

    /**
     * No instances should be created.
     */
<span class='nc' id='L32' title='0|0|0 - Total: 2'>    protected ScriptRuntime() {
</span><span class='nc' id='L33' title='0|0|0 - Total: 1'>    }
</span>

    /**
     * Returns representation of the [[ThrowTypeError]] object.
     * See ECMA 5 spec, 13.2.3
     *
     * @deprecated {@link #typeErrorThrower(Context)}
     */
    @Deprecated
    public static BaseFunction typeErrorThrower() {
<span class='bc' id='L44' title='0|3|3 - Total: 3'>      return typeErrorThrower(Context.getCurrentContext());
</span>    }

    /**
     * Returns representation of the [[ThrowTypeError]] object.
     * See ECMA 5 spec, 13.2.3
     */
    public static BaseFunction typeErrorThrower(Context cx) {
<span class='bc' id='L52' title='0|2|2 - Total: 2'>      if (cx.typeErrorThrower == null) {
</span><span class='bc' id='L53' title='0|4|4 - Total: 4'>        BaseFunction thrower = new BaseFunction() {
</span>          static final long serialVersionUID = -5891740962154902286L;

          @Override
          public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
            throw typeError0("msg.op.not.allowed");
          }
          @Override
          public int getLength() {
            return 0;
          }
        };
<span class='bc' id='L65' title='0|4|4 - Total: 4'>        ScriptRuntime.setFunctionProtoAndParent(thrower, cx.topCallScope);
</span><span class='bc' id='L66' title='0|2|2 - Total: 2'>        thrower.preventExtensions();
</span><span class='bc' id='L67' title='0|3|3 - Total: 3'>        cx.typeErrorThrower = thrower;
</span>      }
<span class='bc' id='L69' title='0|3|3 - Total: 3'>      return cx.typeErrorThrower;
</span>    }

    static class NoSuchMethodShim implements Callable {
        String methodName;
        Callable noSuchMethodMethod;

        NoSuchMethodShim(Callable noSuchMethodMethod, String methodName)
        {
            this.noSuchMethodMethod = noSuchMethodMethod;
            this.methodName = methodName;
        }
        /**
         * Perform the call.
         *
         * @param cx the current Context for this thread
         * @param scope the scope to use to resolve properties.
         * @param thisObj the JavaScript <code>this</code> object
         * @param args the array of arguments
         * @return the result of the call
         */
        public Object call(Context cx, Scriptable scope, Scriptable thisObj,
                           Object[] args)
        {
            Object[] nestedArgs = new Object[2];

            nestedArgs[0] = methodName;
            nestedArgs[1] = newArrayLiteral(args, null, cx, scope);
            return noSuchMethodMethod.call(cx, scope, thisObj, nestedArgs);
        }

    }
    /*
     * There's such a huge space (and some time) waste for the Foo.class
     * syntax: the compiler sticks in a test of a static field in the
     * enclosing class for null and the code for creating the class value.
     * It has to do this since the reference has to get pushed off until
     * execution time (i.e. can't force an early load), but for the
     * 'standard' classes - especially those in java.lang, we can trust
     * that they won't cause problems by being loaded early.
     */

    public final static Class<?>
<span class='bc' id='L112' title='0|3|3 - Total: 3'>        BooleanClass      = Kit.classOrNull("java.lang.Boolean"),
</span><span class='bc' id='L113' title='0|3|3 - Total: 3'>        ByteClass         = Kit.classOrNull("java.lang.Byte"),
</span><span class='bc' id='L114' title='0|3|3 - Total: 3'>        CharacterClass    = Kit.classOrNull("java.lang.Character"),
</span><span class='bc' id='L115' title='0|3|3 - Total: 3'>        ClassClass        = Kit.classOrNull("java.lang.Class"),
</span><span class='bc' id='L116' title='0|3|3 - Total: 3'>        DoubleClass       = Kit.classOrNull("java.lang.Double"),
</span><span class='bc' id='L117' title='0|3|3 - Total: 3'>        FloatClass        = Kit.classOrNull("java.lang.Float"),
</span><span class='bc' id='L118' title='0|3|3 - Total: 3'>        IntegerClass      = Kit.classOrNull("java.lang.Integer"),
</span><span class='bc' id='L119' title='0|3|3 - Total: 3'>        LongClass         = Kit.classOrNull("java.lang.Long"),
</span><span class='bc' id='L120' title='0|3|3 - Total: 3'>        NumberClass       = Kit.classOrNull("java.lang.Number"),
</span><span class='bc' id='L121' title='0|3|3 - Total: 3'>        ObjectClass       = Kit.classOrNull("java.lang.Object"),
</span><span class='bc' id='L122' title='0|3|3 - Total: 3'>        ShortClass        = Kit.classOrNull("java.lang.Short"),
</span><span class='bc' id='L123' title='0|3|3 - Total: 3'>        StringClass       = Kit.classOrNull("java.lang.String"),
</span><span class='bc' id='L124' title='0|3|3 - Total: 3'>        DateClass         = Kit.classOrNull("java.util.Date");
</span>
    public final static Class<?>
<span class='bc' id='L127' title='0|1|1 - Total: 1'>        ContextClass
</span><span class='bc' id='L128' title='0|2|2 - Total: 2'>            = Kit.classOrNull("org.mozilla.javascript.Context"),
</span><span class='bc' id='L129' title='0|1|1 - Total: 1'>        ContextFactoryClass
</span><span class='bc' id='L130' title='0|2|2 - Total: 2'>            = Kit.classOrNull("org.mozilla.javascript.ContextFactory"),
</span><span class='bc' id='L131' title='0|1|1 - Total: 1'>        FunctionClass
</span><span class='bc' id='L132' title='0|2|2 - Total: 2'>            = Kit.classOrNull("org.mozilla.javascript.Function"),
</span><span class='bc' id='L133' title='0|1|1 - Total: 1'>        ScriptableObjectClass
</span><span class='bc' id='L134' title='0|2|2 - Total: 2'>            = Kit.classOrNull("org.mozilla.javascript.ScriptableObject");
</span><span class='bc' id='L135' title='0|2|2 - Total: 2'>    public static final Class<Scriptable> ScriptableClass =
</span>        Scriptable.class;

    // Locale object used to request locale-neutral operations.
<span class='bc' id='L139' title='0|5|5 - Total: 5'>    public static Locale ROOT_LOCALE = new Locale("");
</span>
<span class='bc' id='L141' title='0|2|2 - Total: 2'>    private static final Object LIBRARY_SCOPE_KEY = "LIBRARY_SCOPE";
</span>
    public static boolean isRhinoRuntimeType(Class<?> cl)
    {
<span class='nc' id='L145' title='0|0|0 - Total: 2'>        if (cl.isPrimitive()) {
</span><span class='nc' id='L146' title='0|0|0 - Total: 2'>            return (cl != Character.TYPE);
</span>        } else {
<span class='nc' id='L148' title='0|0|0 - Total: 4'>            return (cl == StringClass || cl == BooleanClass
</span><span class='nc' id='L149' title='0|0|0 - Total: 2'>                    || NumberClass.isAssignableFrom(cl)
</span><span class='nc' id='L150' title='0|0|0 - Total: 2'>                    || ScriptableClass.isAssignableFrom(cl));
</span>        }
    }

    public static ScriptableObject initSafeStandardObjects(Context cx,
                                                           ScriptableObject scope,
                                                           boolean sealed)
    {
<span class='bc' id='L158' title='0|2|2 - Total: 2'>        if (scope == null) {
</span><span class='bc' id='L159' title='0|4|4 - Total: 4'>            scope = new NativeObject();
</span>        }
<span class='bc' id='L161' title='0|5|5 - Total: 5'>        scope.associateValue(LIBRARY_SCOPE_KEY, scope);
</span><span class='bc' id='L162' title='0|6|6 - Total: 6'>        (new ClassCache()).associate(scope);
</span>
<span class='bc' id='L164' title='0|3|3 - Total: 3'>        BaseFunction.init(scope, sealed);
</span><span class='bc' id='L165' title='0|3|3 - Total: 3'>        NativeObject.init(scope, sealed);
</span>
<span class='bc' id='L167' title='0|3|3 - Total: 3'>        Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
</span>
        // Function.prototype.__proto__ should be Object.prototype
<span class='bc' id='L170' title='0|4|4 - Total: 4'>        Scriptable functionProto = ScriptableObject.getClassPrototype(scope, "Function");
</span><span class='bc' id='L171' title='0|3|3 - Total: 3'>        functionProto.setPrototype(objectProto);
</span>
        // Set the prototype of the object passed in if need be
<span class='bc' id='L174' title='0|2|2 - Total: 2'>        if (scope.getPrototype() == null)
</span><span class='bc' id='L175' title='0|3|3 - Total: 3'>            scope.setPrototype(objectProto);
</span>
        // must precede NativeGlobal since it's needed therein
<span class='bc' id='L178' title='0|3|3 - Total: 3'>        NativeError.init(scope, sealed);
</span><span class='bc' id='L179' title='0|4|4 - Total: 4'>        NativeGlobal.init(cx, scope, sealed);
</span>
<span class='bc' id='L181' title='0|3|3 - Total: 3'>        NativeArray.init(scope, sealed);
</span><span class='bc' id='L182' title='0|2|2 - Total: 2'>        if (cx.getOptimizationLevel() > 0) {
</span>            // When optimizing, attempt to fulfill all requests for new Array(N)
            // with a higher threshold before switching to a sparse
            // representation
<span class='bc' id='L186' title='0|2|2 - Total: 2'>            NativeArray.setMaximumInitialCapacity(200000);
</span>        }
<span class='bc' id='L188' title='0|3|3 - Total: 3'>        NativeString.init(scope, sealed);
</span><span class='bc' id='L189' title='0|3|3 - Total: 3'>        NativeBoolean.init(scope, sealed);
</span><span class='bc' id='L190' title='0|3|3 - Total: 3'>        NativeNumber.init(scope, sealed);
</span><span class='bc' id='L191' title='0|3|3 - Total: 3'>        NativeDate.init(scope, sealed);
</span><span class='bc' id='L192' title='0|3|3 - Total: 3'>        NativeMath.init(scope, sealed);
</span><span class='bc' id='L193' title='0|3|3 - Total: 3'>        NativeJSON.init(scope, sealed);
</span>
<span class='bc' id='L195' title='0|3|3 - Total: 3'>        NativeWith.init(scope, sealed);
</span><span class='bc' id='L196' title='0|3|3 - Total: 3'>        NativeCall.init(scope, sealed);
</span><span class='bc' id='L197' title='0|3|3 - Total: 3'>        NativeScript.init(scope, sealed);
</span>
<span class='bc' id='L199' title='0|3|3 - Total: 3'>        NativeIterator.init(scope, sealed); // Also initializes NativeGenerator
</span>
<span class='bc' id='L201' title='0|3|3 - Total: 3'>        NativeArrayIterator.init(scope, sealed);
</span><span class='bc' id='L202' title='0|3|3 - Total: 3'>        NativeStringIterator.init(scope, sealed);
</span>
<span class='bpc' id='L204' title='0|1|1 - Total: 2'>        boolean withXml = cx.hasFeature(Context.FEATURE_E4X) &&
</span><span class='bpc' id='L205' title='0|1|1 - Total: 2'>                          cx.getE4xImplementationFactory() != null;
</span>
        // define lazy-loaded properties using their class name
<span class='bc' id='L208' title='0|9|9 - Total: 9'>        new LazilyLoadedCtor(scope, "RegExp",
</span>                "org.mozilla.javascript.regexp.NativeRegExp", sealed, true);
<span class='bc' id='L210' title='0|9|9 - Total: 9'>        new LazilyLoadedCtor(scope, "Continuation",
</span>                "org.mozilla.javascript.NativeContinuation", sealed, true);

<span class='bpc' id='L213' title='0|1|1 - Total: 2'>        if (withXml) {
</span><span class='bc' id='L214' title='0|4|4 - Total: 4'>            String xmlImpl = cx.getE4xImplementationFactory().getImplementationClassName();
</span><span class='bc' id='L215' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "XML", xmlImpl, sealed, true);
</span><span class='bc' id='L216' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "XMLList", xmlImpl, sealed, true);
</span><span class='bc' id='L217' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Namespace", xmlImpl, sealed, true);
</span><span class='bc' id='L218' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "QName", xmlImpl, sealed, true);
</span>        }

<span class='bc' id='L221' title='0|2|2 - Total: 2'>        if (((cx.getLanguageVersion() >= Context.VERSION_1_8) &&
</span><span class='bpc' id='L222' title='0|1|1 - Total: 2'>             cx.hasFeature(Context.FEATURE_V8_EXTENSIONS)) ||
</span><span class='bpc' id='L223' title='0|1|1 - Total: 2'>            (cx.getLanguageVersion() >= Context.VERSION_ES6))
</span>        {
<span class='bc' id='L225' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "ArrayBuffer",
</span>                                 "org.mozilla.javascript.typedarrays.NativeArrayBuffer",
                                 sealed, true);
<span class='bc' id='L228' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Int8Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeInt8Array",
                                 sealed, true);
<span class='bc' id='L231' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Uint8Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeUint8Array",
                                 sealed, true);
<span class='bc' id='L234' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Uint8ClampedArray",
</span>                                 "org.mozilla.javascript.typedarrays.NativeUint8ClampedArray",
                                 sealed, true);
<span class='bc' id='L237' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Int16Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeInt16Array",
                                 sealed, true);
<span class='bc' id='L240' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Uint16Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeUint16Array",
                                 sealed, true);
<span class='bc' id='L243' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Int32Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeInt32Array",
                                 sealed, true);
<span class='bc' id='L246' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Uint32Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeUint32Array",
                                 sealed, true);
<span class='bc' id='L249' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Float32Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeFloat32Array",
                                 sealed, true);
<span class='bc' id='L252' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "Float64Array",
</span>                                 "org.mozilla.javascript.typedarrays.NativeFloat64Array",
                                 sealed, true);
<span class='bc' id='L255' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(scope, "DataView",
</span>                                 "org.mozilla.javascript.typedarrays.NativeDataView",
                                 sealed, true);
        }

<span class='bc' id='L260' title='0|2|2 - Total: 2'>        if (cx.getLanguageVersion() >= Context.VERSION_ES6) {
</span><span class='bc' id='L261' title='0|4|4 - Total: 4'>            NativeSymbol.init(cx, scope, sealed);
</span>        }

<span class='bc' id='L264' title='0|2|2 - Total: 2'>        if (scope instanceof TopLevel) {
</span><span class='bc' id='L265' title='0|3|3 - Total: 3'>            ((TopLevel)scope).cacheBuiltins();
</span>        }

<span class='bc' id='L268' title='0|2|2 - Total: 2'>        return scope;
</span>    }

    public static ScriptableObject initStandardObjects(Context cx,
                                                       ScriptableObject scope,
                                                       boolean sealed)
    {
<span class='bc' id='L275' title='0|5|5 - Total: 5'>        ScriptableObject s = initSafeStandardObjects(cx, scope, sealed);
</span>
<span class='bc' id='L277' title='0|9|9 - Total: 9'>        new LazilyLoadedCtor(s, "Packages",
</span>                "org.mozilla.javascript.NativeJavaTopPackage", sealed, true);
<span class='bc' id='L279' title='0|9|9 - Total: 9'>        new LazilyLoadedCtor(s, "getClass",
</span>                "org.mozilla.javascript.NativeJavaTopPackage", sealed, true);
<span class='bc' id='L281' title='0|9|9 - Total: 9'>        new LazilyLoadedCtor(s, "JavaAdapter",
</span>                "org.mozilla.javascript.JavaAdapter", sealed, true);
<span class='bc' id='L283' title='0|9|9 - Total: 9'>        new LazilyLoadedCtor(s, "JavaImporter",
</span>                "org.mozilla.javascript.ImporterTopLevel", sealed, true);

<span class='bc' id='L286' title='0|2|2 - Total: 2'>        for (String packageName : getTopPackageNames()) {
</span><span class='bc' id='L287' title='0|9|9 - Total: 9'>            new LazilyLoadedCtor(s, packageName,
</span>                    "org.mozilla.javascript.NativeJavaTopPackage", sealed, true);
        }

<span class='bc' id='L291' title='0|2|2 - Total: 2'>        return s;
</span>    }

    static String[] getTopPackageNames() {
        // Include "android" top package if running on Android
<span class='bpc' id='L296' title='0|1|1 - Total: 2'>        return "Dalvik".equals(System.getProperty("java.vm.name")) ?
</span>            new String[] { "java", "javax", "org", "com", "edu", "net", "android" } :
            new String[] { "java", "javax", "org", "com", "edu", "net" };
    }

    public static ScriptableObject getLibraryScopeOrNull(Scriptable scope)
    {
        ScriptableObject libScope;
<span class='bc' id='L304' title='0|2|2 - Total: 2'>        libScope = (ScriptableObject)ScriptableObject.
</span><span class='bc' id='L305' title='0|3|3 - Total: 3'>                       getTopScopeValue(scope, LIBRARY_SCOPE_KEY);
</span><span class='bc' id='L306' title='0|2|2 - Total: 2'>        return libScope;
</span>    }

    // It is public so NativeRegExp can access it.
    public static boolean isJSLineTerminator(int c)
    {
        // Optimization for faster check for eol character:
        // they do not have 0xDFD0 bits set
<span class='bc' id='L314' title='0|2|2 - Total: 2'>        if ((c & 0xDFD0) != 0) {
</span><span class='bc' id='L315' title='0|2|2 - Total: 2'>            return false;
</span>        }
<span class='bpc' id='L317' title='0|6|6 - Total: 8'>        return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
</span>    }

    public static boolean isJSWhitespaceOrLineTerminator(int c) {
<span class='bpc' id='L321' title='0|3|3 - Total: 4'>      return (isStrWhiteSpaceChar(c) || isJSLineTerminator(c));
</span>    }

    /**
     * Indicates if the character is a Str whitespace char according to ECMA spec:
     * StrWhiteSpaceChar :::
      <TAB>
      <SP>
      <NBSP>
      <FF>
      <VT>
      <CR>
      <LF>
      <LS>
      <PS>
      <USP>
      <BOM>
     */
    static boolean isStrWhiteSpaceChar(int c)
    {
<span class='bc' id='L341' title='0|2|2 - Total: 2'>        switch (c) {
</span>            case ' ': // <SP>
            case '\n': // <LF>
            case '\r': // <CR>
            case '\t': // <TAB>
            case '\u00A0': // <NBSP>
            case '\u000C': // <FF>
            case '\u000B': // <VT>
            case '\u2028': // <LS>
            case '\u2029': // <PS>
            case '\uFEFF': // <BOM>
<span class='bc' id='L352' title='0|2|2 - Total: 2'>                return true;
</span>            default:
<span class='bc' id='L354' title='0|2|2 - Total: 2'>                return Character.getType(c) == Character.SPACE_SEPARATOR;
</span>        }
    }

    public static Boolean wrapBoolean(boolean b)
    {
<span class='bc' id='L360' title='0|2|2 - Total: 2'>        return b ? Boolean.TRUE : Boolean.FALSE;
</span>    }

    public static Integer wrapInt(int i)
    {
<span class='bc' id='L365' title='0|3|3 - Total: 3'>        return Integer.valueOf(i);
</span>    }

    public static Number wrapNumber(double x)
    {
<span class='bc' id='L370' title='0|2|2 - Total: 2'>        if (x != x) {
</span><span class='bc' id='L371' title='0|2|2 - Total: 2'>            return ScriptRuntime.NaNobj;
</span>        }
<span class='bc' id='L373' title='0|5|5 - Total: 5'>        return new Double(x);
</span>    }

    /**
     * Convert the value to a boolean.
     *
     * See ECMA 9.2.
     */
    public static boolean toBoolean(Object val)
    {
        for (;;) {
<span class='bc' id='L384' title='0|2|2 - Total: 2'>            if (val instanceof Boolean)
</span><span class='bc' id='L385' title='0|4|4 - Total: 4'>                return ((Boolean) val).booleanValue();
</span><span class='bc' id='L386' title='0|4|4 - Total: 4'>            if (val == null || val == Undefined.instance)
</span><span class='bc' id='L387' title='0|2|2 - Total: 2'>                return false;
</span><span class='bc' id='L388' title='0|2|2 - Total: 2'>            if (val instanceof CharSequence)
</span><span class='bc' id='L389' title='0|2|2 - Total: 2'>                return ((CharSequence) val).length() != 0;
</span><span class='bc' id='L390' title='0|2|2 - Total: 2'>            if (val instanceof Number) {
</span><span class='bc' id='L391' title='0|4|4 - Total: 4'>                double d = ((Number) val).doubleValue();
</span><span class='bc' id='L392' title='0|4|4 - Total: 4'>                return (d == d && d != 0.0);
</span>            }
<span class='bpc' id='L394' title='0|1|1 - Total: 2'>            if (val instanceof Scriptable) {
</span><span class='bc' id='L395' title='0|2|2 - Total: 2'>                if (val instanceof ScriptableObject &&
</span><span class='bpc' id='L396' title='0|1|1 - Total: 2'>                    ((ScriptableObject) val).avoidObjectDetection())
</span>                {
<span class='nc' id='L398' title='0|0|0 - Total: 2'>                    return false;
</span>                }
<span class='bc' id='L400' title='0|2|2 - Total: 2'>                if (Context.getContext().isVersionECMA1()) {
</span>                    // pure ECMA
<span class='bc' id='L402' title='0|2|2 - Total: 2'>                    return true;
</span>                }
                // ECMA extension
<span class='bc' id='L405' title='0|5|5 - Total: 5'>                val = ((Scriptable) val).getDefaultValue(BooleanClass);
</span><span class='bpc' id='L406' title='0|1|1 - Total: 4'>                if ((val instanceof Scriptable) && !isSymbol(val))
</span><span class='nc' id='L407' title='0|0|0 - Total: 4'>                    throw errorWithClassName("msg.primitive.expected", val);
</span>                continue;
            }
<span class='nc' id='L410' title='0|0|0 - Total: 2'>            warnAboutNonJSObject(val);
</span><span class='nc' id='L411' title='0|0|0 - Total: 2'>            return true;
</span>        }
    }

    /**
     * Convert the value to a number.
     *
     * See ECMA 9.3.
     */
    public static double toNumber(Object val)
    {
        for (;;) {
<span class='bc' id='L423' title='0|2|2 - Total: 2'>            if (val instanceof Number)
</span><span class='bc' id='L424' title='0|4|4 - Total: 4'>                return ((Number) val).doubleValue();
</span><span class='bc' id='L425' title='0|2|2 - Total: 2'>            if (val == null)
</span><span class='bc' id='L426' title='0|2|2 - Total: 2'>                return +0.0;
</span><span class='bc' id='L427' title='0|2|2 - Total: 2'>            if (val == Undefined.instance)
</span><span class='bc' id='L428' title='0|2|2 - Total: 2'>                return NaN;
</span><span class='bc' id='L429' title='0|2|2 - Total: 2'>            if (val instanceof String)
</span><span class='bc' id='L430' title='0|4|4 - Total: 4'>                return toNumber((String) val);
</span><span class='bc' id='L431' title='0|2|2 - Total: 2'>            if (val instanceof CharSequence)
</span><span class='bc' id='L432' title='0|4|4 - Total: 4'>                return toNumber(val.toString());
</span><span class='bc' id='L433' title='0|2|2 - Total: 2'>            if (val instanceof Boolean)
</span><span class='bc' id='L434' title='0|2|2 - Total: 2'>                return ((Boolean) val).booleanValue() ? 1 : +0.0;
</span><span class='bc' id='L435' title='0|2|2 - Total: 2'>            if (val instanceof Symbol)
</span><span class='bc' id='L436' title='0|3|3 - Total: 3'>                throw typeError0("msg.not.a.number");
</span><span class='bpc' id='L437' title='0|1|1 - Total: 2'>            if (val instanceof Scriptable) {
</span><span class='bc' id='L438' title='0|5|5 - Total: 5'>                val = ((Scriptable) val).getDefaultValue(NumberClass);
</span><span class='bpc' id='L439' title='0|1|1 - Total: 4'>                if ((val instanceof Scriptable) && !isSymbol(val))
</span><span class='nc' id='L440' title='0|0|0 - Total: 4'>                    throw errorWithClassName("msg.primitive.expected", val);
</span>                continue;
            }
<span class='nc' id='L443' title='0|0|0 - Total: 2'>            warnAboutNonJSObject(val);
</span><span class='nc' id='L444' title='0|0|0 - Total: 2'>            return NaN;
</span>        }
    }

    public static double toNumber(Object[] args, int index) {
<span class='bc' id='L449' title='0|2|2 - Total: 2'>        return (index < args.length) ? toNumber(args[index]) : NaN;
</span>    }

    // Can not use Double.NaN defined as 0.0d / 0.0 as under the Microsoft VM,
    // versions 2.01 and 3.0P1, that causes some uses (returns at least) of
    // Double.NaN to be converted to 1.0.
    // So we use ScriptRuntime.NaN instead of Double.NaN.
    public static final double
<span class='bc' id='L457' title='0|3|3 - Total: 3'>        NaN = Double.longBitsToDouble(0x7ff8000000000000L);
</span>
    // A similar problem exists for negative zero.
    public static final double
<span class='bc' id='L461' title='0|3|3 - Total: 3'>        negativeZero = Double.longBitsToDouble(0x8000000000000000L);
</span>
<span class='bc' id='L463' title='0|5|5 - Total: 5'>    public static final Double NaNobj = new Double(NaN);
</span>
    static double stringPrefixToNumber(String s, int start, int radix) {
<span class='bc' id='L466' title='0|10|10 - Total: 10'>        return stringToNumber(s, start, s.length() - 1, radix, true);
</span>    }

    static double stringToNumber(String s, int start, int end, int radix) {
<span class='bc' id='L470' title='0|7|7 - Total: 7'>        return stringToNumber(s, start, end, radix, false);
</span>    }

    /*
     * Helper function for toNumber, parseInt, and TokenStream.getToken.
     */
    private static double stringToNumber(String source, int sourceStart, int sourceEnd, int radix, boolean isPrefix) {
<span class='bc' id='L477' title='0|2|2 - Total: 2'>        char digitMax = '9';
</span><span class='bc' id='L478' title='0|2|2 - Total: 2'>        char lowerCaseBound = 'a';
</span><span class='bc' id='L479' title='0|2|2 - Total: 2'>        char upperCaseBound = 'A';
</span><span class='bc' id='L480' title='0|2|2 - Total: 2'>        if (radix < 10) {
</span><span class='bc' id='L481' title='0|7|7 - Total: 7'>            digitMax = (char) ('0' + radix - 1);
</span>        }
<span class='bc' id='L483' title='0|2|2 - Total: 2'>        if (radix > 10) {
</span><span class='bc' id='L484' title='0|7|7 - Total: 7'>            lowerCaseBound = (char) ('a' + radix - 10);
</span><span class='bc' id='L485' title='0|7|7 - Total: 7'>            upperCaseBound = (char) ('A' + radix - 10);
</span>        }
        int end;
<span class='bc' id='L488' title='0|2|2 - Total: 2'>        double sum = 0.0;
</span><span class='bc' id='L489' title='0|2|2 - Total: 2'>        for (end = sourceStart; end <= sourceEnd; end++) {
</span><span class='bc' id='L490' title='0|4|4 - Total: 4'>            char c = source.charAt(end);
</span>            int newDigit;
<span class='bc' id='L492' title='0|4|4 - Total: 4'>            if ('0' <= c && c <= digitMax)
</span><span class='bc' id='L493' title='0|5|5 - Total: 5'>                newDigit = c - '0';
</span><span class='bc' id='L494' title='0|4|4 - Total: 4'>            else if ('a' <= c && c < lowerCaseBound)
</span><span class='bc' id='L495' title='0|7|7 - Total: 7'>                newDigit = c - 'a' + 10;
</span><span class='bc' id='L496' title='0|4|4 - Total: 4'>            else if ('A' <= c && c < upperCaseBound)
</span><span class='bc' id='L497' title='0|7|7 - Total: 7'>                newDigit = c - 'A' + 10;
</span><span class='bc' id='L498' title='0|2|2 - Total: 2'>            else if (!isPrefix)
</span><span class='bc' id='L499' title='0|2|2 - Total: 2'>                return NaN; // isn't a prefix but found unexpected char
</span>            else
                break; // unexpected char
<span class='bc' id='L502' title='0|8|8 - Total: 8'>            sum = sum*radix + newDigit;
</span>        }
<span class='bc' id='L504' title='0|2|2 - Total: 2'>        if (sourceStart == end) { // stopped right at the beginning
</span><span class='bc' id='L505' title='0|2|2 - Total: 2'>            return NaN;
</span>        }
<span class='bc' id='L507' title='0|2|2 - Total: 2'>        if (sum >= 9007199254740992.0) {
</span><span class='bc' id='L508' title='0|2|2 - Total: 2'>            if (radix == 10) {
</span>                /* If we're accumulating a decimal number and the number
                 * is >= 2^53, then the result from the repeated multiply-add
                 * above may be inaccurate.  Call Java to get the correct
                 * answer.
                 */
                try {
<span class='bc' id='L515' title='0|6|6 - Total: 6'>                    return Double.parseDouble(source.substring(sourceStart, end));
</span><span class='nc' id='L516' title='0|0|0 - Total: 1'>                } catch (NumberFormatException nfe) {
</span><span class='nc' id='L517' title='0|0|0 - Total: 2'>                    return NaN;
</span>                }
<span class='bpc' id='L519' title='0|7|7 - Total: 10'>            } else if (radix == 2 || radix == 4 || radix == 8 ||
</span>                       radix == 16 || radix == 32)
            {
                /* The number may also be inaccurate for one of these bases.
                 * This happens if the addition in value*radix + digit causes
                 * a round-down to an even least significant mantissa bit
                 * when the first dropped bit is a one.  If any of the
                 * following digits in the number (which haven't been added
                 * in yet) are nonzero then the correct action would have
                 * been to round up instead of down.  An example of this
                 * occurs when reading the number 0x1000000000000081, which
                 * rounds to 0x1000000000000000 instead of 0x1000000000000100.
                 */
<span class='bc' id='L532' title='0|2|2 - Total: 2'>                int bitShiftInChar = 1;
</span><span class='bc' id='L533' title='0|2|2 - Total: 2'>                int digit = 0;
</span>
<span class='bc' id='L535' title='0|2|2 - Total: 2'>                final int SKIP_LEADING_ZEROS = 0;
</span><span class='bc' id='L536' title='0|2|2 - Total: 2'>                final int FIRST_EXACT_53_BITS = 1;
</span><span class='bc' id='L537' title='0|2|2 - Total: 2'>                final int AFTER_BIT_53         = 2;
</span><span class='bc' id='L538' title='0|2|2 - Total: 2'>                final int ZEROS_AFTER_54 = 3;
</span><span class='bc' id='L539' title='0|2|2 - Total: 2'>                final int MIXED_AFTER_54 = 4;
</span>
<span class='bc' id='L541' title='0|2|2 - Total: 2'>                int state = SKIP_LEADING_ZEROS;
</span><span class='bc' id='L542' title='0|2|2 - Total: 2'>                int exactBitsLimit = 53;
</span><span class='bc' id='L543' title='0|2|2 - Total: 2'>                double factor = 0.0;
</span><span class='bc' id='L544' title='0|2|2 - Total: 2'>                boolean bit53 = false;
</span>                // bit54 is the 54th bit (the first dropped from the mantissa)
<span class='bc' id='L546' title='0|2|2 - Total: 2'>                boolean bit54 = false;
</span><span class='bc' id='L547' title='0|2|2 - Total: 2'>                int pos = sourceStart;
</span>
                for (;;) {
<span class='bc' id='L550' title='0|2|2 - Total: 2'>                    if (bitShiftInChar == 1) {
</span><span class='bc' id='L551' title='0|2|2 - Total: 2'>                        if (pos == end)
</span><span class='bc' id='L552' title='0|1|1 - Total: 1'>                            break;
</span><span class='bc' id='L553' title='0|5|5 - Total: 5'>                        digit = source.charAt(pos++);
</span><span class='bpc' id='L554' title='0|3|3 - Total: 4'>                        if ('0' <= digit && digit <= '9')
</span><span class='bc' id='L555' title='0|2|2 - Total: 2'>                            digit -= '0';
</span><span class='bpc' id='L556' title='0|3|3 - Total: 4'>                        else if ('a' <= digit && digit <= 'z')
</span><span class='bc' id='L557' title='0|2|2 - Total: 2'>                            digit -= 'a' - 10;
</span>                        else
<span class='bc' id='L559' title='0|1|1 - Total: 1'>                            digit -= 'A' - 10;
</span><span class='bc' id='L560' title='0|2|2 - Total: 2'>                        bitShiftInChar = radix;
</span>                    }
<span class='bc' id='L562' title='0|4|4 - Total: 4'>                    bitShiftInChar >>= 1;
</span><span class='bc' id='L563' title='0|2|2 - Total: 2'>                    boolean bit = (digit & bitShiftInChar) != 0;
</span>
<span class='bpc' id='L565' title='0|5|5 - Total: 6'>                    switch (state) {
</span>                      case SKIP_LEADING_ZEROS:
<span class='bc' id='L567' title='0|2|2 - Total: 2'>                          if (bit) {
</span><span class='bc' id='L568' title='0|1|1 - Total: 1'>                            --exactBitsLimit;
</span><span class='bc' id='L569' title='0|2|2 - Total: 2'>                            sum = 1.0;
</span><span class='bc' id='L570' title='0|3|3 - Total: 3'>                            state = FIRST_EXACT_53_BITS;
</span>                        }
                        break;
                      case FIRST_EXACT_53_BITS:
<span class='bc' id='L574' title='0|4|4 - Total: 4'>                           sum *= 2.0;
</span><span class='bc' id='L575' title='0|2|2 - Total: 2'>                        if (bit)
</span><span class='bc' id='L576' title='0|4|4 - Total: 4'>                            sum += 1.0;
</span><span class='bc' id='L577' title='0|1|1 - Total: 1'>                        --exactBitsLimit;
</span><span class='bc' id='L578' title='0|2|2 - Total: 2'>                        if (exactBitsLimit == 0) {
</span><span class='bc' id='L579' title='0|2|2 - Total: 2'>                            bit53 = bit;
</span><span class='bc' id='L580' title='0|3|3 - Total: 3'>                            state = AFTER_BIT_53;
</span>                        }
                        break;
                      case AFTER_BIT_53:
<span class='bc' id='L584' title='0|2|2 - Total: 2'>                        bit54 = bit;
</span><span class='bc' id='L585' title='0|2|2 - Total: 2'>                        factor = 2.0;
</span><span class='bc' id='L586' title='0|2|2 - Total: 2'>                        state = ZEROS_AFTER_54;
</span><span class='bc' id='L587' title='0|1|1 - Total: 1'>                        break;
</span>                      case ZEROS_AFTER_54:
<span class='bc' id='L589' title='0|2|2 - Total: 2'>                        if (bit) {
</span><span class='bc' id='L590' title='0|2|2 - Total: 2'>                            state = MIXED_AFTER_54;
</span>                        }
                        // fallthrough
                      case MIXED_AFTER_54:
<span class='bc' id='L594' title='0|4|4 - Total: 4'>                        factor *= 2;
</span>                        break;
                    }
<span class='bc' id='L597' title='0|1|1 - Total: 1'>                }
</span><span class='bpc' id='L598' title='0|2|2 - Total: 5'>                switch (state) {
</span>                  case SKIP_LEADING_ZEROS:
<span class='nc' id='L600' title='0|0|0 - Total: 2'>                    sum = 0.0;
</span><span class='nc' id='L601' title='0|0|0 - Total: 1'>                    break;
</span>                  case FIRST_EXACT_53_BITS:
                  case AFTER_BIT_53:
                    // do nothing
<span class='nc' id='L605' title='0|0|0 - Total: 1'>                    break;
</span>                  case ZEROS_AFTER_54:
                    // x1.1 -> x1 + 1 (round up)
                    // x0.1 -> x0 (round down)
<span class='bc' id='L609' title='0|2|2 - Total: 2'>                    if (bit54 & bit53)
</span><span class='bc' id='L610' title='0|4|4 - Total: 4'>                        sum += 1.0;
</span><span class='bc' id='L611' title='0|4|4 - Total: 4'>                    sum *= factor;
</span><span class='bc' id='L612' title='0|1|1 - Total: 1'>                    break;
</span>                  case MIXED_AFTER_54:
                    // x.100...1.. -> x + 1 (round up)
                    // x.0anything -> x (round down)
<span class='bc' id='L616' title='0|2|2 - Total: 2'>                    if (bit54)
</span><span class='bc' id='L617' title='0|4|4 - Total: 4'>                        sum += 1.0;
</span><span class='bc' id='L618' title='0|4|4 - Total: 4'>                    sum *= factor;
</span>                    break;
                }
            }
            /* We don't worry about inaccurate numbers for any other base. */
        }
<span class='bc' id='L624' title='0|2|2 - Total: 2'>        return sum;
</span>    }

    /**
     * ToNumber applied to the String type
     *
     * See the #sec-tonumber-applied-to-the-string-type section of ECMA
     */
    public static double toNumber(String s) {
<span class='bc' id='L633' title='0|3|3 - Total: 3'>        final int len = s.length();
</span>
        // Skip whitespace at the start
<span class='bc' id='L636' title='0|2|2 - Total: 2'>        int start = 0;
</span>        char startChar;
        for (;;) {
<span class='bc' id='L639' title='0|2|2 - Total: 2'>            if (start == len) {
</span>                // empty or contains only whitespace
<span class='bc' id='L641' title='0|2|2 - Total: 2'>                return +0.0;
</span>            }
<span class='bc' id='L643' title='0|4|4 - Total: 4'>            startChar = s.charAt(start);
</span><span class='bc' id='L644' title='0|2|2 - Total: 2'>            if (!ScriptRuntime.isStrWhiteSpaceChar(startChar)) {
</span>                // found first non-whitespace character
<span class='bc' id='L646' title='0|1|1 - Total: 1'>                break;
</span>            }
<span class='bc' id='L648' title='0|2|2 - Total: 2'>            start++;
</span>        }

        // Skip whitespace at the end
<span class='bc' id='L652' title='0|4|4 - Total: 4'>        int end = len - 1;
</span>        char endChar;
<span class='bc' id='L654' title='0|2|2 - Total: 2'>        while (ScriptRuntime.isStrWhiteSpaceChar(endChar = s.charAt(end))) {
</span><span class='bc' id='L655' title='0|2|2 - Total: 2'>            end--;
</span>        }

        // Do not break scripts relying on old non-compliant conversion
        // (see bug #368)
        // 1. makes ToNumber parse only a valid prefix in hex literals (similar to 'parseInt()')
        //    ToNumber('0x10 something') => 16
        // 2. allows plus and minus signs for hexadecimal numbers
        //    ToNumber('-0x10') => -16
        // 3. disables support for binary ('0b10') and octal ('0o13') literals
        //    ToNumber('0b1') => NaN
        //    ToNumber('0o5') => NaN
<span class='bc' id='L667' title='0|2|2 - Total: 2'>        final Context cx = Context.getCurrentContext();
</span><span class='bc' id='L668' title='0|2|2 - Total: 2'>        final boolean oldParsingMode =
</span><span class='bc' id='L669' title='0|2|2 - Total: 2'>                cx == null || cx.getLanguageVersion() < Context.VERSION_ES6;
</span>
        // Handle non-base10 numbers
<span class='bc' id='L672' title='0|2|2 - Total: 2'>        if (startChar == '0') {
</span><span class='bc' id='L673' title='0|2|2 - Total: 2'>            if (start + 2 <= end) {
</span><span class='bc' id='L674' title='0|6|6 - Total: 6'>                final char radixC = s.charAt(start + 1);
</span><span class='bc' id='L675' title='0|2|2 - Total: 2'>                int radix = -1;
</span><span class='bc' id='L676' title='0|4|4 - Total: 4'>                if (radixC == 'x' || radixC == 'X') {
</span><span class='bc' id='L677' title='0|3|3 - Total: 3'>                    radix = 16;
</span><span class='bc' id='L678' title='0|6|6 - Total: 6'>                } else if (!oldParsingMode && (radixC == 'o' || radixC == 'O')) {
</span><span class='bc' id='L679' title='0|3|3 - Total: 3'>                    radix = 8;
</span><span class='bpc' id='L680' title='0|5|5 - Total: 6'>                } else if (!oldParsingMode && (radixC == 'b' || radixC == 'B')) {
</span><span class='bc' id='L681' title='0|2|2 - Total: 2'>                    radix = 2;
</span>                }
<span class='bc' id='L683' title='0|2|2 - Total: 2'>                if (radix != -1) {
</span><span class='bc' id='L684' title='0|2|2 - Total: 2'>                    if (oldParsingMode) {
</span><span class='bc' id='L685' title='0|7|7 - Total: 7'>                        return stringPrefixToNumber(s, start + 2, radix);
</span>                    }
<span class='bc' id='L687' title='0|8|8 - Total: 8'>                    return stringToNumber(s, start + 2, end, radix);
</span>                }
<span class='bc' id='L689' title='0|1|1 - Total: 1'>            }
</span><span class='bc' id='L690' title='0|6|6 - Total: 6'>        } else if (oldParsingMode && (startChar == '+' || startChar == '-')) {
</span>            // If in old parsing mode, check for a signed hexadecimal number
<span class='bc' id='L692' title='0|4|4 - Total: 4'>            if (start + 3 <= end && s.charAt(start + 1) == '0') {
</span><span class='bc' id='L693' title='0|6|6 - Total: 6'>                final char radixC = s.charAt(start + 2);
</span><span class='bpc' id='L694' title='0|3|3 - Total: 4'>                if (radixC == 'x' || radixC == 'X') {
</span><span class='bc' id='L695' title='0|7|7 - Total: 7'>                    double val = stringPrefixToNumber(s, start + 3, 16);
</span><span class='bc' id='L696' title='0|2|2 - Total: 2'>                    return startChar == '-' ? -val : val;
</span>                }
            }
        }

<span class='bc' id='L701' title='0|2|2 - Total: 2'>        if (endChar == 'y') {
</span>            // check for "Infinity"
<span class='bc' id='L703' title='0|4|4 - Total: 4'>            if (startChar == '+' || startChar == '-') {
</span><span class='bc' id='L704' title='0|1|1 - Total: 1'>                start++;
</span>            }
<span class='bpc' id='L706' title='0|2|2 - Total: 4'>            if (start + 7 == end && s.regionMatches(start, "Infinity", 0, 8)) {
</span><span class='bc' id='L707' title='0|2|2 - Total: 2'>                return startChar == '-'
</span>                        ? Double.NEGATIVE_INFINITY
                        : Double.POSITIVE_INFINITY;
            }
<span class='nc' id='L711' title='0|0|0 - Total: 2'>            return NaN;
</span>        }
        // A base10, non-infinity number:
        // just try a normal floating point conversion
<span class='bc' id='L715' title='0|7|7 - Total: 7'>        String sub = s.substring(start, end+1);
</span>        // Quick test to check string contains only valid characters because
        // Double.parseDouble() can be slow and accept input we want to reject
<span class='bc' id='L718' title='0|2|2 - Total: 2'>        for (int i = sub.length() - 1; i >= 0; i--) {
</span><span class='bc' id='L719' title='0|4|4 - Total: 4'>            char c = sub.charAt(i);
</span><span class='bpc' id='L720' title='0|13|13 - Total: 14'>            if (('0' <= c && c <= '9') || c == '.' ||
</span>                    c == 'e' || c == 'E'  ||
                    c == '+' || c == '-')
<span class='bc' id='L723' title='0|1|1 - Total: 1'>                continue;
</span><span class='bc' id='L724' title='0|2|2 - Total: 2'>            return NaN;
</span>        }
        try {
<span class='bc' id='L727' title='0|3|3 - Total: 3'>            return Double.parseDouble(sub);
</span><span class='bc' id='L728' title='0|1|1 - Total: 1'>        } catch (NumberFormatException ex) {
</span><span class='bc' id='L729' title='0|2|2 - Total: 2'>            return NaN;
</span>        }
    }

    /**
     * Helper function for builtin objects that use the varargs form.
     * ECMA function formal arguments are undefined if not supplied;
     * this function pads the argument array out to the expected
     * length, if necessary.
     */
    public static Object[] padArguments(Object[] args, int count) {
<span class='bpc' id='L740' title='0|1|1 - Total: 2'>        if (count < args.length)
</span><span class='nc' id='L741' title='0|0|0 - Total: 2'>            return args;
</span>
        int i;
<span class='bc' id='L744' title='0|3|3 - Total: 3'>        Object[] result = new Object[count];
</span><span class='bc' id='L745' title='0|2|2 - Total: 2'>        for (i = 0; i < args.length; i++) {
</span><span class='bc' id='L746' title='0|6|6 - Total: 6'>            result[i] = args[i];
</span>        }

<span class='bc' id='L749' title='0|2|2 - Total: 2'>        for (; i < count; i++) {
</span><span class='bc' id='L750' title='0|4|4 - Total: 4'>            result[i] = Undefined.instance;
</span>        }

<span class='bc' id='L753' title='0|2|2 - Total: 2'>        return result;
</span>    }

    public static String escapeString(String s)
    {
<span class='bc' id='L758' title='0|4|4 - Total: 4'>        return escapeString(s, '"');
</span>    }

    /**
     * For escaping strings printed by object and array literals; not quite
     * the same as 'escape.'
     */
    public static String escapeString(String s, char escapeQuote)
    {
<span class='bpc' id='L767' title='0|3|3 - Total: 4'>        if (!(escapeQuote == '"' || escapeQuote == '\'')) Kit.codeBug();
</span><span class='bc' id='L768' title='0|2|2 - Total: 2'>        StringBuilder sb = null;
</span>
<span class='bc' id='L770' title='0|2|2 - Total: 2'>        for(int i = 0, L = s.length(); i != L; ++i) {
</span><span class='bc' id='L771' title='0|4|4 - Total: 4'>            int c = s.charAt(i);
</span>
<span class='bc' id='L773' title='0|8|8 - Total: 8'>            if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\') {
</span>                // an ordinary print character (like C isprint()) and not "
                // or \ .
<span class='bc' id='L776' title='0|2|2 - Total: 2'>                if (sb != null) {
</span><span class='bc' id='L777' title='0|6|6 - Total: 6'>                    sb.append((char)c);
</span>                }
                continue;
            }
<span class='bc' id='L781' title='0|2|2 - Total: 2'>            if (sb == null) {
</span><span class='bc' id='L782' title='0|7|7 - Total: 7'>                sb = new StringBuilder(L + 3);
</span><span class='bc' id='L783' title='0|4|4 - Total: 4'>                sb.append(s);
</span><span class='bc' id='L784' title='0|3|3 - Total: 3'>                sb.setLength(i);
</span>            }

<span class='bc' id='L787' title='0|2|2 - Total: 2'>            int escape = -1;
</span><span class='bpc' id='L788' title='0|8|8 - Total: 9'>            switch (c) {
</span><span class='bc' id='L789' title='0|3|3 - Total: 3'>                case '\b':  escape = 'b';  break;
</span><span class='bc' id='L790' title='0|3|3 - Total: 3'>                case '\f':  escape = 'f';  break;
</span><span class='bc' id='L791' title='0|3|3 - Total: 3'>                case '\n':  escape = 'n';  break;
</span><span class='bc' id='L792' title='0|3|3 - Total: 3'>                case '\r':  escape = 'r';  break;
</span><span class='bc' id='L793' title='0|3|3 - Total: 3'>                case '\t':  escape = 't';  break;
</span><span class='bc' id='L794' title='0|3|3 - Total: 3'>                case 0xb:   escape = 'v';  break; // Java lacks \v.
</span><span class='nc' id='L795' title='0|0|0 - Total: 3'>                case ' ':   escape = ' ';  break;
</span><span class='bc' id='L796' title='0|2|2 - Total: 2'>                case '\\':  escape = '\\'; break;
</span>            }
<span class='bc' id='L798' title='0|2|2 - Total: 2'>            if (escape >= 0) {
</span>                // an \escaped sort of character
<span class='bc' id='L800' title='0|4|4 - Total: 4'>                sb.append('\\');
</span><span class='bc' id='L801' title='0|6|6 - Total: 6'>                sb.append((char)escape);
</span><span class='bc' id='L802' title='0|2|2 - Total: 2'>            } else if (c == escapeQuote) {
</span><span class='bc' id='L803' title='0|4|4 - Total: 4'>                sb.append('\\');
</span><span class='bc' id='L804' title='0|5|5 - Total: 5'>                sb.append(escapeQuote);
</span>            } else {
                int hexSize;
<span class='bc' id='L807' title='0|2|2 - Total: 2'>                if (c < 256) {
</span>                    // 2-digit hex
<span class='bc' id='L809' title='0|4|4 - Total: 4'>                    sb.append("\\x");
</span><span class='bc' id='L810' title='0|3|3 - Total: 3'>                    hexSize = 2;
</span>                } else {
                    // Unicode.
<span class='bc' id='L813' title='0|4|4 - Total: 4'>                    sb.append("\\u");
</span><span class='bc' id='L814' title='0|2|2 - Total: 2'>                    hexSize = 4;
</span>                }
                // append hexadecimal form of c left-padded with 0
<span class='bc' id='L817' title='0|2|2 - Total: 2'>                for (int shift = (hexSize - 1) * 4; shift >= 0; shift -= 4) {
</span><span class='bc' id='L818' title='0|6|6 - Total: 6'>                    int digit = 0xf & (c >> shift);
</span><span class='bc' id='L819' title='0|2|2 - Total: 2'>                    int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
</span><span class='bc' id='L820' title='0|5|5 - Total: 5'>                    sb.append((char)hc);
</span>                }
            }
        }
<span class='bc' id='L824' title='0|2|2 - Total: 2'>        return (sb == null) ? s : sb.toString();
</span>    }

    static boolean isValidIdentifierName(String s, Context cx, boolean isStrict)
    {
<span class='bc' id='L829' title='0|3|3 - Total: 3'>        int L = s.length();
</span><span class='bpc' id='L830' title='0|1|1 - Total: 2'>        if (L == 0)
</span><span class='nc' id='L831' title='0|0|0 - Total: 2'>            return false;
</span><span class='bc' id='L832' title='0|2|2 - Total: 2'>        if (!Character.isJavaIdentifierStart(s.charAt(0)))
</span><span class='bc' id='L833' title='0|2|2 - Total: 2'>            return false;
</span><span class='bc' id='L834' title='0|2|2 - Total: 2'>        for (int i = 1; i != L; ++i) {
</span><span class='bpc' id='L835' title='0|1|1 - Total: 2'>            if (!Character.isJavaIdentifierPart(s.charAt(i)))
</span><span class='nc' id='L836' title='0|0|0 - Total: 2'>                return false;
</span>        }
<span class='bc' id='L838' title='0|2|2 - Total: 2'>        return !TokenStream.isKeyword(s, cx.getLanguageVersion(), isStrict);
</span>    }

    public static CharSequence toCharSequence(Object val) {
<span class='bc' id='L842' title='0|2|2 - Total: 2'>        if (val instanceof NativeString) {
</span><span class='bc' id='L843' title='0|4|4 - Total: 4'>            return ((NativeString)val).toCharSequence();
</span>        }
<span class='bc' id='L845' title='0|2|2 - Total: 2'>        return val instanceof CharSequence ? (CharSequence) val : toString(val);
</span>    }

    /**
     * Convert the value to a string.
     *
     * See ECMA 9.8.
     */
    public static String toString(Object val) {
        for (;;) {
<span class='bc' id='L855' title='0|2|2 - Total: 2'>            if (val == null) {
</span><span class='bc' id='L856' title='0|2|2 - Total: 2'>                return "null";
</span>            }
<span class='bpc' id='L858' title='0|3|3 - Total: 4'>            if (val == Undefined.instance || val == Undefined.SCRIPTABLE_UNDEFINED) {
</span><span class='bc' id='L859' title='0|2|2 - Total: 2'>                return "undefined";
</span>            }
<span class='bc' id='L861' title='0|2|2 - Total: 2'>            if (val instanceof String) {
</span><span class='bc' id='L862' title='0|3|3 - Total: 3'>                return (String)val;
</span>            }
<span class='bc' id='L864' title='0|2|2 - Total: 2'>            if (val instanceof CharSequence) {
</span><span class='bc' id='L865' title='0|3|3 - Total: 3'>                return val.toString();
</span>            }
<span class='bc' id='L867' title='0|2|2 - Total: 2'>            if (val instanceof Number) {
</span>                // XXX should we just teach NativeNumber.stringValue()
                // about Numbers?
<span class='bc' id='L870' title='0|6|6 - Total: 6'>                return numberToString(((Number)val).doubleValue(), 10);
</span>            }
<span class='bc' id='L872' title='0|2|2 - Total: 2'>            if (val instanceof Symbol) {
</span><span class='bc' id='L873' title='0|3|3 - Total: 3'>                throw typeError0("msg.not.a.string");
</span>            }
<span class='bc' id='L875' title='0|2|2 - Total: 2'>            if (val instanceof Scriptable) {
</span><span class='bc' id='L876' title='0|5|5 - Total: 5'>                val = ((Scriptable) val).getDefaultValue(StringClass);
</span><span class='bpc' id='L877' title='0|1|1 - Total: 4'>                if ((val instanceof Scriptable) && !isSymbol(val)) {
</span><span class='nc' id='L878' title='0|0|0 - Total: 4'>                    throw errorWithClassName("msg.primitive.expected", val);
</span>                }
                continue;
            }
<span class='bc' id='L882' title='0|3|3 - Total: 3'>            return val.toString();
</span>        }
    }

    static String defaultObjectToString(Scriptable obj)
    {
<span class='bc' id='L888' title='0|2|2 - Total: 2'>        if (obj == null)
</span><span class='bc' id='L889' title='0|2|2 - Total: 2'>            return "[object Null]";
</span><span class='bc' id='L890' title='0|2|2 - Total: 2'>        if (Undefined.isUndefined(obj))
</span><span class='bc' id='L891' title='0|2|2 - Total: 2'>            return "[object Undefined]";
</span><span class='bc' id='L892' title='0|12|12 - Total: 12'>        return "[object " + obj.getClassName() + ']';
</span>    }

    public static String toString(Object[] args, int index)
    {
<span class='bc' id='L897' title='0|2|2 - Total: 2'>        return (index < args.length) ? toString(args[index]) : "undefined";
</span>    }

    /**
     * Optimized version of toString(Object) for numbers.
     */
    public static String toString(double val) {
<span class='bc' id='L904' title='0|4|4 - Total: 4'>        return numberToString(val, 10);
</span>    }

    public static String numberToString(double d, int base) {
<span class='bpc' id='L908' title='0|2|2 - Total: 4'>        if ((base < 2) || (base > 36)) {
</span><span class='nc' id='L909' title='0|0|0 - Total: 4'>            throw Context.reportRuntimeError1(
</span><span class='nc' id='L910' title='0|0|0 - Total: 1'>                "msg.bad.radix", Integer.toString(base));
</span>        }

<span class='bc' id='L913' title='0|2|2 - Total: 2'>        if (d != d)
</span><span class='bc' id='L914' title='0|2|2 - Total: 2'>            return "NaN";
</span><span class='bc' id='L915' title='0|2|2 - Total: 2'>        if (d == Double.POSITIVE_INFINITY)
</span><span class='bc' id='L916' title='0|2|2 - Total: 2'>            return "Infinity";
</span><span class='bc' id='L917' title='0|2|2 - Total: 2'>        if (d == Double.NEGATIVE_INFINITY)
</span><span class='bc' id='L918' title='0|2|2 - Total: 2'>            return "-Infinity";
</span><span class='bc' id='L919' title='0|2|2 - Total: 2'>        if (d == 0.0)
</span><span class='bc' id='L920' title='0|2|2 - Total: 2'>            return "0";
</span>
<span class='bc' id='L922' title='0|2|2 - Total: 2'>        if (base != 10) {
</span><span class='bc' id='L923' title='0|4|4 - Total: 4'>            return DToA.JS_dtobasestr(base, d);
</span>        } else {
            // V8 FastDtoa can't convert all numbers, so try it first but
            // fall back to old DToA in case it fails
<span class='bc' id='L927' title='0|3|3 - Total: 3'>            String result = FastDtoa.numberToString(d);
</span><span class='bc' id='L928' title='0|2|2 - Total: 2'>            if (result != null) {
</span><span class='bc' id='L929' title='0|2|2 - Total: 2'>                return result;
</span>            }
<span class='bc' id='L931' title='0|4|4 - Total: 4'>            StringBuilder buffer = new StringBuilder();
</span><span class='bc' id='L932' title='0|5|5 - Total: 5'>            DToA.JS_dtostr(buffer, DToA.DTOSTR_STANDARD, 0, d);
</span><span class='bc' id='L933' title='0|3|3 - Total: 3'>            return buffer.toString();
</span>        }

    }

    static String uneval(Context cx, Scriptable scope, Object value)
    {
<span class='bc' id='L940' title='0|2|2 - Total: 2'>        if (value == null) {
</span><span class='bc' id='L941' title='0|2|2 - Total: 2'>            return "null";
</span>        }
<span class='bc' id='L943' title='0|2|2 - Total: 2'>        if (value == Undefined.instance) {
</span><span class='bc' id='L944' title='0|2|2 - Total: 2'>            return "undefined";
</span>        }
<span class='bc' id='L946' title='0|2|2 - Total: 2'>        if (value instanceof CharSequence) {
</span><span class='bc' id='L947' title='0|4|4 - Total: 4'>            String escaped = escapeString(value.toString());
</span><span class='bc' id='L948' title='0|8|8 - Total: 8'>            StringBuilder sb = new StringBuilder(escaped.length() + 2);
</span><span class='bc' id='L949' title='0|4|4 - Total: 4'>            sb.append('\"');
</span><span class='bc' id='L950' title='0|4|4 - Total: 4'>            sb.append(escaped);
</span><span class='bc' id='L951' title='0|4|4 - Total: 4'>            sb.append('\"');
</span><span class='bc' id='L952' title='0|3|3 - Total: 3'>            return sb.toString();
</span>        }
<span class='bc' id='L954' title='0|2|2 - Total: 2'>        if (value instanceof Number) {
</span><span class='bc' id='L955' title='0|4|4 - Total: 4'>            double d = ((Number)value).doubleValue();
</span><span class='bpc' id='L956' title='0|3|3 - Total: 4'>            if (d == 0 && 1 / d < 0) {
</span><span class='nc' id='L957' title='0|0|0 - Total: 2'>                return "-0";
</span>            }
<span class='bc' id='L959' title='0|3|3 - Total: 3'>            return toString(d);
</span>        }
<span class='bc' id='L961' title='0|2|2 - Total: 2'>        if (value instanceof Boolean) {
</span><span class='bc' id='L962' title='0|3|3 - Total: 3'>            return toString(value);
</span>        }
<span class='bpc' id='L964' title='0|1|1 - Total: 2'>        if (value instanceof Scriptable) {
</span><span class='bc' id='L965' title='0|3|3 - Total: 3'>            Scriptable obj = (Scriptable)value;
</span>            // Wrapped Java objects won't have "toSource" and will report
            // errors for get()s of nonexistent name, so use has() first
<span class='bpc' id='L968' title='0|1|1 - Total: 2'>            if (ScriptableObject.hasProperty(obj, "toSource")) {
</span><span class='bc' id='L969' title='0|4|4 - Total: 4'>                Object v = ScriptableObject.getProperty(obj, "toSource");
</span><span class='bpc' id='L970' title='0|1|1 - Total: 2'>                if (v instanceof Function) {
</span><span class='bc' id='L971' title='0|3|3 - Total: 3'>                    Function f = (Function)v;
</span><span class='bc' id='L972' title='0|8|8 - Total: 8'>                    return toString(f.call(cx, scope, obj, emptyArgs));
</span>                }
            }
<span class='nc' id='L975' title='0|0|0 - Total: 3'>            return toString(value);
</span>        }
<span class='nc' id='L977' title='0|0|0 - Total: 2'>        warnAboutNonJSObject(value);
</span><span class='nc' id='L978' title='0|0|0 - Total: 3'>        return value.toString();
</span>    }

    static String defaultObjectToSource(Context cx, Scriptable scope,
                                        Scriptable thisObj, Object[] args)
    {
        boolean toplevel, iterating;
<span class='bc' id='L985' title='0|2|2 - Total: 2'>        if (cx.iterating == null) {
</span><span class='bc' id='L986' title='0|2|2 - Total: 2'>            toplevel = true;
</span><span class='bc' id='L987' title='0|2|2 - Total: 2'>            iterating = false;
</span><span class='bc' id='L988' title='0|7|7 - Total: 7'>            cx.iterating = new ObjToIntMap(31);
</span>        } else {
<span class='bc' id='L990' title='0|2|2 - Total: 2'>            toplevel = false;
</span><span class='bc' id='L991' title='0|5|5 - Total: 5'>            iterating = cx.iterating.has(thisObj);
</span>        }

<span class='bc' id='L994' title='0|5|5 - Total: 5'>        StringBuilder result = new StringBuilder(128);
</span><span class='bc' id='L995' title='0|2|2 - Total: 2'>        if (toplevel) {
</span><span class='bc' id='L996' title='0|4|4 - Total: 4'>            result.append("(");
</span>        }
<span class='bc' id='L998' title='0|4|4 - Total: 4'>        result.append('{');
</span>
        // Make sure cx.iterating is set to null when done
        // so we don't leak memory
        try {
<span class='bc' id='L1003' title='0|2|2 - Total: 2'>            if (!iterating) {
</span><span class='bc' id='L1004' title='0|5|5 - Total: 5'>                cx.iterating.intern(thisObj); // stop recursion.
</span><span class='bc' id='L1005' title='0|3|3 - Total: 3'>                Object[] ids = thisObj.getIds();
</span><span class='bc' id='L1006' title='0|2|2 - Total: 2'>                for (int i=0; i < ids.length; i++) {
</span><span class='bc' id='L1007' title='0|4|4 - Total: 4'>                    Object id = ids[i];
</span>                    Object value;
<span class='bc' id='L1009' title='0|2|2 - Total: 2'>                    if (id instanceof Integer) {
</span><span class='bc' id='L1010' title='0|4|4 - Total: 4'>                        int intId = ((Integer)id).intValue();
</span><span class='bc' id='L1011' title='0|5|5 - Total: 5'>                        value = thisObj.get(intId, thisObj);
</span><span class='bpc' id='L1012' title='0|1|1 - Total: 2'>                        if (value == Scriptable.NOT_FOUND)
</span><span class='nc' id='L1013' title='0|0|0 - Total: 1'>                            continue;   // a property has been removed
</span><span class='bc' id='L1014' title='0|2|2 - Total: 2'>                        if (i > 0)
</span><span class='bc' id='L1015' title='0|4|4 - Total: 4'>                            result.append(", ");
</span><span class='bc' id='L1016' title='0|4|4 - Total: 4'>                        result.append(intId);
</span><span class='bc' id='L1017' title='0|1|1 - Total: 1'>                    } else {
</span><span class='bc' id='L1018' title='0|3|3 - Total: 3'>                        String strId = (String)id;
</span><span class='bc' id='L1019' title='0|5|5 - Total: 5'>                        value = thisObj.get(strId, thisObj);
</span><span class='bc' id='L1020' title='0|2|2 - Total: 2'>                        if (value == Scriptable.NOT_FOUND)
</span><span class='bc' id='L1021' title='0|1|1 - Total: 1'>                            continue;   // a property has been removed
</span><span class='bc' id='L1022' title='0|2|2 - Total: 2'>                        if (i > 0)
</span><span class='bc' id='L1023' title='0|4|4 - Total: 4'>                            result.append(", ");
</span><span class='bc' id='L1024' title='0|2|2 - Total: 2'>                        if (ScriptRuntime.isValidIdentifierName(strId, cx, cx.isStrictMode())) {
</span><span class='bc' id='L1025' title='0|5|5 - Total: 5'>                            result.append(strId);
</span>                        } else {
<span class='bc' id='L1027' title='0|4|4 - Total: 4'>                            result.append('\'');
</span><span class='bc' id='L1028' title='0|5|5 - Total: 5'>                            result.append(
</span><span class='bc' id='L1029' title='0|1|1 - Total: 1'>                                ScriptRuntime.escapeString(strId, '\''));
</span><span class='bc' id='L1030' title='0|4|4 - Total: 4'>                            result.append('\'');
</span>                        }
                    }
<span class='bc' id='L1033' title='0|4|4 - Total: 4'>                    result.append(':');
</span><span class='bc' id='L1034' title='0|7|7 - Total: 7'>                    result.append(ScriptRuntime.uneval(cx, scope, value));
</span>                }
            }
        } finally {
<span class='bpc' id='L1038' title='0|2|2 - Total: 4'>            if (toplevel) {
</span><span class='bpc' id='L1039' title='0|4|4 - Total: 7'>                cx.iterating = null;
</span>            }
<span class='nc' id='L1041' title='0|0|0 - Total: 2'>        }
</span>
<span class='bc' id='L1043' title='0|4|4 - Total: 4'>        result.append('}');
</span><span class='bc' id='L1044' title='0|2|2 - Total: 2'>        if (toplevel) {
</span><span class='bc' id='L1045' title='0|4|4 - Total: 4'>            result.append(')');
</span>        }
<span class='bc' id='L1047' title='0|3|3 - Total: 3'>        return result.toString();
</span>    }

    public static Scriptable toObject(Scriptable scope, Object val)
    {
<span class='bpc' id='L1052' title='0|1|1 - Total: 2'>        if (val instanceof Scriptable) {
</span><span class='bc' id='L1053' title='0|3|3 - Total: 3'>            return (Scriptable)val;
</span>        }
<span class='nc' id='L1055' title='0|0|0 - Total: 5'>        return toObject(Context.getContext(), scope, val);
</span>    }

    /**
     * <strong>Warning</strong>: This doesn't allow to resolve primitive
     * prototype properly when many top scopes are involved
     *
     * @deprecated Use {@link #toObjectOrNull(Context, Object, Scriptable)} instead
     */
    @Deprecated
    public static Scriptable toObjectOrNull(Context cx, Object obj)
    {
<span class='bpc' id='L1067' title='0|1|1 - Total: 2'>        if (obj instanceof Scriptable) {
</span><span class='nc' id='L1068' title='0|0|0 - Total: 3'>            return (Scriptable)obj;
</span><span class='bpc' id='L1069' title='0|2|2 - Total: 4'>        } else if (obj != null && obj != Undefined.instance) {
</span><span class='bc' id='L1070' title='0|6|6 - Total: 6'>            return toObject(cx, getTopCallScope(cx), obj);
</span>        }
<span class='nc' id='L1072' title='0|0|0 - Total: 2'>        return null;
</span>    }

    /**
     * @param scope the scope that should be used to resolve primitive prototype
     */
    public static Scriptable toObjectOrNull(Context cx, Object obj,
                                            Scriptable scope)
    {
<span class='bc' id='L1081' title='0|2|2 - Total: 2'>        if (obj instanceof Scriptable) {
</span><span class='bc' id='L1082' title='0|3|3 - Total: 3'>            return (Scriptable)obj;
</span><span class='bc' id='L1083' title='0|4|4 - Total: 4'>        } else if (obj != null && obj != Undefined.instance) {
</span><span class='bc' id='L1084' title='0|5|5 - Total: 5'>            return toObject(cx, scope, obj);
</span>        }
<span class='bc' id='L1086' title='0|2|2 - Total: 2'>        return null;
</span>    }

    /**
     * @deprecated Use {@link #toObject(Scriptable, Object)} instead.
     */
    @Deprecated
    public static Scriptable toObject(Scriptable scope, Object val,
                                      Class<?> staticClass)
    {
<span class='nc' id='L1096' title='0|0|0 - Total: 2'>        if (val instanceof Scriptable) {
</span><span class='nc' id='L1097' title='0|0|0 - Total: 3'>            return (Scriptable)val;
</span>        }
<span class='nc' id='L1099' title='0|0|0 - Total: 5'>        return toObject(Context.getContext(), scope, val);
</span>    }

    /**
     * Convert the value to an object.
     *
     * See ECMA 9.9.
     */
    public static Scriptable toObject(Context cx, Scriptable scope, Object val)
    {
<span class='bc' id='L1109' title='0|2|2 - Total: 2'>        if (isSymbol(val)) {
</span><span class='bc' id='L1110' title='0|6|6 - Total: 6'>            NativeSymbol result = new NativeSymbol((NativeSymbol)val);
</span><span class='bc' id='L1111' title='0|4|4 - Total: 4'>            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.Symbol);
</span><span class='bc' id='L1112' title='0|2|2 - Total: 2'>            return result;
</span>        }
<span class='bc' id='L1114' title='0|2|2 - Total: 2'>        if (val instanceof Scriptable) {
</span><span class='bc' id='L1115' title='0|3|3 - Total: 3'>            return (Scriptable) val;
</span>        }
<span class='bc' id='L1117' title='0|2|2 - Total: 2'>        if (val instanceof CharSequence) {
</span>            // FIXME we want to avoid toString() here, especially for concat()
<span class='bc' id='L1119' title='0|6|6 - Total: 6'>            NativeString result = new NativeString((CharSequence)val);
</span><span class='bc' id='L1120' title='0|4|4 - Total: 4'>            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.String);
</span><span class='bc' id='L1121' title='0|2|2 - Total: 2'>            return result;
</span>        }
<span class='bc' id='L1123' title='0|2|2 - Total: 2'>        if (val instanceof Number) {
</span><span class='bc' id='L1124' title='0|7|7 - Total: 7'>            NativeNumber result = new NativeNumber(((Number)val).doubleValue());
</span><span class='bc' id='L1125' title='0|4|4 - Total: 4'>            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.Number);
</span><span class='bc' id='L1126' title='0|2|2 - Total: 2'>            return result;
</span>        }
<span class='bc' id='L1128' title='0|2|2 - Total: 2'>        if (val instanceof Boolean) {
</span><span class='bc' id='L1129' title='0|7|7 - Total: 7'>            NativeBoolean result = new NativeBoolean(((Boolean)val).booleanValue());
</span><span class='bc' id='L1130' title='0|4|4 - Total: 4'>            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.Boolean);
</span><span class='bc' id='L1131' title='0|2|2 - Total: 2'>            return result;
</span>        }
<span class='bc' id='L1133' title='0|2|2 - Total: 2'>        if (val == null) {
</span><span class='bc' id='L1134' title='0|3|3 - Total: 3'>            throw typeError0("msg.null.to.object");
</span>        }
<span class='bc' id='L1136' title='0|2|2 - Total: 2'>        if (val == Undefined.instance) {
</span><span class='bc' id='L1137' title='0|3|3 - Total: 3'>            throw typeError0("msg.undef.to.object");
</span>        }

        // Extension: Wrap as a LiveConnect object.
<span class='bc' id='L1141' title='0|8|8 - Total: 8'>        Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);
</span><span class='bpc' id='L1142' title='0|1|1 - Total: 2'>        if (wrapped instanceof Scriptable)
</span><span class='bc' id='L1143' title='0|3|3 - Total: 3'>            return (Scriptable) wrapped;
</span><span class='nc' id='L1144' title='0|0|0 - Total: 4'>        throw errorWithClassName("msg.invalid.type", val);
</span>    }

    /**
     * @deprecated Use {@link #toObject(Context, Scriptable, Object)} instead.
     */
    @Deprecated
    public static Scriptable toObject(Context cx, Scriptable scope, Object val,
                                      Class<?> staticClass)
    {
<span class='nc' id='L1154' title='0|0|0 - Total: 5'>        return toObject(cx, scope, val);
</span>    }

    /**
     * @deprecated The method is only present for compatibility.
     */
    @Deprecated
    public static Object call(Context cx, Object fun, Object thisArg,
                              Object[] args, Scriptable scope)
    {
<span class='nc' id='L1164' title='0|0|0 - Total: 2'>        if (!(fun instanceof Function)) {
</span><span class='nc' id='L1165' title='0|0|0 - Total: 4'>            throw notFunctionError(toString(fun));
</span>        }
<span class='nc' id='L1167' title='0|0|0 - Total: 3'>        Function function = (Function)fun;
</span><span class='nc' id='L1168' title='0|0|0 - Total: 5'>        Scriptable thisObj = toObjectOrNull(cx, thisArg, scope);
</span><span class='nc' id='L1169' title='0|0|0 - Total: 2'>        if (thisObj == null) {
</span><span class='nc' id='L1170' title='0|0|0 - Total: 4'>            throw undefCallError(thisObj, "function");
</span>        }
<span class='nc' id='L1172' title='0|0|0 - Total: 7'>        return function.call(cx, scope, thisObj, args);
</span>    }

    public static Scriptable newObject(Context cx, Scriptable scope,
                                       String constructorName, Object[] args)
    {
<span class='bc' id='L1178' title='0|3|3 - Total: 3'>        scope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L1179' title='0|5|5 - Total: 5'>        Function ctor = getExistingCtor(cx, scope, constructorName);
</span><span class='bpc' id='L1180' title='0|1|1 - Total: 2'>        if (args == null) { args = ScriptRuntime.emptyArgs; }
</span><span class='bc' id='L1181' title='0|6|6 - Total: 6'>        return ctor.construct(cx, scope, args);
</span>    }

    public static Scriptable newBuiltinObject(Context cx, Scriptable scope,
                                              TopLevel.Builtins type,
                                              Object[] args)
    {
<span class='bc' id='L1188' title='0|3|3 - Total: 3'>        scope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L1189' title='0|5|5 - Total: 5'>        Function ctor = TopLevel.getBuiltinCtor(cx, scope, type);
</span><span class='bpc' id='L1190' title='0|1|1 - Total: 2'>        if (args == null) { args = ScriptRuntime.emptyArgs; }
</span><span class='bc' id='L1191' title='0|6|6 - Total: 6'>        return ctor.construct(cx, scope, args);
</span>    }

    static Scriptable newNativeError(Context cx, Scriptable scope,
                                     TopLevel.NativeErrors type, Object[] args)
    {
<span class='bc' id='L1197' title='0|3|3 - Total: 3'>        scope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L1198' title='0|5|5 - Total: 5'>        Function ctor = TopLevel.getNativeErrorCtor(cx, scope, type);
</span><span class='bpc' id='L1199' title='0|1|1 - Total: 2'>        if (args == null) { args = ScriptRuntime.emptyArgs; }
</span><span class='bc' id='L1200' title='0|6|6 - Total: 6'>        return ctor.construct(cx, scope, args);
</span>    }

    /**
     *
     * See ECMA 9.4.
     */
    public static double toInteger(Object val) {
<span class='bc' id='L1208' title='0|4|4 - Total: 4'>        return toInteger(toNumber(val));
</span>    }

    // convenience method
    public static double toInteger(double d) {
        // if it's NaN
<span class='bc' id='L1214' title='0|2|2 - Total: 2'>        if (d != d)
</span><span class='bc' id='L1215' title='0|2|2 - Total: 2'>            return +0.0;
</span>
<span class='bc' id='L1217' title='0|6|6 - Total: 6'>        if (d == 0.0 ||
</span>            d == Double.POSITIVE_INFINITY ||
            d == Double.NEGATIVE_INFINITY)
<span class='bc' id='L1220' title='0|2|2 - Total: 2'>            return d;
</span>
<span class='bc' id='L1222' title='0|2|2 - Total: 2'>        if (d > 0.0)
</span><span class='bc' id='L1223' title='0|3|3 - Total: 3'>            return Math.floor(d);
</span>        else
<span class='bc' id='L1225' title='0|3|3 - Total: 3'>            return Math.ceil(d);
</span>    }

    public static double toInteger(Object[] args, int index) {
<span class='bc' id='L1229' title='0|2|2 - Total: 2'>        return (index < args.length) ? toInteger(args[index]) : +0.0;
</span>    }

    /**
     *
     * See ECMA 9.5.
     */
    public static int toInt32(Object val)
    {
        // short circuit for common integer values
<span class='bc' id='L1239' title='0|2|2 - Total: 2'>        if (val instanceof Integer)
</span><span class='bc' id='L1240' title='0|4|4 - Total: 4'>            return ((Integer)val).intValue();
</span>
<span class='bc' id='L1242' title='0|4|4 - Total: 4'>        return toInt32(toNumber(val));
</span>    }

    public static int toInt32(Object[] args, int index) {
<span class='bc' id='L1246' title='0|2|2 - Total: 2'>        return (index < args.length) ? toInt32(args[index]) : 0;
</span>    }

    public static int toInt32(double d) {
<span class='bc' id='L1250' title='0|3|3 - Total: 3'>        return DoubleConversion.doubleToInt32(d);
</span>    }

    /**
     * See ECMA 9.6.
     * @return long value representing 32 bits unsigned integer
     */
    public static long toUint32(double d) {
<span class='bc' id='L1258' title='0|6|6 - Total: 6'>        return DoubleConversion.doubleToInt32(d) & 0xffffffffL;
</span>    }

    public static long toUint32(Object val) {
<span class='bc' id='L1262' title='0|4|4 - Total: 4'>        return toUint32(toNumber(val));
</span>    }

    /**
     *
     * See ECMA 9.7.
     */
    public static char toUint16(Object val) {
<span class='bc' id='L1270' title='0|3|3 - Total: 3'>        double d = toNumber(val);
</span><span class='bc' id='L1271' title='0|4|4 - Total: 4'>        return (char)DoubleConversion.doubleToInt32(d);
</span>    }

    // XXX: this is until setDefaultNamespace will learn how to store NS
    // properly and separates namespace form Scriptable.get etc.
    private static final String DEFAULT_NS_TAG = "__default_namespace__";

    public static Object setDefaultNamespace(Object namespace, Context cx)
    {
<span class='bc' id='L1280' title='0|3|3 - Total: 3'>        Scriptable scope = cx.currentActivationCall;
</span><span class='bc' id='L1281' title='0|2|2 - Total: 2'>        if (scope == null) {
</span><span class='bc' id='L1282' title='0|3|3 - Total: 3'>            scope = getTopCallScope(cx);
</span>        }

<span class='bc' id='L1285' title='0|3|3 - Total: 3'>        XMLLib xmlLib = currentXMLLib(cx);
</span><span class='bc' id='L1286' title='0|5|5 - Total: 5'>        Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);
</span>
        // XXX : this should be in separated namesapce from Scriptable.get/put
<span class='bc' id='L1289' title='0|2|2 - Total: 2'>        if (!scope.has(DEFAULT_NS_TAG, scope)) {
</span>            // XXX: this is racy of cause
<span class='bc' id='L1291' title='0|6|6 - Total: 6'>            ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns,
</span>                                            ScriptableObject.PERMANENT
                                            | ScriptableObject.DONTENUM);
        } else {
<span class='bc' id='L1295' title='0|5|5 - Total: 5'>            scope.put(DEFAULT_NS_TAG, scope, ns);
</span>        }

<span class='bc' id='L1298' title='0|2|2 - Total: 2'>        return Undefined.instance;
</span>    }

    public static Object searchDefaultNamespace(Context cx)
    {
<span class='bc' id='L1303' title='0|3|3 - Total: 3'>        Scriptable scope = cx.currentActivationCall;
</span><span class='bc' id='L1304' title='0|2|2 - Total: 2'>        if (scope == null) {
</span><span class='bc' id='L1305' title='0|3|3 - Total: 3'>            scope = getTopCallScope(cx);
</span>        }
        Object nsObject;
        for (;;) {
<span class='bc' id='L1309' title='0|3|3 - Total: 3'>            Scriptable parent = scope.getParentScope();
</span><span class='bc' id='L1310' title='0|2|2 - Total: 2'>            if (parent == null) {
</span><span class='bc' id='L1311' title='0|4|4 - Total: 4'>                nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);
</span><span class='bc' id='L1312' title='0|2|2 - Total: 2'>                if (nsObject == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1313' title='0|2|2 - Total: 2'>                    return null;
</span>                }
                break;
            }
<span class='bc' id='L1317' title='0|5|5 - Total: 5'>            nsObject = scope.get(DEFAULT_NS_TAG, scope);
</span><span class='bc' id='L1318' title='0|2|2 - Total: 2'>            if (nsObject != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1319' title='0|1|1 - Total: 1'>                break;
</span>            }
<span class='bc' id='L1321' title='0|2|2 - Total: 2'>            scope = parent;
</span><span class='bc' id='L1322' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L1323' title='0|2|2 - Total: 2'>        return nsObject;
</span>    }

    public static Object getTopLevelProp(Scriptable scope, String id) {
<span class='bc' id='L1327' title='0|3|3 - Total: 3'>        scope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L1328' title='0|4|4 - Total: 4'>        return ScriptableObject.getProperty(scope, id);
</span>    }

    static Function getExistingCtor(Context cx, Scriptable scope,
                                    String constructorName)
    {
<span class='bc' id='L1334' title='0|4|4 - Total: 4'>        Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
</span><span class='bpc' id='L1335' title='0|1|1 - Total: 2'>        if (ctorVal instanceof Function) {
</span><span class='bc' id='L1336' title='0|3|3 - Total: 3'>            return (Function)ctorVal;
</span>        }
<span class='nc' id='L1338' title='0|0|0 - Total: 2'>        if (ctorVal == Scriptable.NOT_FOUND) {
</span><span class='nc' id='L1339' title='0|0|0 - Total: 4'>            throw Context.reportRuntimeError1(
</span>                "msg.ctor.not.found", constructorName);
        } else {
<span class='nc' id='L1342' title='0|0|0 - Total: 4'>            throw Context.reportRuntimeError1(
</span>                "msg.not.ctor", constructorName);
        }
    }

    /**
     * Return -1L if str is not an index, or the index value as lower 32
     * bits of the result. Note that the result needs to be cast to an int
     * in order to produce the actual index, which may be negative.
     */
    public static long indexFromString(String str)
    {
        // The length of the decimal string representation of
        //  Integer.MAX_VALUE, 2147483647
<span class='bc' id='L1356' title='0|2|2 - Total: 2'>        final int MAX_VALUE_LENGTH = 10;
</span>
<span class='bc' id='L1358' title='0|3|3 - Total: 3'>        int len = str.length();
</span><span class='bc' id='L1359' title='0|2|2 - Total: 2'>        if (len > 0) {
</span><span class='bc' id='L1360' title='0|2|2 - Total: 2'>            int i = 0;
</span><span class='bc' id='L1361' title='0|2|2 - Total: 2'>            boolean negate = false;
</span><span class='bc' id='L1362' title='0|4|4 - Total: 4'>            int c = str.charAt(0);
</span><span class='bc' id='L1363' title='0|2|2 - Total: 2'>            if (c == '-') {
</span><span class='bpc' id='L1364' title='0|1|1 - Total: 2'>                if (len > 1) {
</span><span class='bc' id='L1365' title='0|4|4 - Total: 4'>                    c = str.charAt(1);
</span><span class='bc' id='L1366' title='0|2|2 - Total: 2'>                    if (c == '0') return -1L; // "-0" is not an index
</span><span class='bc' id='L1367' title='0|2|2 - Total: 2'>                    i = 1;
</span><span class='bc' id='L1368' title='0|2|2 - Total: 2'>                    negate = true;
</span>                }
            }
<span class='bc' id='L1371' title='0|1|1 - Total: 1'>            c -= '0';
</span><span class='bc' id='L1372' title='0|8|8 - Total: 8'>            if (0 <= c && c <= 9
</span>                && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH))
            {
                // Use negative numbers to accumulate index to handle
                // Integer.MIN_VALUE that is greater by 1 in absolute value
                // then Integer.MAX_VALUE
<span class='bc' id='L1378' title='0|3|3 - Total: 3'>                int index = -c;
</span><span class='bc' id='L1379' title='0|2|2 - Total: 2'>                int oldIndex = 0;
</span><span class='bc' id='L1380' title='0|1|1 - Total: 1'>                i++;
</span><span class='bc' id='L1381' title='0|2|2 - Total: 2'>                if (index != 0) {
</span>                    // Note that 00, 01, 000 etc. are not indexes
<span class='bc' id='L1383' title='0|6|6 - Total: 6'>                    while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9)
</span>                    {
<span class='bc' id='L1385' title='0|2|2 - Total: 2'>                        oldIndex = index;
</span><span class='bc' id='L1386' title='0|6|6 - Total: 6'>                        index = 10 * index - c;
</span><span class='bc' id='L1387' title='0|2|2 - Total: 2'>                        i++;
</span>                    }
                }
                // Make sure all characters were consumed and that it couldn't
                // have overflowed.
<span class='bpc' id='L1392' title='0|5|5 - Total: 10'>                if (i == len &&
</span>                    (oldIndex > (Integer.MIN_VALUE / 10) ||
                     (oldIndex == (Integer.MIN_VALUE / 10) &&
                      c <= (negate ? -(Integer.MIN_VALUE % 10)
                                   : (Integer.MAX_VALUE % 10)))))
                {
<span class='bc' id='L1398' title='0|2|2 - Total: 2'>                    return 0xFFFFFFFFL & (negate ? index : -index);
</span>                }
            }
        }
<span class='bc' id='L1402' title='0|2|2 - Total: 2'>        return -1L;
</span>    }

    /**
     * If str is a decimal presentation of Uint32 value, return it as long.
     * Othewise return -1L;
     */
    public static long testUint32String(String str)
    {
        // The length of the decimal string representation of
        //  UINT32_MAX_VALUE, 4294967296
<span class='bc' id='L1413' title='0|2|2 - Total: 2'>        final int MAX_VALUE_LENGTH = 10;
</span>
<span class='bc' id='L1415' title='0|3|3 - Total: 3'>        int len = str.length();
</span><span class='bpc' id='L1416' title='0|2|2 - Total: 4'>        if (1 <= len && len <= MAX_VALUE_LENGTH) {
</span><span class='bc' id='L1417' title='0|4|4 - Total: 4'>            int c = str.charAt(0);
</span><span class='bc' id='L1418' title='0|1|1 - Total: 1'>            c -= '0';
</span><span class='bpc' id='L1419' title='0|1|1 - Total: 2'>            if (c == 0) {
</span>                // Note that 00,01 etc. are not valid Uint32 presentations
<span class='nc' id='L1421' title='0|0|0 - Total: 2'>                return (len == 1) ? 0L : -1L;
</span>            }
<span class='bpc' id='L1423' title='0|3|3 - Total: 4'>            if (1 <= c && c <= 9) {
</span><span class='nc' id='L1424' title='0|0|0 - Total: 3'>                long v = c;
</span><span class='nc' id='L1425' title='0|0|0 - Total: 2'>                for (int i = 1; i != len; ++i) {
</span><span class='nc' id='L1426' title='0|0|0 - Total: 6'>                    c = str.charAt(i) - '0';
</span><span class='nc' id='L1427' title='0|0|0 - Total: 4'>                    if (!(0 <= c && c <= 9)) {
</span><span class='nc' id='L1428' title='0|0|0 - Total: 2'>                        return -1;
</span>                    }
<span class='nc' id='L1430' title='0|0|0 - Total: 7'>                    v = 10 * v + c;
</span>                }
                // Check for overflow
<span class='nc' id='L1433' title='0|0|0 - Total: 2'>                if ((v >>> 32) == 0) {
</span><span class='nc' id='L1434' title='0|0|0 - Total: 2'>                    return v;
</span>                }
            }
        }
<span class='bc' id='L1438' title='0|2|2 - Total: 2'>        return -1;
</span>    }

    /**
     * If s represents index, then return index value wrapped as Integer
     * and othewise return s.
     */
    static Object getIndexObject(String s)
    {
<span class='bc' id='L1447' title='0|3|3 - Total: 3'>        long indexTest = indexFromString(s);
</span><span class='bc' id='L1448' title='0|2|2 - Total: 2'>        if (indexTest >= 0) {
</span><span class='bc' id='L1449' title='0|4|4 - Total: 4'>            return Integer.valueOf((int)indexTest);
</span>        }
<span class='bc' id='L1451' title='0|2|2 - Total: 2'>        return s;
</span>    }

    /**
     * If d is exact int value, return its value wrapped as Integer
     * and othewise return d converted to String.
     */
    static Object getIndexObject(double d)
    {
<span class='bc' id='L1460' title='0|3|3 - Total: 3'>        int i = (int)d;
</span><span class='bpc' id='L1461' title='0|1|1 - Total: 2'>        if (i == d) {
</span><span class='bc' id='L1462' title='0|3|3 - Total: 3'>            return Integer.valueOf(i);
</span>        }
<span class='nc' id='L1464' title='0|0|0 - Total: 3'>        return toString(d);
</span>    }

    /**
     * If toString(id) is a decimal presentation of int32 value, then id
     * is index. In this case return null and make the index available
     * as ScriptRuntime.lastIndexResult(cx). Otherwise return toString(id).
     */
    static String toStringIdOrIndex(Context cx, Object id)
    {
<span class='bc' id='L1474' title='0|2|2 - Total: 2'>        if (id instanceof Number) {
</span><span class='bc' id='L1475' title='0|4|4 - Total: 4'>            double d = ((Number)id).doubleValue();
</span><span class='bc' id='L1476' title='0|3|3 - Total: 3'>            int index = (int)d;
</span><span class='bc' id='L1477' title='0|2|2 - Total: 2'>            if (index == d) {
</span><span class='bc' id='L1478' title='0|3|3 - Total: 3'>                storeIndexResult(cx, index);
</span><span class='bc' id='L1479' title='0|2|2 - Total: 2'>                return null;
</span>            }
<span class='bc' id='L1481' title='0|3|3 - Total: 3'>            return toString(id);
</span>        } else {
            String s;
<span class='bc' id='L1484' title='0|2|2 - Total: 2'>            if (id instanceof String) {
</span><span class='bc' id='L1485' title='0|4|4 - Total: 4'>                s = (String)id;
</span>            } else {
<span class='bc' id='L1487' title='0|3|3 - Total: 3'>                s = toString(id);
</span>            }
<span class='bc' id='L1489' title='0|3|3 - Total: 3'>            long indexTest = indexFromString(s);
</span><span class='bc' id='L1490' title='0|2|2 - Total: 2'>            if (indexTest >= 0) {
</span><span class='bc' id='L1491' title='0|4|4 - Total: 4'>                storeIndexResult(cx, (int)indexTest);
</span><span class='bc' id='L1492' title='0|2|2 - Total: 2'>                return null;
</span>            }
<span class='bc' id='L1494' title='0|2|2 - Total: 2'>            return s;
</span>        }
    }

    /**
     * Call obj.[[Get]](id)
     *
     * @deprecated Use {@link #getObjectElem(Object, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectElem(Object obj, Object elem, Context cx)
    {
<span class='nc' id='L1506' title='0|0|0 - Total: 7'>        return getObjectElem(obj, elem, cx, getTopCallScope(cx));
</span>    }

    /**
     * Call obj.[[Get]](id)
     */
    public static Object getObjectElem(Object obj, Object elem, Context cx, Scriptable scope)
    {
<span class='bc' id='L1514' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L1515' title='0|2|2 - Total: 2'>        if (sobj == null) {
</span><span class='bc' id='L1516' title='0|4|4 - Total: 4'>            throw undefReadError(obj, elem);
</span>        }
<span class='bc' id='L1518' title='0|5|5 - Total: 5'>        return getObjectElem(sobj, elem, cx);
</span>    }

    public static Object getObjectElem(Scriptable obj, Object elem,
                                       Context cx)
    {

        Object result;

<span class='bc' id='L1527' title='0|2|2 - Total: 2'>        if (obj instanceof XMLObject) {
</span><span class='bc' id='L1528' title='0|7|7 - Total: 7'>            result = ((XMLObject)obj).get(cx, elem);
</span><span class='bc' id='L1529' title='0|2|2 - Total: 2'>        } else if (isSymbol(elem)) {
</span><span class='bc' id='L1530' title='0|6|6 - Total: 6'>            result = ScriptableObject.getProperty(obj, (Symbol)elem);
</span>        } else {
<span class='bc' id='L1532' title='0|4|4 - Total: 4'>            String s = toStringIdOrIndex(cx, elem);
</span><span class='bc' id='L1533' title='0|2|2 - Total: 2'>            if (s == null) {
</span><span class='bc' id='L1534' title='0|3|3 - Total: 3'>                int index = lastIndexResult(cx);
</span><span class='bc' id='L1535' title='0|4|4 - Total: 4'>                result = ScriptableObject.getProperty(obj, index);
</span><span class='bc' id='L1536' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L1537' title='0|4|4 - Total: 4'>                result = ScriptableObject.getProperty(obj, s);
</span>            }
        }

<span class='bc' id='L1541' title='0|2|2 - Total: 2'>        if (result == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1542' title='0|2|2 - Total: 2'>            result = Undefined.instance;
</span>        }

<span class='bc' id='L1545' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Version of getObjectElem when elem is a valid JS identifier name.
     *
     * @deprecated Use {@link #getObjectProp(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectProp(Object obj, String property,
                                       Context cx)
    {
<span class='nc' id='L1557' title='0|0|0 - Total: 7'>        return getObjectProp(obj, property, cx, getTopCallScope(cx));
</span>    }

    /**
     * Version of getObjectElem when elem is a valid JS identifier name.
     *
     * @param scope the scope that should be used to resolve primitive prototype
     */
    public static Object getObjectProp(Object obj, String property,
                                       Context cx, Scriptable scope)
    {
<span class='bc' id='L1568' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L1569' title='0|2|2 - Total: 2'>        if (sobj == null) {
</span><span class='bc' id='L1570' title='0|4|4 - Total: 4'>            throw undefReadError(obj, property);
</span>        }
<span class='bc' id='L1572' title='0|5|5 - Total: 5'>        return getObjectProp(sobj, property, cx);
</span>    }

    public static Object getObjectProp(Scriptable obj, String property,
                                       Context cx)
    {

<span class='bc' id='L1579' title='0|4|4 - Total: 4'>        Object result = ScriptableObject.getProperty(obj, property);
</span><span class='bc' id='L1580' title='0|2|2 - Total: 2'>        if (result == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1581' title='0|2|2 - Total: 2'>            if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {
</span><span class='nc' id='L1582' title='0|0|0 - Total: 4'>                Context.reportWarning(ScriptRuntime.getMessage1(
</span>                    "msg.ref.undefined.prop", property));
            }
<span class='bc' id='L1585' title='0|2|2 - Total: 2'>            result = Undefined.instance;
</span>        }

<span class='bc' id='L1588' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * @deprecated Use {@link #getObjectPropNoWarn(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectPropNoWarn(Object obj, String property,
                                             Context cx)
    {
<span class='nc' id='L1598' title='0|0|0 - Total: 7'>        return getObjectPropNoWarn(obj, property, cx, getTopCallScope(cx));
</span>    }

    public static Object getObjectPropNoWarn(Object obj, String property,
                                             Context cx, Scriptable scope)
    {
<span class='bc' id='L1604' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bpc' id='L1605' title='0|1|1 - Total: 2'>        if (sobj == null) {
</span><span class='nc' id='L1606' title='0|0|0 - Total: 4'>            throw undefReadError(obj, property);
</span>        }
<span class='bc' id='L1608' title='0|4|4 - Total: 4'>        Object result = ScriptableObject.getProperty(sobj, property);
</span><span class='bc' id='L1609' title='0|2|2 - Total: 2'>        if (result == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1610' title='0|2|2 - Total: 2'>          return Undefined.instance;
</span>        }
<span class='bc' id='L1612' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     *
     * @deprecated Use {@link #getObjectIndex(Object, double, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectIndex(Object obj, double dblIndex,
                                        Context cx)
    {
<span class='bc' id='L1625' title='0|7|7 - Total: 7'>        return getObjectIndex(obj, dblIndex, cx, getTopCallScope(cx));
</span>    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     */
    public static Object getObjectIndex(Object obj, double dblIndex,
                                        Context cx, Scriptable scope)
    {
<span class='bc' id='L1635' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L1636' title='0|2|2 - Total: 2'>        if (sobj == null) {
</span><span class='bc' id='L1637' title='0|5|5 - Total: 5'>            throw undefReadError(obj, toString(dblIndex));
</span>        }

<span class='bc' id='L1640' title='0|3|3 - Total: 3'>        int index = (int)dblIndex;
</span><span class='bc' id='L1641' title='0|2|2 - Total: 2'>        if (index == dblIndex) {
</span><span class='bc' id='L1642' title='0|5|5 - Total: 5'>            return getObjectIndex(sobj, index, cx);
</span>        } else {
<span class='bc' id='L1644' title='0|3|3 - Total: 3'>            String s = toString(dblIndex);
</span><span class='bc' id='L1645' title='0|5|5 - Total: 5'>            return getObjectProp(sobj, s, cx);
</span>        }
    }

    public static Object getObjectIndex(Scriptable obj, int index,
                                        Context cx)
    {
<span class='bc' id='L1652' title='0|4|4 - Total: 4'>        Object result = ScriptableObject.getProperty(obj, index);
</span><span class='bc' id='L1653' title='0|2|2 - Total: 2'>        if (result == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1654' title='0|2|2 - Total: 2'>            result = Undefined.instance;
</span>        }

<span class='bc' id='L1657' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Call obj.[[Put]](id, value)
     *
     * @deprecated Use {@link #setObjectElem(Object, Object, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object setObjectElem(Object obj, Object elem, Object value,
                                       Context cx)
    {
<span class='nc' id='L1669' title='0|0|0 - Total: 8'>        return setObjectElem(obj, elem, value, cx, getTopCallScope(cx));
</span>    }

    /**
     * Call obj.[[Put]](id, value)
     */
    public static Object setObjectElem(Object obj, Object elem, Object value,
                                       Context cx, Scriptable scope)
    {
<span class='bc' id='L1678' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L1679' title='0|2|2 - Total: 2'>        if (sobj == null) {
</span><span class='bc' id='L1680' title='0|5|5 - Total: 5'>            throw undefWriteError(obj, elem, value);
</span>        }
<span class='bc' id='L1682' title='0|6|6 - Total: 6'>        return setObjectElem(sobj, elem, value, cx);
</span>    }

    public static Object setObjectElem(Scriptable obj, Object elem,
                                       Object value, Context cx)
    {
<span class='bc' id='L1688' title='0|2|2 - Total: 2'>        if (obj instanceof XMLObject) {
</span><span class='bc' id='L1689' title='0|7|7 - Total: 7'>            ((XMLObject)obj).put(cx, elem, value);
</span><span class='bc' id='L1690' title='0|2|2 - Total: 2'>        } else if (isSymbol(elem)) {
</span><span class='bc' id='L1691' title='0|6|6 - Total: 6'>            ScriptableObject.putProperty(obj, (Symbol)elem, value);
</span>        } else {
<span class='bc' id='L1693' title='0|4|4 - Total: 4'>            String s = toStringIdOrIndex(cx, elem);
</span><span class='bc' id='L1694' title='0|2|2 - Total: 2'>            if (s == null) {
</span><span class='bc' id='L1695' title='0|3|3 - Total: 3'>                int index = lastIndexResult(cx);
</span><span class='bc' id='L1696' title='0|4|4 - Total: 4'>                ScriptableObject.putProperty(obj, index, value);
</span><span class='bc' id='L1697' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L1698' title='0|4|4 - Total: 4'>                ScriptableObject.putProperty(obj, s, value);
</span>            }
        }

<span class='bc' id='L1702' title='0|2|2 - Total: 2'>        return value;
</span>    }

    /**
     * Version of setObjectElem when elem is a valid JS identifier name.
     *
     * @deprecated Use {@link #setObjectProp(Object, String, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object setObjectProp(Object obj, String property,
                                       Object value, Context cx)
    {
<span class='nc' id='L1714' title='0|0|0 - Total: 8'>        return setObjectProp(obj, property, value, cx, getTopCallScope(cx));
</span>    }

    /**
     * Version of setObjectElem when elem is a valid JS identifier name.
     */
    public static Object setObjectProp(Object obj, String property,
                                       Object value, Context cx,
                                       Scriptable scope)
    {
<span class='bc' id='L1724' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L1725' title='0|2|2 - Total: 2'>        if (sobj == null) {
</span><span class='bc' id='L1726' title='0|5|5 - Total: 5'>            throw undefWriteError(obj, property, value);
</span>        }
<span class='bc' id='L1728' title='0|6|6 - Total: 6'>        return setObjectProp(sobj, property, value, cx);
</span>    }

    public static Object setObjectProp(Scriptable obj, String property,
                                       Object value, Context cx)
    {
<span class='bc' id='L1734' title='0|4|4 - Total: 4'>        ScriptableObject.putProperty(obj, property, value);
</span><span class='bc' id='L1735' title='0|2|2 - Total: 2'>        return value;
</span>    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     *
     * @deprecated Use {@link #setObjectIndex(Object, double, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object setObjectIndex(Object obj, double dblIndex,
                                        Object value, Context cx)
    {
<span class='nc' id='L1748' title='0|0|0 - Total: 8'>        return setObjectIndex(obj, dblIndex, value, cx, getTopCallScope(cx));
</span>    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     */
    public static Object setObjectIndex(Object obj, double dblIndex,
                                        Object value, Context cx,
                                        Scriptable scope)
    {
<span class='bc' id='L1759' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bpc' id='L1760' title='0|1|1 - Total: 2'>        if (sobj == null) {
</span><span class='nc' id='L1761' title='0|0|0 - Total: 6'>            throw undefWriteError(obj, String.valueOf(dblIndex), value);
</span>        }

<span class='bc' id='L1764' title='0|3|3 - Total: 3'>        int index = (int)dblIndex;
</span><span class='bc' id='L1765' title='0|2|2 - Total: 2'>        if (index == dblIndex) {
</span><span class='bc' id='L1766' title='0|6|6 - Total: 6'>            return setObjectIndex(sobj, index, value, cx);
</span>        } else {
<span class='bc' id='L1768' title='0|3|3 - Total: 3'>            String s = toString(dblIndex);
</span><span class='bc' id='L1769' title='0|6|6 - Total: 6'>            return setObjectProp(sobj, s, value, cx);
</span>        }
    }

    public static Object setObjectIndex(Scriptable obj, int index, Object value,
                                        Context cx)
    {
<span class='bc' id='L1776' title='0|4|4 - Total: 4'>        ScriptableObject.putProperty(obj, index, value);
</span><span class='bc' id='L1777' title='0|2|2 - Total: 2'>        return value;
</span>    }

    public static boolean deleteObjectElem(Scriptable target, Object elem,
                                           Context cx)
    {
<span class='bc' id='L1783' title='0|2|2 - Total: 2'>        if (isSymbol(elem)) {
</span><span class='bc' id='L1784' title='0|3|3 - Total: 3'>            SymbolScriptable so = ScriptableObject.ensureSymbolScriptable(target);
</span><span class='bc' id='L1785' title='0|3|3 - Total: 3'>            Symbol s = (Symbol)elem;
</span><span class='bc' id='L1786' title='0|3|3 - Total: 3'>            so.delete(s);
</span><span class='bpc' id='L1787' title='0|1|1 - Total: 2'>            return !so.has(s, target);
</span>        }
<span class='bc' id='L1789' title='0|4|4 - Total: 4'>        String s = toStringIdOrIndex(cx, elem);
</span><span class='bc' id='L1790' title='0|2|2 - Total: 2'>        if (s == null) {
</span><span class='bc' id='L1791' title='0|3|3 - Total: 3'>            int index = lastIndexResult(cx);
</span><span class='bc' id='L1792' title='0|3|3 - Total: 3'>            target.delete(index);
</span><span class='bc' id='L1793' title='0|2|2 - Total: 2'>            return !target.has(index, target);
</span>        } else {
<span class='bc' id='L1795' title='0|3|3 - Total: 3'>            target.delete(s);
</span><span class='bc' id='L1796' title='0|2|2 - Total: 2'>            return !target.has(s, target);
</span>        }
    }

    public static boolean hasObjectElem(Scriptable target, Object elem,
                                        Context cx)
    {
        boolean result;

<span class='bc' id='L1805' title='0|2|2 - Total: 2'>        if (isSymbol(elem)) {
</span><span class='bc' id='L1806' title='0|6|6 - Total: 6'>            result = ScriptableObject.hasProperty(target, (Symbol)elem);
</span>        } else {
<span class='bc' id='L1808' title='0|4|4 - Total: 4'>            String s = toStringIdOrIndex(cx, elem);
</span><span class='bc' id='L1809' title='0|2|2 - Total: 2'>            if (s == null) {
</span><span class='bc' id='L1810' title='0|3|3 - Total: 3'>                int index = lastIndexResult(cx);
</span><span class='bc' id='L1811' title='0|4|4 - Total: 4'>                result = ScriptableObject.hasProperty(target, index);
</span><span class='bc' id='L1812' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L1813' title='0|4|4 - Total: 4'>                result = ScriptableObject.hasProperty(target, s);
</span>            }
        }

<span class='bc' id='L1817' title='0|2|2 - Total: 2'>        return result;
</span>    }

    public static Object refGet(Ref ref, Context cx)
    {
<span class='bc' id='L1822' title='0|4|4 - Total: 4'>        return ref.get(cx);
</span>    }

    /**
     * @deprecated Use {@link #refSet(Ref, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object refSet(Ref ref, Object value, Context cx)
    {
<span class='nc' id='L1831' title='0|0|0 - Total: 7'>        return refSet(ref, value, cx, getTopCallScope(cx));
</span>    }

    public static Object refSet(Ref ref, Object value, Context cx,
                                Scriptable scope)
    {
<span class='bc' id='L1837' title='0|6|6 - Total: 6'>        return ref.set(cx, scope, value);
</span>    }

    public static Object refDel(Ref ref, Context cx)
    {
<span class='bc' id='L1842' title='0|5|5 - Total: 5'>        return wrapBoolean(ref.delete(cx));
</span>    }

    static boolean isSpecialProperty(String s)
    {
<span class='bc' id='L1847' title='0|4|4 - Total: 4'>        return s.equals("__proto__") || s.equals("__parent__");
</span>    }

    /**
     * @deprecated Use {@link #specialRef(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Ref specialRef(Object obj, String specialProperty,
                                 Context cx)
    {
<span class='nc' id='L1857' title='0|0|0 - Total: 7'>        return specialRef(obj, specialProperty, cx, getTopCallScope(cx));
</span>    }

    public static Ref specialRef(Object obj, String specialProperty,
                                 Context cx, Scriptable scope)
    {
<span class='bc' id='L1863' title='0|6|6 - Total: 6'>        return SpecialRef.createSpecial(cx, scope, obj, specialProperty);
</span>    }

    /**
     * @deprecated Use {@link #delete(Object, Object, Context, Scriptable, boolean)} instead
     */
    @Deprecated
    public static Object delete(Object obj, Object id, Context cx)
    {
<span class='nc' id='L1872' title='0|0|0 - Total: 6'>        return delete(obj, id, cx, false);
</span>    }

    /**
     * The delete operator
     *
     * See ECMA 11.4.1
     *
     * In ECMA 0.19, the description of the delete operator (11.4.1)
     * assumes that the [[Delete]] method returns a value. However,
     * the definition of the [[Delete]] operator (8.6.2.5) does not
     * define a return value. Here we assume that the [[Delete]]
     * method doesn't return a value.
     *
     * @deprecated Use {@link #delete(Object, Object, Context, Scriptable, boolean)} instead
     */
    @Deprecated
    public static Object delete(Object obj, Object id, Context cx, boolean isName)
    {
<span class='bc' id='L1891' title='0|8|8 - Total: 8'>        return delete(obj, id, cx, getTopCallScope(cx), isName);
</span>    }

    /**
     * The delete operator
     *
     * See ECMA 11.4.1
     *
     * In ECMA 0.19, the description of the delete operator (11.4.1)
     * assumes that the [[Delete]] method returns a value. However,
     * the definition of the [[Delete]] operator (8.6.2.5) does not
     * define a return value. Here we assume that the [[Delete]]
     * method doesn't return a value.
     */
    public static Object delete(Object obj, Object id, Context cx,
                                Scriptable scope, boolean isName)
    {
<span class='bc' id='L1908' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L1909' title='0|2|2 - Total: 2'>        if (sobj == null) {
</span><span class='bpc' id='L1910' title='0|1|1 - Total: 2'>            if (isName) {
</span><span class='bc' id='L1911' title='0|2|2 - Total: 2'>                return Boolean.TRUE;
</span>            }
<span class='nc' id='L1913' title='0|0|0 - Total: 4'>            throw undefDeleteError(obj, id);
</span>        }
<span class='bc' id='L1915' title='0|5|5 - Total: 5'>        boolean result = deleteObjectElem(sobj, id, cx);
</span><span class='bc' id='L1916' title='0|3|3 - Total: 3'>        return wrapBoolean(result);
</span>    }

    /**
     * Looks up a name in the scope chain and returns its value.
     */
    public static Object name(Context cx, Scriptable scope, String name)
    {
<span class='bc' id='L1924' title='0|3|3 - Total: 3'>        Scriptable parent = scope.getParentScope();
</span><span class='bc' id='L1925' title='0|2|2 - Total: 2'>        if (parent == null) {
</span><span class='bc' id='L1926' title='0|5|5 - Total: 5'>            Object result = topScopeName(cx, scope, name);
</span><span class='bc' id='L1927' title='0|2|2 - Total: 2'>            if (result == Scriptable.NOT_FOUND) {
</span><span class='nc' id='L1928' title='0|0|0 - Total: 4'>                throw notFoundError(scope, name);
</span>            }
<span class='bc' id='L1930' title='0|2|2 - Total: 2'>            return result;
</span>        }

<span class='bc' id='L1933' title='0|7|7 - Total: 7'>        return nameOrFunction(cx, scope, parent, name, false);
</span>    }

    private static Object nameOrFunction(Context cx, Scriptable scope,
                                         Scriptable parentScope, String name,
                                         boolean asFunctionCall)
    {
        Object result;
<span class='bc' id='L1941' title='0|2|2 - Total: 2'>        Scriptable thisObj = scope; // It is used only if asFunctionCall==true.
</span>
<span class='bc' id='L1943' title='0|2|2 - Total: 2'>        XMLObject firstXMLObject = null;
</span>        for (;;) {
<span class='bc' id='L1945' title='0|2|2 - Total: 2'>            if (scope instanceof NativeWith) {
</span><span class='bc' id='L1946' title='0|3|3 - Total: 3'>                Scriptable withObj = scope.getPrototype();
</span><span class='bc' id='L1947' title='0|2|2 - Total: 2'>                if (withObj instanceof XMLObject) {
</span><span class='bc' id='L1948' title='0|3|3 - Total: 3'>                    XMLObject xmlObj = (XMLObject)withObj;
</span><span class='bc' id='L1949' title='0|2|2 - Total: 2'>                    if (xmlObj.has(name, xmlObj)) {
</span>                        // function this should be the target object of with
<span class='bc' id='L1951' title='0|2|2 - Total: 2'>                        thisObj = xmlObj;
</span><span class='bc' id='L1952' title='0|5|5 - Total: 5'>                        result = xmlObj.get(name, xmlObj);
</span><span class='bc' id='L1953' title='0|1|1 - Total: 1'>                        break;
</span>                    }
<span class='bpc' id='L1955' title='0|1|1 - Total: 2'>                    if (firstXMLObject == null) {
</span><span class='bc' id='L1956' title='0|2|2 - Total: 2'>                        firstXMLObject = xmlObj;
</span>                    }
<span class='bc' id='L1958' title='0|1|1 - Total: 1'>                } else {
</span><span class='bc' id='L1959' title='0|4|4 - Total: 4'>                    result = ScriptableObject.getProperty(withObj, name);
</span><span class='bc' id='L1960' title='0|2|2 - Total: 2'>                    if (result != Scriptable.NOT_FOUND) {
</span>                        // function this should be the target object of with
<span class='bc' id='L1962' title='0|2|2 - Total: 2'>                        thisObj = withObj;
</span><span class='bc' id='L1963' title='0|1|1 - Total: 1'>                        break;
</span>                    }
                }
<span class='bc' id='L1966' title='0|2|2 - Total: 2'>            } else if (scope instanceof NativeCall) {
</span>                // NativeCall does not prototype chain and Scriptable.get
                // can be called directly.
<span class='bc' id='L1969' title='0|5|5 - Total: 5'>                result = scope.get(name, scope);
</span><span class='bc' id='L1970' title='0|2|2 - Total: 2'>                if (result != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1971' title='0|2|2 - Total: 2'>                    if (asFunctionCall) {
</span>                        // ECMA 262 requires that this for nested funtions
                        // should be top scope
<span class='bc' id='L1974' title='0|1|1 - Total: 1'>                        thisObj = ScriptableObject.
</span><span class='bc' id='L1975' title='0|3|3 - Total: 3'>                                      getTopLevelScope(parentScope);
</span>                    }
                    break;
                }
            } else {
                // Can happen if Rhino embedding decided that nested
                // scopes are useful for what ever reasons.
<span class='bc' id='L1982' title='0|4|4 - Total: 4'>                result = ScriptableObject.getProperty(scope, name);
</span><span class='bc' id='L1983' title='0|2|2 - Total: 2'>                if (result != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L1984' title='0|2|2 - Total: 2'>                    thisObj = scope;
</span><span class='bc' id='L1985' title='0|1|1 - Total: 1'>                    break;
</span>                }
            }
<span class='bc' id='L1988' title='0|2|2 - Total: 2'>            scope = parentScope;
</span><span class='bc' id='L1989' title='0|3|3 - Total: 3'>            parentScope = parentScope.getParentScope();
</span><span class='bc' id='L1990' title='0|2|2 - Total: 2'>            if (parentScope == null) {
</span><span class='bc' id='L1991' title='0|5|5 - Total: 5'>                result = topScopeName(cx, scope, name);
</span><span class='bc' id='L1992' title='0|2|2 - Total: 2'>                if (result == Scriptable.NOT_FOUND) {
</span><span class='bpc' id='L1993' title='0|3|3 - Total: 4'>                    if (firstXMLObject == null || asFunctionCall) {
</span><span class='nc' id='L1994' title='0|0|0 - Total: 4'>                        throw notFoundError(scope, name);
</span>                    }
                    // The name was not found, but we did find an XML
                    // object in the scope chain and we are looking for name,
                    // not function. The result should be an empty XMLList
                    // in name context.
<span class='bc' id='L2000' title='0|5|5 - Total: 5'>                    result = firstXMLObject.get(name, firstXMLObject);
</span>                }
                // For top scope thisObj for functions is always scope itself.
<span class='bc' id='L2003' title='0|2|2 - Total: 2'>                thisObj = scope;
</span><span class='bc' id='L2004' title='0|1|1 - Total: 1'>                break;
</span>            }
        }

<span class='bc' id='L2008' title='0|2|2 - Total: 2'>        if (asFunctionCall) {
</span><span class='bc' id='L2009' title='0|2|2 - Total: 2'>            if (!(result instanceof Callable)) {
</span><span class='bc' id='L2010' title='0|4|4 - Total: 4'>                throw notFunctionError(result, name);
</span>            }
<span class='bc' id='L2012' title='0|3|3 - Total: 3'>            storeScriptable(cx, thisObj);
</span>        }

<span class='bc' id='L2015' title='0|2|2 - Total: 2'>        return result;
</span>    }

    private static Object topScopeName(Context cx, Scriptable scope,
                                       String name)
    {
<span class='bc' id='L2021' title='0|2|2 - Total: 2'>        if (cx.useDynamicScope) {
</span><span class='bc' id='L2022' title='0|5|5 - Total: 5'>            scope = checkDynamicScope(cx.topCallScope, scope);
</span>        }
<span class='bc' id='L2024' title='0|4|4 - Total: 4'>        return ScriptableObject.getProperty(scope, name);
</span>    }


    /**
     * Returns the object in the scope chain that has a given property.
     *
     * The order of evaluation of an assignment expression involves
     * evaluating the lhs to a reference, evaluating the rhs, and then
     * modifying the reference with the rhs value. This method is used
     * to 'bind' the given name to an object containing that property
     * so that the side effects of evaluating the rhs do not affect
     * which property is modified.
     * Typically used in conjunction with setName.
     *
     * See ECMA 10.1.4
     */
    public static Scriptable bind(Context cx, Scriptable scope, String id)
    {
<span class='bc' id='L2043' title='0|2|2 - Total: 2'>        Scriptable firstXMLObject = null;
</span><span class='bc' id='L2044' title='0|3|3 - Total: 3'>        Scriptable parent = scope.getParentScope();
</span><span class='bc' id='L2045' title='0|2|2 - Total: 2'>        childScopesChecks: if (parent != null) {
</span>            // Check for possibly nested "with" scopes first
<span class='bc' id='L2047' title='0|2|2 - Total: 2'>            while (scope instanceof NativeWith) {
</span><span class='bc' id='L2048' title='0|3|3 - Total: 3'>                Scriptable withObj = scope.getPrototype();
</span><span class='bc' id='L2049' title='0|2|2 - Total: 2'>                if (withObj instanceof XMLObject) {
</span><span class='bc' id='L2050' title='0|3|3 - Total: 3'>                    XMLObject xmlObject = (XMLObject)withObj;
</span><span class='bpc' id='L2051' title='0|1|1 - Total: 2'>                    if (xmlObject.has(cx, id)) {
</span><span class='nc' id='L2052' title='0|0|0 - Total: 2'>                        return xmlObject;
</span>                    }
<span class='bpc' id='L2054' title='0|1|1 - Total: 2'>                    if (firstXMLObject == null) {
</span><span class='bc' id='L2055' title='0|2|2 - Total: 2'>                        firstXMLObject = xmlObject;
</span>                    }
<span class='bc' id='L2057' title='0|1|1 - Total: 1'>                } else {
</span><span class='bc' id='L2058' title='0|2|2 - Total: 2'>                    if (ScriptableObject.hasProperty(withObj, id)) {
</span><span class='bc' id='L2059' title='0|2|2 - Total: 2'>                        return withObj;
</span>                    }
                }
<span class='bc' id='L2062' title='0|2|2 - Total: 2'>                scope = parent;
</span><span class='bc' id='L2063' title='0|3|3 - Total: 3'>                parent = parent.getParentScope();
</span><span class='bc' id='L2064' title='0|2|2 - Total: 2'>                if (parent == null) {
</span><span class='bc' id='L2065' title='0|1|1 - Total: 1'>                    break childScopesChecks;
</span>                }
<span class='bc' id='L2067' title='0|1|1 - Total: 1'>            }
</span>            for (;;) {
<span class='bc' id='L2069' title='0|2|2 - Total: 2'>                if (ScriptableObject.hasProperty(scope, id)) {
</span><span class='bc' id='L2070' title='0|2|2 - Total: 2'>                    return scope;
</span>                }
<span class='bc' id='L2072' title='0|2|2 - Total: 2'>                scope = parent;
</span><span class='bc' id='L2073' title='0|3|3 - Total: 3'>                parent = parent.getParentScope();
</span><span class='bc' id='L2074' title='0|2|2 - Total: 2'>                if (parent == null) {
</span><span class='bc' id='L2075' title='0|1|1 - Total: 1'>                    break childScopesChecks;
</span>                }
            }
        }
        // scope here is top scope
<span class='bc' id='L2080' title='0|2|2 - Total: 2'>        if (cx.useDynamicScope) {
</span><span class='bc' id='L2081' title='0|5|5 - Total: 5'>            scope = checkDynamicScope(cx.topCallScope, scope);
</span>        }
<span class='bc' id='L2083' title='0|2|2 - Total: 2'>        if (ScriptableObject.hasProperty(scope, id)) {
</span><span class='bc' id='L2084' title='0|2|2 - Total: 2'>            return scope;
</span>        }
        // Nothing was found, but since XML objects always bind
        // return one if found
<span class='bc' id='L2088' title='0|2|2 - Total: 2'>        return firstXMLObject;
</span>    }

    public static Object setName(Scriptable bound, Object value,
                                 Context cx, Scriptable scope, String id)
    {
<span class='bc' id='L2094' title='0|2|2 - Total: 2'>        if (bound != null) {
</span>            // TODO: we used to special-case XMLObject here, but putProperty
            // seems to work for E4X and it's better to optimize  the common case
<span class='bc' id='L2097' title='0|5|5 - Total: 5'>            ScriptableObject.putProperty(bound, id, value);
</span>        } else {
            // "newname = 7;", where 'newname' has not yet
            // been defined, creates a new property in the
            // top scope unless strict mode is specified.
<span class='bpc' id='L2102' title='0|1|1 - Total: 2'>            if (cx.hasFeature(Context.FEATURE_STRICT_MODE) ||
</span><span class='bpc' id='L2103' title='0|1|1 - Total: 2'>                cx.hasFeature(Context.FEATURE_STRICT_VARS))
</span>            {
<span class='nc' id='L2105' title='0|0|0 - Total: 3'>                Context.reportWarning(
</span><span class='nc' id='L2106' title='0|0|0 - Total: 1'>                    ScriptRuntime.getMessage1("msg.assn.create.strict", id));
</span>            }
            // Find the top scope by walking up the scope chain.
<span class='bc' id='L2109' title='0|3|3 - Total: 3'>            bound = ScriptableObject.getTopLevelScope(scope);
</span><span class='bpc' id='L2110' title='0|1|1 - Total: 2'>            if (cx.useDynamicScope) {
</span><span class='nc' id='L2111' title='0|0|0 - Total: 5'>                bound = checkDynamicScope(cx.topCallScope, bound);
</span>            }
<span class='bc' id='L2113' title='0|5|5 - Total: 5'>            bound.put(id, bound, value);
</span>        }
<span class='bc' id='L2115' title='0|2|2 - Total: 2'>        return value;
</span>    }

    public static Object strictSetName(Scriptable bound, Object value,
            Context cx, Scriptable scope, String id) {
<span class='bpc' id='L2120' title='0|1|1 - Total: 2'>        if (bound != null) {
</span>            // TODO: The LeftHandSide also may not be a reference to a
            // data property with the attribute value {[[Writable]]:false},
            // to an accessor property with the attribute value
            // {[[Put]]:undefined}, nor to a non-existent property of an
            // object whose [[Extensible]] internal property has the value
            // false. In these cases a TypeError exception is thrown (11.13.1).
            // TODO: we used to special-case XMLObject here, but putProperty
            // seems to work for E4X and we should optimize  the common case
<span class='nc' id='L2129' title='0|0|0 - Total: 4'>            ScriptableObject.putProperty(bound, id, value);
</span><span class='nc' id='L2130' title='0|0|0 - Total: 2'>            return value;
</span>        } else {
            // See ES5 8.7.2
<span class='bc' id='L2133' title='0|11|11 - Total: 11'>            String msg = "Assignment to undefined \"" + id + "\" in strict mode";
</span><span class='bc' id='L2134' title='0|4|4 - Total: 4'>            throw constructError("ReferenceError", msg);
</span>        }
    }

    public static Object setConst(Scriptable bound, Object value,
                                 Context cx, String id)
    {
<span class='bpc' id='L2141' title='0|1|1 - Total: 2'>        if (bound instanceof XMLObject) {
</span><span class='nc' id='L2142' title='0|0|0 - Total: 6'>            bound.put(id, bound, value);
</span>        } else {
<span class='bc' id='L2144' title='0|4|4 - Total: 4'>            ScriptableObject.putConstProperty(bound, id, value);
</span>        }
<span class='bc' id='L2146' title='0|2|2 - Total: 2'>        return value;
</span>    }

    /**
     * This is the enumeration needed by the for..in statement.
     *
     * See ECMA 12.6.3.
     *
     * IdEnumeration maintains a ObjToIntMap to make sure a given
     * id is enumerated only once across multiple objects in a
     * prototype chain.
     *
     * XXX - ECMA delete doesn't hide properties in the prototype,
     * but js/ref does. This means that the js/ref for..in can
     * avoid maintaining a hash table and instead perform lookups
     * to see if a given property has already been enumerated.
     *
     */
    private static class IdEnumeration implements Serializable
    {
        private static final long serialVersionUID = 1L;
        Scriptable obj;
        Object[] ids;
        int index;
        ObjToIntMap used;
        Object currentId;
        int enumType; /* one of ENUM_INIT_KEYS, ENUM_INIT_VALUES,
                         ENUM_INIT_ARRAY, ENUMERATE_VALUES_IN_ORDER */

        // if true, integer ids will be returned as numbers rather than strings
        boolean enumNumbers;

        Scriptable iterator;
    }

    public static Scriptable toIterator(Context cx, Scriptable scope,
                                        Scriptable obj, boolean keyOnly)
    {
<span class='bc' id='L2184' title='0|2|2 - Total: 2'>        if (ScriptableObject.hasProperty(obj,
</span>            NativeIterator.ITERATOR_PROPERTY_NAME))
        {
<span class='bc' id='L2187' title='0|4|4 - Total: 4'>            Object v = ScriptableObject.getProperty(obj,
</span>                NativeIterator.ITERATOR_PROPERTY_NAME);
<span class='bpc' id='L2189' title='0|1|1 - Total: 2'>            if (!(v instanceof Callable)) {
</span><span class='nc' id='L2190' title='0|0|0 - Total: 3'>               throw typeError0("msg.invalid.iterator");
</span>            }
<span class='bc' id='L2192' title='0|3|3 - Total: 3'>            Callable f = (Callable) v;
</span><span class='bc' id='L2193' title='0|2|2 - Total: 2'>            Object[] args = new Object[] { keyOnly ? Boolean.TRUE
</span>                                                   : Boolean.FALSE };
<span class='bc' id='L2195' title='0|7|7 - Total: 7'>            v = f.call(cx, scope, obj, args);
</span><span class='bc' id='L2196' title='0|2|2 - Total: 2'>            if (!(v instanceof Scriptable)) {
</span><span class='bc' id='L2197' title='0|3|3 - Total: 3'>                throw typeError0("msg.iterator.primitive");
</span>            }
<span class='bc' id='L2199' title='0|3|3 - Total: 3'>            return (Scriptable) v;
</span>        }
<span class='bc' id='L2201' title='0|2|2 - Total: 2'>        return null;
</span>    }

    /**
     * For backwards compatibility with generated class files
     *
     * @deprecated Use {@link #enumInit(Object, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object enumInit(Object value, Context cx, boolean enumValues)
    {
<span class='nc' id='L2212' title='0|0|0 - Total: 2'>        return enumInit(value, cx, enumValues ? ENUMERATE_VALUES
</span>                                              : ENUMERATE_KEYS);
    }

    public static final int ENUMERATE_KEYS = 0;
    public static final int ENUMERATE_VALUES = 1;
    public static final int ENUMERATE_ARRAY = 2;
    public static final int ENUMERATE_KEYS_NO_ITERATOR = 3;
    public static final int ENUMERATE_VALUES_NO_ITERATOR = 4;
    public static final int ENUMERATE_ARRAY_NO_ITERATOR = 5;
    public static final int ENUMERATE_VALUES_IN_ORDER = 6;

    /**
     * @deprecated Use {@link #enumInit(Object, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object enumInit(Object value, Context cx, int enumType)
    {
<span class='nc' id='L2230' title='0|0|0 - Total: 7'>        return enumInit(value, cx, getTopCallScope(cx), enumType);
</span>    }

    public static Object enumInit(Object value, Context cx, Scriptable scope,
                                  int enumType)
    {
<span class='bc' id='L2236' title='0|5|5 - Total: 5'>        IdEnumeration x = new IdEnumeration();
</span><span class='bc' id='L2237' title='0|6|6 - Total: 6'>        x.obj = toObjectOrNull(cx, value, scope);
</span>        // "for of" loop
<span class='bc' id='L2239' title='0|2|2 - Total: 2'>        if (enumType == ENUMERATE_VALUES_IN_ORDER) {
</span><span class='bc' id='L2240' title='0|3|3 - Total: 3'>            x.enumType = enumType;
</span><span class='bc' id='L2241' title='0|3|3 - Total: 3'>            x.iterator = null;
</span><span class='bc' id='L2242' title='0|4|4 - Total: 4'>            return enumInitInOrder(cx, x);
</span>        }
<span class='bc' id='L2244' title='0|2|2 - Total: 2'>        if (x.obj == null) {
</span>            // null or undefined do not cause errors but rather lead to empty
            // "for in" loop
<span class='bc' id='L2247' title='0|2|2 - Total: 2'>            return x;
</span>        }
<span class='bc' id='L2249' title='0|3|3 - Total: 3'>        x.enumType = enumType;
</span><span class='bc' id='L2250' title='0|3|3 - Total: 3'>        x.iterator = null;
</span><span class='bpc' id='L2251' title='0|5|5 - Total: 6'>        if (enumType != ENUMERATE_KEYS_NO_ITERATOR &&
</span>            enumType != ENUMERATE_VALUES_NO_ITERATOR &&
            enumType != ENUMERATE_ARRAY_NO_ITERATOR)
        {
<span class='bc' id='L2255' title='0|2|2 - Total: 2'>            x.iterator = toIterator(cx, x.obj.getParentScope(), x.obj,
</span>                                    enumType == ScriptRuntime.ENUMERATE_KEYS);
        }
<span class='bc' id='L2258' title='0|2|2 - Total: 2'>        if (x.iterator == null) {
</span>            // enumInit should read all initial ids before returning
            // or "for (a.i in a)" would wrongly enumerate i in a as well
<span class='bc' id='L2261' title='0|2|2 - Total: 2'>            enumChangeObject(x);
</span>        }

<span class='bc' id='L2264' title='0|2|2 - Total: 2'>        return x;
</span>    }

    private static Object enumInitInOrder(Context cx, IdEnumeration x) {
<span class='bc' id='L2268' title='0|2|2 - Total: 2'>        if (!(x.obj instanceof ScriptableObject)) {
</span><span class='bc' id='L2269' title='0|6|6 - Total: 6'>            throw typeError1("msg.not.iterable", toString(x.obj));
</span>        }

<span class='bc' id='L2272' title='0|4|4 - Total: 4'>        ScriptableObject xo = (ScriptableObject)x.obj;
</span><span class='bc' id='L2273' title='0|2|2 - Total: 2'>        if (!ScriptableObject.hasProperty(xo, SymbolKey.ITERATOR)) {
</span><span class='bc' id='L2274' title='0|6|6 - Total: 6'>            throw typeError1("msg.not.iterable", toString(x.obj));
</span>        }
<span class='bc' id='L2276' title='0|4|4 - Total: 4'>        Object iterator = ScriptableObject.getProperty(xo, SymbolKey.ITERATOR);
</span><span class='bpc' id='L2277' title='0|1|1 - Total: 2'>        if (!(iterator instanceof Callable)) {
</span><span class='nc' id='L2278' title='0|0|0 - Total: 6'>            throw typeError1("msg.not.iterable", toString(x.obj));
</span>        }
<span class='bc' id='L2280' title='0|3|3 - Total: 3'>        Callable f = (Callable) iterator;
</span><span class='bc' id='L2281' title='0|4|4 - Total: 4'>        Scriptable scope = x.obj.getParentScope();
</span><span class='bc' id='L2282' title='0|3|3 - Total: 3'>        Object[] args = new Object[] {};
</span><span class='bc' id='L2283' title='0|8|8 - Total: 8'>        Object v = f.call(cx, scope, x.obj, args);
</span><span class='bpc' id='L2284' title='0|1|1 - Total: 2'>        if (!(v instanceof Scriptable)) {
</span><span class='nc' id='L2285' title='0|0|0 - Total: 6'>            throw typeError1("msg.not.iterable", toString(x.obj));
</span>        }
<span class='bc' id='L2287' title='0|4|4 - Total: 4'>        x.iterator = (Scriptable) v;
</span><span class='bc' id='L2288' title='0|2|2 - Total: 2'>        return x;
</span>    }

    public static void setEnumNumbers(Object enumObj, boolean enumNumbers) {
<span class='bc' id='L2292' title='0|4|4 - Total: 4'>        ((IdEnumeration)enumObj).enumNumbers = enumNumbers;
</span><span class='bc' id='L2293' title='0|1|1 - Total: 1'>    }
</span>
    public static Boolean enumNext(Object enumObj)
    {
<span class='bc' id='L2297' title='0|3|3 - Total: 3'>        IdEnumeration x = (IdEnumeration)enumObj;
</span><span class='bc' id='L2298' title='0|2|2 - Total: 2'>        if (x.iterator != null) {
</span><span class='bc' id='L2299' title='0|2|2 - Total: 2'>            if (x.enumType == ENUMERATE_VALUES_IN_ORDER) {
</span><span class='bc' id='L2300' title='0|3|3 - Total: 3'>                return enumNextInOrder(x);
</span>            }
<span class='bc' id='L2302' title='0|5|5 - Total: 5'>            Object v = ScriptableObject.getProperty(x.iterator, "next");
</span><span class='bpc' id='L2303' title='0|1|1 - Total: 2'>            if (!(v instanceof Callable))
</span><span class='nc' id='L2304' title='0|0|0 - Total: 2'>                return Boolean.FALSE;
</span><span class='bc' id='L2305' title='0|3|3 - Total: 3'>            Callable f = (Callable) v;
</span><span class='bc' id='L2306' title='0|2|2 - Total: 2'>            Context cx = Context.getContext();
</span>            try {
<span class='bc' id='L2308' title='0|11|11 - Total: 11'>                x.currentId = f.call(cx, x.iterator.getParentScope(),
</span>                                     x.iterator, emptyArgs);
<span class='bc' id='L2310' title='0|2|2 - Total: 2'>                return Boolean.TRUE;
</span><span class='bc' id='L2311' title='0|1|1 - Total: 1'>            } catch (JavaScriptException e) {
</span><span class='bpc' id='L2312' title='0|1|1 - Total: 2'>                if (e.getValue() instanceof NativeIterator.StopIteration) {
</span><span class='bc' id='L2313' title='0|2|2 - Total: 2'>                    return Boolean.FALSE;
</span>                }
<span class='nc' id='L2315' title='0|0|0 - Total: 2'>                throw e;
</span>            }
        }
        for (;;) {
<span class='bc' id='L2319' title='0|2|2 - Total: 2'>            if (x.obj == null) {
</span><span class='bc' id='L2320' title='0|2|2 - Total: 2'>                return Boolean.FALSE;
</span>            }
<span class='bc' id='L2322' title='0|2|2 - Total: 2'>            if (x.index == x.ids.length) {
</span><span class='bc' id='L2323' title='0|5|5 - Total: 5'>                x.obj = x.obj.getPrototype();
</span><span class='bc' id='L2324' title='0|2|2 - Total: 2'>                enumChangeObject(x);
</span><span class='bc' id='L2325' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L2327' title='0|11|11 - Total: 11'>            Object id = x.ids[x.index++];
</span><span class='bc' id='L2328' title='0|4|4 - Total: 4'>            if (x.used != null && x.used.has(id)) {
</span><span class='bc' id='L2329' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bpc' id='L2331' title='0|1|1 - Total: 2'>            if (id instanceof Symbol) {
</span><span class='nc' id='L2332' title='0|0|0 - Total: 1'>                continue;
</span><span class='bc' id='L2333' title='0|2|2 - Total: 2'>            } else if (id instanceof String) {
</span><span class='bc' id='L2334' title='0|3|3 - Total: 3'>                String strId = (String) id;
</span><span class='bc' id='L2335' title='0|2|2 - Total: 2'>                if (!x.obj.has(strId, x.obj))
</span><span class='bc' id='L2336' title='0|1|1 - Total: 1'>                    continue;   // must have been deleted
</span><span class='bc' id='L2337' title='0|3|3 - Total: 3'>                x.currentId = strId;
</span><span class='bc' id='L2338' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L2339' title='0|4|4 - Total: 4'>                int intId = ((Number)id).intValue();
</span><span class='bpc' id='L2340' title='0|1|1 - Total: 2'>                if (!x.obj.has(intId, x.obj))
</span><span class='nc' id='L2341' title='0|0|0 - Total: 1'>                    continue;   // must have been deleted
</span><span class='bc' id='L2342' title='0|2|2 - Total: 2'>                x.currentId = x.enumNumbers ? (Object) (Integer.valueOf(intId))
</span><span class='bc' id='L2343' title='0|2|2 - Total: 2'>                                            : String.valueOf(intId);
</span>            }
<span class='bc' id='L2345' title='0|2|2 - Total: 2'>            return Boolean.TRUE;
</span>        }
    }

    private static Boolean enumNextInOrder(IdEnumeration enumObj)
    {
<span class='bc' id='L2351' title='0|5|5 - Total: 5'>        Object v = ScriptableObject.getProperty(enumObj.iterator, ES6Iterator.NEXT_METHOD);
</span><span class='bpc' id='L2352' title='0|1|1 - Total: 2'>        if (!(v instanceof Callable)) {
</span><span class='nc' id='L2353' title='0|0|0 - Total: 5'>            throw notFunctionError(enumObj.iterator, ES6Iterator.NEXT_METHOD);
</span>        }
<span class='bc' id='L2355' title='0|3|3 - Total: 3'>        Callable f = (Callable) v;
</span><span class='bc' id='L2356' title='0|2|2 - Total: 2'>        Context cx = Context.getContext();
</span><span class='bc' id='L2357' title='0|4|4 - Total: 4'>        Scriptable scope = enumObj.iterator.getParentScope();
</span><span class='bc' id='L2358' title='0|8|8 - Total: 8'>        Object r = f.call(cx, scope, enumObj.iterator, emptyArgs);
</span><span class='bc' id='L2359' title='0|5|5 - Total: 5'>        Scriptable iteratorResult = toObject(cx, scope, r);
</span><span class='bc' id='L2360' title='0|4|4 - Total: 4'>        Object done = ScriptableObject.getProperty(iteratorResult, ES6Iterator.DONE_PROPERTY);
</span><span class='bpc' id='L2361' title='0|3|3 - Total: 4'>        if (done != ScriptableObject.NOT_FOUND && toBoolean(done)) {
</span><span class='bc' id='L2362' title='0|2|2 - Total: 2'>            return Boolean.FALSE;
</span>        }
<span class='bc' id='L2364' title='0|5|5 - Total: 5'>        enumObj.currentId = ScriptableObject.getProperty(iteratorResult, ES6Iterator.VALUE_PROPERTY);
</span><span class='bc' id='L2365' title='0|2|2 - Total: 2'>        return Boolean.TRUE;
</span>    }

    public static Object enumId(Object enumObj, Context cx)
    {
<span class='bc' id='L2370' title='0|3|3 - Total: 3'>        IdEnumeration x = (IdEnumeration)enumObj;
</span><span class='bc' id='L2371' title='0|2|2 - Total: 2'>        if (x.iterator != null) {
</span><span class='bc' id='L2372' title='0|3|3 - Total: 3'>            return x.currentId;
</span>        }
<span class='bpc' id='L2374' title='0|3|3 - Total: 4'>        switch (x.enumType) {
</span>          case ENUMERATE_KEYS:
          case ENUMERATE_KEYS_NO_ITERATOR:
<span class='bc' id='L2377' title='0|3|3 - Total: 3'>            return x.currentId;
</span>          case ENUMERATE_VALUES:
          case ENUMERATE_VALUES_NO_ITERATOR:
<span class='bc' id='L2380' title='0|4|4 - Total: 4'>            return enumValue(enumObj, cx);
</span>          case ENUMERATE_ARRAY:
          case ENUMERATE_ARRAY_NO_ITERATOR:
<span class='bc' id='L2383' title='0|14|14 - Total: 14'>            Object[] elements = { x.currentId, enumValue(enumObj, cx) };
</span><span class='bc' id='L2384' title='0|7|7 - Total: 7'>            return cx.newArray(ScriptableObject.getTopLevelScope(x.obj), elements);
</span>          default:
<span class='nc' id='L2386' title='0|0|0 - Total: 2'>            throw Kit.codeBug();
</span>        }
    }

    public static Object enumValue(Object enumObj, Context cx) {
<span class='bc' id='L2391' title='0|3|3 - Total: 3'>        IdEnumeration x = (IdEnumeration)enumObj;
</span>
        Object result;

<span class='bpc' id='L2395' title='0|1|1 - Total: 2'>        if (isSymbol(x.currentId)) {
</span><span class='nc' id='L2396' title='0|0|0 - Total: 4'>            SymbolScriptable so = ScriptableObject.ensureSymbolScriptable(x.obj);
</span><span class='nc' id='L2397' title='0|0|0 - Total: 8'>            result = so.get((Symbol)x.currentId, x.obj);
</span><span class='nc' id='L2398' title='0|0|0 - Total: 1'>        } else {
</span><span class='bc' id='L2399' title='0|5|5 - Total: 5'>            String s = toStringIdOrIndex(cx, x.currentId);
</span><span class='bc' id='L2400' title='0|2|2 - Total: 2'>            if (s == null) {
</span><span class='bc' id='L2401' title='0|3|3 - Total: 3'>                int index = lastIndexResult(cx);
</span><span class='bc' id='L2402' title='0|7|7 - Total: 7'>                result = x.obj.get(index, x.obj);
</span><span class='bc' id='L2403' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L2404' title='0|7|7 - Total: 7'>                result = x.obj.get(s, x.obj);
</span>            }
        }

<span class='bc' id='L2408' title='0|2|2 - Total: 2'>        return result;
</span>    }

    private static void enumChangeObject(IdEnumeration x)
    {
<span class='bc' id='L2413' title='0|2|2 - Total: 2'>        Object[] ids = null;
</span><span class='bc' id='L2414' title='0|2|2 - Total: 2'>        while (x.obj != null) {
</span><span class='bc' id='L2415' title='0|4|4 - Total: 4'>            ids = x.obj.getIds();
</span><span class='bc' id='L2416' title='0|2|2 - Total: 2'>            if (ids.length != 0) {
</span><span class='bc' id='L2417' title='0|1|1 - Total: 1'>                break;
</span>            }
<span class='bc' id='L2419' title='0|6|6 - Total: 6'>            x.obj = x.obj.getPrototype();
</span>        }
<span class='bc' id='L2421' title='0|4|4 - Total: 4'>        if (x.obj != null && x.ids != null) {
</span><span class='bc' id='L2422' title='0|3|3 - Total: 3'>            Object[] previous = x.ids;
</span><span class='bc' id='L2423' title='0|3|3 - Total: 3'>            int L = previous.length;
</span><span class='bpc' id='L2424' title='0|1|1 - Total: 2'>            if (x.used == null) {
</span><span class='bc' id='L2425' title='0|6|6 - Total: 6'>                x.used = new ObjToIntMap(L);
</span>            }
<span class='bc' id='L2427' title='0|2|2 - Total: 2'>            for (int i = 0; i != L; ++i) {
</span><span class='bc' id='L2428' title='0|7|7 - Total: 7'>                x.used.intern(previous[i]);
</span>            }
        }
<span class='bc' id='L2431' title='0|3|3 - Total: 3'>        x.ids = ids;
</span><span class='bc' id='L2432' title='0|3|3 - Total: 3'>        x.index = 0;
</span><span class='bc' id='L2433' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Prepare for calling name(...): return function corresponding to
     * name and make current top scope available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getNameFunctionAndThis(String name,
                                                  Context cx,
                                                  Scriptable scope)
    {
<span class='bc' id='L2446' title='0|3|3 - Total: 3'>        Scriptable parent = scope.getParentScope();
</span><span class='bc' id='L2447' title='0|2|2 - Total: 2'>        if (parent == null) {
</span><span class='bc' id='L2448' title='0|5|5 - Total: 5'>            Object result = topScopeName(cx, scope, name);
</span><span class='bc' id='L2449' title='0|2|2 - Total: 2'>            if (!(result instanceof Callable)) {
</span><span class='bc' id='L2450' title='0|2|2 - Total: 2'>                if (result == Scriptable.NOT_FOUND) {
</span><span class='nc' id='L2451' title='0|0|0 - Total: 4'>                    throw notFoundError(scope, name);
</span>                } else {
<span class='bc' id='L2453' title='0|4|4 - Total: 4'>                    throw notFunctionError(result, name);
</span>                }
            }
            // Top scope is not NativeWith or NativeCall => thisObj == scope
<span class='bc' id='L2457' title='0|2|2 - Total: 2'>            Scriptable thisObj = scope;
</span><span class='bc' id='L2458' title='0|3|3 - Total: 3'>            storeScriptable(cx, thisObj);
</span><span class='bc' id='L2459' title='0|3|3 - Total: 3'>            return (Callable)result;
</span>        }

        // name will call storeScriptable(cx, thisObj);
<span class='bc' id='L2463' title='0|8|8 - Total: 8'>        return (Callable)nameOrFunction(cx, scope, parent, name, true);
</span>    }

    /**
     * Prepare for calling obj[id](...): return function corresponding to
     * obj[id] and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     *
     * @deprecated Use {@link #getElemFunctionAndThis(Object, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Callable getElemFunctionAndThis(Object obj,
                                                  Object elem,
                                                  Context cx)
    {
<span class='nc' id='L2480' title='0|0|0 - Total: 7'>        return getElemFunctionAndThis(obj, elem, cx, getTopCallScope(cx));
</span>    }

    /**
     * Prepare for calling obj[id](...): return function corresponding to
     * obj[id] and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getElemFunctionAndThis(Object obj, Object elem,
                                                  Context cx, Scriptable scope)
    {
        Scriptable thisObj;
        Object value;

<span class='bc' id='L2496' title='0|2|2 - Total: 2'>        if (isSymbol(elem)) {
</span><span class='bc' id='L2497' title='0|5|5 - Total: 5'>            thisObj = toObjectOrNull(cx, obj, scope);
</span><span class='bpc' id='L2498' title='0|1|1 - Total: 2'>            if (thisObj == null) {
</span><span class='nc' id='L2499' title='0|0|0 - Total: 5'>                throw undefCallError(obj, String.valueOf(elem));
</span>            }
<span class='bc' id='L2501' title='0|6|6 - Total: 6'>            value = ScriptableObject.getProperty(thisObj, (Symbol)elem);
</span>
        } else {
<span class='bc' id='L2504' title='0|4|4 - Total: 4'>            String str = toStringIdOrIndex(cx, elem);
</span><span class='bc' id='L2505' title='0|2|2 - Total: 2'>            if (str != null) {
</span><span class='bc' id='L2506' title='0|6|6 - Total: 6'>                return getPropFunctionAndThis(obj, str, cx, scope);
</span>            }
<span class='bc' id='L2508' title='0|3|3 - Total: 3'>            int index = lastIndexResult(cx);
</span>
<span class='bc' id='L2510' title='0|5|5 - Total: 5'>            thisObj = toObjectOrNull(cx, obj, scope);
</span><span class='bpc' id='L2511' title='0|1|1 - Total: 2'>            if (thisObj == null) {
</span><span class='nc' id='L2512' title='0|0|0 - Total: 5'>                throw undefCallError(obj, String.valueOf(elem));
</span>            }

<span class='bc' id='L2515' title='0|4|4 - Total: 4'>            value = ScriptableObject.getProperty(thisObj, index);
</span>        }

<span class='bc' id='L2518' title='0|2|2 - Total: 2'>        if (!(value instanceof Callable)) {
</span><span class='bc' id='L2519' title='0|4|4 - Total: 4'>            throw notFunctionError(value, elem);
</span>        }

<span class='bc' id='L2522' title='0|3|3 - Total: 3'>        storeScriptable(cx, thisObj);
</span><span class='bc' id='L2523' title='0|3|3 - Total: 3'>        return (Callable)value;
</span>    }

    /**
     * Prepare for calling obj.property(...): return function corresponding to
     * obj.property and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     * Warning: this doesn't allow to resolve primitive prototype properly when
     * many top scopes are involved.
     *
     * @deprecated Use {@link #getPropFunctionAndThis(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Callable getPropFunctionAndThis(Object obj,
                                                  String property,
                                                  Context cx)
    {
<span class='nc' id='L2542' title='0|0|0 - Total: 7'>        return getPropFunctionAndThis(obj, property, cx, getTopCallScope(cx));
</span>    }

    /**
     * Prepare for calling obj.property(...): return function corresponding to
     * obj.property and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getPropFunctionAndThis(Object obj,
                                                  String property,
                                                  Context cx, Scriptable scope)
    {
<span class='bc' id='L2556' title='0|5|5 - Total: 5'>        Scriptable thisObj = toObjectOrNull(cx, obj, scope);
</span><span class='bc' id='L2557' title='0|6|6 - Total: 6'>        return getPropFunctionAndThisHelper(obj, property, cx, thisObj);
</span>    }

    private static Callable getPropFunctionAndThisHelper(Object obj,
          String property, Context cx, Scriptable thisObj)
    {
<span class='bc' id='L2563' title='0|2|2 - Total: 2'>        if (thisObj == null) {
</span><span class='bc' id='L2564' title='0|4|4 - Total: 4'>            throw undefCallError(obj, property);
</span>        }

<span class='bc' id='L2567' title='0|4|4 - Total: 4'>        Object value = ScriptableObject.getProperty(thisObj, property);
</span><span class='bc' id='L2568' title='0|2|2 - Total: 2'>        if (!(value instanceof Callable)) {
</span><span class='bc' id='L2569' title='0|4|4 - Total: 4'>            Object noSuchMethod = ScriptableObject.getProperty(thisObj, "__noSuchMethod__");
</span><span class='bc' id='L2570' title='0|2|2 - Total: 2'>            if (noSuchMethod instanceof Callable)
</span><span class='bc' id='L2571' title='0|7|7 - Total: 7'>                value = new NoSuchMethodShim((Callable)noSuchMethod, property);
</span>        }

<span class='bc' id='L2574' title='0|2|2 - Total: 2'>        if (!(value instanceof Callable)) {
</span><span class='bc' id='L2575' title='0|5|5 - Total: 5'>            throw notFunctionError(thisObj, value, property);
</span>        }

<span class='bc' id='L2578' title='0|3|3 - Total: 3'>        storeScriptable(cx, thisObj);
</span><span class='bc' id='L2579' title='0|3|3 - Total: 3'>        return (Callable)value;
</span>    }

    /**
     * Prepare for calling <expression>(...): return function corresponding to
     * <expression> and make parent scope of the function available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getValueFunctionAndThis(Object value, Context cx)
    {
<span class='bc' id='L2591' title='0|2|2 - Total: 2'>        if (!(value instanceof Callable)) {
</span><span class='bc' id='L2592' title='0|3|3 - Total: 3'>            throw notFunctionError(value);
</span>        }

<span class='bc' id='L2595' title='0|3|3 - Total: 3'>        Callable f = (Callable)value;
</span><span class='bc' id='L2596' title='0|2|2 - Total: 2'>        Scriptable thisObj = null;
</span><span class='bpc' id='L2597' title='0|1|1 - Total: 2'>        if (f instanceof Scriptable) {
</span><span class='bc' id='L2598' title='0|4|4 - Total: 4'>            thisObj = ((Scriptable)f).getParentScope();
</span>        }
<span class='bpc' id='L2600' title='0|1|1 - Total: 2'>        if (thisObj == null) {
</span><span class='nc' id='L2601' title='0|0|0 - Total: 2'>            if (cx.topCallScope == null) throw new IllegalStateException();
</span><span class='nc' id='L2602' title='0|0|0 - Total: 3'>            thisObj = cx.topCallScope;
</span>        }
<span class='bc' id='L2604' title='0|2|2 - Total: 2'>        if (thisObj.getParentScope() != null) {
</span><span class='bc' id='L2605' title='0|2|2 - Total: 2'>            if (thisObj instanceof NativeWith) {
</span>                // functions defined inside with should have with target
                // as their thisObj
<span class='bc' id='L2608' title='0|2|2 - Total: 2'>            } else if (thisObj instanceof NativeCall) {
</span>                // nested functions should have top scope as their thisObj
<span class='bc' id='L2610' title='0|3|3 - Total: 3'>                thisObj = ScriptableObject.getTopLevelScope(thisObj);
</span>            }
        }
<span class='bc' id='L2613' title='0|3|3 - Total: 3'>        storeScriptable(cx, thisObj);
</span><span class='bc' id='L2614' title='0|2|2 - Total: 2'>        return f;
</span>    }

    /**
     * Perform function call in reference context. Should always
     * return value that can be passed to
     * {@link #refGet(Ref, Context)} or {@link #refSet(Ref, Object, Context)}
     * arbitrary number of times.
     * The args array reference should not be stored in any object that is
     * can be GC-reachable after this method returns. If this is necessary,
     * store args.clone(), not args array itself.
     */
    public static Ref callRef(Callable function, Scriptable thisObj,
                              Object[] args, Context cx)
    {
<span class='bpc' id='L2629' title='0|1|1 - Total: 2'>        if (function instanceof RefCallable) {
</span><span class='nc' id='L2630' title='0|0|0 - Total: 3'>            RefCallable rfunction = (RefCallable)function;
</span><span class='nc' id='L2631' title='0|0|0 - Total: 6'>            Ref ref = rfunction.refCall(cx, thisObj, args);
</span><span class='nc' id='L2632' title='0|0|0 - Total: 2'>            if (ref == null) {
</span><span class='nc' id='L2633' title='0|0|0 - Total: 14'>                throw new IllegalStateException(rfunction.getClass().getName()+".refCall() returned null");
</span>            }
<span class='nc' id='L2635' title='0|0|0 - Total: 2'>            return ref;
</span>        }
        // No runtime support for now
<span class='bc' id='L2638' title='0|4|4 - Total: 4'>        String msg = getMessage1("msg.no.ref.from.function",
</span><span class='bc' id='L2639' title='0|1|1 - Total: 1'>                                 toString(function));
</span><span class='bc' id='L2640' title='0|4|4 - Total: 4'>        throw constructError("ReferenceError", msg);
</span>    }

    /**
     * Operator new.
     *
     * See ECMA 11.2.2
     */
    public static Scriptable newObject(Object fun, Context cx,
                                       Scriptable scope, Object[] args)
    {
<span class='bc' id='L2651' title='0|2|2 - Total: 2'>        if (!(fun instanceof Function)) {
</span><span class='bc' id='L2652' title='0|3|3 - Total: 3'>            throw notFunctionError(fun);
</span>        }
<span class='bc' id='L2654' title='0|3|3 - Total: 3'>        Function function = (Function)fun;
</span><span class='bc' id='L2655' title='0|6|6 - Total: 6'>        return function.construct(cx, scope, args);
</span>    }

    public static Object callSpecial(Context cx, Callable fun,
                                     Scriptable thisObj,
                                     Object[] args, Scriptable scope,
                                     Scriptable callerThis, int callType,
                                     String filename, int lineNumber)
    {
<span class='bpc' id='L2664' title='0|1|1 - Total: 2'>        if (callType == Node.SPECIALCALL_EVAL) {
</span><span class='bpc' id='L2665' title='0|3|3 - Total: 4'>            if (thisObj.getParentScope() == null && NativeGlobal.isEvalFunction(fun)) {
</span><span class='bc' id='L2666' title='0|8|8 - Total: 8'>                return evalSpecial(cx, scope, callerThis, args,
</span>                                   filename, lineNumber);
            }
<span class='nc' id='L2669' title='0|0|0 - Total: 2'>        } else if (callType == Node.SPECIALCALL_WITH) {
</span><span class='nc' id='L2670' title='0|0|0 - Total: 2'>            if (NativeWith.isWithFunction(fun)) {
</span><span class='nc' id='L2671' title='0|0|0 - Total: 4'>                throw Context.reportRuntimeError1("msg.only.from.new",
</span>                                                  "With");
            }
        } else {
<span class='nc' id='L2675' title='0|0|0 - Total: 2'>            throw Kit.codeBug();
</span>        }

<span class='bc' id='L2678' title='0|7|7 - Total: 7'>        return fun.call(cx, scope, thisObj, args);
</span>    }

    public static Object newSpecial(Context cx, Object fun,
                                    Object[] args, Scriptable scope,
                                    int callType)
    {
<span class='bpc' id='L2685' title='0|1|1 - Total: 2'>        if (callType == Node.SPECIALCALL_EVAL) {
</span><span class='bpc' id='L2686' title='0|1|1 - Total: 2'>            if (NativeGlobal.isEvalFunction(fun)) {
</span><span class='bc' id='L2687' title='0|4|4 - Total: 4'>                throw typeError1("msg.not.ctor", "eval");
</span>            }
<span class='nc' id='L2689' title='0|0|0 - Total: 2'>        } else if (callType == Node.SPECIALCALL_WITH) {
</span><span class='nc' id='L2690' title='0|0|0 - Total: 2'>            if (NativeWith.isWithFunction(fun)) {
</span><span class='nc' id='L2691' title='0|0|0 - Total: 5'>                return NativeWith.newWithSpecial(cx, scope, args);
</span>            }
        } else {
<span class='nc' id='L2694' title='0|0|0 - Total: 2'>            throw Kit.codeBug();
</span>        }

<span class='nc' id='L2697' title='0|0|0 - Total: 6'>        return newObject(fun, cx, scope, args);
</span>    }

    /**
     * Function.prototype.apply and Function.prototype.call
     *
     * See Ecma 15.3.4.[34]
     */
    public static Object applyOrCall(boolean isApply,
                                     Context cx, Scriptable scope,
                                     Scriptable thisObj, Object[] args)
    {
<span class='bc' id='L2709' title='0|3|3 - Total: 3'>        int L = args.length;
</span><span class='bc' id='L2710' title='0|3|3 - Total: 3'>        Callable function = getCallable(thisObj);
</span>
<span class='bc' id='L2712' title='0|2|2 - Total: 2'>        Scriptable callThis = null;
</span><span class='bc' id='L2713' title='0|2|2 - Total: 2'>        if (L != 0) {
</span><span class='bc' id='L2714' title='0|2|2 - Total: 2'>            if  (cx.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS)) {
</span><span class='bc' id='L2715' title='0|8|8 - Total: 8'>                callThis = toObjectOrNull(cx, args[0], scope);
</span>            } else {
<span class='bc' id='L2717' title='0|2|2 - Total: 2'>                callThis = args[0] == Undefined.instance ? Undefined.SCRIPTABLE_UNDEFINED : toObjectOrNull(cx, args[0], scope);
</span>            }
        }
<span class='bc' id='L2720' title='0|4|4 - Total: 4'>        if (callThis == null && cx.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS)) {
</span><span class='bc' id='L2721' title='0|3|3 - Total: 3'>            callThis = getTopCallScope(cx); // This covers the case of args[0] == (null|undefined) as well.
</span>        }

        Object[] callArgs;
<span class='bc' id='L2725' title='0|2|2 - Total: 2'>        if (isApply) {
</span>            // Follow Ecma 15.3.4.3
<span class='bc' id='L2727' title='0|2|2 - Total: 2'>            callArgs = L <= 1 ? ScriptRuntime.emptyArgs :
</span><span class='bc' id='L2728' title='0|3|3 - Total: 3'>                getApplyArguments(cx, args[1]);
</span>        } else {
            // Follow Ecma 15.3.4.4
<span class='bc' id='L2731' title='0|2|2 - Total: 2'>            if (L <= 1) {
</span><span class='bc' id='L2732' title='0|3|3 - Total: 3'>                callArgs = ScriptRuntime.emptyArgs;
</span>            } else {
<span class='bc' id='L2734' title='0|5|5 - Total: 5'>                callArgs = new Object[L - 1];
</span><span class='bc' id='L2735' title='0|8|8 - Total: 8'>                System.arraycopy(args, 1, callArgs, 0, L - 1);
</span>            }
        }

<span class='bc' id='L2739' title='0|7|7 - Total: 7'>        return function.call(cx, scope, callThis, callArgs);
</span>    }
    
    /**
      * @return true if the passed in Scriptable looks like an array
      */
    private static boolean isArrayLike(Scriptable obj)
    {
<span class='bpc' id='L2747' title='0|5|5 - Total: 6'>        return obj != null && (
</span>            obj instanceof NativeArray ||
            obj instanceof Arguments ||
<span class='bc' id='L2750' title='0|2|2 - Total: 2'>            ScriptableObject.hasProperty(obj, "length")
</span>        );
    }

    static Object[] getApplyArguments(Context cx, Object arg1)
    {
<span class='bc' id='L2756' title='0|4|4 - Total: 4'>        if (arg1 == null || arg1 == Undefined.instance) {
</span><span class='bc' id='L2757' title='0|2|2 - Total: 2'>            return ScriptRuntime.emptyArgs;
</span><span class='bc' id='L2758' title='0|4|4 - Total: 4'>        } else if ( arg1 instanceof Scriptable && isArrayLike((Scriptable) arg1) ) {
</span><span class='bc' id='L2759' title='0|5|5 - Total: 5'>            return cx.getElements((Scriptable) arg1);
</span><span class='bc' id='L2760' title='0|2|2 - Total: 2'>        } else if( arg1 instanceof ScriptableObject ) {
</span><span class='bc' id='L2761' title='0|2|2 - Total: 2'>            return ScriptRuntime.emptyArgs;
</span>        } else {
<span class='bc' id='L2763' title='0|3|3 - Total: 3'>            throw ScriptRuntime.typeError0("msg.arg.isnt.array");
</span>        }
    }

    static Callable getCallable(Scriptable thisObj)
    {
        Callable function;
<span class='bc' id='L2770' title='0|2|2 - Total: 2'>        if (thisObj instanceof Callable) {
</span><span class='bc' id='L2771' title='0|4|4 - Total: 4'>            function = (Callable)thisObj;
</span>        } else {
<span class='bc' id='L2773' title='0|4|4 - Total: 4'>            Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);
</span><span class='bpc' id='L2774' title='0|1|1 - Total: 2'>            if (!(value instanceof Callable)) {
</span><span class='bc' id='L2775' title='0|4|4 - Total: 4'>                throw ScriptRuntime.notFunctionError(value, thisObj);
</span>            }
<span class='nc' id='L2777' title='0|0|0 - Total: 3'>            function = (Callable)value;
</span>        }
<span class='bc' id='L2779' title='0|2|2 - Total: 2'>        return function;
</span>    }

    /**
     * The eval function property of the global object.
     *
     * See ECMA 15.1.2.1
     */
    public static Object evalSpecial(Context cx, Scriptable scope,
                                     Object thisArg, Object[] args,
                                     String filename, int lineNumber)
    {
<span class='bc' id='L2791' title='0|2|2 - Total: 2'>        if (args.length < 1)
</span><span class='bc' id='L2792' title='0|2|2 - Total: 2'>            return Undefined.instance;
</span><span class='bc' id='L2793' title='0|4|4 - Total: 4'>        Object x = args[0];
</span><span class='bc' id='L2794' title='0|2|2 - Total: 2'>        if (!(x instanceof CharSequence)) {
</span><span class='bpc' id='L2795' title='0|1|1 - Total: 2'>            if (cx.hasFeature(Context.FEATURE_STRICT_MODE) ||
</span><span class='bpc' id='L2796' title='0|1|1 - Total: 2'>                cx.hasFeature(Context.FEATURE_STRICT_EVAL))
</span>            {
<span class='nc' id='L2798' title='0|0|0 - Total: 3'>                throw Context.reportRuntimeError0("msg.eval.nonstring.strict");
</span>            }
<span class='bc' id='L2800' title='0|3|3 - Total: 3'>            String message = ScriptRuntime.getMessage0("msg.eval.nonstring");
</span><span class='bc' id='L2801' title='0|2|2 - Total: 2'>            Context.reportWarning(message);
</span><span class='bc' id='L2802' title='0|2|2 - Total: 2'>            return x;
</span>        }
<span class='bpc' id='L2804' title='0|1|1 - Total: 2'>        if (filename == null) {
</span><span class='nc' id='L2805' title='0|0|0 - Total: 3'>            int[] linep = new int[1];
</span><span class='nc' id='L2806' title='0|0|0 - Total: 3'>            filename = Context.getSourcePositionFromStack(linep);
</span><span class='nc' id='L2807' title='0|0|0 - Total: 2'>            if (filename != null) {
</span><span class='nc' id='L2808' title='0|0|0 - Total: 5'>                lineNumber = linep[0];
</span>            } else {
<span class='nc' id='L2810' title='0|0|0 - Total: 2'>                filename = "";
</span>            }
        }
<span class='bc' id='L2813' title='0|3|3 - Total: 3'>        String sourceName = ScriptRuntime.
</span><span class='bc' id='L2814' title='0|2|2 - Total: 2'>            makeUrlForGeneratedScript(true, filename, lineNumber);
</span>
        ErrorReporter reporter;
<span class='bc' id='L2817' title='0|4|4 - Total: 4'>        reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());
</span>
<span class='bc' id='L2819' title='0|2|2 - Total: 2'>        Evaluator evaluator = Context.createInterpreter();
</span><span class='bpc' id='L2820' title='0|1|1 - Total: 2'>        if (evaluator == null) {
</span><span class='nc' id='L2821' title='0|0|0 - Total: 7'>            throw new JavaScriptException("Interpreter not present",
</span>                    filename, lineNumber);
        }

        // Compile with explicit interpreter instance to force interpreter
        // mode.
<span class='bc' id='L2827' title='0|10|10 - Total: 10'>        Script script = cx.compileString(x.toString(), evaluator,
</span>                                         reporter, sourceName, 1, null);
<span class='bc' id='L2829' title='0|3|3 - Total: 3'>        evaluator.setEvalScriptFlag(script);
</span><span class='bc' id='L2830' title='0|3|3 - Total: 3'>        Callable c = (Callable)script;
</span><span class='bc' id='L2831' title='0|8|8 - Total: 8'>        return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);
</span>    }

    /**
     * The typeof operator
     */
    public static String typeof(Object value)
    {
<span class='bc' id='L2839' title='0|2|2 - Total: 2'>        if (value == null)
</span><span class='bc' id='L2840' title='0|2|2 - Total: 2'>            return "object";
</span><span class='bc' id='L2841' title='0|2|2 - Total: 2'>        if (value == Undefined.instance)
</span><span class='bc' id='L2842' title='0|2|2 - Total: 2'>            return "undefined";
</span><span class='bc' id='L2843' title='0|2|2 - Total: 2'>        if (value instanceof ScriptableObject)
</span><span class='bc' id='L2844' title='0|4|4 - Total: 4'>            return ((ScriptableObject) value).getTypeOf();
</span><span class='bc' id='L2845' title='0|2|2 - Total: 2'>        if (value instanceof Scriptable)
</span><span class='bc' id='L2846' title='0|2|2 - Total: 2'>            return (value instanceof Callable) ? "function" : "object";
</span><span class='bc' id='L2847' title='0|2|2 - Total: 2'>        if (value instanceof CharSequence)
</span><span class='bc' id='L2848' title='0|2|2 - Total: 2'>            return "string";
</span><span class='bc' id='L2849' title='0|2|2 - Total: 2'>        if (value instanceof Number)
</span><span class='bc' id='L2850' title='0|2|2 - Total: 2'>            return "number";
</span><span class='bpc' id='L2851' title='0|1|1 - Total: 2'>        if (value instanceof Boolean)
</span><span class='bc' id='L2852' title='0|2|2 - Total: 2'>            return "boolean";
</span><span class='nc' id='L2853' title='0|0|0 - Total: 4'>        throw errorWithClassName("msg.invalid.type", value);
</span>    }

    /**
     * The typeof operator that correctly handles the undefined case
     */
    public static String typeofName(Scriptable scope, String id)
    {
<span class='bc' id='L2861' title='0|2|2 - Total: 2'>        Context cx = Context.getContext();
</span><span class='bc' id='L2862' title='0|5|5 - Total: 5'>        Scriptable val = bind(cx, scope, id);
</span><span class='bc' id='L2863' title='0|2|2 - Total: 2'>        if (val == null)
</span><span class='bc' id='L2864' title='0|2|2 - Total: 2'>            return "undefined";
</span><span class='bc' id='L2865' title='0|6|6 - Total: 6'>        return typeof(getObjectProp(val, id, cx));
</span>    }

    // neg:
    // implement the '-' operator inline in the caller
    // as "-toNumber(val)"

    // not:
    // implement the '!' operator inline in the caller
    // as "!toBoolean(val)"

    // bitnot:
    // implement the '~' operator inline in the caller
    // as "~toInt32(val)"

    public static Object add(Object val1, Object val2, Context cx)
    {
<span class='bc' id='L2882' title='0|4|4 - Total: 4'>        if(val1 instanceof Number && val2 instanceof Number) {
</span><span class='bc' id='L2883' title='0|7|7 - Total: 7'>            return wrapNumber(((Number)val1).doubleValue() +
</span><span class='bc' id='L2884' title='0|2|2 - Total: 2'>                              ((Number)val2).doubleValue());
</span>        }
<span class='bc' id='L2886' title='0|2|2 - Total: 2'>        if (val1 instanceof XMLObject) {
</span><span class='bc' id='L2887' title='0|7|7 - Total: 7'>            Object test = ((XMLObject)val1).addValues(cx, true, val2);
</span><span class='bc' id='L2888' title='0|2|2 - Total: 2'>            if (test != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L2889' title='0|2|2 - Total: 2'>                return test;
</span>            }
        }
<span class='bc' id='L2892' title='0|2|2 - Total: 2'>        if (val2 instanceof XMLObject) {
</span><span class='bc' id='L2893' title='0|7|7 - Total: 7'>            Object test = ((XMLObject)val2).addValues(cx, false, val1);
</span><span class='bpc' id='L2894' title='0|1|1 - Total: 2'>            if (test != Scriptable.NOT_FOUND) {
</span><span class='nc' id='L2895' title='0|0|0 - Total: 2'>                return test;
</span>            }
        }
<span class='bpc' id='L2898' title='0|3|3 - Total: 4'>        if ((val1 instanceof Symbol) || (val2 instanceof Symbol)) {
</span><span class='bc' id='L2899' title='0|3|3 - Total: 3'>            throw typeError0("msg.not.a.number");
</span>        }
<span class='bc' id='L2901' title='0|2|2 - Total: 2'>        if (val1 instanceof Scriptable)
</span><span class='bc' id='L2902' title='0|5|5 - Total: 5'>            val1 = ((Scriptable) val1).getDefaultValue(null);
</span><span class='bc' id='L2903' title='0|2|2 - Total: 2'>        if (val2 instanceof Scriptable)
</span><span class='bc' id='L2904' title='0|5|5 - Total: 5'>            val2 = ((Scriptable) val2).getDefaultValue(null);
</span><span class='bc' id='L2905' title='0|4|4 - Total: 4'>        if (!(val1 instanceof CharSequence) && !(val2 instanceof CharSequence))
</span><span class='bc' id='L2906' title='0|4|4 - Total: 4'>            if ((val1 instanceof Number) && (val2 instanceof Number))
</span><span class='bc' id='L2907' title='0|7|7 - Total: 7'>                return wrapNumber(((Number)val1).doubleValue() +
</span><span class='bc' id='L2908' title='0|2|2 - Total: 2'>                                  ((Number)val2).doubleValue());
</span>            else
<span class='bc' id='L2910' title='0|7|7 - Total: 7'>                return wrapNumber(toNumber(val1) + toNumber(val2));
</span><span class='bc' id='L2911' title='0|8|8 - Total: 8'>        return new ConsString(toCharSequence(val1), toCharSequence(val2));
</span>    }

    public static CharSequence add(CharSequence val1, Object val2) {
<span class='bc' id='L2915' title='0|7|7 - Total: 7'>        return new ConsString(val1, toCharSequence(val2));
</span>    }

    public static CharSequence add(Object val1, CharSequence val2) {
<span class='bc' id='L2919' title='0|7|7 - Total: 7'>        return new ConsString(toCharSequence(val1), val2);
</span>    }

    /**
     * The method is only present for compatibility.
     *
     * @deprecated Use {@link #nameIncrDecr(Scriptable, String, Context, int)} instead
     */
    @Deprecated
    public static Object nameIncrDecr(Scriptable scopeChain, String id,
                                      int incrDecrMask)
    {
<span class='nc' id='L2931' title='0|0|0 - Total: 6'>        return nameIncrDecr(scopeChain, id, Context.getContext(), incrDecrMask);
</span>    }

    public static Object nameIncrDecr(Scriptable scopeChain, String id,
                                      Context cx, int incrDecrMask)
    {
        Scriptable target;
        Object value;
      search: {
            do {
<span class='bpc' id='L2941' title='0|1|1 - Total: 4'>                if (cx.useDynamicScope && scopeChain.getParentScope() == null) {
</span><span class='nc' id='L2942' title='0|0|0 - Total: 5'>                    scopeChain = checkDynamicScope(cx.topCallScope, scopeChain);
</span>                }
<span class='bc' id='L2944' title='0|2|2 - Total: 2'>                target = scopeChain;
</span>                do {
<span class='bc' id='L2946' title='0|2|2 - Total: 2'>                    if (target instanceof NativeWith &&
</span><span class='bc' id='L2947' title='0|2|2 - Total: 2'>                            target.getPrototype() instanceof XMLObject) {
</span><span class='bc' id='L2948' title='0|1|1 - Total: 1'>                        break;
</span>                    }
<span class='bc' id='L2950' title='0|5|5 - Total: 5'>                    value = target.get(id, scopeChain);
</span><span class='bc' id='L2951' title='0|2|2 - Total: 2'>                    if (value != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L2952' title='0|1|1 - Total: 1'>                        break search;
</span>                    }
<span class='bc' id='L2954' title='0|3|3 - Total: 3'>                    target = target.getPrototype();
</span><span class='bc' id='L2955' title='0|2|2 - Total: 2'>                } while (target != null);
</span><span class='bc' id='L2956' title='0|3|3 - Total: 3'>                scopeChain = scopeChain.getParentScope();
</span><span class='bc' id='L2957' title='0|2|2 - Total: 2'>            } while (scopeChain != null);
</span><span class='nc' id='L2958' title='0|0|0 - Total: 4'>            throw notFoundError(scopeChain, id);
</span>        }
<span class='bc' id='L2960' title='0|7|7 - Total: 7'>        return doScriptableIncrDecr(target, id, scopeChain, value,
</span>                                    incrDecrMask);
    }

    /**
     * @deprecated Use {@link #propIncrDecr(Object, String, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object propIncrDecr(Object obj, String id,
                                      Context cx, int incrDecrMask)
    {
<span class='nc' id='L2971' title='0|0|0 - Total: 8'>        return propIncrDecr(obj, id, cx, getTopCallScope(cx), incrDecrMask);
</span>    }

    public static Object propIncrDecr(Object obj, String id,
                                      Context cx, Scriptable scope,
                                      int incrDecrMask)
    {
<span class='bc' id='L2978' title='0|5|5 - Total: 5'>        Scriptable start = toObjectOrNull(cx, obj, scope);
</span><span class='bpc' id='L2979' title='0|1|1 - Total: 2'>        if (start == null) {
</span><span class='nc' id='L2980' title='0|0|0 - Total: 4'>            throw undefReadError(obj, id);
</span>        }

<span class='bc' id='L2983' title='0|2|2 - Total: 2'>        Scriptable target = start;
</span>        Object value;
      search: {
            do {
<span class='bc' id='L2987' title='0|5|5 - Total: 5'>                value = target.get(id, start);
</span><span class='bc' id='L2988' title='0|2|2 - Total: 2'>                if (value != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L2989' title='0|1|1 - Total: 1'>                    break search;
</span>                }
<span class='bc' id='L2991' title='0|3|3 - Total: 3'>                target = target.getPrototype();
</span><span class='bc' id='L2992' title='0|2|2 - Total: 2'>            } while (target != null);
</span><span class='bc' id='L2993' title='0|5|5 - Total: 5'>            start.put(id, start, NaNobj);
</span><span class='bc' id='L2994' title='0|2|2 - Total: 2'>            return NaNobj;
</span>        }
<span class='bc' id='L2996' title='0|7|7 - Total: 7'>        return doScriptableIncrDecr(target, id, start, value,
</span>                                    incrDecrMask);
    }

    private static Object doScriptableIncrDecr(Scriptable target,
                                               String id,
                                               Scriptable protoChainStart,
                                               Object value,
                                               int incrDecrMask)
    {
<span class='bc' id='L3006' title='0|2|2 - Total: 2'>        boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
</span>        double number;
<span class='bc' id='L3008' title='0|2|2 - Total: 2'>        if (value instanceof Number) {
</span><span class='bc' id='L3009' title='0|5|5 - Total: 5'>            number = ((Number)value).doubleValue();
</span>        } else {
<span class='bc' id='L3011' title='0|3|3 - Total: 3'>            number = toNumber(value);
</span><span class='bc' id='L3012' title='0|2|2 - Total: 2'>            if (post) {
</span>                // convert result to number
<span class='bc' id='L3014' title='0|3|3 - Total: 3'>                value = wrapNumber(number);
</span>            }
        }
<span class='bc' id='L3017' title='0|2|2 - Total: 2'>        if ((incrDecrMask & Node.DECR_FLAG) == 0) {
</span><span class='bc' id='L3018' title='0|5|5 - Total: 5'>            ++number;
</span>        } else {
<span class='bc' id='L3020' title='0|4|4 - Total: 4'>            --number;
</span>        }
<span class='bc' id='L3022' title='0|3|3 - Total: 3'>        Number result = wrapNumber(number);
</span><span class='bc' id='L3023' title='0|5|5 - Total: 5'>        target.put(id, protoChainStart, result);
</span><span class='bc' id='L3024' title='0|2|2 - Total: 2'>        if (post) {
</span><span class='bc' id='L3025' title='0|2|2 - Total: 2'>            return value;
</span>        } else {
<span class='bc' id='L3027' title='0|2|2 - Total: 2'>            return result;
</span>        }
    }

    /**
     * @deprecated Use {@link #elemIncrDecr(Object, Object, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object elemIncrDecr(Object obj, Object index,
                                      Context cx, int incrDecrMask)
    {
<span class='nc' id='L3038' title='0|0|0 - Total: 8'>        return elemIncrDecr(obj, index, cx, getTopCallScope(cx), incrDecrMask);
</span>    }

    public static Object elemIncrDecr(Object obj, Object index,
                                      Context cx, Scriptable scope,
                                      int incrDecrMask)
    {
<span class='bc' id='L3045' title='0|6|6 - Total: 6'>        Object value = getObjectElem(obj, index, cx, scope);
</span><span class='bc' id='L3046' title='0|2|2 - Total: 2'>        boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
</span>        double number;
<span class='bc' id='L3048' title='0|2|2 - Total: 2'>        if (value instanceof Number) {
</span><span class='bc' id='L3049' title='0|5|5 - Total: 5'>            number = ((Number)value).doubleValue();
</span>        } else {
<span class='bc' id='L3051' title='0|3|3 - Total: 3'>            number = toNumber(value);
</span><span class='bc' id='L3052' title='0|2|2 - Total: 2'>            if (post) {
</span>                // convert result to number
<span class='bc' id='L3054' title='0|3|3 - Total: 3'>                value = wrapNumber(number);
</span>            }
        }
<span class='bc' id='L3057' title='0|2|2 - Total: 2'>        if ((incrDecrMask & Node.DECR_FLAG) == 0) {
</span><span class='bc' id='L3058' title='0|5|5 - Total: 5'>            ++number;
</span>        } else {
<span class='bc' id='L3060' title='0|4|4 - Total: 4'>            --number;
</span>        }
<span class='bc' id='L3062' title='0|3|3 - Total: 3'>        Number result = wrapNumber(number);
</span><span class='bc' id='L3063' title='0|7|7 - Total: 7'>        setObjectElem(obj, index, result, cx, scope);
</span><span class='bc' id='L3064' title='0|2|2 - Total: 2'>        if (post) {
</span><span class='bc' id='L3065' title='0|2|2 - Total: 2'>            return value;
</span>        } else {
<span class='bc' id='L3067' title='0|2|2 - Total: 2'>            return result;
</span>        }
    }

    /**
     * @deprecated Use {@link #refIncrDecr(Ref, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask)
    {
<span class='nc' id='L3077' title='0|0|0 - Total: 7'>        return refIncrDecr(ref, cx, getTopCallScope(cx), incrDecrMask);
</span>    }

    public static Object refIncrDecr(Ref ref, Context cx, Scriptable scope,
                                     int incrDecrMask)
    {
<span class='nc' id='L3083' title='0|0|0 - Total: 4'>        Object value = ref.get(cx);
</span><span class='nc' id='L3084' title='0|0|0 - Total: 2'>        boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
</span>        double number;
<span class='nc' id='L3086' title='0|0|0 - Total: 2'>        if (value instanceof Number) {
</span><span class='nc' id='L3087' title='0|0|0 - Total: 5'>            number = ((Number)value).doubleValue();
</span>        } else {
<span class='nc' id='L3089' title='0|0|0 - Total: 3'>            number = toNumber(value);
</span><span class='nc' id='L3090' title='0|0|0 - Total: 2'>            if (post) {
</span>                // convert result to number
<span class='nc' id='L3092' title='0|0|0 - Total: 3'>                value = wrapNumber(number);
</span>            }
        }
<span class='nc' id='L3095' title='0|0|0 - Total: 2'>        if ((incrDecrMask & Node.DECR_FLAG) == 0) {
</span><span class='nc' id='L3096' title='0|0|0 - Total: 5'>            ++number;
</span>        } else {
<span class='nc' id='L3098' title='0|0|0 - Total: 4'>            --number;
</span>        }
<span class='nc' id='L3100' title='0|0|0 - Total: 3'>        Number result = wrapNumber(number);
</span><span class='nc' id='L3101' title='0|0|0 - Total: 6'>        ref.set(cx, scope, result);
</span><span class='nc' id='L3102' title='0|0|0 - Total: 2'>        if (post) {
</span><span class='nc' id='L3103' title='0|0|0 - Total: 2'>            return value;
</span>        } else {
<span class='nc' id='L3105' title='0|0|0 - Total: 2'>            return result;
</span>        }
    }

    public static Object toPrimitive(Object val) {
<span class='bc' id='L3110' title='0|4|4 - Total: 4'>        return toPrimitive(val, null);
</span>    }

    public static Object toPrimitive(Object val, Class<?> typeHint)
    {
<span class='bpc' id='L3115' title='0|1|1 - Total: 2'>        if (!(val instanceof Scriptable)) {
</span><span class='nc' id='L3116' title='0|0|0 - Total: 2'>            return val;
</span>        }
<span class='bc' id='L3118' title='0|3|3 - Total: 3'>        Scriptable s = (Scriptable)val;
</span><span class='bc' id='L3119' title='0|4|4 - Total: 4'>        Object result = s.getDefaultValue(typeHint);
</span><span class='bpc' id='L3120' title='0|1|1 - Total: 4'>        if ((result instanceof Scriptable) && !isSymbol(result))
</span><span class='nc' id='L3121' title='0|0|0 - Total: 3'>            throw typeError0("msg.bad.default.value");
</span><span class='bc' id='L3122' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Equality
     *
     * See ECMA 11.9
     */
    public static boolean eq(Object x, Object y)
    {
<span class='bc' id='L3132' title='0|4|4 - Total: 4'>        if (x == null || x == Undefined.instance) {
</span><span class='bc' id='L3133' title='0|4|4 - Total: 4'>            if (y == null || y == Undefined.instance) {
</span><span class='bc' id='L3134' title='0|2|2 - Total: 2'>                return true;
</span>            }
<span class='bc' id='L3136' title='0|2|2 - Total: 2'>            if (y instanceof ScriptableObject) {
</span><span class='bc' id='L3137' title='0|5|5 - Total: 5'>                Object test = ((ScriptableObject)y).equivalentValues(x);
</span><span class='bc' id='L3138' title='0|2|2 - Total: 2'>                if (test != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L3139' title='0|4|4 - Total: 4'>                    return ((Boolean)test).booleanValue();
</span>                }
            }
<span class='bc' id='L3142' title='0|2|2 - Total: 2'>            return false;
</span><span class='bc' id='L3143' title='0|2|2 - Total: 2'>        } else if (x instanceof Number) {
</span><span class='bc' id='L3144' title='0|6|6 - Total: 6'>            return eqNumber(((Number)x).doubleValue(), y);
</span><span class='bc' id='L3145' title='0|2|2 - Total: 2'>        } else if (x == y) {
</span><span class='bc' id='L3146' title='0|2|2 - Total: 2'>            return true;
</span><span class='bc' id='L3147' title='0|2|2 - Total: 2'>        } else if (x instanceof CharSequence) {
</span><span class='bc' id='L3148' title='0|5|5 - Total: 5'>            return eqString((CharSequence)x, y);
</span><span class='bc' id='L3149' title='0|2|2 - Total: 2'>        } else if (x instanceof Boolean) {
</span><span class='bc' id='L3150' title='0|4|4 - Total: 4'>            boolean b = ((Boolean)x).booleanValue();
</span><span class='bc' id='L3151' title='0|2|2 - Total: 2'>            if (y instanceof Boolean) {
</span><span class='bc' id='L3152' title='0|2|2 - Total: 2'>                return b == ((Boolean)y).booleanValue();
</span>            }
<span class='bc' id='L3154' title='0|2|2 - Total: 2'>            if (y instanceof ScriptableObject) {
</span><span class='bc' id='L3155' title='0|5|5 - Total: 5'>                Object test = ((ScriptableObject)y).equivalentValues(x);
</span><span class='bpc' id='L3156' title='0|1|1 - Total: 2'>                if (test != Scriptable.NOT_FOUND) {
</span><span class='nc' id='L3157' title='0|0|0 - Total: 4'>                    return ((Boolean)test).booleanValue();
</span>                }
            }
<span class='bc' id='L3160' title='0|2|2 - Total: 2'>            return eqNumber(b ? 1.0 : 0.0, y);
</span><span class='bpc' id='L3161' title='0|1|1 - Total: 2'>        } else if (x instanceof Scriptable) {
</span><span class='bc' id='L3162' title='0|2|2 - Total: 2'>            if (y instanceof Scriptable) {
</span><span class='bc' id='L3163' title='0|2|2 - Total: 2'>                if (x instanceof ScriptableObject) {
</span><span class='bc' id='L3164' title='0|5|5 - Total: 5'>                    Object test = ((ScriptableObject)x).equivalentValues(y);
</span><span class='bc' id='L3165' title='0|2|2 - Total: 2'>                    if (test != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L3166' title='0|4|4 - Total: 4'>                        return ((Boolean)test).booleanValue();
</span>                    }
                }
<span class='bc' id='L3169' title='0|2|2 - Total: 2'>                if (y instanceof ScriptableObject) {
</span><span class='bc' id='L3170' title='0|5|5 - Total: 5'>                    Object test = ((ScriptableObject)y).equivalentValues(x);
</span><span class='bpc' id='L3171' title='0|1|1 - Total: 2'>                    if (test != Scriptable.NOT_FOUND) {
</span><span class='nc' id='L3172' title='0|0|0 - Total: 4'>                        return ((Boolean)test).booleanValue();
</span>                    }
                }
<span class='bpc' id='L3175' title='0|3|3 - Total: 4'>                if (x instanceof Wrapper && y instanceof Wrapper) {
</span>                    // See bug 413838. Effectively an extension to ECMA for
                    // the LiveConnect case.
<span class='bc' id='L3178' title='0|4|4 - Total: 4'>                    Object unwrappedX = ((Wrapper)x).unwrap();
</span><span class='bc' id='L3179' title='0|4|4 - Total: 4'>                    Object unwrappedY = ((Wrapper)y).unwrap();
</span><span class='bc' id='L3180' title='0|2|2 - Total: 2'>                    return unwrappedX == unwrappedY ||
</span><span class='bpc' id='L3181' title='0|1|1 - Total: 2'>                           (isPrimitive(unwrappedX) &&
</span><span class='bpc' id='L3182' title='0|1|1 - Total: 2'>                            isPrimitive(unwrappedY) &&
</span><span class='bc' id='L3183' title='0|2|2 - Total: 2'>                            eq(unwrappedX, unwrappedY));
</span>                }
<span class='bc' id='L3185' title='0|2|2 - Total: 2'>                return false;
</span><span class='bc' id='L3186' title='0|2|2 - Total: 2'>            } else if (y instanceof Boolean) {
</span><span class='bpc' id='L3187' title='0|1|1 - Total: 2'>                if (x instanceof ScriptableObject) {
</span><span class='bc' id='L3188' title='0|5|5 - Total: 5'>                    Object test = ((ScriptableObject)x).equivalentValues(y);
</span><span class='bpc' id='L3189' title='0|1|1 - Total: 2'>                    if (test != Scriptable.NOT_FOUND) {
</span><span class='nc' id='L3190' title='0|0|0 - Total: 4'>                        return ((Boolean)test).booleanValue();
</span>                    }
                }
<span class='bpc' id='L3193' title='0|1|1 - Total: 2'>                double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;
</span><span class='bc' id='L3194' title='0|4|4 - Total: 4'>                return eqNumber(d, x);
</span><span class='bc' id='L3195' title='0|2|2 - Total: 2'>            } else if (y instanceof Number) {
</span><span class='bc' id='L3196' title='0|6|6 - Total: 6'>                return eqNumber(((Number)y).doubleValue(), x);
</span><span class='bc' id='L3197' title='0|2|2 - Total: 2'>            } else if (y instanceof CharSequence) {
</span><span class='bc' id='L3198' title='0|5|5 - Total: 5'>                return eqString((CharSequence)y, x);
</span>            }
            // covers the case when y == Undefined.instance as well
<span class='bc' id='L3201' title='0|2|2 - Total: 2'>            return false;
</span>        } else {
<span class='nc' id='L3203' title='0|0|0 - Total: 2'>            warnAboutNonJSObject(x);
</span><span class='nc' id='L3204' title='0|0|0 - Total: 2'>            return x == y;
</span>        }
    }

    /*
     * Implement "SameValue" as in ECMA 7.2.9. This is not the same as "eq" because it handles
     * signed zeroes and NaNs differently.
     */
    public static boolean same(Object x, Object y) {
<span class='bpc' id='L3213' title='0|1|1 - Total: 2'>        if (!typeof(x).equals(typeof(y))) {
</span><span class='nc' id='L3214' title='0|0|0 - Total: 2'>            return false;
</span>        }
<span class='bpc' id='L3216' title='0|1|1 - Total: 2'>        if (x instanceof Number) {
</span><span class='nc' id='L3217' title='0|0|0 - Total: 4'>            if (isNaN(x) && isNaN(y)) {
</span><span class='nc' id='L3218' title='0|0|0 - Total: 2'>                return true;
</span>            }
<span class='nc' id='L3220' title='0|0|0 - Total: 4'>            return x.equals(y);
</span>        }
<span class='bc' id='L3222' title='0|4|4 - Total: 4'>        return eq(x, y);
</span>    }

    public static boolean isNaN(Object n) {
<span class='nc' id='L3226' title='0|0|0 - Total: 2'>        if (n == NaNobj) {
</span><span class='nc' id='L3227' title='0|0|0 - Total: 2'>            return true;
</span>        }
<span class='nc' id='L3229' title='0|0|0 - Total: 2'>        if (n instanceof Double) {
</span><span class='nc' id='L3230' title='0|0|0 - Total: 3'>            Double d = (Double)n;
</span><span class='nc' id='L3231' title='0|0|0 - Total: 4'>            return ((d == NaN) || Double.isNaN(d));
</span>        }
<span class='nc' id='L3233' title='0|0|0 - Total: 2'>        if (n instanceof Float) {
</span><span class='nc' id='L3234' title='0|0|0 - Total: 3'>            Float f = (Float)n;
</span><span class='nc' id='L3235' title='0|0|0 - Total: 4'>            return ((f == NaN) || Float.isNaN(f));
</span>        }
<span class='nc' id='L3237' title='0|0|0 - Total: 2'>        return false;
</span>    }

    public static boolean isPrimitive(Object obj) {
<span class='bpc' id='L3241' title='0|7|7 - Total: 10'>        return obj == null || obj == Undefined.instance ||
</span>                (obj instanceof Number) || (obj instanceof String) ||
                (obj instanceof Boolean);
    }

    static boolean eqNumber(double x, Object y)
    {
        for (;;) {
<span class='bc' id='L3249' title='0|4|4 - Total: 4'>            if (y == null || y == Undefined.instance) {
</span><span class='bc' id='L3250' title='0|2|2 - Total: 2'>                return false;
</span><span class='bc' id='L3251' title='0|2|2 - Total: 2'>            } else if (y instanceof Number) {
</span><span class='bc' id='L3252' title='0|2|2 - Total: 2'>                return x == ((Number)y).doubleValue();
</span><span class='bc' id='L3253' title='0|2|2 - Total: 2'>            } else if (y instanceof CharSequence) {
</span><span class='bc' id='L3254' title='0|2|2 - Total: 2'>                return x == toNumber(y);
</span><span class='bc' id='L3255' title='0|2|2 - Total: 2'>            } else if (y instanceof Boolean) {
</span><span class='bc' id='L3256' title='0|4|4 - Total: 4'>                return x == (((Boolean) y).booleanValue() ? 1.0 : +0.0);
</span><span class='bc' id='L3257' title='0|2|2 - Total: 2'>            } else if (isSymbol(y)) {
</span><span class='bc' id='L3258' title='0|2|2 - Total: 2'>                return false;
</span><span class='bpc' id='L3259' title='0|1|1 - Total: 2'>            } else if (y instanceof Scriptable) {
</span><span class='bpc' id='L3260' title='0|1|1 - Total: 2'>                if (y instanceof ScriptableObject) {
</span><span class='bc' id='L3261' title='0|3|3 - Total: 3'>                    Object xval = wrapNumber(x);
</span><span class='bc' id='L3262' title='0|5|5 - Total: 5'>                    Object test = ((ScriptableObject)y).equivalentValues(xval);
</span><span class='bc' id='L3263' title='0|2|2 - Total: 2'>                    if (test != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L3264' title='0|4|4 - Total: 4'>                        return ((Boolean)test).booleanValue();
</span>                    }
                }
<span class='bc' id='L3267' title='0|4|4 - Total: 4'>                y = toPrimitive(y);
</span>            } else {
<span class='nc' id='L3269' title='0|0|0 - Total: 2'>                warnAboutNonJSObject(y);
</span><span class='nc' id='L3270' title='0|0|0 - Total: 2'>                return false;
</span>            }
        }
    }

    private static boolean eqString(CharSequence x, Object y)
    {
        for (;;) {
<span class='bc' id='L3278' title='0|4|4 - Total: 4'>            if (y == null || y == Undefined.instance) {
</span><span class='bc' id='L3279' title='0|2|2 - Total: 2'>                return false;
</span><span class='bc' id='L3280' title='0|2|2 - Total: 2'>            } else if (y instanceof CharSequence) {
</span><span class='bc' id='L3281' title='0|3|3 - Total: 3'>                CharSequence c = (CharSequence)y;
</span><span class='bc' id='L3282' title='0|4|4 - Total: 4'>                return x.length() == c.length() && x.toString().equals(c.toString());
</span><span class='bc' id='L3283' title='0|2|2 - Total: 2'>            } else if (y instanceof Number) {
</span><span class='bc' id='L3284' title='0|2|2 - Total: 2'>                return toNumber(x.toString()) == ((Number)y).doubleValue();
</span><span class='bpc' id='L3285' title='0|1|1 - Total: 2'>            } else if (y instanceof Boolean) {
</span><span class='nc' id='L3286' title='0|0|0 - Total: 4'>                return toNumber(x.toString()) == (((Boolean) y).booleanValue() ? 1.0 : 0.0);
</span><span class='bc' id='L3287' title='0|2|2 - Total: 2'>            } else if (isSymbol(y)) {
</span><span class='bc' id='L3288' title='0|2|2 - Total: 2'>                return false;
</span><span class='bpc' id='L3289' title='0|1|1 - Total: 2'>            } else if (y instanceof Scriptable) {
</span><span class='bc' id='L3290' title='0|2|2 - Total: 2'>                if (y instanceof ScriptableObject) {
</span><span class='bc' id='L3291' title='0|6|6 - Total: 6'>                    Object test = ((ScriptableObject)y).equivalentValues(x.toString());
</span><span class='bc' id='L3292' title='0|2|2 - Total: 2'>                    if (test != Scriptable.NOT_FOUND) {
</span><span class='bc' id='L3293' title='0|4|4 - Total: 4'>                        return ((Boolean)test).booleanValue();
</span>                    }
                }
<span class='bc' id='L3296' title='0|3|3 - Total: 3'>                y = toPrimitive(y);
</span><span class='bc' id='L3297' title='0|1|1 - Total: 1'>                continue;
</span>            } else {
<span class='nc' id='L3299' title='0|0|0 - Total: 2'>                warnAboutNonJSObject(y);
</span><span class='nc' id='L3300' title='0|0|0 - Total: 2'>                return false;
</span>            }
        }
    }
    public static boolean shallowEq(Object x, Object y)
    {
<span class='bc' id='L3306' title='0|2|2 - Total: 2'>        if (x == y) {
</span><span class='bc' id='L3307' title='0|2|2 - Total: 2'>            if (!(x instanceof Number)) {
</span><span class='bc' id='L3308' title='0|2|2 - Total: 2'>                return true;
</span>            }
            // NaN check
<span class='bc' id='L3311' title='0|4|4 - Total: 4'>            double d = ((Number)x).doubleValue();
</span><span class='bc' id='L3312' title='0|2|2 - Total: 2'>            return d == d;
</span>        }
<span class='bpc' id='L3314' title='0|5|5 - Total: 6'>        if (x == null || x == Undefined.instance || x == Undefined.SCRIPTABLE_UNDEFINED) {
</span><span class='bpc' id='L3315' title='0|4|4 - Total: 8'>            if ((x == Undefined.instance && y == Undefined.SCRIPTABLE_UNDEFINED)
</span><span class='nc' id='L3316' title='0|0|0 - Total: 2'>                || (x == Undefined.SCRIPTABLE_UNDEFINED && y == Undefined.instance)) return true;
</span><span class='bc' id='L3317' title='0|2|2 - Total: 2'>            return false;
</span><span class='bc' id='L3318' title='0|2|2 - Total: 2'>        } else if (x instanceof Number) {
</span><span class='bc' id='L3319' title='0|2|2 - Total: 2'>            if (y instanceof Number) {
</span><span class='bc' id='L3320' title='0|2|2 - Total: 2'>                return ((Number)x).doubleValue() == ((Number)y).doubleValue();
</span>            }
<span class='bc' id='L3322' title='0|2|2 - Total: 2'>        } else if (x instanceof CharSequence) {
</span><span class='bc' id='L3323' title='0|2|2 - Total: 2'>            if (y instanceof CharSequence) {
</span><span class='bc' id='L3324' title='0|6|6 - Total: 6'>                return x.toString().equals(y.toString());
</span>            }
<span class='bc' id='L3326' title='0|2|2 - Total: 2'>        } else if (x instanceof Boolean) {
</span><span class='bc' id='L3327' title='0|2|2 - Total: 2'>            if (y instanceof Boolean) {
</span><span class='bc' id='L3328' title='0|4|4 - Total: 4'>                return x.equals(y);
</span>            }
<span class='bpc' id='L3330' title='0|1|1 - Total: 2'>        } else if (x instanceof Scriptable) {
</span><span class='bpc' id='L3331' title='0|3|3 - Total: 4'>            if (x instanceof Wrapper && y instanceof Wrapper) {
</span><span class='bpc' id='L3332' title='0|1|1 - Total: 2'>                return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
</span>            }
        } else {
<span class='nc' id='L3335' title='0|0|0 - Total: 2'>            warnAboutNonJSObject(x);
</span><span class='nc' id='L3336' title='0|0|0 - Total: 2'>            return x == y;
</span>        }
<span class='bc' id='L3338' title='0|2|2 - Total: 2'>        return false;
</span>    }

    /**
     * The instanceof operator.
     *
     * @return a instanceof b
     */
    public static boolean instanceOf(Object a, Object b, Context cx)
    {
        // Check RHS is an object
<span class='bc' id='L3349' title='0|2|2 - Total: 2'>        if (! (b instanceof Scriptable)) {
</span><span class='bc' id='L3350' title='0|3|3 - Total: 3'>            throw typeError0("msg.instanceof.not.object");
</span>        }

        // for primitive values on LHS, return false
<span class='bc' id='L3354' title='0|2|2 - Total: 2'>        if (! (a instanceof Scriptable))
</span><span class='bc' id='L3355' title='0|2|2 - Total: 2'>            return false;
</span>
<span class='bc' id='L3357' title='0|6|6 - Total: 6'>        return ((Scriptable)b).hasInstance((Scriptable)a);
</span>    }

    /**
     * Delegates to
     *
     * @return true iff rhs appears in lhs' proto chain
     */
    public static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
<span class='bc' id='L3366' title='0|3|3 - Total: 3'>        Scriptable proto = lhs.getPrototype();
</span>
<span class='bc' id='L3368' title='0|2|2 - Total: 2'>        while (proto != null) {
</span><span class='bc' id='L3369' title='0|2|2 - Total: 2'>            if (proto.equals(rhs)) return true;
</span><span class='bc' id='L3370' title='0|4|4 - Total: 4'>            proto = proto.getPrototype();
</span>        }

<span class='bc' id='L3373' title='0|2|2 - Total: 2'>        return false;
</span>    }

    /**
     * The in operator.
     *
     * This is a new JS 1.3 language feature.  The in operator mirrors
     * the operation of the for .. in construct, and tests whether the
     * rhs has the property given by the lhs.  It is different from the
     * for .. in construct in that:
     * <BR> - it doesn't perform ToObject on the right hand side
     * <BR> - it returns true for DontEnum properties.
     * @param a the left hand operand
     * @param b the right hand operand
     *
     * @return true if property name or element number a is a property of b
     */
    public static boolean in(Object a, Object b, Context cx)
    {
<span class='bpc' id='L3392' title='0|1|1 - Total: 2'>        if (!(b instanceof Scriptable)) {
</span><span class='nc' id='L3393' title='0|0|0 - Total: 3'>            throw typeError0("msg.in.not.object");
</span>        }

<span class='bc' id='L3396' title='0|6|6 - Total: 6'>        return hasObjectElem((Scriptable)b, a, cx);
</span>    }

    public static boolean cmp_LT(Object val1, Object val2)
    {
        double d1, d2;
<span class='bc' id='L3402' title='0|4|4 - Total: 4'>        if (val1 instanceof Number && val2 instanceof Number) {
</span><span class='bc' id='L3403' title='0|4|4 - Total: 4'>            d1 = ((Number)val1).doubleValue();
</span><span class='bc' id='L3404' title='0|5|5 - Total: 5'>            d2 = ((Number)val2).doubleValue();
</span>        } else {
<span class='bpc' id='L3406' title='0|3|3 - Total: 4'>            if ((val1 instanceof Symbol) || (val2 instanceof Symbol)) {
</span><span class='bc' id='L3407' title='0|3|3 - Total: 3'>                throw typeError0("msg.compare.symbol");
</span>            }
<span class='bc' id='L3409' title='0|2|2 - Total: 2'>            if (val1 instanceof Scriptable)
</span><span class='bc' id='L3410' title='0|5|5 - Total: 5'>                val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
</span><span class='bc' id='L3411' title='0|2|2 - Total: 2'>            if (val2 instanceof Scriptable)
</span><span class='bc' id='L3412' title='0|5|5 - Total: 5'>                val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
</span><span class='bc' id='L3413' title='0|4|4 - Total: 4'>            if (val1 instanceof CharSequence && val2 instanceof CharSequence) {
</span><span class='bc' id='L3414' title='0|2|2 - Total: 2'>                return val1.toString().compareTo(val2.toString()) < 0;
</span>            }
<span class='bc' id='L3416' title='0|3|3 - Total: 3'>            d1 = toNumber(val1);
</span><span class='bc' id='L3417' title='0|3|3 - Total: 3'>            d2 = toNumber(val2);
</span>        }
<span class='bc' id='L3419' title='0|2|2 - Total: 2'>        return d1 < d2;
</span>    }

    public static boolean cmp_LE(Object val1, Object val2)
    {
        double d1, d2;
<span class='bc' id='L3425' title='0|4|4 - Total: 4'>        if (val1 instanceof Number && val2 instanceof Number) {
</span><span class='bc' id='L3426' title='0|4|4 - Total: 4'>            d1 = ((Number)val1).doubleValue();
</span><span class='bc' id='L3427' title='0|5|5 - Total: 5'>            d2 = ((Number)val2).doubleValue();
</span>        } else {
<span class='bpc' id='L3429' title='0|3|3 - Total: 4'>            if ((val1 instanceof Symbol) || (val2 instanceof Symbol)) {
</span><span class='bc' id='L3430' title='0|3|3 - Total: 3'>                throw typeError0("msg.compare.symbol");
</span>            }
<span class='bc' id='L3432' title='0|2|2 - Total: 2'>            if (val1 instanceof Scriptable)
</span><span class='bc' id='L3433' title='0|5|5 - Total: 5'>                val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
</span><span class='bc' id='L3434' title='0|2|2 - Total: 2'>            if (val2 instanceof Scriptable)
</span><span class='bc' id='L3435' title='0|5|5 - Total: 5'>                val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
</span><span class='bc' id='L3436' title='0|4|4 - Total: 4'>            if (val1 instanceof CharSequence && val2 instanceof CharSequence) {
</span><span class='bc' id='L3437' title='0|2|2 - Total: 2'>                return val1.toString().compareTo(val2.toString()) <= 0;
</span>            }
<span class='bc' id='L3439' title='0|3|3 - Total: 3'>            d1 = toNumber(val1);
</span><span class='bc' id='L3440' title='0|3|3 - Total: 3'>            d2 = toNumber(val2);
</span>        }
<span class='bc' id='L3442' title='0|2|2 - Total: 2'>        return d1 <= d2;
</span>    }

    // ------------------
    // Statements
    // ------------------

    public static ScriptableObject getGlobal(Context cx) {
<span class='nc' id='L3450' title='0|0|0 - Total: 2'>        final String GLOBAL_CLASS = "org.mozilla.javascript.tools.shell.Global";
</span><span class='nc' id='L3451' title='0|0|0 - Total: 3'>        Class<?> globalClass = Kit.classOrNull(GLOBAL_CLASS);
</span><span class='nc' id='L3452' title='0|0|0 - Total: 2'>        if (globalClass != null) {
</span>            try {
<span class='nc' id='L3454' title='0|0|0 - Total: 7'>                Class<?>[] parm = { ScriptRuntime.ContextClass };
</span><span class='nc' id='L3455' title='0|0|0 - Total: 4'>                Constructor<?> globalClassCtor = globalClass.getConstructor(parm);
</span><span class='nc' id='L3456' title='0|0|0 - Total: 7'>                Object[] arg = { cx };
</span><span class='nc' id='L3457' title='0|0|0 - Total: 5'>                return (ScriptableObject) globalClassCtor.newInstance(arg);
</span>            }
<span class='nc' id='L3459' title='0|0|0 - Total: 1'>            catch (RuntimeException e) {
</span><span class='nc' id='L3460' title='0|0|0 - Total: 2'>                throw e;
</span>            }
<span class='nc' id='L3462' title='0|0|0 - Total: 1'>            catch (Exception e) {
</span>                // fall through...
            }
        }
<span class='nc' id='L3466' title='0|0|0 - Total: 5'>        return new ImporterTopLevel(cx);
</span>    }

    public static boolean hasTopCall(Context cx)
    {
<span class='bc' id='L3471' title='0|2|2 - Total: 2'>        return (cx.topCallScope != null);
</span>    }

    public static Scriptable getTopCallScope(Context cx)
    {
<span class='bc' id='L3476' title='0|3|3 - Total: 3'>        Scriptable scope = cx.topCallScope;
</span><span class='bpc' id='L3477' title='0|1|1 - Total: 2'>        if (scope == null) {
</span><span class='nc' id='L3478' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span>        }
<span class='bc' id='L3480' title='0|2|2 - Total: 2'>        return scope;
</span>    }

    /**
     * @deprecated Use {@link #doTopCall(Callable, Context, Scriptable, Scriptable, Object[], boolean)} instead
     */
    public static Object doTopCall(Callable callable,
                                   Context cx, Scriptable scope,
                                   Scriptable thisObj, Object[] args)
    {
<span class='nc' id='L3490' title='0|0|0 - Total: 9'>        return doTopCall(callable, cx, scope, thisObj, args, cx.isTopLevelStrict);
</span>    }

    public static Object doTopCall(Callable callable,
                                   Context cx, Scriptable scope,
                                   Scriptable thisObj, Object[] args, boolean isTopLevelStrict)
    {
<span class='bpc' id='L3497' title='0|1|1 - Total: 2'>        if (scope == null)
</span><span class='nc' id='L3498' title='0|0|0 - Total: 4'>            throw new IllegalArgumentException();
</span><span class='bpc' id='L3499' title='0|1|1 - Total: 2'>        if (cx.topCallScope != null) throw new IllegalStateException();
</span>
        Object result;
<span class='bc' id='L3502' title='0|4|4 - Total: 4'>        cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L3503' title='0|5|5 - Total: 5'>        cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
</span><span class='bc' id='L3504' title='0|3|3 - Total: 3'>        boolean previousTopLevelStrict = cx.isTopLevelStrict;
</span><span class='bc' id='L3505' title='0|3|3 - Total: 3'>        cx.isTopLevelStrict = isTopLevelStrict;
</span><span class='bc' id='L3506' title='0|3|3 - Total: 3'>        ContextFactory f = cx.getFactory();
</span>        try {
<span class='bc' id='L3508' title='0|8|8 - Total: 8'>            result = f.doTopCall(callable, cx, scope, thisObj, args);
</span>        } finally {
<span class='bc' id='L3510' title='0|7|7 - Total: 7'>            cx.topCallScope = null;
</span>            // Cleanup cached references
<span class='bc' id='L3512' title='0|6|6 - Total: 6'>            cx.cachedXMLLib = null;
</span><span class='bc' id='L3513' title='0|6|6 - Total: 6'>            cx.isTopLevelStrict = previousTopLevelStrict;
</span>
<span class='bpc' id='L3515' title='0|2|2 - Total: 4'>            if (cx.currentActivationCall != null) {
</span>                // Function should always call exitActivationFunction
                // if it creates activation record
<span class='nc' id='L3518' title='0|0|0 - Total: 8'>                throw new IllegalStateException();
</span>            }
<span class='bc' id='L3520' title='0|2|2 - Total: 2'>        }
</span><span class='bc' id='L3521' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Return <tt>possibleDynamicScope</tt> if <tt>staticTopScope</tt>
     * is present on its prototype chain and return <tt>staticTopScope</tt>
     * otherwise.
     * Should only be called when <tt>staticTopScope</tt> is top scope.
     */
    static Scriptable checkDynamicScope(Scriptable possibleDynamicScope,
                                        Scriptable staticTopScope)
    {
        // Return cx.topCallScope if scope
<span class='bpc' id='L3534' title='0|1|1 - Total: 2'>        if (possibleDynamicScope == staticTopScope) {
</span><span class='bc' id='L3535' title='0|2|2 - Total: 2'>            return possibleDynamicScope;
</span>        }
<span class='nc' id='L3537' title='0|0|0 - Total: 2'>        Scriptable proto = possibleDynamicScope;
</span>        for (;;) {
<span class='nc' id='L3539' title='0|0|0 - Total: 3'>            proto = proto.getPrototype();
</span><span class='nc' id='L3540' title='0|0|0 - Total: 2'>            if (proto == staticTopScope) {
</span><span class='nc' id='L3541' title='0|0|0 - Total: 2'>                return possibleDynamicScope;
</span>            }
<span class='nc' id='L3543' title='0|0|0 - Total: 2'>            if (proto == null) {
</span><span class='nc' id='L3544' title='0|0|0 - Total: 2'>                return staticTopScope;
</span>            }
        }
    }

    public static void addInstructionCount(Context cx, int instructionsToAdd)
    {
<span class='bc' id='L3551' title='0|6|6 - Total: 6'>        cx.instructionCount += instructionsToAdd;
</span><span class='bc' id='L3552' title='0|2|2 - Total: 2'>        if (cx.instructionCount > cx.instructionThreshold)
</span>        {
<span class='bc' id='L3554' title='0|4|4 - Total: 4'>            cx.observeInstructionCount(cx.instructionCount);
</span><span class='bc' id='L3555' title='0|3|3 - Total: 3'>            cx.instructionCount = 0;
</span>        }
<span class='bc' id='L3557' title='0|1|1 - Total: 1'>    }
</span>
    public static void initScript(NativeFunction funObj, Scriptable thisObj,
                                  Context cx, Scriptable scope,
                                  boolean evalScript)
    {
<span class='bpc' id='L3563' title='0|1|1 - Total: 2'>        if (cx.topCallScope == null)
</span><span class='nc' id='L3564' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span>
<span class='bc' id='L3566' title='0|3|3 - Total: 3'>        int varCount = funObj.getParamAndVarCount();
</span><span class='bc' id='L3567' title='0|2|2 - Total: 2'>        if (varCount != 0) {
</span>
<span class='bc' id='L3569' title='0|2|2 - Total: 2'>            Scriptable varScope = scope;
</span>            // Never define any variables from var statements inside with
            // object. See bug 38590.
<span class='bc' id='L3572' title='0|2|2 - Total: 2'>            while (varScope instanceof NativeWith) {
</span><span class='bc' id='L3573' title='0|4|4 - Total: 4'>                varScope = varScope.getParentScope();
</span>            }

<span class='bc' id='L3576' title='0|2|2 - Total: 2'>            for (int i = varCount; i-- != 0;) {
</span><span class='bc' id='L3577' title='0|4|4 - Total: 4'>                String name = funObj.getParamOrVarName(i);
</span><span class='bc' id='L3578' title='0|4|4 - Total: 4'>                boolean isConst = funObj.getParamOrVarConst(i);
</span>                // Don't overwrite existing def if already defined in object
                // or prototypes of object.
<span class='bc' id='L3581' title='0|2|2 - Total: 2'>                if (!ScriptableObject.hasProperty(scope, name)) {
</span><span class='bc' id='L3582' title='0|2|2 - Total: 2'>                    if (isConst) {
</span><span class='bc' id='L3583' title='0|4|4 - Total: 4'>                        ScriptableObject.defineConstProperty(varScope, name);
</span><span class='bc' id='L3584' title='0|2|2 - Total: 2'>                    } else if (!evalScript) {
</span>                        // Global var definitions are supposed to be DONTDELETE
<span class='bc' id='L3586' title='0|6|6 - Total: 6'>                        ScriptableObject.defineProperty(
</span>                            varScope, name, Undefined.instance,
                            ScriptableObject.PERMANENT);
                    } else {
<span class='bc' id='L3590' title='0|6|6 - Total: 6'>                        varScope.put(name, varScope, Undefined.instance);
</span>                    }
                } else {
<span class='bc' id='L3593' title='0|4|4 - Total: 4'>                    ScriptableObject.redefineProperty(scope, name, isConst);
</span>                }
<span class='bc' id='L3595' title='0|1|1 - Total: 1'>            }
</span>        }
<span class='bc' id='L3597' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * @deprecated Use {@link #createFunctionActivation(NativeFunction, Scriptable, Object[], boolean)} instead
     */
    @Deprecated
    public static Scriptable createFunctionActivation(NativeFunction funObj,
                                                      Scriptable scope,
                                                      Object[] args)
    {
<span class='nc' id='L3607' title='0|0|0 - Total: 6'>        return createFunctionActivation(funObj, scope, args, false);
</span>    }

    public static Scriptable createFunctionActivation(NativeFunction funObj,
                                                      Scriptable scope,
                                                      Object[] args,
                                                      boolean isStrict)
    {
<span class='bc' id='L3615' title='0|9|9 - Total: 9'>        return new NativeCall(funObj, scope, args, false, isStrict);
</span>    }

    public static Scriptable createArrowFunctionActivation(NativeFunction funObj,
                                                           Scriptable scope,
                                                           Object[] args,
                                                           boolean isStrict)
    {
<span class='bc' id='L3623' title='0|9|9 - Total: 9'>        return new NativeCall(funObj, scope, args, true, isStrict);
</span>    }

    public static void enterActivationFunction(Context cx,
                                               Scriptable scope)
    {
<span class='bpc' id='L3629' title='0|1|1 - Total: 2'>        if (cx.topCallScope == null)
</span><span class='nc' id='L3630' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span><span class='bc' id='L3631' title='0|3|3 - Total: 3'>        NativeCall call = (NativeCall)scope;
</span><span class='bc' id='L3632' title='0|4|4 - Total: 4'>        call.parentActivationCall = cx.currentActivationCall;
</span><span class='bc' id='L3633' title='0|3|3 - Total: 3'>        cx.currentActivationCall = call;
</span><span class='bc' id='L3634' title='0|2|2 - Total: 2'>        call.defineAttributesForArguments();
</span><span class='bc' id='L3635' title='0|1|1 - Total: 1'>    }
</span>
    public static void exitActivationFunction(Context cx)
    {
<span class='bc' id='L3639' title='0|3|3 - Total: 3'>        NativeCall call = cx.currentActivationCall;
</span><span class='bc' id='L3640' title='0|4|4 - Total: 4'>        cx.currentActivationCall = call.parentActivationCall;
</span><span class='bc' id='L3641' title='0|3|3 - Total: 3'>        call.parentActivationCall = null;
</span><span class='bc' id='L3642' title='0|1|1 - Total: 1'>    }
</span>
    static NativeCall findFunctionActivation(Context cx, Function f)
    {
<span class='bc' id='L3646' title='0|3|3 - Total: 3'>        NativeCall call = cx.currentActivationCall;
</span><span class='bc' id='L3647' title='0|2|2 - Total: 2'>        while (call != null) {
</span><span class='bpc' id='L3648' title='0|1|1 - Total: 2'>            if (call.function == f)
</span><span class='bc' id='L3649' title='0|2|2 - Total: 2'>                return call;
</span><span class='nc' id='L3650' title='0|0|0 - Total: 4'>            call = call.parentActivationCall;
</span>        }
<span class='bc' id='L3652' title='0|2|2 - Total: 2'>        return null;
</span>    }

    public static Scriptable newCatchScope(Throwable t,
                                           Scriptable lastCatchScope,
                                           String exceptionName,
                                           Context cx, Scriptable scope)
    {
        Object obj;
        boolean cacheObj;

    getObj:
<span class='bc' id='L3664' title='0|2|2 - Total: 2'>        if (t instanceof JavaScriptException) {
</span><span class='bc' id='L3665' title='0|2|2 - Total: 2'>            cacheObj = false;
</span><span class='bc' id='L3666' title='0|5|5 - Total: 5'>            obj = ((JavaScriptException)t).getValue();
</span>        } else {
<span class='bc' id='L3668' title='0|2|2 - Total: 2'>            cacheObj = true;
</span>
            // Create wrapper object unless it was associated with
            // the previous scope object

<span class='bpc' id='L3673' title='0|1|1 - Total: 2'>            if (lastCatchScope != null) {
</span><span class='nc' id='L3674' title='0|0|0 - Total: 3'>                NativeObject last = (NativeObject)lastCatchScope;
</span><span class='nc' id='L3675' title='0|0|0 - Total: 4'>                obj = last.getAssociatedValue(t);
</span><span class='nc' id='L3676' title='0|0|0 - Total: 2'>                if (obj == null) Kit.codeBug();
</span>                break getObj;
            }

            RhinoException re;
            TopLevel.NativeErrors type;
            String errorMsg;
<span class='bc' id='L3683' title='0|2|2 - Total: 2'>            Throwable javaException = null;
</span>
<span class='bc' id='L3685' title='0|2|2 - Total: 2'>            if (t instanceof EcmaError) {
</span><span class='bc' id='L3686' title='0|3|3 - Total: 3'>                EcmaError ee = (EcmaError)t;
</span><span class='bc' id='L3687' title='0|2|2 - Total: 2'>                re = ee;
</span><span class='bc' id='L3688' title='0|4|4 - Total: 4'>                type = TopLevel.NativeErrors.valueOf(ee.getName());
</span><span class='bc' id='L3689' title='0|3|3 - Total: 3'>                errorMsg = ee.getErrorMessage();
</span><span class='bpc' id='L3690' title='0|1|1 - Total: 2'>            } else if (t instanceof WrappedException) {
</span><span class='nc' id='L3691' title='0|0|0 - Total: 3'>                WrappedException we = (WrappedException)t;
</span><span class='nc' id='L3692' title='0|0|0 - Total: 2'>                re = we;
</span><span class='nc' id='L3693' title='0|0|0 - Total: 3'>                javaException = we.getWrappedException();
</span><span class='nc' id='L3694' title='0|0|0 - Total: 2'>                type = TopLevel.NativeErrors.JavaException;
</span><span class='nc' id='L3695' title='0|0|0 - Total: 10'>                errorMsg = javaException.getClass().getName()
</span><span class='nc' id='L3696' title='0|0|0 - Total: 4'>                           +": "+javaException.getMessage();
</span><span class='bpc' id='L3697' title='0|1|1 - Total: 2'>            } else if (t instanceof EvaluatorException) {
</span>                // Pure evaluator exception, nor WrappedException instance
<span class='bc' id='L3699' title='0|3|3 - Total: 3'>                EvaluatorException ee = (EvaluatorException)t;
</span><span class='bc' id='L3700' title='0|2|2 - Total: 2'>                re = ee;
</span><span class='bc' id='L3701' title='0|2|2 - Total: 2'>                type = TopLevel.NativeErrors.InternalError;
</span><span class='bc' id='L3702' title='0|3|3 - Total: 3'>                errorMsg = ee.getMessage();
</span><span class='nc' id='L3703' title='0|0|0 - Total: 2'>            } else if (cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)) {
</span>                // With FEATURE_ENHANCED_JAVA_ACCESS, scripts can catch
                // all exception types
<span class='nc' id='L3706' title='0|0|0 - Total: 5'>                re = new WrappedException(t);
</span><span class='nc' id='L3707' title='0|0|0 - Total: 2'>                type = TopLevel.NativeErrors.JavaException;
</span><span class='nc' id='L3708' title='0|0|0 - Total: 4'>                errorMsg = t.toString();
</span>            } else {
                // Script can catch only instances of JavaScriptException,
                // EcmaError and EvaluatorException
<span class='nc' id='L3712' title='0|0|0 - Total: 2'>                throw Kit.codeBug();
</span>            }

<span class='bc' id='L3715' title='0|3|3 - Total: 3'>            String sourceUri = re.sourceName();
</span><span class='bc' id='L3716' title='0|2|2 - Total: 2'>            if (sourceUri == null) {
</span><span class='bc' id='L3717' title='0|2|2 - Total: 2'>                sourceUri = "";
</span>            }
<span class='bc' id='L3719' title='0|3|3 - Total: 3'>            int line = re.lineNumber();
</span>            Object args[];
<span class='bc' id='L3721' title='0|2|2 - Total: 2'>            if (line > 0) {
</span><span class='bc' id='L3722' title='0|17|17 - Total: 17'>                args = new Object[] { errorMsg, sourceUri, Integer.valueOf(line) };
</span>            } else {
<span class='bc' id='L3724' title='0|11|11 - Total: 11'>                args = new Object[] { errorMsg, sourceUri };
</span>            }

<span class='bc' id='L3727' title='0|6|6 - Total: 6'>            Scriptable errorObject = newNativeError(cx, scope, type, args);
</span>            // set exception in Error objects to enable non-ECMA "stack" property
<span class='bc' id='L3729' title='0|2|2 - Total: 2'>            if (errorObject instanceof NativeError) {
</span><span class='bc' id='L3730' title='0|4|4 - Total: 4'>                ((NativeError) errorObject).setStackProvider(re);
</span>            }

<span class='bpc' id='L3733' title='0|1|1 - Total: 4'>            if (javaException != null && isVisible(cx, javaException)) {
</span><span class='nc' id='L3734' title='0|0|0 - Total: 8'>                Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException,
</span>                                                       null);
<span class='nc' id='L3736' title='0|0|0 - Total: 5'>                ScriptableObject.defineProperty(
</span>                    errorObject, "javaException", wrap,
                    ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
            }
<span class='bc' id='L3740' title='0|2|2 - Total: 2'>            if (isVisible(cx, re)) {
</span><span class='bc' id='L3741' title='0|8|8 - Total: 8'>                Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);
</span><span class='bc' id='L3742' title='0|5|5 - Total: 5'>                ScriptableObject.defineProperty(
</span>                        errorObject, "rhinoException", wrap,
                        ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
            }
<span class='bc' id='L3746' title='0|2|2 - Total: 2'>            obj = errorObject;
</span>        }

<span class='bc' id='L3749' title='0|4|4 - Total: 4'>        NativeObject catchScopeObject = new NativeObject();
</span>        // See ECMA 12.4
<span class='bc' id='L3751' title='0|5|5 - Total: 5'>        catchScopeObject.defineProperty(
</span>            exceptionName, obj, ScriptableObject.PERMANENT);

<span class='bc' id='L3754' title='0|2|2 - Total: 2'>        if (isVisible(cx, t)) {
</span>            // Add special Rhino object __exception__ defined in the catch
            // scope that can be used to retrieve the Java exception associated
            // with the JavaScript exception (to get stack trace info, etc.)
<span class='bc' id='L3758' title='0|5|5 - Total: 5'>            catchScopeObject.defineProperty(
</span><span class='bc' id='L3759' title='0|2|2 - Total: 2'>                "__exception__", Context.javaToJS(t, scope),
</span>                ScriptableObject.PERMANENT|ScriptableObject.DONTENUM);
        }

<span class='bc' id='L3763' title='0|2|2 - Total: 2'>        if (cacheObj) {
</span><span class='bc' id='L3764' title='0|5|5 - Total: 5'>            catchScopeObject.associateValue(t, obj);
</span>        }
<span class='bc' id='L3766' title='0|2|2 - Total: 2'>        return catchScopeObject;
</span>    }

    public static Scriptable wrapException(Throwable t,
                                           Scriptable scope,
                                           Context cx) {
        RhinoException re;
        String errorName;
        String errorMsg;
<span class='nc' id='L3775' title='0|0|0 - Total: 2'>        Throwable javaException = null;
</span>
<span class='nc' id='L3777' title='0|0|0 - Total: 2'>        if (t instanceof EcmaError) {
</span><span class='nc' id='L3778' title='0|0|0 - Total: 3'>            EcmaError ee = (EcmaError)t;
</span><span class='nc' id='L3779' title='0|0|0 - Total: 2'>            re = ee;
</span><span class='nc' id='L3780' title='0|0|0 - Total: 3'>            errorName = ee.getName();
</span><span class='nc' id='L3781' title='0|0|0 - Total: 3'>            errorMsg = ee.getErrorMessage();
</span><span class='nc' id='L3782' title='0|0|0 - Total: 2'>        } else if (t instanceof WrappedException) {
</span><span class='nc' id='L3783' title='0|0|0 - Total: 3'>            WrappedException we = (WrappedException)t;
</span><span class='nc' id='L3784' title='0|0|0 - Total: 2'>            re = we;
</span><span class='nc' id='L3785' title='0|0|0 - Total: 3'>            javaException = we.getWrappedException();
</span><span class='nc' id='L3786' title='0|0|0 - Total: 2'>            errorName = "JavaException";
</span><span class='nc' id='L3787' title='0|0|0 - Total: 10'>            errorMsg = javaException.getClass().getName()
</span><span class='nc' id='L3788' title='0|0|0 - Total: 4'>                       +": "+javaException.getMessage();
</span><span class='nc' id='L3789' title='0|0|0 - Total: 2'>        } else if (t instanceof EvaluatorException) {
</span>            // Pure evaluator exception, nor WrappedException instance
<span class='nc' id='L3791' title='0|0|0 - Total: 3'>            EvaluatorException ee = (EvaluatorException)t;
</span><span class='nc' id='L3792' title='0|0|0 - Total: 2'>            re = ee;
</span><span class='nc' id='L3793' title='0|0|0 - Total: 2'>            errorName = "InternalError";
</span><span class='nc' id='L3794' title='0|0|0 - Total: 3'>            errorMsg = ee.getMessage();
</span><span class='nc' id='L3795' title='0|0|0 - Total: 2'>        } else if (cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)) {
</span>            // With FEATURE_ENHANCED_JAVA_ACCESS, scripts can catch
            // all exception types
<span class='nc' id='L3798' title='0|0|0 - Total: 5'>            re = new WrappedException(t);
</span><span class='nc' id='L3799' title='0|0|0 - Total: 2'>            errorName = "JavaException";
</span><span class='nc' id='L3800' title='0|0|0 - Total: 4'>            errorMsg = t.toString();
</span>        } else {
            // Script can catch only instances of JavaScriptException,
            // EcmaError and EvaluatorException
<span class='nc' id='L3804' title='0|0|0 - Total: 2'>            throw Kit.codeBug();
</span>        }

<span class='nc' id='L3807' title='0|0|0 - Total: 3'>        String sourceUri = re.sourceName();
</span><span class='nc' id='L3808' title='0|0|0 - Total: 2'>        if (sourceUri == null) {
</span><span class='nc' id='L3809' title='0|0|0 - Total: 2'>            sourceUri = "";
</span>        }
<span class='nc' id='L3811' title='0|0|0 - Total: 3'>        int line = re.lineNumber();
</span>        Object args[];
<span class='nc' id='L3813' title='0|0|0 - Total: 2'>        if (line > 0) {
</span><span class='nc' id='L3814' title='0|0|0 - Total: 17'>            args = new Object[] { errorMsg, sourceUri, Integer.valueOf(line) };
</span>        } else {
<span class='nc' id='L3816' title='0|0|0 - Total: 11'>            args = new Object[] { errorMsg, sourceUri };
</span>        }

<span class='nc' id='L3819' title='0|0|0 - Total: 6'>        Scriptable errorObject = cx.newObject(scope, errorName, args);
</span><span class='nc' id='L3820' title='0|0|0 - Total: 4'>        ScriptableObject.putProperty(errorObject, "name", errorName);
</span>        // set exception in Error objects to enable non-ECMA "stack" property
<span class='nc' id='L3822' title='0|0|0 - Total: 2'>        if (errorObject instanceof NativeError) {
</span><span class='nc' id='L3823' title='0|0|0 - Total: 4'>            ((NativeError) errorObject).setStackProvider(re);
</span>        }

<span class='nc' id='L3826' title='0|0|0 - Total: 4'>        if (javaException != null && isVisible(cx, javaException)) {
</span><span class='nc' id='L3827' title='0|0|0 - Total: 8'>            Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException,
</span>                                                   null);
<span class='nc' id='L3829' title='0|0|0 - Total: 5'>            ScriptableObject.defineProperty(
</span>                errorObject, "javaException", wrap,
                ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
        }
<span class='nc' id='L3833' title='0|0|0 - Total: 2'>        if (isVisible(cx, re)) {
</span><span class='nc' id='L3834' title='0|0|0 - Total: 8'>            Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);
</span><span class='nc' id='L3835' title='0|0|0 - Total: 5'>            ScriptableObject.defineProperty(
</span>                    errorObject, "rhinoException", wrap,
                    ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
        }
<span class='nc' id='L3839' title='0|0|0 - Total: 2'>        return errorObject;
</span>    }

    private static boolean isVisible(Context cx, Object obj) {
<span class='bc' id='L3843' title='0|3|3 - Total: 3'>        ClassShutter shutter = cx.getClassShutter();
</span><span class='bc' id='L3844' title='0|2|2 - Total: 2'>        return shutter == null ||
</span><span class='bpc' id='L3845' title='0|1|1 - Total: 2'>            shutter.visibleToScripts(obj.getClass().getName());
</span>    }

    public static Scriptable enterWith(Object obj, Context cx,
                                       Scriptable scope)
    {
<span class='bc' id='L3851' title='0|5|5 - Total: 5'>        Scriptable sobj = toObjectOrNull(cx, obj, scope);
</span><span class='bpc' id='L3852' title='0|1|1 - Total: 2'>        if (sobj == null) {
</span><span class='nc' id='L3853' title='0|0|0 - Total: 5'>            throw typeError1("msg.undef.with", toString(obj));
</span>        }
<span class='bc' id='L3855' title='0|2|2 - Total: 2'>        if (sobj instanceof XMLObject) {
</span><span class='bc' id='L3856' title='0|3|3 - Total: 3'>            XMLObject xmlObject = (XMLObject)sobj;
</span><span class='bc' id='L3857' title='0|4|4 - Total: 4'>            return xmlObject.enterWith(scope);
</span>        }
<span class='bc' id='L3859' title='0|6|6 - Total: 6'>        return new NativeWith(scope, sobj);
</span>    }

    public static Scriptable leaveWith(Scriptable scope)
    {
<span class='bc' id='L3864' title='0|3|3 - Total: 3'>        NativeWith nw = (NativeWith)scope;
</span><span class='bc' id='L3865' title='0|3|3 - Total: 3'>        return nw.getParentScope();
</span>    }

    public static Scriptable enterDotQuery(Object value, Scriptable scope)
    {
<span class='bc' id='L3870' title='0|2|2 - Total: 2'>        if (!(value instanceof XMLObject)) {
</span><span class='nc' id='L3871' title='0|0|0 - Total: 3'>            throw notXmlError(value);
</span>        }
<span class='bc' id='L3873' title='0|3|3 - Total: 3'>        XMLObject object = (XMLObject)value;
</span><span class='bc' id='L3874' title='0|4|4 - Total: 4'>        return object.enterDotQuery(scope);
</span>    }

    public static Object updateDotQuery(boolean value, Scriptable scope)
    {
        // Return null to continue looping
<span class='bc' id='L3880' title='0|3|3 - Total: 3'>        NativeWith nw = (NativeWith)scope;
</span><span class='bc' id='L3881' title='0|4|4 - Total: 4'>        return nw.updateDotQuery(value);
</span>    }

    public static Scriptable leaveDotQuery(Scriptable scope)
    {
<span class='bc' id='L3886' title='0|3|3 - Total: 3'>        NativeWith nw = (NativeWith)scope;
</span><span class='bc' id='L3887' title='0|3|3 - Total: 3'>        return nw.getParentScope();
</span>    }

    public static void setFunctionProtoAndParent(BaseFunction fn,
                                                 Scriptable scope)
    {
<span class='bc' id='L3893' title='0|3|3 - Total: 3'>        fn.setParentScope(scope);
</span><span class='bc' id='L3894' title='0|4|4 - Total: 4'>        fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
</span><span class='bc' id='L3895' title='0|1|1 - Total: 1'>    }
</span>
    public static void setObjectProtoAndParent(ScriptableObject object,
                                               Scriptable scope)
    {
        // Compared with function it always sets the scope to top scope
<span class='bc' id='L3901' title='0|3|3 - Total: 3'>        scope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L3902' title='0|3|3 - Total: 3'>        object.setParentScope(scope);
</span><span class='bc' id='L3903' title='0|2|2 - Total: 2'>        Scriptable proto
</span><span class='bc' id='L3904' title='0|3|3 - Total: 3'>            = ScriptableObject.getClassPrototype(scope, object.getClassName());
</span><span class='bc' id='L3905' title='0|3|3 - Total: 3'>        object.setPrototype(proto);
</span><span class='bc' id='L3906' title='0|1|1 - Total: 1'>    }
</span>
    public static void setBuiltinProtoAndParent(ScriptableObject object,
                                                Scriptable scope,
                                                TopLevel.Builtins type)
    {
<span class='bc' id='L3912' title='0|3|3 - Total: 3'>        scope = ScriptableObject.getTopLevelScope(scope);
</span><span class='bc' id='L3913' title='0|3|3 - Total: 3'>        object.setParentScope(scope);
</span><span class='bc' id='L3914' title='0|5|5 - Total: 5'>        object.setPrototype(TopLevel.getBuiltinPrototype(scope, type));
</span><span class='bc' id='L3915' title='0|1|1 - Total: 1'>    }
</span>

    public static void initFunction(Context cx, Scriptable scope,
                                    NativeFunction function, int type,
                                    boolean fromEvalCode)
    {
<span class='bc' id='L3922' title='0|2|2 - Total: 2'>        if (type == FunctionNode.FUNCTION_STATEMENT) {
</span><span class='bc' id='L3923' title='0|3|3 - Total: 3'>            String name = function.getFunctionName();
</span><span class='bpc' id='L3924' title='0|3|3 - Total: 4'>            if (name != null && name.length() != 0) {
</span><span class='bc' id='L3925' title='0|2|2 - Total: 2'>                if (!fromEvalCode) {
</span>                    // ECMA specifies that functions defined in global and
                    // function scope outside eval should have DONTDELETE set.
<span class='bc' id='L3928' title='0|4|4 - Total: 4'>                    ScriptableObject.defineProperty
</span><span class='bc' id='L3929' title='0|2|2 - Total: 2'>                        (scope, name, function, ScriptableObject.PERMANENT);
</span>                } else {
<span class='bc' id='L3931' title='0|5|5 - Total: 5'>                    scope.put(name, scope, function);
</span>                }
            }
<span class='bpc' id='L3934' title='0|1|1 - Total: 2'>        } else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
</span><span class='bc' id='L3935' title='0|3|3 - Total: 3'>            String name = function.getFunctionName();
</span><span class='bpc' id='L3936' title='0|3|3 - Total: 4'>            if (name != null && name.length() != 0) {
</span>                // Always put function expression statements into initial
                // activation object ignoring the with statement to follow
                // SpiderMonkey
<span class='bc' id='L3940' title='0|2|2 - Total: 2'>                while (scope instanceof NativeWith) {
</span><span class='bc' id='L3941' title='0|4|4 - Total: 4'>                    scope = scope.getParentScope();
</span>                }
<span class='bc' id='L3943' title='0|5|5 - Total: 5'>                scope.put(name, scope, function);
</span>            }
<span class='bc' id='L3945' title='0|1|1 - Total: 1'>        } else {
</span><span class='nc' id='L3946' title='0|0|0 - Total: 2'>            throw Kit.codeBug();
</span>        }
<span class='bc' id='L3948' title='0|1|1 - Total: 1'>    }
</span>
    public static Scriptable newArrayLiteral(Object[] objects,
                                             int[] skipIndices,
                                             Context cx, Scriptable scope)
    {
<span class='bc' id='L3954' title='0|2|2 - Total: 2'>        final int SKIP_DENSITY = 2;
</span><span class='bc' id='L3955' title='0|3|3 - Total: 3'>        int count = objects.length;
</span><span class='bc' id='L3956' title='0|2|2 - Total: 2'>        int skipCount = 0;
</span><span class='bc' id='L3957' title='0|2|2 - Total: 2'>        if (skipIndices != null) {
</span><span class='bc' id='L3958' title='0|3|3 - Total: 3'>            skipCount = skipIndices.length;
</span>        }
<span class='bc' id='L3960' title='0|4|4 - Total: 4'>        int length = count + skipCount;
</span><span class='bc' id='L3961' title='0|4|4 - Total: 4'>        if (length > 1 && skipCount * SKIP_DENSITY < length) {
</span>            // If not too sparse, create whole array for constructor
            Object[] sparse;
<span class='bc' id='L3964' title='0|2|2 - Total: 2'>            if (skipCount == 0) {
</span><span class='bc' id='L3965' title='0|3|3 - Total: 3'>                sparse = objects;
</span>            } else {
<span class='bc' id='L3967' title='0|3|3 - Total: 3'>                sparse = new Object[length];
</span><span class='bc' id='L3968' title='0|2|2 - Total: 2'>                int skip = 0;
</span><span class='bc' id='L3969' title='0|2|2 - Total: 2'>                for (int i = 0, j = 0; i != length; ++i) {
</span><span class='bc' id='L3970' title='0|4|4 - Total: 4'>                    if (skip != skipCount && skipIndices[skip] == i) {
</span><span class='bc' id='L3971' title='0|4|4 - Total: 4'>                        sparse[i] = Scriptable.NOT_FOUND;
</span><span class='bc' id='L3972' title='0|1|1 - Total: 1'>                        ++skip;
</span><span class='bc' id='L3973' title='0|1|1 - Total: 1'>                        continue;
</span>                    }
<span class='bc' id='L3975' title='0|6|6 - Total: 6'>                    sparse[i] = objects[j];
</span><span class='bc' id='L3976' title='0|1|1 - Total: 1'>                    ++j;
</span>                }
            }
<span class='bc' id='L3979' title='0|5|5 - Total: 5'>            return cx.newArray(scope, sparse);
</span>        }

<span class='bc' id='L3982' title='0|5|5 - Total: 5'>        Scriptable array = cx.newArray(scope, length);
</span>
<span class='bc' id='L3984' title='0|2|2 - Total: 2'>        int skip = 0;
</span><span class='bc' id='L3985' title='0|2|2 - Total: 2'>        for (int i = 0, j = 0; i != length; ++i) {
</span><span class='bc' id='L3986' title='0|4|4 - Total: 4'>            if (skip != skipCount && skipIndices[skip] == i) {
</span><span class='bc' id='L3987' title='0|1|1 - Total: 1'>                ++skip;
</span><span class='bc' id='L3988' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L3990' title='0|7|7 - Total: 7'>            array.put(i, array, objects[j]);
</span><span class='bc' id='L3991' title='0|1|1 - Total: 1'>            ++j;
</span>        }
<span class='bc' id='L3993' title='0|2|2 - Total: 2'>        return array;
</span>    }

    /**
     * This method is here for backward compat with existing compiled code.  It
     * is called when an object literal is compiled.  The next instance will be
     * the version called from new code.
     * <strong>This method only present for compatibility.</strong>
     * @deprecated Use {@link #newObjectLiteral(Object[], Object[], int[], Context, Scriptable)} instead
     */
    @Deprecated
    public static Scriptable newObjectLiteral(Object[] propertyIds,
                                              Object[] propertyValues,
                                              Context cx, Scriptable scope)
    {
        // Passing null for getterSetters means no getters or setters
<span class='nc' id='L4009' title='0|0|0 - Total: 7'>        return newObjectLiteral(propertyIds, propertyValues, null, cx, scope);
</span>    }

    public static Scriptable newObjectLiteral(Object[] propertyIds,
                                              Object[] propertyValues,
                                              int [] getterSetters,
                                              Context cx, Scriptable scope)
    {
<span class='bc' id='L4017' title='0|4|4 - Total: 4'>        Scriptable object = cx.newObject(scope);
</span><span class='bc' id='L4018' title='0|2|2 - Total: 2'>        for (int i = 0, end = propertyIds.length; i != end; ++i) {
</span><span class='bc' id='L4019' title='0|4|4 - Total: 4'>            Object id = propertyIds[i];
</span><span class='bc' id='L4020' title='0|2|2 - Total: 2'>            int getterSetter = getterSetters == null ? 0 : getterSetters[i];
</span><span class='bc' id='L4021' title='0|4|4 - Total: 4'>            Object value = propertyValues[i];
</span><span class='bc' id='L4022' title='0|2|2 - Total: 2'>            if (id instanceof String) {
</span><span class='bc' id='L4023' title='0|2|2 - Total: 2'>                if (getterSetter == 0) {
</span><span class='bc' id='L4024' title='0|2|2 - Total: 2'>                    if (isSpecialProperty((String)id)) {
</span><span class='bc' id='L4025' title='0|7|7 - Total: 7'>                        Ref ref = specialRef(object, (String)id, cx, scope);
</span><span class='bc' id='L4026' title='0|6|6 - Total: 6'>                        ref.set(cx, scope, value);
</span><span class='bc' id='L4027' title='0|1|1 - Total: 1'>                    } else {
</span><span class='bc' id='L4028' title='0|7|7 - Total: 7'>                        object.put((String)id, object, value);
</span>                    }
                } else {
<span class='bc' id='L4031' title='0|3|3 - Total: 3'>                    ScriptableObject so = (ScriptableObject)object;
</span><span class='bc' id='L4032' title='0|3|3 - Total: 3'>                    Callable getterOrSetter = (Callable)value;
</span><span class='bc' id='L4033' title='0|2|2 - Total: 2'>                    boolean isSetter = getterSetter == 1;
</span><span class='bc' id='L4034' title='0|7|7 - Total: 7'>                    so.setGetterOrSetter((String)id, 0, getterOrSetter, isSetter);
</span><span class='bc' id='L4035' title='0|1|1 - Total: 1'>                }
</span>            } else {
<span class='bc' id='L4037' title='0|4|4 - Total: 4'>                int index = ((Integer)id).intValue();
</span><span class='bc' id='L4038' title='0|5|5 - Total: 5'>                object.put(index, object, value);
</span>            }
        }
<span class='bc' id='L4041' title='0|2|2 - Total: 2'>        return object;
</span>    }

    public static boolean isArrayObject(Object obj)
    {
<span class='nc' id='L4046' title='0|0|0 - Total: 4'>        return obj instanceof NativeArray || obj instanceof Arguments;
</span>    }

    public static Object[] getArrayElements(Scriptable object)
    {
<span class='bc' id='L4051' title='0|2|2 - Total: 2'>        Context cx = Context.getContext();
</span><span class='bc' id='L4052' title='0|4|4 - Total: 4'>        long longLen = NativeArray.getLengthProperty(cx, object);
</span><span class='bpc' id='L4053' title='0|1|1 - Total: 2'>        if (longLen > Integer.MAX_VALUE) {
</span>            // arrays beyond  MAX_INT is not in Java in any case
<span class='nc' id='L4055' title='0|0|0 - Total: 4'>            throw new IllegalArgumentException();
</span>        }
<span class='bc' id='L4057' title='0|3|3 - Total: 3'>        int len = (int) longLen;
</span><span class='bc' id='L4058' title='0|2|2 - Total: 2'>        if (len == 0) {
</span><span class='bc' id='L4059' title='0|2|2 - Total: 2'>            return ScriptRuntime.emptyArgs;
</span>        } else {
<span class='bc' id='L4061' title='0|3|3 - Total: 3'>            Object[] result = new Object[len];
</span><span class='bc' id='L4062' title='0|2|2 - Total: 2'>            for (int i=0; i < len; i++) {
</span><span class='bc' id='L4063' title='0|4|4 - Total: 4'>                Object elem = ScriptableObject.getProperty(object, i);
</span><span class='bc' id='L4064' title='0|2|2 - Total: 2'>                result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance
</span>                                                           : elem;
            }
<span class='bc' id='L4067' title='0|2|2 - Total: 2'>            return result;
</span>        }
    }

    static void checkDeprecated(Context cx, String name) {
<span class='nc' id='L4072' title='0|0|0 - Total: 3'>        int version = cx.getLanguageVersion();
</span><span class='nc' id='L4073' title='0|0|0 - Total: 4'>        if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
</span><span class='nc' id='L4074' title='0|0|0 - Total: 4'>            String msg = getMessage1("msg.deprec.ctor", name);
</span><span class='nc' id='L4075' title='0|0|0 - Total: 2'>            if (version == Context.VERSION_DEFAULT)
</span><span class='nc' id='L4076' title='0|0|0 - Total: 3'>                Context.reportWarning(msg);
</span>            else
<span class='nc' id='L4078' title='0|0|0 - Total: 3'>                throw Context.reportRuntimeError(msg);
</span>        }
<span class='nc' id='L4080' title='0|0|0 - Total: 1'>    }
</span>
    public static String getMessage0(String messageId)
    {
<span class='bc' id='L4084' title='0|4|4 - Total: 4'>        return getMessage(messageId, null);
</span>    }

    public static String getMessage1(String messageId, Object arg1)
    {
<span class='bc' id='L4089' title='0|7|7 - Total: 7'>        Object[] arguments = {arg1};
</span><span class='bc' id='L4090' title='0|4|4 - Total: 4'>        return getMessage(messageId, arguments);
</span>    }

    public static String getMessage2(
        String messageId, Object arg1, Object arg2)
    {
<span class='bc' id='L4096' title='0|11|11 - Total: 11'>        Object[] arguments = {arg1, arg2};
</span><span class='bc' id='L4097' title='0|4|4 - Total: 4'>        return getMessage(messageId, arguments);
</span>    }

    public static String getMessage3(
        String messageId, Object arg1, Object arg2, Object arg3)
    {
<span class='bc' id='L4103' title='0|15|15 - Total: 15'>        Object[] arguments = {arg1, arg2, arg3};
</span><span class='bc' id='L4104' title='0|4|4 - Total: 4'>        return getMessage(messageId, arguments);
</span>    }

    public static String getMessage4(
        String messageId, Object arg1, Object arg2, Object arg3, Object arg4)
    {
<span class='bc' id='L4110' title='0|19|19 - Total: 19'>        Object[] arguments = {arg1, arg2, arg3, arg4};
</span><span class='bc' id='L4111' title='0|4|4 - Total: 4'>        return getMessage(messageId, arguments);
</span>    }

    /**
     * This is an interface defining a message provider. Create your
     * own implementation to override the default error message provider.
     *
     * @author Mike Harm
     */
    public interface MessageProvider {

        /**
         * Returns a textual message identified by the given messageId,
         * parameterized by the given arguments.
         *
         * @param messageId the identifier of the message
         * @param arguments the arguments to fill into the message
         */
        String getMessage(String messageId, Object[] arguments);
    }

<span class='bc' id='L4132' title='0|5|5 - Total: 5'>    public static MessageProvider messageProvider = new DefaultMessageProvider();
</span>
    public static String getMessage(String messageId, Object[] arguments)
    {
<span class='bc' id='L4136' title='0|5|5 - Total: 5'>        return messageProvider.getMessage(messageId, arguments);
</span>    }

    /* OPT there's a noticable delay for the first error!  Maybe it'd
     * make sense to use a ListResourceBundle instead of a properties
     * file to avoid (synchronized) text parsing.
     */
    private static class DefaultMessageProvider implements MessageProvider {
        public String getMessage(String messageId, Object[] arguments) {
            final String defaultResource
                = "org.mozilla.javascript.resources.Messages";

            Context cx = Context.getCurrentContext();
            Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();

            // ResourceBundle does caching.
            ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);

            String formatString;
            try {
                formatString = rb.getString(messageId);
            } catch (java.util.MissingResourceException mre) {
                throw new RuntimeException
                    ("no message resource found for message property "+ messageId);
            }

            /*
             * It's OK to format the string, even if 'arguments' is null;
             * we need to format it anyway, to make double ''s collapse to
             * single 's.
             */
            MessageFormat formatter = new MessageFormat(formatString);
            return formatter.format(arguments);
        }
    }

    public static EcmaError constructError(String error, String message)
    {
<span class='bc' id='L4174' title='0|3|3 - Total: 3'>        int[] linep = new int[1];
</span><span class='bc' id='L4175' title='0|3|3 - Total: 3'>        String filename = Context.getSourcePositionFromStack(linep);
</span><span class='bc' id='L4176' title='0|10|10 - Total: 10'>        return constructError(error, message, filename, linep[0], null, 0);
</span>    }

    public static EcmaError constructError(String error,
                                           String message,
                                           int lineNumberDelta)
    {
<span class='bc' id='L4183' title='0|3|3 - Total: 3'>        int[] linep = new int[1];
</span><span class='bc' id='L4184' title='0|3|3 - Total: 3'>        String filename = Context.getSourcePositionFromStack(linep);
</span><span class='bc' id='L4185' title='0|2|2 - Total: 2'>        if (linep[0] != 0) {
</span><span class='bc' id='L4186' title='0|7|7 - Total: 7'>            linep[0] += lineNumberDelta;
</span>        }
<span class='bc' id='L4188' title='0|10|10 - Total: 10'>        return constructError(error, message, filename, linep[0], null, 0);
</span>    }

    public static EcmaError constructError(String error,
                                           String message,
                                           String sourceName,
                                           int lineNumber,
                                           String lineSource,
                                           int columnNumber)
    {
<span class='bc' id='L4198' title='0|10|10 - Total: 10'>        return new EcmaError(error, message, sourceName,
</span>                             lineNumber, lineSource, columnNumber);
    }

    public static EcmaError rangeError(String message)
    {
<span class='bc' id='L4204' title='0|4|4 - Total: 4'>        return constructError("RangeError", message);
</span>    }

    public static EcmaError typeError(String message)
    {
<span class='bc' id='L4209' title='0|4|4 - Total: 4'>        return constructError("TypeError", message);
</span>    }

    public static EcmaError typeError0(String messageId)
    {
<span class='bc' id='L4214' title='0|3|3 - Total: 3'>        String msg = getMessage0(messageId);
</span><span class='bc' id='L4215' title='0|3|3 - Total: 3'>        return typeError(msg);
</span>    }

    public static EcmaError typeError1(String messageId, Object arg1)
    {
<span class='bc' id='L4220' title='0|4|4 - Total: 4'>        String msg = getMessage1(messageId, arg1);
</span><span class='bc' id='L4221' title='0|3|3 - Total: 3'>        return typeError(msg);
</span>    }

    public static EcmaError typeError2(String messageId, Object arg1,
                                       Object arg2)
    {
<span class='bc' id='L4227' title='0|5|5 - Total: 5'>        String msg = getMessage2(messageId, arg1, arg2);
</span><span class='bc' id='L4228' title='0|3|3 - Total: 3'>        return typeError(msg);
</span>    }

    public static EcmaError typeError3(String messageId, String arg1,
                                       String arg2, String arg3)
    {
<span class='bc' id='L4234' title='0|6|6 - Total: 6'>        String msg = getMessage3(messageId, arg1, arg2, arg3);
</span><span class='bc' id='L4235' title='0|3|3 - Total: 3'>        return typeError(msg);
</span>    }

    public static RuntimeException undefReadError(Object object, Object id)
    {
<span class='bc' id='L4240' title='0|7|7 - Total: 7'>        return typeError2("msg.undef.prop.read", toString(object), toString(id));
</span>    }

    public static RuntimeException undefCallError(Object object, Object id)
    {
<span class='bc' id='L4245' title='0|7|7 - Total: 7'>        return typeError2("msg.undef.method.call", toString(object), toString(id));
</span>    }

    public static RuntimeException undefWriteError(Object object,
                                                   Object id,
                                                   Object value)
    {
<span class='bc' id='L4252' title='0|8|8 - Total: 8'>        return typeError3("msg.undef.prop.write", toString(object), toString(id),
</span><span class='bc' id='L4253' title='0|1|1 - Total: 1'>                          toString(value));
</span>    }

    private static RuntimeException undefDeleteError(Object object, Object id)
    {
<span class='bc' id='L4258' title='0|7|7 - Total: 7'>        throw typeError2("msg.undef.prop.delete", toString(object), toString(id));
</span>    }

    public static RuntimeException notFoundError(Scriptable object,
                                                 String property)
    {
        // XXX: use object to improve the error message
<span class='bc' id='L4265' title='0|4|4 - Total: 4'>        String msg = getMessage1("msg.is.not.defined", property);
</span><span class='bc' id='L4266' title='0|4|4 - Total: 4'>        throw constructError("ReferenceError", msg);
</span>    }

    public static RuntimeException notFunctionError(Object value)
    {
<span class='bc' id='L4271' title='0|4|4 - Total: 4'>        return notFunctionError(value, value);
</span>    }

    public static RuntimeException notFunctionError(Object value,
                                                    Object messageHelper)
    {
        // Use value for better error reporting
<span class='bc' id='L4278' title='0|2|2 - Total: 2'>        String msg = (messageHelper == null)
</span><span class='bc' id='L4279' title='0|2|2 - Total: 2'>                     ? "null" : messageHelper.toString();
</span><span class='bc' id='L4280' title='0|2|2 - Total: 2'>        if (value == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L4281' title='0|4|4 - Total: 4'>            return typeError1("msg.function.not.found", msg);
</span>        }
<span class='bc' id='L4283' title='0|6|6 - Total: 6'>        return typeError2("msg.isnt.function", msg, typeof(value));
</span>    }

    public static RuntimeException notFunctionError(Object obj, Object value,
            String propertyName)
    {
        // Use obj and value for better error reporting
<span class='bc' id='L4290' title='0|3|3 - Total: 3'>        String objString = toString(obj);
</span><span class='bc' id='L4291' title='0|2|2 - Total: 2'>        if (obj instanceof NativeFunction) {
</span>            // Omit function body in string representations of functions
<span class='bc' id='L4293' title='0|4|4 - Total: 4'>            int paren = objString.indexOf(')');
</span><span class='bc' id='L4294' title='0|5|5 - Total: 5'>            int curly = objString.indexOf('{', paren);
</span><span class='bpc' id='L4295' title='0|1|1 - Total: 2'>            if (curly > -1) {
</span><span class='bc' id='L4296' title='0|14|14 - Total: 14'>                objString = objString.substring(0, curly + 1) + "...}";
</span>            }
        }
<span class='bc' id='L4299' title='0|2|2 - Total: 2'>        if (value == Scriptable.NOT_FOUND) {
</span><span class='bc' id='L4300' title='0|5|5 - Total: 5'>            return typeError2("msg.function.not.found.in", propertyName,
</span>                    objString);
        }
<span class='bc' id='L4303' title='0|6|6 - Total: 6'>        return typeError3("msg.isnt.function.in", propertyName, objString,
</span><span class='bc' id='L4304' title='0|1|1 - Total: 1'>                          typeof(value));
</span>    }

    private static RuntimeException notXmlError(Object value)
    {
<span class='bc' id='L4309' title='0|5|5 - Total: 5'>        throw typeError1("msg.isnt.xml.object", toString(value));
</span>    }

    private static void warnAboutNonJSObject(Object nonJSObject)
    {
<span class='nc' id='L4314' title='0|0|0 - Total: 3'>        final String omitParam = ScriptRuntime.getMessage0("params.omit.non.js.object.warning");
</span><span class='nc' id='L4315' title='0|0|0 - Total: 2'>        if (!"true".equals(omitParam)) {
</span><span class='nc' id='L4316' title='0|0|0 - Total: 7'>            String message = ScriptRuntime.getMessage2("msg.non.js.object.warning",nonJSObject,nonJSObject.getClass().getName());
</span><span class='nc' id='L4317' title='0|0|0 - Total: 2'>            Context.reportWarning(message);
</span>            // Just to be sure that it would be noticed
<span class='nc' id='L4319' title='0|0|0 - Total: 3'>            System.err.println(message);
</span>        }
<span class='nc' id='L4321' title='0|0|0 - Total: 1'>    }
</span>
    public static RegExpProxy getRegExpProxy(Context cx)
    {
<span class='bc' id='L4325' title='0|3|3 - Total: 3'>        return cx.getRegExpProxy();
</span>    }

    public static void setRegExpProxy(Context cx, RegExpProxy proxy)
    {
<span class='bpc' id='L4330' title='0|1|1 - Total: 2'>        if (proxy == null) throw new IllegalArgumentException();
</span><span class='bc' id='L4331' title='0|3|3 - Total: 3'>        cx.regExpProxy = proxy;
</span><span class='bc' id='L4332' title='0|1|1 - Total: 1'>    }
</span>
    public static RegExpProxy checkRegExpProxy(Context cx)
    {
<span class='bc' id='L4336' title='0|3|3 - Total: 3'>        RegExpProxy result = getRegExpProxy(cx);
</span><span class='bpc' id='L4337' title='0|1|1 - Total: 2'>        if (result == null) {
</span><span class='nc' id='L4338' title='0|0|0 - Total: 3'>            throw Context.reportRuntimeError0("msg.no.regexp");
</span>        }
<span class='bc' id='L4340' title='0|2|2 - Total: 2'>        return result;
</span>    }

    public static Scriptable wrapRegExp(Context cx, Scriptable scope,
                                        Object compiled) {
<span class='bc' id='L4345' title='0|7|7 - Total: 7'>        return cx.getRegExpProxy().wrapRegExp(cx, scope, compiled);
</span>    }

    private static XMLLib currentXMLLib(Context cx)
    {
        // Scripts should be running to access this
<span class='bpc' id='L4351' title='0|1|1 - Total: 2'>        if (cx.topCallScope == null)
</span><span class='nc' id='L4352' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span>
<span class='bc' id='L4354' title='0|3|3 - Total: 3'>        XMLLib xmlLib = cx.cachedXMLLib;
</span><span class='bc' id='L4355' title='0|2|2 - Total: 2'>        if (xmlLib == null) {
</span><span class='bc' id='L4356' title='0|4|4 - Total: 4'>            xmlLib = XMLLib.extractFromScope(cx.topCallScope);
</span><span class='bpc' id='L4357' title='0|1|1 - Total: 2'>            if (xmlLib == null)
</span><span class='nc' id='L4358' title='0|0|0 - Total: 4'>                throw new IllegalStateException();
</span><span class='bc' id='L4359' title='0|3|3 - Total: 3'>            cx.cachedXMLLib = xmlLib;
</span>        }

<span class='bc' id='L4362' title='0|2|2 - Total: 2'>        return xmlLib;
</span>    }

    /**
     * Escapes the reserved characters in a value of an attribute
     *
     * @param value Unescaped text
     * @return The escaped text
     */
    public static String escapeAttributeValue(Object value, Context cx)
    {
<span class='bc' id='L4373' title='0|3|3 - Total: 3'>        XMLLib xmlLib = currentXMLLib(cx);
</span><span class='bc' id='L4374' title='0|4|4 - Total: 4'>        return xmlLib.escapeAttributeValue(value);
</span>    }

    /**
     * Escapes the reserved characters in a value of a text node
     *
     * @param value Unescaped text
     * @return The escaped text
     */
    public static String escapeTextValue(Object value, Context cx)
    {
<span class='bc' id='L4385' title='0|3|3 - Total: 3'>        XMLLib xmlLib = currentXMLLib(cx);
</span><span class='bc' id='L4386' title='0|4|4 - Total: 4'>        return xmlLib.escapeTextValue(value);
</span>    }

    public static Ref memberRef(Object obj, Object elem,
                                Context cx, int memberTypeFlags)
    {
<span class='bpc' id='L4392' title='0|1|1 - Total: 2'>        if (!(obj instanceof XMLObject)) {
</span><span class='nc' id='L4393' title='0|0|0 - Total: 3'>            throw notXmlError(obj);
</span>        }
<span class='bc' id='L4395' title='0|3|3 - Total: 3'>        XMLObject xmlObject = (XMLObject)obj;
</span><span class='bc' id='L4396' title='0|6|6 - Total: 6'>        return xmlObject.memberRef(cx, elem, memberTypeFlags);
</span>    }

    public static Ref memberRef(Object obj, Object namespace, Object elem,
                                Context cx, int memberTypeFlags)
    {
<span class='bpc' id='L4402' title='0|1|1 - Total: 2'>        if (!(obj instanceof XMLObject)) {
</span><span class='nc' id='L4403' title='0|0|0 - Total: 3'>            throw notXmlError(obj);
</span>        }
<span class='bc' id='L4405' title='0|3|3 - Total: 3'>        XMLObject xmlObject = (XMLObject)obj;
</span><span class='bc' id='L4406' title='0|7|7 - Total: 7'>        return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);
</span>    }

    public static Ref nameRef(Object name, Context cx,
                              Scriptable scope, int memberTypeFlags)
    {
<span class='bc' id='L4412' title='0|3|3 - Total: 3'>        XMLLib xmlLib = currentXMLLib(cx);
</span><span class='bc' id='L4413' title='0|7|7 - Total: 7'>        return xmlLib.nameRef(cx, name, scope, memberTypeFlags);
</span>    }

    public static Ref nameRef(Object namespace, Object name, Context cx,
                              Scriptable scope, int memberTypeFlags)
    {
<span class='bc' id='L4419' title='0|3|3 - Total: 3'>        XMLLib xmlLib = currentXMLLib(cx);
</span><span class='bc' id='L4420' title='0|8|8 - Total: 8'>        return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);
</span>    }

    private static void storeIndexResult(Context cx, int index)
    {
<span class='bc' id='L4425' title='0|3|3 - Total: 3'>        cx.scratchIndex = index;
</span><span class='bc' id='L4426' title='0|1|1 - Total: 1'>    }
</span>
    static int lastIndexResult(Context cx)
    {
<span class='bc' id='L4430' title='0|3|3 - Total: 3'>        return cx.scratchIndex;
</span>    }

    public static void storeUint32Result(Context cx, long value)
    {
<span class='bpc' id='L4435' title='0|1|1 - Total: 2'>        if ((value >>> 32) != 0)
</span><span class='nc' id='L4436' title='0|0|0 - Total: 4'>            throw new IllegalArgumentException();
</span><span class='bc' id='L4437' title='0|3|3 - Total: 3'>        cx.scratchUint32 = value;
</span><span class='bc' id='L4438' title='0|1|1 - Total: 1'>    }
</span>
    public static long lastUint32Result(Context cx)
    {
<span class='bc' id='L4442' title='0|3|3 - Total: 3'>        long value = cx.scratchUint32;
</span><span class='bpc' id='L4443' title='0|1|1 - Total: 2'>        if ((value >>> 32) != 0)
</span><span class='nc' id='L4444' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span><span class='bc' id='L4445' title='0|2|2 - Total: 2'>        return value;
</span>    }

    private static void storeScriptable(Context cx, Scriptable value)
    {
        // The previously stored scratchScriptable should be consumed
<span class='bpc' id='L4451' title='0|1|1 - Total: 2'>        if (cx.scratchScriptable != null)
</span><span class='nc' id='L4452' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span><span class='bc' id='L4453' title='0|3|3 - Total: 3'>        cx.scratchScriptable = value;
</span><span class='bc' id='L4454' title='0|1|1 - Total: 1'>    }
</span>
    public static Scriptable lastStoredScriptable(Context cx)
    {
<span class='bc' id='L4458' title='0|3|3 - Total: 3'>        Scriptable result = cx.scratchScriptable;
</span><span class='bc' id='L4459' title='0|3|3 - Total: 3'>        cx.scratchScriptable = null;
</span><span class='bc' id='L4460' title='0|2|2 - Total: 2'>        return result;
</span>    }

    static String makeUrlForGeneratedScript
        (boolean isEval, String masterScriptUrl, int masterScriptLine)
    {
<span class='bc' id='L4466' title='0|2|2 - Total: 2'>        if (isEval) {
</span><span class='bc' id='L4467' title='0|13|13 - Total: 13'>            return masterScriptUrl+'#'+masterScriptLine+"(eval)";
</span>        } else {
<span class='bc' id='L4469' title='0|13|13 - Total: 13'>            return masterScriptUrl+'#'+masterScriptLine+"(Function)";
</span>        }
    }

    static boolean isGeneratedScript(String sourceUrl) {
        // ALERT: this may clash with a valid URL containing (eval) or
        // (Function)
<span class='nc' id='L4476' title='0|0|0 - Total: 2'>        return sourceUrl.indexOf("(eval)") >= 0
</span><span class='nc' id='L4477' title='0|0|0 - Total: 2'>               || sourceUrl.indexOf("(Function)") >= 0;
</span>    }

    /**
     * Not all "NativeSymbol" instances are actually symbols. So account for that here rather than just
     * by using an "instanceof" check.
     */
    static boolean isSymbol(Object obj) {
<span class='bc' id='L4485' title='0|2|2 - Total: 2'>        return (((obj instanceof NativeSymbol) &&
</span><span class='bpc' id='L4486' title='0|3|3 - Total: 4'>                ((NativeSymbol)obj).isSymbol())) || (obj instanceof SymbolKey);
</span>    }

    private static RuntimeException errorWithClassName(String msg, Object val)
    {
<span class='nc' id='L4491' title='0|0|0 - Total: 6'>        return Context.reportRuntimeError1(msg, val.getClass().getName());
</span>    }

    /**
     * Equivalent to executing "new Error(message, sourceFileName, sourceLineNo)" from JavaScript.
     * @param cx the current context
     * @param scope the current scope
     * @param message the message
     * @return a JavaScriptException you should throw
     */
    public static JavaScriptException throwError(Context cx, Scriptable scope,
            String message) {
<span class='bc' id='L4503' title='0|7|7 - Total: 7'>      int[] linep = { 0 };
</span><span class='bc' id='L4504' title='0|3|3 - Total: 3'>      String filename = Context.getSourcePositionFromStack(linep);
</span><span class='bc' id='L4505' title='0|20|20 - Total: 20'>        final Scriptable error = newBuiltinObject(cx, scope,
</span><span class='bc' id='L4506' title='0|2|2 - Total: 2'>                TopLevel.Builtins.Error, new Object[] { message, filename, Integer.valueOf(linep[0]) });
</span><span class='bc' id='L4507' title='0|9|9 - Total: 9'>        return new JavaScriptException(error, filename, linep[0]);
</span>    }


    /**
     * Equivalent to executing "new $constructorName(message, sourceFileName, sourceLineNo)" from JavaScript.
     * @param cx the current context
     * @param scope the current scope
     * @param message the message
     * @return a JavaScriptException you should throw
     */
    public static JavaScriptException throwCustomError(Context cx, Scriptable scope, String constructorName,
            String message) {
<span class='bc' id='L4520' title='0|7|7 - Total: 7'>      int[] linep = { 0 };
</span><span class='bc' id='L4521' title='0|3|3 - Total: 3'>      String filename = Context.getSourcePositionFromStack(linep);
</span><span class='bc' id='L4522' title='0|20|20 - Total: 20'>      final Scriptable error =  cx.newObject(scope, constructorName,
</span><span class='bc' id='L4523' title='0|2|2 - Total: 2'>        new Object[] { message, filename, Integer.valueOf(linep[0]) });
</span><span class='bc' id='L4524' title='0|9|9 - Total: 9'>      return new JavaScriptException(error, filename, linep[0]);
</span>    }

<span class='bc' id='L4527' title='0|3|3 - Total: 3'>    public static final Object[] emptyArgs = new Object[0];
</span><span class='bc' id='L4528' title='0|4|4 - Total: 4'>    public static final String[] emptyStrings = new String[0];
</span>

}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>