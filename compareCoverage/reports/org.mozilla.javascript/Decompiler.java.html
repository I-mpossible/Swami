<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.Decompiler.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.Decompiler.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import org.mozilla.javascript.ast.FunctionNode;

/**
 * The following class save decompilation information about the source.
 * Source information is returned from the parser as a String
 * associated with function nodes and with the toplevel script.  When
 * saved in the constant pool of a class, this string will be UTF-8
 * encoded, and token values will occupy a single byte.

 * Source is saved (mostly) as token numbers.  The tokens saved pretty
 * much correspond to the token stream of a 'canonical' representation
 * of the input program, as directed by the parser.  (There were a few
 * cases where tokens could have been left out where decompiler could
 * easily reconstruct them, but I left them in for clarity).  (I also
 * looked adding source collection to TokenStream instead, where I
 * could have limited the changes to a few lines in getToken... but
 * this wouldn't have saved any space in the resulting source
 * representation, and would have meant that I'd have to duplicate
 * parser logic in the decompiler to disambiguate situations where
 * newlines are important.)  The function decompile expands the
 * tokens back into their string representations, using simple
 * lookahead to correct spacing and indentation.
 *
 * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens
 * are stored inline, as a NUMBER token, a character representing the type, and
 * either 1 or 4 characters representing the bit-encoding of the number.  String
 * types NAME, STRING and OBJECT are currently stored as a token type,
 * followed by a character giving the length of the string (assumed to
 * be less than 2^16), followed by the characters of the string
 * inlined into the source string.  Changing this to some reference to
 * to the string in the compiled class' constant pool would probably
 * save a lot of space... but would require some method of deriving
 * the final constant pool entry from information available at parse
 * time.
 */
<span class='uc' id='L44' title='2|2|2 - Total: 2'>public class Decompiler
</span>{
    /**
     * Flag to indicate that the decompilation should omit the
     * function header and trailing brace.
     */
    public static final int ONLY_BODY_FLAG = 1 << 0;

    /**
     * Flag to indicate that the decompilation generates toSource result.
     */
    public static final int TO_SOURCE_FLAG = 1 << 1;

    /**
     * Decompilation property to specify initial ident value.
     */
    public static final int INITIAL_INDENT_PROP = 1;

    /**
     * Decompilation property to specify default identation offset.
     */
    public static final int INDENT_GAP_PROP = 2;

    /**
     * Decompilation property to specify identation offset for case labels.
     */
    public static final int CASE_GAP_PROP = 3;

    // Marker to denote the last RC of function so it can be distinguished from
    // the last RC of object literals in case of function expressions
    private static final int FUNCTION_END = Token.LAST_TOKEN + 1;

    String getEncodedSource()
    {
<span class='uc' id='L78' title='4|4|4 - Total: 4'>        return sourceToString(0);
</span>    }

    int getCurrentOffset()
    {
<span class='uc' id='L83' title='3|3|3 - Total: 3'>        return sourceTop;
</span>    }

    int markFunctionStart(int functionType)
    {
<span class='uc' id='L88' title='3|3|3 - Total: 3'>        int savedOffset = getCurrentOffset();
</span><span class='uc' id='L89' title='2|2|2 - Total: 2'>        if (functionType != FunctionNode.ARROW_FUNCTION) {
</span><span class='uc' id='L90' title='3|3|3 - Total: 3'>            addToken(Token.FUNCTION);
</span><span class='uc' id='L91' title='4|4|4 - Total: 4'>            append((char)functionType);
</span>        }
<span class='uc' id='L93' title='2|2|2 - Total: 2'>        return savedOffset;
</span>    }

    int markFunctionEnd(int functionStart)
    {
<span class='uc' id='L98' title='3|3|3 - Total: 3'>        int offset = getCurrentOffset();
</span><span class='uc' id='L99' title='3|3|3 - Total: 3'>        append((char)FUNCTION_END);
</span><span class='uc' id='L100' title='2|2|2 - Total: 2'>        return offset;
</span>    }

    void addToken(int token)
    {
<span class='upc' id='L105' title='2|2|2 - Total: 4'>        if (!(0 <= token && token <= Token.LAST_TOKEN))
</span><span class='nc' id='L106' title='0|0|0 - Total: 4'>            throw new IllegalArgumentException();
</span>
<span class='uc' id='L108' title='4|4|4 - Total: 4'>        append((char)token);
</span><span class='uc' id='L109' title='1|1|1 - Total: 1'>    }
</span>
    void addEOL(int token)
    {
<span class='upc' id='L113' title='2|2|2 - Total: 4'>        if (!(0 <= token && token <= Token.LAST_TOKEN))
</span><span class='nc' id='L114' title='0|0|0 - Total: 4'>            throw new IllegalArgumentException();
</span>
<span class='uc' id='L116' title='4|4|4 - Total: 4'>        append((char)token);
</span><span class='uc' id='L117' title='3|3|3 - Total: 3'>        append((char)Token.EOL);
</span><span class='uc' id='L118' title='1|1|1 - Total: 1'>    }
</span>
    void addName(String str)
    {
<span class='uc' id='L122' title='3|3|3 - Total: 3'>        addToken(Token.NAME);
</span><span class='uc' id='L123' title='3|3|3 - Total: 3'>        appendString(str);
</span><span class='uc' id='L124' title='1|1|1 - Total: 1'>    }
</span>
    void addString(String str)
    {
<span class='uc' id='L128' title='3|3|3 - Total: 3'>        addToken(Token.STRING);
</span><span class='uc' id='L129' title='3|3|3 - Total: 3'>        appendString(str);
</span><span class='uc' id='L130' title='1|1|1 - Total: 1'>    }
</span>
    void addRegexp(String regexp, String flags)
    {
<span class='uc' id='L134' title='3|3|3 - Total: 3'>        addToken(Token.REGEXP);
</span><span class='uc' id='L135' title='14|14|14 - Total: 14'>        appendString('/' + regexp + '/' + flags);
</span><span class='uc' id='L136' title='1|1|1 - Total: 1'>    }
</span>
    void addNumber(double n)
    {
<span class='uc' id='L140' title='3|3|3 - Total: 3'>        addToken(Token.NUMBER);
</span>
        /* encode the number in the source stream.
         * Save as NUMBER type (char | char char char char)
         * where type is
         * 'D' - double, 'S' - short, 'J' - long.

         * We need to retain float vs. integer type info to keep the
         * behavior of liveconnect type-guessing the same after
         * decompilation.  (Liveconnect tries to present 1.0 to Java
         * as a float/double)
         * OPT: This is no longer true. We could compress the format.

         * This may not be the most space-efficient encoding;
         * the chars created below may take up to 3 bytes in
         * constant pool UTF-8 encoding, so a Double could take
         * up to 12 bytes.
         */

<span class='uc' id='L159' title='3|3|3 - Total: 3'>        long lbits = (long)n;
</span><span class='uc' id='L160' title='2|2|2 - Total: 2'>        if (lbits != n) {
</span>            // if it's floating point, save as a Double bit pattern.
            // (12/15/97 our scanner only returns Double for f.p.)
<span class='uc' id='L163' title='3|3|3 - Total: 3'>            lbits = Double.doubleToLongBits(n);
</span><span class='uc' id='L164' title='3|3|3 - Total: 3'>            append('D');
</span><span class='uc' id='L165' title='7|7|7 - Total: 7'>            append((char)(lbits >> 48));
</span><span class='uc' id='L166' title='7|7|7 - Total: 7'>            append((char)(lbits >> 32));
</span><span class='uc' id='L167' title='7|7|7 - Total: 7'>            append((char)(lbits >> 16));
</span><span class='uc' id='L168' title='6|6|6 - Total: 6'>            append((char)lbits);
</span>        }
        else {
            // we can ignore negative values, bc they're already prefixed
            // by NEG
<span class='upc' id='L173' title='1|1|1 - Total: 2'>               if (lbits < 0) Kit.codeBug();
</span>
            // will it fit in a char?
            // this gives a short encoding for integer values up to 2^16.
<span class='uc' id='L177' title='2|2|2 - Total: 2'>            if (lbits <= Character.MAX_VALUE) {
</span><span class='uc' id='L178' title='3|3|3 - Total: 3'>                append('S');
</span><span class='uc' id='L179' title='6|6|6 - Total: 6'>                append((char)lbits);
</span>            }
            else { // Integral, but won't fit in a char. Store as a long.
<span class='uc' id='L182' title='3|3|3 - Total: 3'>                append('J');
</span><span class='uc' id='L183' title='7|7|7 - Total: 7'>                append((char)(lbits >> 48));
</span><span class='uc' id='L184' title='7|7|7 - Total: 7'>                append((char)(lbits >> 32));
</span><span class='uc' id='L185' title='7|7|7 - Total: 7'>                append((char)(lbits >> 16));
</span><span class='uc' id='L186' title='5|5|5 - Total: 5'>                append((char)lbits);
</span>            }
        }
<span class='uc' id='L189' title='1|1|1 - Total: 1'>    }
</span>
    private void appendString(String str)
    {
<span class='uc' id='L193' title='3|3|3 - Total: 3'>        int L = str.length();
</span><span class='uc' id='L194' title='2|2|2 - Total: 2'>        int lengthEncodingSize = 1;
</span><span class='uc' id='L195' title='2|2|2 - Total: 2'>        if (L >= 0x8000) {
</span><span class='uc' id='L196' title='2|2|2 - Total: 2'>            lengthEncodingSize = 2;
</span>        }
<span class='uc' id='L198' title='7|7|7 - Total: 7'>        int nextTop = sourceTop + lengthEncodingSize + L;
</span><span class='uc' id='L199' title='2|2|2 - Total: 2'>        if (nextTop > sourceBuffer.length) {
</span><span class='uc' id='L200' title='3|3|3 - Total: 3'>            increaseSourceCapacity(nextTop);
</span>        }
<span class='uc' id='L202' title='2|2|2 - Total: 2'>        if (L >= 0x8000) {
</span>            // Use 2 chars to encode strings exceeding 32K, were the highest
            // bit in the first char indicates presence of the next byte
<span class='uc' id='L205' title='11|11|11 - Total: 11'>            sourceBuffer[sourceTop] = (char)(0x8000 | (L >>> 16));
</span><span class='uc' id='L206' title='6|6|6 - Total: 6'>            ++sourceTop;
</span>        }
<span class='uc' id='L208' title='7|7|7 - Total: 7'>        sourceBuffer[sourceTop] = (char)L;
</span><span class='uc' id='L209' title='6|6|6 - Total: 6'>        ++sourceTop;
</span><span class='uc' id='L210' title='8|8|8 - Total: 8'>        str.getChars(0, L, sourceBuffer, sourceTop);
</span><span class='uc' id='L211' title='3|3|3 - Total: 3'>        sourceTop = nextTop;
</span><span class='uc' id='L212' title='1|1|1 - Total: 1'>    }
</span>
    private void append(char c)
    {
<span class='uc' id='L216' title='2|2|2 - Total: 2'>        if (sourceTop == sourceBuffer.length) {
</span><span class='uc' id='L217' title='6|6|6 - Total: 6'>            increaseSourceCapacity(sourceTop + 1);
</span>        }
<span class='uc' id='L219' title='6|6|6 - Total: 6'>        sourceBuffer[sourceTop] = c;
</span><span class='uc' id='L220' title='6|6|6 - Total: 6'>        ++sourceTop;
</span><span class='uc' id='L221' title='1|1|1 - Total: 1'>    }
</span>
    private void increaseSourceCapacity(int minimalCapacity)
    {
        // Call this only when capacity increase is must
<span class='upc' id='L226' title='1|1|1 - Total: 2'>        if (minimalCapacity <= sourceBuffer.length) Kit.codeBug();
</span><span class='uc' id='L227' title='6|6|6 - Total: 6'>        int newCapacity = sourceBuffer.length * 2;
</span><span class='uc' id='L228' title='2|2|2 - Total: 2'>        if (newCapacity < minimalCapacity) {
</span><span class='uc' id='L229' title='2|2|2 - Total: 2'>            newCapacity = minimalCapacity;
</span>        }
<span class='uc' id='L231' title='3|3|3 - Total: 3'>        char[] tmp = new char[newCapacity];
</span><span class='uc' id='L232' title='8|8|8 - Total: 8'>        System.arraycopy(sourceBuffer, 0, tmp, 0, sourceTop);
</span><span class='uc' id='L233' title='3|3|3 - Total: 3'>        sourceBuffer = tmp;
</span><span class='uc' id='L234' title='1|1|1 - Total: 1'>    }
</span>
    private String sourceToString(int offset)
    {
<span class='upc' id='L238' title='2|2|2 - Total: 4'>        if (offset < 0 || sourceTop < offset) Kit.codeBug();
</span><span class='uc' id='L239' title='11|11|11 - Total: 11'>        return new String(sourceBuffer, offset, sourceTop - offset);
</span>    }

    /**
     * Decompile the source information associated with this js
     * function/script back into a string.  For the most part, this
     * just means translating tokens back to their string
     * representations; there's a little bit of lookahead logic to
     * decide the proper spacing/indentation.  Most of the work in
     * mapping the original source to the prettyprinted decompiled
     * version is done by the parser.
     *
     * @param source encoded source tree presentation
     *
     * @param flags flags to select output format
     *
     * @param properties indentation properties
     *
     */
    public static String decompile(String source, int flags,
                                   UintMap properties)
    {
<span class='uc' id='L261' title='3|3|3 - Total: 3'>        int length = source.length();
</span><span class='upc' id='L262' title='1|1|1 - Total: 2'>        if (length == 0) { return ""; }
</span>
<span class='uc' id='L264' title='5|5|5 - Total: 5'>        int indent = properties.getInt(INITIAL_INDENT_PROP, 0);
</span><span class='upc' id='L265' title='1|1|1 - Total: 2'>        if (indent < 0) throw new IllegalArgumentException();
</span><span class='uc' id='L266' title='5|5|5 - Total: 5'>        int indentGap = properties.getInt(INDENT_GAP_PROP, 4);
</span><span class='upc' id='L267' title='1|1|1 - Total: 2'>        if (indentGap < 0) throw new IllegalArgumentException();
</span><span class='uc' id='L268' title='5|5|5 - Total: 5'>        int caseGap = properties.getInt(CASE_GAP_PROP, 2);
</span><span class='upc' id='L269' title='1|1|1 - Total: 2'>        if (caseGap < 0) throw new IllegalArgumentException();
</span>
<span class='uc' id='L271' title='4|4|4 - Total: 4'>        StringBuilder result = new StringBuilder();
</span><span class='upc' id='L272' title='1|1|1 - Total: 2'>        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));
</span><span class='uc' id='L273' title='2|2|2 - Total: 2'>        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));
</span>
        // Spew tokens in source, for debugging.
        // as TYPE number char
        if (printSource) {
            System.err.println("length:" + length);
            for (int i = 0; i < length; ++i) {
                // Note that tokenToName will fail unless Context.printTrees
                // is true.
                String tokenname = null;
                if (Token.printNames) {
                    tokenname = Token.name(source.charAt(i));
                }
                if (tokenname == null) {
                    tokenname = "---";
                }
                String pad = tokenname.length() > 7
                    ? "\t"
                    : "\t\t";
                System.err.println
                    (tokenname
                     + pad + (int)source.charAt(i)
                     + "\t'" + ScriptRuntime.escapeString
                     (source.substring(i, i+1))
                     + "'");
            }
            System.err.println();
        }

<span class='uc' id='L302' title='2|2|2 - Total: 2'>        int braceNesting = 0;
</span><span class='uc' id='L303' title='2|2|2 - Total: 2'>        boolean afterFirstEOL = false;
</span><span class='uc' id='L304' title='2|2|2 - Total: 2'>        int i = 0;
</span>        int topFunctionType;
<span class='uc' id='L306' title='2|2|2 - Total: 2'>        if (source.charAt(i) == Token.SCRIPT) {
</span><span class='uc' id='L307' title='1|1|1 - Total: 1'>            ++i;
</span><span class='uc' id='L308' title='3|3|3 - Total: 3'>            topFunctionType = -1;
</span>        } else {
<span class='uc' id='L310' title='6|6|6 - Total: 6'>            topFunctionType = source.charAt(i + 1);
</span>        }

<span class='uc' id='L313' title='2|2|2 - Total: 2'>        if (!toSource) {
</span>            // add an initial newline to exactly match js.
<span class='uc' id='L315' title='4|4|4 - Total: 4'>            result.append('\n');
</span><span class='uc' id='L316' title='2|2|2 - Total: 2'>            for (int j = 0; j < indent; j++)
</span><span class='uc' id='L317' title='4|4|4 - Total: 4'>                result.append(' ');
</span>        } else {
<span class='uc' id='L319' title='2|2|2 - Total: 2'>            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {
</span><span class='uc' id='L320' title='4|4|4 - Total: 4'>                result.append('(');
</span>            }
        }

<span class='uc' id='L324' title='2|2|2 - Total: 2'>        while (i < length) {
</span><span class='upc' id='L325' title='76|76|76 - Total: 95'>            switch(source.charAt(i)) {
</span>            case Token.GET:
            case Token.SET:
            case Token.METHOD:
<span class='uc' id='L329' title='2|2|2 - Total: 2'>                if (source.charAt(i) == Token.GET) {
</span><span class='uc' id='L330' title='5|5|5 - Total: 5'>                    result.append("get ");
</span><span class='upc' id='L331' title='1|1|1 - Total: 2'>                } else if (source.charAt(i) == Token.SET) {
</span><span class='nc' id='L332' title='0|0|0 - Total: 4'>                    result.append("set ");
</span>                }
<span class='uc' id='L334' title='1|1|1 - Total: 1'>                ++i;
</span><span class='uc' id='L335' title='8|8|8 - Total: 8'>                i = printSourceString(source, i + 1, false, result);
</span>                // Now increment one more to get past the FUNCTION token
<span class='uc' id='L337' title='1|1|1 - Total: 1'>                ++i;
</span><span class='uc' id='L338' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.NAME:
            case Token.REGEXP:  // re-wrapped in '/'s in parser...
<span class='uc' id='L342' title='8|8|8 - Total: 8'>                i = printSourceString(source, i + 1, false, result);
</span><span class='uc' id='L343' title='1|1|1 - Total: 1'>                continue;
</span>
            case Token.STRING:
<span class='uc' id='L346' title='8|8|8 - Total: 8'>                i = printSourceString(source, i + 1, true, result);
</span><span class='uc' id='L347' title='1|1|1 - Total: 1'>                continue;
</span>
            case Token.NUMBER:
<span class='uc' id='L350' title='7|7|7 - Total: 7'>                i = printSourceNumber(source, i + 1, result);
</span><span class='uc' id='L351' title='1|1|1 - Total: 1'>                continue;
</span>
            case Token.TRUE:
<span class='uc' id='L354' title='4|4|4 - Total: 4'>                result.append("true");
</span><span class='uc' id='L355' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.FALSE:
<span class='uc' id='L358' title='4|4|4 - Total: 4'>                result.append("false");
</span><span class='uc' id='L359' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.NULL:
<span class='uc' id='L362' title='4|4|4 - Total: 4'>                result.append("null");
</span><span class='uc' id='L363' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.THIS:
<span class='uc' id='L366' title='4|4|4 - Total: 4'>                result.append("this");
</span><span class='uc' id='L367' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.FUNCTION:
<span class='uc' id='L370' title='1|1|1 - Total: 1'>                ++i; // skip function type
</span><span class='uc' id='L371' title='4|4|4 - Total: 4'>                result.append("function ");
</span><span class='uc' id='L372' title='1|1|1 - Total: 1'>                break;
</span>
            case FUNCTION_END:
                // Do nothing
<span class='uc' id='L376' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.COMMA:
<span class='uc' id='L379' title='4|4|4 - Total: 4'>                result.append(", ");
</span><span class='uc' id='L380' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.LC:
<span class='uc' id='L383' title='1|1|1 - Total: 1'>                ++braceNesting;
</span><span class='uc' id='L384' title='2|2|2 - Total: 2'>                if (Token.EOL == getNext(source, length, i))
</span><span class='uc' id='L385' title='4|4|4 - Total: 4'>                    indent += indentGap;
</span><span class='uc' id='L386' title='4|4|4 - Total: 4'>                result.append('{');
</span><span class='uc' id='L387' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.RC: {
<span class='uc' id='L390' title='1|1|1 - Total: 1'>                --braceNesting;
</span>                /* don't print the closing RC if it closes the
                 * toplevel function and we're called from
                 * decompileFunctionBody.
                 */
<span class='upc' id='L395' title='1|1|1 - Total: 4'>                if (justFunctionBody && braceNesting == 0)
</span><span class='nc' id='L396' title='0|0|0 - Total: 1'>                    break;
</span>
<span class='uc' id='L398' title='4|4|4 - Total: 4'>                result.append('}');
</span><span class='uc' id='L399' title='3|3|3 - Total: 3'>                switch (getNext(source, length, i)) {
</span>                    case Token.EOL:
                    case FUNCTION_END:
<span class='uc' id='L402' title='4|4|4 - Total: 4'>                        indent -= indentGap;
</span><span class='uc' id='L403' title='1|1|1 - Total: 1'>                        break;
</span>                    case Token.WHILE:
                    case Token.ELSE:
<span class='uc' id='L406' title='4|4|4 - Total: 4'>                        indent -= indentGap;
</span><span class='uc' id='L407' title='4|4|4 - Total: 4'>                        result.append(' ');
</span>                        break;
                }
<span class='uc' id='L410' title='1|1|1 - Total: 1'>                break;
</span>            }
            case Token.LP:
<span class='uc' id='L413' title='4|4|4 - Total: 4'>                result.append('(');
</span><span class='uc' id='L414' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.RP:
<span class='uc' id='L417' title='4|4|4 - Total: 4'>                result.append(')');
</span><span class='uc' id='L418' title='2|2|2 - Total: 2'>                if (Token.LC == getNext(source, length, i))
</span><span class='uc' id='L419' title='5|5|5 - Total: 5'>                    result.append(' ');
</span>                break;

            case Token.LB:
<span class='uc' id='L423' title='4|4|4 - Total: 4'>                result.append('[');
</span><span class='uc' id='L424' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.RB:
<span class='uc' id='L427' title='4|4|4 - Total: 4'>                result.append(']');
</span><span class='uc' id='L428' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.EOL: {
<span class='uc' id='L431' title='2|2|2 - Total: 2'>                if (toSource) break;
</span><span class='uc' id='L432' title='2|2|2 - Total: 2'>                boolean newLine = true;
</span><span class='uc' id='L433' title='2|2|2 - Total: 2'>                if (!afterFirstEOL) {
</span><span class='uc' id='L434' title='2|2|2 - Total: 2'>                    afterFirstEOL = true;
</span><span class='upc' id='L435' title='1|1|1 - Total: 2'>                    if (justFunctionBody) {
</span>                        /* throw away just added 'function name(...) {'
                         * and restore the original indent
                         */
<span class='nc' id='L439' title='0|0|0 - Total: 3'>                        result.setLength(0);
</span><span class='nc' id='L440' title='0|0|0 - Total: 4'>                        indent -= indentGap;
</span><span class='nc' id='L441' title='0|0|0 - Total: 2'>                        newLine = false;
</span>                    }
                }
<span class='upc' id='L444' title='1|1|1 - Total: 2'>                if (newLine) {
</span><span class='uc' id='L445' title='4|4|4 - Total: 4'>                    result.append('\n');
</span>                }

                /* add indent if any tokens remain,
                 * less setback if next token is
                 * a label, case or default.
                 */
<span class='uc' id='L452' title='2|2|2 - Total: 2'>                if (i + 1 < length) {
</span><span class='uc' id='L453' title='2|2|2 - Total: 2'>                    int less = 0;
</span><span class='uc' id='L454' title='6|6|6 - Total: 6'>                    int nextToken = source.charAt(i + 1);
</span><span class='uc' id='L455' title='4|4|4 - Total: 4'>                    if (nextToken == Token.CASE
</span>                        || nextToken == Token.DEFAULT)
                    {
<span class='uc' id='L458' title='5|5|5 - Total: 5'>                        less = indentGap - caseGap;
</span><span class='uc' id='L459' title='2|2|2 - Total: 2'>                    } else if (nextToken == Token.RC) {
</span><span class='uc' id='L460' title='3|3|3 - Total: 3'>                        less = indentGap;
</span>                    }

                    /* elaborate check against label... skip past a
                     * following inlined NAME and look for a COLON.
                     */
<span class='uc' id='L466' title='2|2|2 - Total: 2'>                    else if (nextToken == Token.NAME) {
</span><span class='uc' id='L467' title='6|6|6 - Total: 6'>                        int afterName = getSourceStringEnd(source, i + 2);
</span><span class='uc' id='L468' title='2|2|2 - Total: 2'>                        if (source.charAt(afterName) == Token.COLON)
</span><span class='uc' id='L469' title='2|2|2 - Total: 2'>                            less = indentGap;
</span>                    }

<span class='uc' id='L472' title='2|2|2 - Total: 2'>                    for (; less < indent; less++)
</span><span class='uc' id='L473' title='4|4|4 - Total: 4'>                        result.append(' ');
</span><span class='uc' id='L474' title='1|1|1 - Total: 1'>                }
</span>                break;
            }
            case Token.DOT:
<span class='uc' id='L478' title='4|4|4 - Total: 4'>                result.append('.');
</span><span class='uc' id='L479' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.NEW:
<span class='uc' id='L482' title='4|4|4 - Total: 4'>                result.append("new ");
</span><span class='uc' id='L483' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DELPROP:
<span class='uc' id='L486' title='4|4|4 - Total: 4'>                result.append("delete ");
</span><span class='uc' id='L487' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.IF:
<span class='uc' id='L490' title='4|4|4 - Total: 4'>                result.append("if ");
</span><span class='uc' id='L491' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ELSE:
<span class='uc' id='L494' title='4|4|4 - Total: 4'>                result.append("else ");
</span><span class='uc' id='L495' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.FOR:
<span class='uc' id='L498' title='4|4|4 - Total: 4'>                result.append("for ");
</span><span class='uc' id='L499' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.IN:
<span class='uc' id='L502' title='4|4|4 - Total: 4'>                result.append(" in ");
</span><span class='uc' id='L503' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.WITH:
<span class='uc' id='L506' title='4|4|4 - Total: 4'>                result.append("with ");
</span><span class='uc' id='L507' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.WHILE:
<span class='uc' id='L510' title='4|4|4 - Total: 4'>                result.append("while ");
</span><span class='uc' id='L511' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DO:
<span class='uc' id='L514' title='4|4|4 - Total: 4'>                result.append("do ");
</span><span class='uc' id='L515' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.TRY:
<span class='uc' id='L518' title='4|4|4 - Total: 4'>                result.append("try ");
</span><span class='uc' id='L519' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.CATCH:
<span class='uc' id='L522' title='4|4|4 - Total: 4'>                result.append("catch ");
</span><span class='uc' id='L523' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.FINALLY:
<span class='uc' id='L526' title='4|4|4 - Total: 4'>                result.append("finally ");
</span><span class='uc' id='L527' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.THROW:
<span class='uc' id='L530' title='4|4|4 - Total: 4'>                result.append("throw ");
</span><span class='uc' id='L531' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.SWITCH:
<span class='uc' id='L534' title='4|4|4 - Total: 4'>                result.append("switch ");
</span><span class='uc' id='L535' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.BREAK:
<span class='uc' id='L538' title='4|4|4 - Total: 4'>                result.append("break");
</span><span class='uc' id='L539' title='2|2|2 - Total: 2'>                if (Token.NAME == getNext(source, length, i))
</span><span class='uc' id='L540' title='5|5|5 - Total: 5'>                    result.append(' ');
</span>                break;

            case Token.CONTINUE:
<span class='uc' id='L544' title='4|4|4 - Total: 4'>                result.append("continue");
</span><span class='upc' id='L545' title='1|1|1 - Total: 2'>                if (Token.NAME == getNext(source, length, i))
</span><span class='nc' id='L546' title='0|0|0 - Total: 5'>                    result.append(' ');
</span>                break;

            case Token.CASE:
<span class='uc' id='L550' title='4|4|4 - Total: 4'>                result.append("case ");
</span><span class='uc' id='L551' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DEFAULT:
<span class='uc' id='L554' title='4|4|4 - Total: 4'>                result.append("default");
</span><span class='uc' id='L555' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.RETURN:
<span class='uc' id='L558' title='4|4|4 - Total: 4'>                result.append("return");
</span><span class='uc' id='L559' title='2|2|2 - Total: 2'>                if (Token.SEMI != getNext(source, length, i))
</span><span class='uc' id='L560' title='5|5|5 - Total: 5'>                    result.append(' ');
</span>                break;

            case Token.VAR:
<span class='uc' id='L564' title='4|4|4 - Total: 4'>                result.append("var ");
</span><span class='uc' id='L565' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.LET:
<span class='uc' id='L568' title='4|4|4 - Total: 4'>              result.append("let ");
</span><span class='uc' id='L569' title='1|1|1 - Total: 1'>              break;
</span>
            case Token.SEMI:
<span class='uc' id='L572' title='4|4|4 - Total: 4'>                result.append(';');
</span><span class='uc' id='L573' title='2|2|2 - Total: 2'>                if (Token.EOL != getNext(source, length, i)) {
</span>                    // separators in FOR
<span class='uc' id='L575' title='5|5|5 - Total: 5'>                    result.append(' ');
</span>                }
                break;

            case Token.ASSIGN:
<span class='uc' id='L580' title='4|4|4 - Total: 4'>                result.append(" = ");
</span><span class='uc' id='L581' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ASSIGN_ADD:
<span class='uc' id='L584' title='4|4|4 - Total: 4'>                result.append(" += ");
</span><span class='uc' id='L585' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ASSIGN_SUB:
<span class='nc' id='L588' title='0|0|0 - Total: 4'>                result.append(" -= ");
</span><span class='nc' id='L589' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ASSIGN_MUL:
<span class='uc' id='L592' title='4|4|4 - Total: 4'>                result.append(" *= ");
</span><span class='uc' id='L593' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ASSIGN_DIV:
<span class='nc' id='L596' title='0|0|0 - Total: 4'>                result.append(" /= ");
</span><span class='nc' id='L597' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ASSIGN_MOD:
<span class='uc' id='L600' title='4|4|4 - Total: 4'>                result.append(" %= ");
</span><span class='uc' id='L601' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ASSIGN_BITOR:
<span class='nc' id='L604' title='0|0|0 - Total: 4'>                result.append(" |= ");
</span><span class='nc' id='L605' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ASSIGN_BITXOR:
<span class='nc' id='L608' title='0|0|0 - Total: 4'>                result.append(" ^= ");
</span><span class='nc' id='L609' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ASSIGN_BITAND:
<span class='nc' id='L612' title='0|0|0 - Total: 4'>                result.append(" &= ");
</span><span class='nc' id='L613' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ASSIGN_LSH:
<span class='nc' id='L616' title='0|0|0 - Total: 4'>                result.append(" <<= ");
</span><span class='nc' id='L617' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ASSIGN_RSH:
<span class='uc' id='L620' title='4|4|4 - Total: 4'>                result.append(" >>= ");
</span><span class='uc' id='L621' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ASSIGN_URSH:
<span class='nc' id='L624' title='0|0|0 - Total: 4'>                result.append(" >>>= ");
</span><span class='nc' id='L625' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.HOOK:
<span class='uc' id='L628' title='4|4|4 - Total: 4'>                result.append(" ? ");
</span><span class='uc' id='L629' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.OBJECTLIT:
                // pun OBJECTLIT to mean colon in objlit property
                // initialization.
                // This needs to be distinct from COLON in the general case
                // to distinguish from the colon in a ternary... which needs
                // different spacing.
<span class='uc' id='L637' title='4|4|4 - Total: 4'>                result.append(": ");
</span><span class='uc' id='L638' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.COLON:
<span class='uc' id='L641' title='2|2|2 - Total: 2'>                if (Token.EOL == getNext(source, length, i))
</span>                    // it's the end of a label
<span class='uc' id='L643' title='5|5|5 - Total: 5'>                    result.append(':');
</span>                else
                    // it's the middle part of a ternary
<span class='uc' id='L646' title='4|4|4 - Total: 4'>                    result.append(" : ");
</span><span class='uc' id='L647' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.OR:
<span class='uc' id='L650' title='4|4|4 - Total: 4'>                result.append(" || ");
</span><span class='uc' id='L651' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.AND:
<span class='uc' id='L654' title='4|4|4 - Total: 4'>                result.append(" && ");
</span><span class='uc' id='L655' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.BITOR:
<span class='nc' id='L658' title='0|0|0 - Total: 4'>                result.append(" | ");
</span><span class='nc' id='L659' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.BITXOR:
<span class='nc' id='L662' title='0|0|0 - Total: 4'>                result.append(" ^ ");
</span><span class='nc' id='L663' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.BITAND:
<span class='uc' id='L666' title='4|4|4 - Total: 4'>                result.append(" & ");
</span><span class='uc' id='L667' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.SHEQ:
<span class='uc' id='L670' title='4|4|4 - Total: 4'>                result.append(" === ");
</span><span class='uc' id='L671' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.SHNE:
<span class='uc' id='L674' title='4|4|4 - Total: 4'>                result.append(" !== ");
</span><span class='uc' id='L675' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.EQ:
<span class='uc' id='L678' title='4|4|4 - Total: 4'>                result.append(" == ");
</span><span class='uc' id='L679' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.NE:
<span class='uc' id='L682' title='4|4|4 - Total: 4'>                result.append(" != ");
</span><span class='uc' id='L683' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.LE:
<span class='uc' id='L686' title='4|4|4 - Total: 4'>                result.append(" <= ");
</span><span class='uc' id='L687' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.LT:
<span class='uc' id='L690' title='4|4|4 - Total: 4'>                result.append(" < ");
</span><span class='uc' id='L691' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.GE:
<span class='nc' id='L694' title='0|0|0 - Total: 4'>                result.append(" >= ");
</span><span class='nc' id='L695' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.GT:
<span class='uc' id='L698' title='4|4|4 - Total: 4'>                result.append(" > ");
</span><span class='uc' id='L699' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.INSTANCEOF:
<span class='nc' id='L702' title='0|0|0 - Total: 4'>                result.append(" instanceof ");
</span><span class='nc' id='L703' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.LSH:
<span class='nc' id='L706' title='0|0|0 - Total: 4'>                result.append(" << ");
</span><span class='nc' id='L707' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.RSH:
<span class='nc' id='L710' title='0|0|0 - Total: 4'>                result.append(" >> ");
</span><span class='nc' id='L711' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.URSH:
<span class='nc' id='L714' title='0|0|0 - Total: 4'>                result.append(" >>> ");
</span><span class='nc' id='L715' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.TYPEOF:
<span class='uc' id='L718' title='4|4|4 - Total: 4'>                result.append("typeof ");
</span><span class='uc' id='L719' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.VOID:
<span class='nc' id='L722' title='0|0|0 - Total: 4'>                result.append("void ");
</span><span class='nc' id='L723' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.CONST:
<span class='uc' id='L726' title='4|4|4 - Total: 4'>                result.append("const ");
</span><span class='uc' id='L727' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.YIELD:
<span class='uc' id='L730' title='4|4|4 - Total: 4'>                result.append("yield ");
</span><span class='uc' id='L731' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.NOT:
<span class='uc' id='L734' title='4|4|4 - Total: 4'>                result.append('!');
</span><span class='uc' id='L735' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.BITNOT:
<span class='nc' id='L738' title='0|0|0 - Total: 4'>                result.append('~');
</span><span class='nc' id='L739' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.POS:
<span class='uc' id='L742' title='4|4|4 - Total: 4'>                result.append('+');
</span><span class='uc' id='L743' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.NEG:
<span class='uc' id='L746' title='4|4|4 - Total: 4'>                result.append('-');
</span><span class='uc' id='L747' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.INC:
<span class='uc' id='L750' title='4|4|4 - Total: 4'>                result.append("++");
</span><span class='uc' id='L751' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DEC:
<span class='uc' id='L754' title='4|4|4 - Total: 4'>                result.append("--");
</span><span class='uc' id='L755' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.ADD:
<span class='uc' id='L758' title='4|4|4 - Total: 4'>                result.append(" + ");
</span><span class='uc' id='L759' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.SUB:
<span class='uc' id='L762' title='4|4|4 - Total: 4'>                result.append(" - ");
</span><span class='uc' id='L763' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.MUL:
<span class='uc' id='L766' title='4|4|4 - Total: 4'>                result.append(" * ");
</span><span class='uc' id='L767' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DIV:
<span class='uc' id='L770' title='4|4|4 - Total: 4'>                result.append(" / ");
</span><span class='uc' id='L771' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.MOD:
<span class='uc' id='L774' title='4|4|4 - Total: 4'>                result.append(" % ");
</span><span class='uc' id='L775' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.COLONCOLON:
<span class='nc' id='L778' title='0|0|0 - Total: 4'>                result.append("::");
</span><span class='nc' id='L779' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.DOTDOT:
<span class='uc' id='L782' title='4|4|4 - Total: 4'>                result.append("..");
</span><span class='uc' id='L783' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DOTQUERY:
<span class='uc' id='L786' title='4|4|4 - Total: 4'>                result.append(".(");
</span><span class='uc' id='L787' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.XMLATTR:
<span class='uc' id='L790' title='4|4|4 - Total: 4'>                result.append('@');
</span><span class='uc' id='L791' title='1|1|1 - Total: 1'>                break;
</span>
            case Token.DEBUGGER:
<span class='nc' id='L794' title='0|0|0 - Total: 4'>                result.append("debugger;\n");
</span><span class='nc' id='L795' title='0|0|0 - Total: 1'>                break;
</span>
            case Token.ARROW:
<span class='uc' id='L798' title='4|4|4 - Total: 4'>                result.append(" => ");
</span><span class='uc' id='L799' title='1|1|1 - Total: 1'>                break;
</span>
            default:
                // If we don't know how to decompile it, raise an exception.
<span class='nc' id='L803' title='0|0|0 - Total: 9'>                throw new RuntimeException("Token: " +
</span><span class='nc' id='L804' title='0|0|0 - Total: 6'>                                               Token.name(source.charAt(i)));
</span>            }
<span class='uc' id='L806' title='2|2|2 - Total: 2'>            ++i;
</span>        }

<span class='uc' id='L809' title='2|2|2 - Total: 2'>        if (!toSource) {
</span>            // add that trailing newline if it's an outermost function.
<span class='upc' id='L811' title='1|1|1 - Total: 2'>            if (!justFunctionBody)
</span><span class='uc' id='L812' title='5|5|5 - Total: 5'>                result.append('\n');
</span>        } else {
<span class='uc' id='L814' title='2|2|2 - Total: 2'>            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {
</span><span class='uc' id='L815' title='4|4|4 - Total: 4'>                result.append(')');
</span>            }
        }

<span class='uc' id='L819' title='3|3|3 - Total: 3'>        return result.toString();
</span>    }

    private static int getNext(String source, int length, int i)
    {
<span class='uc' id='L824' title='2|2|2 - Total: 2'>        return (i + 1 < length) ? source.charAt(i + 1) : Token.EOF;
</span>    }

    private static int getSourceStringEnd(String source, int offset)
    {
<span class='uc' id='L829' title='6|6|6 - Total: 6'>        return printSourceString(source, offset, false, null);
</span>    }

    private static int printSourceString(String source, int offset,
                                         boolean asQuotedString,
                                         StringBuilder sb)
    {
<span class='uc' id='L836' title='4|4|4 - Total: 4'>        int length = source.charAt(offset);
</span><span class='uc' id='L837' title='1|1|1 - Total: 1'>        ++offset;
</span><span class='upc' id='L838' title='1|1|1 - Total: 2'>        if ((0x8000 & length) != 0) {
</span><span class='nc' id='L839' title='0|0|0 - Total: 10'>            length = ((0x7FFF & length) << 16) | source.charAt(offset);
</span><span class='nc' id='L840' title='0|0|0 - Total: 1'>            ++offset;
</span>        }
<span class='uc' id='L842' title='2|2|2 - Total: 2'>        if (sb != null) {
</span><span class='uc' id='L843' title='7|7|7 - Total: 7'>            String str = source.substring(offset, offset + length);
</span><span class='uc' id='L844' title='2|2|2 - Total: 2'>            if (!asQuotedString) {
</span><span class='uc' id='L845' title='5|5|5 - Total: 5'>                sb.append(str);
</span>            } else {
<span class='uc' id='L847' title='4|4|4 - Total: 4'>                sb.append('"');
</span><span class='uc' id='L848' title='5|5|5 - Total: 5'>                sb.append(ScriptRuntime.escapeString(str));
</span><span class='uc' id='L849' title='4|4|4 - Total: 4'>                sb.append('"');
</span>            }
        }
<span class='uc' id='L852' title='4|4|4 - Total: 4'>        return offset + length;
</span>    }

    private static int printSourceNumber(String source, int offset,
                                         StringBuilder sb)
    {
<span class='uc' id='L858' title='2|2|2 - Total: 2'>        double number = 0.0;
</span><span class='uc' id='L859' title='4|4|4 - Total: 4'>        char type = source.charAt(offset);
</span><span class='uc' id='L860' title='1|1|1 - Total: 1'>        ++offset;
</span><span class='uc' id='L861' title='2|2|2 - Total: 2'>        if (type == 'S') {
</span><span class='upc' id='L862' title='1|1|1 - Total: 2'>            if (sb != null) {
</span><span class='uc' id='L863' title='4|4|4 - Total: 4'>                int ival = source.charAt(offset);
</span><span class='uc' id='L864' title='3|3|3 - Total: 3'>                number = ival;
</span>            }
<span class='uc' id='L866' title='2|2|2 - Total: 2'>            ++offset;
</span><span class='upc' id='L867' title='3|3|3 - Total: 4'>        } else if (type == 'J' || type == 'D') {
</span><span class='upc' id='L868' title='1|1|1 - Total: 2'>            if (sb != null) {
</span>                long lbits;
<span class='uc' id='L870' title='7|7|7 - Total: 7'>                lbits = (long)source.charAt(offset) << 48;
</span><span class='uc' id='L871' title='11|11|11 - Total: 11'>                lbits |= (long)source.charAt(offset + 1) << 32;
</span><span class='uc' id='L872' title='11|11|11 - Total: 11'>                lbits |= (long)source.charAt(offset + 2) << 16;
</span><span class='uc' id='L873' title='9|9|9 - Total: 9'>                lbits |= source.charAt(offset + 3);
</span><span class='uc' id='L874' title='2|2|2 - Total: 2'>                if (type == 'J') {
</span><span class='uc' id='L875' title='4|4|4 - Total: 4'>                    number = lbits;
</span>                } else {
<span class='uc' id='L877' title='3|3|3 - Total: 3'>                    number = Double.longBitsToDouble(lbits);
</span>                }
            }
<span class='uc' id='L880' title='2|2|2 - Total: 2'>            offset += 4;
</span>        } else {
            // Bad source
<span class='nc' id='L883' title='0|0|0 - Total: 4'>            throw new RuntimeException();
</span>        }
<span class='upc' id='L885' title='1|1|1 - Total: 2'>        if (sb != null) {
</span><span class='uc' id='L886' title='6|6|6 - Total: 6'>            sb.append(ScriptRuntime.numberToString(number, 10));
</span>        }
<span class='uc' id='L888' title='2|2|2 - Total: 2'>        return offset;
</span>    }

<span class='uc' id='L891' title='5|5|5 - Total: 5'>    private char[] sourceBuffer = new char[128];
</span>
// Per script/function source buffer top: parent source does not include a
// nested functions source and uses function index as a reference instead.
    private int sourceTop;

// whether to do a debug print of the source information, when decompiling.
    private static final boolean printSource = false;

}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>