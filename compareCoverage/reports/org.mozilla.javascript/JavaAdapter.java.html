<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.JavaAdapter.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.JavaAdapter.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import org.mozilla.classfile.*;
import java.lang.reflect.*;
import java.io.*;
import java.security.*;
import java.util.*;

<span class='uc' id='L15' title='3|3|3 - Total: 3'>public final class JavaAdapter implements IdFunctionCall
</span>{
    /**
     * Provides a key with which to distinguish previously generated
     * adapter classes stored in a hash table.
     */
    static class JavaAdapterSignature
    {
        Class<?> superClass;
        Class<?>[] interfaces;
        ObjToIntMap names;

        JavaAdapterSignature(Class<?> superClass, Class<?>[] interfaces,
                             ObjToIntMap names)
        {
            this.superClass = superClass;
            this.interfaces = interfaces;
            this.names = names;
        }

        @Override
        public boolean equals(Object obj)
        {
            if (!(obj instanceof JavaAdapterSignature))
                return false;
            JavaAdapterSignature sig = (JavaAdapterSignature) obj;
            if (superClass != sig.superClass)
                return false;
            if (interfaces != sig.interfaces) {
                if (interfaces.length != sig.interfaces.length)
                    return false;
                for (int i=0; i < interfaces.length; i++)
                    if (interfaces[i] != sig.interfaces[i])
                        return false;
            }
            if (names.size() != sig.names.size())
                return false;
            ObjToIntMap.Iterator iter = new ObjToIntMap.Iterator(names);
            for (iter.start(); !iter.done(); iter.next()) {
                String name = (String)iter.getKey();
                int arity = iter.getValue();
                if (arity != sig.names.get(name, arity + 1))
                    return false;
            }
            return true;
        }

        @Override
        public int hashCode()
        {
            return (superClass.hashCode() + Arrays.hashCode(interfaces)) ^ names.size();
        }
    }

    public static void init(Context cx, Scriptable scope, boolean sealed)
    {
<span class='uc' id='L71' title='4|4|4 - Total: 4'>        JavaAdapter obj = new JavaAdapter();
</span><span class='uc' id='L72' title='10|10|10 - Total: 10'>        IdFunctionObject ctor = new IdFunctionObject(obj, FTAG, Id_JavaAdapter,
</span>                                                     "JavaAdapter", 1, scope);
<span class='uc' id='L74' title='3|3|3 - Total: 3'>        ctor.markAsConstructor(null);
</span><span class='upc' id='L75' title='1|1|1 - Total: 2'>        if (sealed) {
</span><span class='nc' id='L76' title='0|0|0 - Total: 2'>            ctor.sealObject();
</span>        }
<span class='uc' id='L78' title='2|2|2 - Total: 2'>        ctor.exportAsScopeProperty();
</span><span class='uc' id='L79' title='1|1|1 - Total: 1'>    }
</span>
    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,
                             Scriptable thisObj, Object[] args)
    {
<span class='upc' id='L84' title='1|1|1 - Total: 2'>        if (f.hasTag(FTAG)) {
</span><span class='upc' id='L85' title='1|1|1 - Total: 2'>            if (f.methodId() == Id_JavaAdapter) {
</span><span class='uc' id='L86' title='5|5|5 - Total: 5'>                return js_createAdapter(cx, scope, args);
</span>            }
        }
<span class='nc' id='L89' title='0|0|0 - Total: 3'>        throw f.unknown();
</span>    }

    public static Object convertResult(Object result, Class<?> c)
    {
<span class='upc' id='L94' title='1|1|1 - Total: 6'>        if (result == Undefined.instance &&
</span>            (c != ScriptRuntime.ObjectClass &&
             c != ScriptRuntime.StringClass))
        {
            // Avoid an error for an undefined value; return null instead.
<span class='nc' id='L99' title='0|0|0 - Total: 2'>            return null;
</span>        }
<span class='uc' id='L101' title='4|4|4 - Total: 4'>        return Context.jsToJava(result, c);
</span>    }

    public static Scriptable createAdapterWrapper(Scriptable obj, Object adapter)
    {
<span class='uc' id='L106' title='3|3|3 - Total: 3'>        Scriptable scope = ScriptableObject.getTopLevelScope(obj);
</span><span class='uc' id='L107' title='8|8|8 - Total: 8'>        NativeJavaObject res = new NativeJavaObject(scope, adapter, null, true);
</span><span class='uc' id='L108' title='3|3|3 - Total: 3'>        res.setPrototype(obj);
</span><span class='uc' id='L109' title='2|2|2 - Total: 2'>        return res;
</span>    }

    public static Object getAdapterSelf(Class<?> adapterClass, Object adapter)
        throws NoSuchFieldException, IllegalAccessException
    {
<span class='uc' id='L115' title='4|4|4 - Total: 4'>        Field self = adapterClass.getDeclaredField("self");
</span><span class='uc' id='L116' title='4|4|4 - Total: 4'>        return self.get(adapter);
</span>    }

    static Object js_createAdapter(Context cx, Scriptable scope, Object[] args)
    {
<span class='uc' id='L121' title='3|3|3 - Total: 3'>        int N = args.length;
</span><span class='upc' id='L122' title='1|1|1 - Total: 2'>        if (N == 0) {
</span><span class='nc' id='L123' title='0|0|0 - Total: 3'>            throw ScriptRuntime.typeError0("msg.adapter.zero.args");
</span>        }

        // Expected arguments:
        // Any number of NativeJavaClass objects representing the super-class
        // and/or interfaces to implement, followed by one NativeObject providing
        // the implementation, followed by any number of arguments to pass on
        // to the (super-class) constructor.

        int classCount;
<span class='uc' id='L133' title='2|2|2 - Total: 2'>        for (classCount = 0; classCount < N - 1; classCount++) {
</span><span class='uc' id='L134' title='4|4|4 - Total: 4'>            Object arg = args[classCount];
</span>            // We explicitly test for NativeObject here since checking for
            // instanceof ScriptableObject or !(instanceof NativeJavaClass)
            // would fail for a Java class that isn't found in the class path
            // as NativeJavaPackage extends ScriptableObject.
<span class='uc' id='L139' title='2|2|2 - Total: 2'>            if (arg instanceof NativeObject) {
</span><span class='uc' id='L140' title='1|1|1 - Total: 1'>                break;
</span>            }
<span class='upc' id='L142' title='1|1|1 - Total: 2'>            if (!(arg instanceof NativeJavaClass)) {
</span><span class='nc' id='L143' title='0|0|0 - Total: 4'>                throw ScriptRuntime.typeError2("msg.not.java.class.arg",
</span><span class='nc' id='L144' title='0|0|0 - Total: 2'>                                               String.valueOf(classCount),
</span><span class='nc' id='L145' title='0|0|0 - Total: 1'>                                               ScriptRuntime.toString(arg));
</span>            }
        }
<span class='uc' id='L148' title='2|2|2 - Total: 2'>        Class<?> superClass = null;
</span><span class='uc' id='L149' title='3|3|3 - Total: 3'>        Class<?>[] intfs = new Class[classCount];
</span><span class='uc' id='L150' title='2|2|2 - Total: 2'>        int interfaceCount = 0;
</span><span class='uc' id='L151' title='2|2|2 - Total: 2'>        for (int i = 0; i < classCount; ++i) {
</span><span class='uc' id='L152' title='6|6|6 - Total: 6'>            Class<?> c = ((NativeJavaClass) args[i]).getClassObject();
</span><span class='uc' id='L153' title='2|2|2 - Total: 2'>            if (!c.isInterface()) {
</span><span class='upc' id='L154' title='1|1|1 - Total: 2'>                if (superClass != null) {
</span><span class='nc' id='L155' title='0|0|0 - Total: 4'>                    throw ScriptRuntime.typeError2("msg.only.one.super",
</span><span class='nc' id='L156' title='0|0|0 - Total: 3'>                              superClass.getName(), c.getName());
</span>                }
<span class='uc' id='L158' title='3|3|3 - Total: 3'>                superClass = c;
</span>            } else {
<span class='uc' id='L160' title='5|5|5 - Total: 5'>                intfs[interfaceCount++] = c;
</span>            }
        }

<span class='uc' id='L164' title='2|2|2 - Total: 2'>        if (superClass == null) {
</span><span class='uc' id='L165' title='2|2|2 - Total: 2'>            superClass = ScriptRuntime.ObjectClass;
</span>        }
        
<span class='uc' id='L168' title='3|3|3 - Total: 3'>        Class<?>[] interfaces = new Class[interfaceCount];
</span><span class='uc' id='L169' title='6|6|6 - Total: 6'>        System.arraycopy(intfs, 0, interfaces, 0, interfaceCount);
</span>        // next argument is implementation, must be scriptable
<span class='uc' id='L171' title='5|5|5 - Total: 5'>        Scriptable obj = ScriptableObject.ensureScriptable(args[classCount]);
</span>
<span class='uc' id='L173' title='6|6|6 - Total: 6'>        Class<?> adapterClass = getAdapterClass(scope, superClass, interfaces, obj);
</span>        Object adapter;
        
<span class='uc' id='L176' title='6|6|6 - Total: 6'>        int argsCount = N - classCount - 1;
</span>        try {
<span class='uc' id='L178' title='2|2|2 - Total: 2'>            if (argsCount > 0) {
</span>                // Arguments contain parameters for super-class constructor.
                // We use the generic Java method lookup logic to find and
                // invoke the right constructor.
<span class='uc' id='L182' title='5|5|5 - Total: 5'>                Object[] ctorArgs = new Object[argsCount + 2];
</span><span class='uc' id='L183' title='4|4|4 - Total: 4'>                ctorArgs[0] = obj;
</span><span class='uc' id='L184' title='5|5|5 - Total: 5'>                ctorArgs[1] = cx.getFactory();
</span><span class='uc' id='L185' title='8|8|8 - Total: 8'>                System.arraycopy(args, classCount + 1, ctorArgs, 2, argsCount);
</span>                // TODO: cache class wrapper?
<span class='uc' id='L187' title='7|7|7 - Total: 7'>                NativeJavaClass classWrapper = new NativeJavaClass(scope,
</span>                        adapterClass, true);
<span class='uc' id='L189' title='4|4|4 - Total: 4'>                NativeJavaMethod ctors = classWrapper.members.ctors;
</span><span class='uc' id='L190' title='5|5|5 - Total: 5'>                int index = ctors.findCachedFunction(cx, ctorArgs);
</span><span class='upc' id='L191' title='1|1|1 - Total: 2'>                if (index < 0) {
</span><span class='nc' id='L192' title='0|0|0 - Total: 3'>                    String sig = NativeJavaMethod.scriptSignature(args);
</span><span class='nc' id='L193' title='0|0|0 - Total: 4'>                    throw Context.reportRuntimeError2(
</span><span class='nc' id='L194' title='0|0|0 - Total: 2'>                            "msg.no.java.ctor", adapterClass.getName(), sig);
</span>                }

                // Found the constructor, so try invoking it.
<span class='uc' id='L198' title='7|7|7 - Total: 7'>                adapter = NativeJavaClass.constructInternal(ctorArgs, ctors.methods[index]);
</span><span class='uc' id='L199' title='1|1|1 - Total: 1'>            } else {
</span><span class='uc' id='L200' title='11|11|11 - Total: 11'>                Class<?>[] ctorParms = {
</span>                        ScriptRuntime.ScriptableClass,
                        ScriptRuntime.ContextFactoryClass
                };
<span class='uc' id='L204' title='12|12|12 - Total: 12'>                Object[] ctorArgs = { obj, cx.getFactory() };
</span><span class='uc' id='L205' title='6|6|6 - Total: 6'>                adapter = adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);
</span>            }

<span class='uc' id='L208' title='4|4|4 - Total: 4'>            Object self = getAdapterSelf(adapterClass, adapter);
</span>            // Return unwrapped JavaAdapter if it implements Scriptable
<span class='upc' id='L210' title='1|1|1 - Total: 2'>            if (self instanceof Wrapper) {
</span><span class='uc' id='L211' title='4|4|4 - Total: 4'>                Object unwrapped = ((Wrapper) self).unwrap();
</span><span class='upc' id='L212' title='1|1|1 - Total: 2'>                if (unwrapped instanceof Scriptable) {
</span><span class='nc' id='L213' title='0|0|0 - Total: 2'>                    if (unwrapped instanceof ScriptableObject) {
</span><span class='nc' id='L214' title='0|0|0 - Total: 4'>                        ScriptRuntime.setObjectProtoAndParent(
</span>                                (ScriptableObject)unwrapped, scope);
                    }
<span class='nc' id='L217' title='0|0|0 - Total: 2'>                    return unwrapped;
</span>                }
            }
<span class='uc' id='L220' title='2|2|2 - Total: 2'>            return self;
</span><span class='nc' id='L221' title='0|0|0 - Total: 1'>        } catch (Exception ex) {
</span><span class='nc' id='L222' title='0|0|0 - Total: 3'>            throw Context.throwAsScriptRuntimeEx(ex);
</span>        }
    }

    // Needed by NativeJavaObject serializer
    public static void writeAdapterObject(Object javaObject,
                                          ObjectOutputStream out)
        throws IOException
    {
<span class='nc' id='L231' title='0|0|0 - Total: 3'>        Class<?> cl = javaObject.getClass();
</span><span class='nc' id='L232' title='0|0|0 - Total: 5'>        out.writeObject(cl.getSuperclass().getName());
</span>
<span class='nc' id='L234' title='0|0|0 - Total: 3'>        Class<?>[] interfaces = cl.getInterfaces();
</span><span class='nc' id='L235' title='0|0|0 - Total: 4'>        String[] interfaceNames = new String[interfaces.length];
</span>
<span class='nc' id='L237' title='0|0|0 - Total: 2'>        for (int i=0; i < interfaces.length; i++)
</span><span class='nc' id='L238' title='0|0|0 - Total: 7'>            interfaceNames[i] = interfaces[i].getName();
</span>
<span class='nc' id='L240' title='0|0|0 - Total: 3'>        out.writeObject(interfaceNames);
</span>
        try {
<span class='nc' id='L243' title='0|0|0 - Total: 6'>            Object delegee = cl.getField("delegee").get(javaObject);
</span><span class='nc' id='L244' title='0|0|0 - Total: 3'>            out.writeObject(delegee);
</span><span class='nc' id='L245' title='0|0|0 - Total: 1'>            return;
</span><span class='nc' id='L246' title='0|0|0 - Total: 1'>        } catch (IllegalAccessException e) {
</span><span class='nc' id='L247' title='0|0|0 - Total: 1'>        } catch (NoSuchFieldException e) {
</span><span class='nc' id='L248' title='0|0|0 - Total: 1'>        }
</span><span class='nc' id='L249' title='0|0|0 - Total: 4'>        throw new IOException();
</span>    }

    // Needed by NativeJavaObject de-serializer
    public static Object readAdapterObject(Scriptable self,
                                           ObjectInputStream in)
        throws IOException, ClassNotFoundException
    {
        ContextFactory factory;
<span class='nc' id='L258' title='0|0|0 - Total: 2'>        Context cx = Context.getCurrentContext();
</span><span class='nc' id='L259' title='0|0|0 - Total: 2'>        if (cx != null) {
</span><span class='nc' id='L260' title='0|0|0 - Total: 4'>            factory = cx.getFactory();
</span>        } else {
<span class='nc' id='L262' title='0|0|0 - Total: 2'>            factory = null;
</span>        }

<span class='nc' id='L265' title='0|0|0 - Total: 5'>        Class<?> superClass = Class.forName((String)in.readObject());
</span>
<span class='nc' id='L267' title='0|0|0 - Total: 5'>        String[] interfaceNames = (String[])in.readObject();
</span><span class='nc' id='L268' title='0|0|0 - Total: 4'>        Class<?>[] interfaces = new Class[interfaceNames.length];
</span>
<span class='nc' id='L270' title='0|0|0 - Total: 2'>        for (int i=0; i < interfaceNames.length; i++)
</span><span class='nc' id='L271' title='0|0|0 - Total: 7'>            interfaces[i] = Class.forName(interfaceNames[i]);
</span>
<span class='nc' id='L273' title='0|0|0 - Total: 4'>        Scriptable delegee = (Scriptable)in.readObject();
</span>
<span class='nc' id='L275' title='0|0|0 - Total: 6'>        Class<?> adapterClass = getAdapterClass(self, superClass, interfaces,
</span>                                             delegee);

<span class='nc' id='L278' title='0|0|0 - Total: 15'>        Class<?>[] ctorParms = {
</span>            ScriptRuntime.ContextFactoryClass,
            ScriptRuntime.ScriptableClass,
            ScriptRuntime.ScriptableClass
        };
<span class='nc' id='L283' title='0|0|0 - Total: 15'>        Object[] ctorArgs = { factory, delegee, self };
</span>        try {
<span class='nc' id='L285' title='0|0|0 - Total: 6'>            return adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);
</span><span class='nc' id='L286' title='0|0|0 - Total: 1'>        } catch(InstantiationException e) {
</span><span class='nc' id='L287' title='0|0|0 - Total: 1'>        } catch(IllegalAccessException e) {
</span><span class='nc' id='L288' title='0|0|0 - Total: 1'>        } catch(InvocationTargetException e) {
</span><span class='nc' id='L289' title='0|0|0 - Total: 1'>        } catch(NoSuchMethodException e) {
</span><span class='nc' id='L290' title='0|0|0 - Total: 3'>        }
</span>
<span class='nc' id='L292' title='0|0|0 - Total: 5'>        throw new ClassNotFoundException("adapter");
</span>    }

    private static ObjToIntMap getObjectFunctionNames(Scriptable obj)
    {
<span class='uc' id='L297' title='3|3|3 - Total: 3'>        Object[] ids = ScriptableObject.getPropertyIds(obj);
</span><span class='uc' id='L298' title='6|6|6 - Total: 6'>        ObjToIntMap map = new ObjToIntMap(ids.length);
</span><span class='uc' id='L299' title='2|2|2 - Total: 2'>        for (int i = 0; i != ids.length; ++i) {
</span><span class='upc' id='L300' title='1|1|1 - Total: 2'>            if (!(ids[i] instanceof String))
</span><span class='nc' id='L301' title='0|0|0 - Total: 1'>                continue;
</span><span class='uc' id='L302' title='5|5|5 - Total: 5'>            String id = (String) ids[i];
</span><span class='uc' id='L303' title='4|4|4 - Total: 4'>            Object value = ScriptableObject.getProperty(obj, id);
</span><span class='upc' id='L304' title='1|1|1 - Total: 2'>            if (value instanceof Function) {
</span><span class='uc' id='L305' title='3|3|3 - Total: 3'>                Function f = (Function)value;
</span><span class='uc' id='L306' title='4|4|4 - Total: 4'>                int length = ScriptRuntime.toInt32(
</span><span class='uc' id='L307' title='1|1|1 - Total: 1'>                                 ScriptableObject.getProperty(f, "length"));
</span><span class='upc' id='L308' title='1|1|1 - Total: 2'>                if (length < 0) {
</span><span class='nc' id='L309' title='0|0|0 - Total: 2'>                    length = 0;
</span>                }
<span class='uc' id='L311' title='4|4|4 - Total: 4'>                map.put(id, length);
</span>            }
        }
<span class='uc' id='L314' title='2|2|2 - Total: 2'>        return map;
</span>    }

    private static Class<?> getAdapterClass(Scriptable scope, Class<?> superClass,
                                            Class<?>[] interfaces, Scriptable obj)
    {
<span class='uc' id='L320' title='3|3|3 - Total: 3'>        ClassCache cache = ClassCache.get(scope);
</span><span class='uc' id='L321' title='1|1|1 - Total: 1'>        Map<JavaAdapterSignature,Class<?>> generated
</span><span class='uc' id='L322' title='2|2|2 - Total: 2'>            = cache.getInterfaceAdapterCacheMap();
</span>
<span class='uc' id='L324' title='3|3|3 - Total: 3'>        ObjToIntMap names = getObjectFunctionNames(obj);
</span>        JavaAdapterSignature sig;
<span class='uc' id='L326' title='7|7|7 - Total: 7'>        sig = new JavaAdapterSignature(superClass, interfaces, names);
</span><span class='uc' id='L327' title='5|5|5 - Total: 5'>        Class<?> adapterClass = generated.get(sig);
</span><span class='uc' id='L328' title='2|2|2 - Total: 2'>        if (adapterClass == null) {
</span><span class='uc' id='L329' title='10|10|10 - Total: 10'>            String adapterName = "adapter" + cache.newClassSerialNumber();
</span><span class='uc' id='L330' title='7|7|7 - Total: 7'>            byte[] code = createAdapterCode(names, adapterName,
</span>                                            superClass, interfaces, null);

<span class='uc' id='L333' title='4|4|4 - Total: 4'>            adapterClass = loadAdapterClass(adapterName, code);
</span><span class='upc' id='L334' title='1|1|1 - Total: 2'>            if (cache.isCachingEnabled()) {
</span><span class='uc' id='L335' title='5|5|5 - Total: 5'>                generated.put(sig, adapterClass);
</span>            }
        }
<span class='uc' id='L338' title='2|2|2 - Total: 2'>        return adapterClass;
</span>    }

    public static byte[] createAdapterCode(ObjToIntMap functionNames,
                                           String adapterName,
                                           Class<?> superClass,
                                           Class<?>[] interfaces,
                                           String scriptClassName)
    {
<span class='uc' id='L347' title='4|4|4 - Total: 4'>        ClassFileWriter cfw = new ClassFileWriter(adapterName,
</span><span class='uc' id='L348' title='4|4|4 - Total: 4'>                                                  superClass.getName(),
</span>                                                  "<adapter>");
<span class='uc' id='L350' title='5|5|5 - Total: 5'>        cfw.addField("factory", "Lorg/mozilla/javascript/ContextFactory;",
</span>                     (short) (ClassFileWriter.ACC_PUBLIC |
                              ClassFileWriter.ACC_FINAL));
<span class='uc' id='L353' title='5|5|5 - Total: 5'>        cfw.addField("delegee", "Lorg/mozilla/javascript/Scriptable;",
</span>                     (short) (ClassFileWriter.ACC_PUBLIC |
                              ClassFileWriter.ACC_FINAL));
<span class='uc' id='L356' title='5|5|5 - Total: 5'>        cfw.addField("self", "Lorg/mozilla/javascript/Scriptable;",
</span>                     (short) (ClassFileWriter.ACC_PUBLIC |
                              ClassFileWriter.ACC_FINAL));
<span class='upc' id='L359' title='1|1|1 - Total: 2'>        int interfacesCount = interfaces == null ? 0 : interfaces.length;
</span><span class='uc' id='L360' title='2|2|2 - Total: 2'>        for (int i=0; i < interfacesCount; i++) {
</span><span class='upc' id='L361' title='1|1|1 - Total: 2'>            if (interfaces[i] != null)
</span><span class='uc' id='L362' title='6|6|6 - Total: 6'>                cfw.addInterface(interfaces[i].getName());
</span>        }

<span class='uc' id='L365' title='6|6|6 - Total: 6'>        String superName = superClass.getName().replace('.', '/');
</span><span class='uc' id='L366' title='3|3|3 - Total: 3'>        Constructor<?>[] ctors = superClass.getDeclaredConstructors();
</span><span class='uc' id='L367' title='2|2|2 - Total: 2'>        for (Constructor<?> ctor : ctors) {
</span><span class='uc' id='L368' title='3|3|3 - Total: 3'>            int mod = ctor.getModifiers();
</span><span class='upc' id='L369' title='3|3|3 - Total: 4'>            if (Modifier.isPublic(mod) || Modifier.isProtected(mod)) {
</span><span class='uc' id='L370' title='5|5|5 - Total: 5'>                generateCtor(cfw, adapterName, superName, ctor);
</span>            }
        }
<span class='uc' id='L373' title='4|4|4 - Total: 4'>        generateSerialCtor(cfw, adapterName, superName);
</span><span class='upc' id='L374' title='1|1|1 - Total: 2'>        if (scriptClassName != null) {
</span><span class='nc' id='L375' title='0|0|0 - Total: 5'>            generateEmptyCtor(cfw, adapterName, superName, scriptClassName);
</span>        }

<span class='uc' id='L378' title='4|4|4 - Total: 4'>        ObjToIntMap generatedOverrides = new ObjToIntMap();
</span><span class='uc' id='L379' title='4|4|4 - Total: 4'>        ObjToIntMap generatedMethods = new ObjToIntMap();
</span>
        // generate methods to satisfy all specified interfaces.
<span class='uc' id='L382' title='2|2|2 - Total: 2'>        for (int i = 0; i < interfacesCount; i++) {
</span><span class='uc' id='L383' title='5|5|5 - Total: 5'>            Method[] methods = interfaces[i].getMethods();
</span><span class='uc' id='L384' title='2|2|2 - Total: 2'>            for (int j = 0; j < methods.length; j++) {
</span><span class='uc' id='L385' title='4|4|4 - Total: 4'>                Method method = methods[j];
</span><span class='uc' id='L386' title='3|3|3 - Total: 3'>                int mods = method.getModifiers();
</span><span class='upc' id='L387' title='3|3|3 - Total: 4'>                if (Modifier.isStatic(mods) || Modifier.isFinal(mods) ||
</span><span class='uc' id='L388' title='2|2|2 - Total: 2'>                    VMBridge.instance.isDefaultMethod(method)) {
</span><span class='uc' id='L389' title='1|1|1 - Total: 1'>                    continue;
</span>                }
<span class='uc' id='L391' title='3|3|3 - Total: 3'>                String methodName = method.getName();
</span><span class='uc' id='L392' title='3|3|3 - Total: 3'>                Class<?>[] argTypes = method.getParameterTypes();
</span><span class='uc' id='L393' title='2|2|2 - Total: 2'>                if (!functionNames.has(methodName)) {
</span>                    try {
<span class='uc' id='L395' title='5|5|5 - Total: 5'>                        superClass.getMethod(methodName, argTypes);
</span>                        // The class we're extending implements this method and
                        // the JavaScript object doesn't have an override. See
                        // bug 61226.
<span class='uc' id='L399' title='1|1|1 - Total: 1'>                        continue;
</span><span class='uc' id='L400' title='1|1|1 - Total: 1'>                    } catch (NoSuchMethodException e) {
</span>                        // Not implemented by superclass; fall through
                    }
                }
                // make sure to generate only one instance of a particular
                // method/signature.
<span class='uc' id='L406' title='4|4|4 - Total: 4'>                String methodSignature = getMethodSignature(method, argTypes);
</span><span class='uc' id='L407' title='9|9|9 - Total: 9'>                String methodKey = methodName + methodSignature;
</span><span class='upc' id='L408' title='1|1|1 - Total: 2'>                if (! generatedOverrides.has(methodKey)) {
</span><span class='uc' id='L409' title='6|6|6 - Total: 6'>                    generateMethod(cfw, adapterName, methodName, argTypes,
</span><span class='uc' id='L410' title='2|2|2 - Total: 2'>                                   method.getReturnType(), true);
</span><span class='uc' id='L411' title='4|4|4 - Total: 4'>                    generatedOverrides.put(methodKey, 0);
</span><span class='uc' id='L412' title='4|4|4 - Total: 4'>                    generatedMethods.put(methodName, 0);
</span>                }
            }
        }

        // Now, go through the superclass's methods, checking for abstract
        // methods or additional methods to override.

        // generate any additional overrides that the object might contain.
<span class='uc' id='L421' title='3|3|3 - Total: 3'>        Method[] methods = getOverridableMethods(superClass);
</span><span class='uc' id='L422' title='2|2|2 - Total: 2'>        for (int j = 0; j < methods.length; j++) {
</span><span class='uc' id='L423' title='4|4|4 - Total: 4'>            Method method = methods[j];
</span><span class='uc' id='L424' title='3|3|3 - Total: 3'>            int mods = method.getModifiers();
</span>            // if a method is marked abstract, must implement it or the
            // resulting class won't be instantiable. otherwise, if the object
            // has a property of the same name, then an override is intended.
<span class='uc' id='L428' title='3|3|3 - Total: 3'>            boolean isAbstractMethod = Modifier.isAbstract(mods);
</span><span class='uc' id='L429' title='3|3|3 - Total: 3'>            String methodName = method.getName();
</span><span class='uc' id='L430' title='4|4|4 - Total: 4'>            if (isAbstractMethod || functionNames.has(methodName)) {
</span>                // make sure to generate only one instance of a particular
                // method/signature.
<span class='uc' id='L433' title='3|3|3 - Total: 3'>                Class<?>[] argTypes = method.getParameterTypes();
</span><span class='uc' id='L434' title='4|4|4 - Total: 4'>                String methodSignature = getMethodSignature(method, argTypes);
</span><span class='uc' id='L435' title='9|9|9 - Total: 9'>                String methodKey = methodName + methodSignature;
</span><span class='upc' id='L436' title='1|1|1 - Total: 2'>                if (! generatedOverrides.has(methodKey)) {
</span><span class='uc' id='L437' title='6|6|6 - Total: 6'>                    generateMethod(cfw, adapterName, methodName, argTypes,
</span><span class='uc' id='L438' title='2|2|2 - Total: 2'>                                   method.getReturnType(), true);
</span><span class='uc' id='L439' title='4|4|4 - Total: 4'>                    generatedOverrides.put(methodKey, 0);
</span><span class='uc' id='L440' title='4|4|4 - Total: 4'>                    generatedMethods.put(methodName, 0);
</span>
                    // if a method was overridden, generate a "super$method"
                    // which lets the delegate call the superclass' version.
<span class='uc' id='L444' title='2|2|2 - Total: 2'>                    if (!isAbstractMethod) {
</span><span class='uc' id='L445' title='8|8|8 - Total: 8'>                        generateSuper(cfw, adapterName, superName,
</span>                                      methodName, methodSignature,
<span class='uc' id='L447' title='1|1|1 - Total: 1'>                                      argTypes, method.getReturnType());
</span>                    }
                }
            }
        }

        // Generate Java methods for remaining properties that are not
        // overrides.
<span class='uc' id='L455' title='5|5|5 - Total: 5'>        ObjToIntMap.Iterator iter = new ObjToIntMap.Iterator(functionNames);
</span><span class='uc' id='L456' title='2|2|2 - Total: 2'>        for (iter.start(); !iter.done(); iter.next()) {
</span><span class='uc' id='L457' title='4|4|4 - Total: 4'>            String functionName = (String)iter.getKey();
</span><span class='uc' id='L458' title='2|2|2 - Total: 2'>            if (generatedMethods.has(functionName))
</span><span class='uc' id='L459' title='1|1|1 - Total: 1'>                continue;
</span><span class='uc' id='L460' title='3|3|3 - Total: 3'>            int length = iter.getValue();
</span><span class='uc' id='L461' title='3|3|3 - Total: 3'>            Class<?>[] parms = new Class[length];
</span><span class='upc' id='L462' title='1|1|1 - Total: 2'>            for (int k=0; k < length; k++)
</span><span class='nc' id='L463' title='0|0|0 - Total: 4'>                parms[k] = ScriptRuntime.ObjectClass;
</span><span class='uc' id='L464' title='7|7|7 - Total: 7'>            generateMethod(cfw, adapterName, functionName, parms,
</span>                           ScriptRuntime.ObjectClass, false);
        }
<span class='uc' id='L467' title='3|3|3 - Total: 3'>        return cfw.toByteArray();
</span>    }

    static Method[] getOverridableMethods(Class<?> clazz)
    {
<span class='uc' id='L472' title='4|4|4 - Total: 4'>        ArrayList<Method> list = new ArrayList<Method>();
</span><span class='uc' id='L473' title='4|4|4 - Total: 4'>        HashSet<String> skip = new HashSet<String>();
</span>        // Check superclasses before interfaces so we always choose
        // implemented methods over abstract ones, even if a subclass
        // re-implements an interface already implemented in a superclass
        // (e.g. java.util.ArrayList)
<span class='uc' id='L478' title='2|2|2 - Total: 2'>        for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {
</span><span class='uc' id='L479' title='4|4|4 - Total: 4'>            appendOverridableMethods(c, list, skip);
</span>        }
<span class='uc' id='L481' title='2|2|2 - Total: 2'>        for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {
</span><span class='uc' id='L482' title='2|2|2 - Total: 2'>            for (Class<?> intf: c.getInterfaces())
</span><span class='uc' id='L483' title='4|4|4 - Total: 4'>                appendOverridableMethods(intf, list, skip);
</span>        }
<span class='uc' id='L485' title='7|7|7 - Total: 7'>        return list.toArray(new Method[list.size()]);
</span>    }

    private static void appendOverridableMethods(Class<?> c,
            ArrayList<Method> list, HashSet<String> skip)
    {
<span class='uc' id='L491' title='3|3|3 - Total: 3'>        Method[] methods = c.getDeclaredMethods();
</span><span class='uc' id='L492' title='2|2|2 - Total: 2'>        for (int i = 0; i < methods.length; i++) {
</span><span class='uc' id='L493' title='14|14|14 - Total: 14'>            String methodKey = methods[i].getName() +
</span><span class='uc' id='L494' title='4|4|4 - Total: 4'>                getMethodSignature(methods[i],
</span><span class='uc' id='L495' title='1|1|1 - Total: 1'>                        methods[i].getParameterTypes());
</span><span class='uc' id='L496' title='2|2|2 - Total: 2'>            if (skip.contains(methodKey))
</span><span class='uc' id='L497' title='1|1|1 - Total: 1'>                continue; // skip this method
</span><span class='uc' id='L498' title='5|5|5 - Total: 5'>            int mods = methods[i].getModifiers();
</span><span class='uc' id='L499' title='2|2|2 - Total: 2'>            if (Modifier.isStatic(mods))
</span><span class='uc' id='L500' title='1|1|1 - Total: 1'>                continue;
</span><span class='uc' id='L501' title='2|2|2 - Total: 2'>            if (Modifier.isFinal(mods)) {
</span>                // Make sure we don't add a final method to the list
                // of overridable methods.
<span class='uc' id='L504' title='4|4|4 - Total: 4'>                skip.add(methodKey);
</span><span class='uc' id='L505' title='1|1|1 - Total: 1'>                continue;
</span>            }
<span class='uc' id='L507' title='4|4|4 - Total: 4'>            if (Modifier.isPublic(mods) || Modifier.isProtected(mods)) {
</span><span class='uc' id='L508' title='6|6|6 - Total: 6'>                list.add(methods[i]);
</span><span class='uc' id='L509' title='4|4|4 - Total: 4'>                skip.add(methodKey);
</span>            }
        }
<span class='uc' id='L512' title='1|1|1 - Total: 1'>    }
</span>
    static Class<?> loadAdapterClass(String className, byte[] classBytes)
    {
        Object staticDomain;
<span class='uc' id='L517' title='2|2|2 - Total: 2'>        Class<?> domainClass = SecurityController.getStaticSecurityDomainClass();
</span><span class='upc' id='L518' title='2|2|2 - Total: 4'>        if(domainClass == CodeSource.class || domainClass == ProtectionDomain.class) {
</span>            // use the calling script's security domain if available
<span class='nc' id='L520' title='0|0|0 - Total: 2'>            ProtectionDomain protectionDomain = SecurityUtilities.getScriptProtectionDomain();
</span><span class='nc' id='L521' title='0|0|0 - Total: 2'>            if (protectionDomain == null) {
</span><span class='nc' id='L522' title='0|0|0 - Total: 3'>                protectionDomain = JavaAdapter.class.getProtectionDomain();
</span>            }
<span class='nc' id='L524' title='0|0|0 - Total: 2'>            if(domainClass == CodeSource.class) {
</span><span class='nc' id='L525' title='0|0|0 - Total: 2'>                staticDomain = protectionDomain == null ? null : protectionDomain.getCodeSource();
</span>            }
            else {
<span class='nc' id='L528' title='0|0|0 - Total: 2'>                staticDomain = protectionDomain;
</span>            }
<span class='nc' id='L530' title='0|0|0 - Total: 1'>        }
</span>        else {
<span class='uc' id='L532' title='2|2|2 - Total: 2'>            staticDomain = null;
</span>        }
<span class='uc' id='L534' title='4|4|4 - Total: 4'>        GeneratedClassLoader loader = SecurityController.createLoader(null,
</span>                staticDomain);
<span class='uc' id='L536' title='5|5|5 - Total: 5'>        Class<?> result = loader.defineClass(className, classBytes);
</span><span class='uc' id='L537' title='3|3|3 - Total: 3'>        loader.linkClass(result);
</span><span class='uc' id='L538' title='2|2|2 - Total: 2'>        return result;
</span>    }

    public static Function getFunction(Scriptable obj, String functionName)
    {
<span class='uc' id='L543' title='4|4|4 - Total: 4'>        Object x = ScriptableObject.getProperty(obj, functionName);
</span><span class='uc' id='L544' title='2|2|2 - Total: 2'>        if (x == Scriptable.NOT_FOUND) {
</span>            // This method used to swallow the exception from calling
            // an undefined method. People have come to depend on this
            // somewhat dubious behavior. It allows people to avoid
            // implementing listener methods that they don't care about,
            // for instance.
<span class='uc' id='L550' title='2|2|2 - Total: 2'>            return null;
</span>        }
<span class='upc' id='L552' title='1|1|1 - Total: 2'>        if (!(x instanceof Function))
</span><span class='nc' id='L553' title='0|0|0 - Total: 4'>            throw ScriptRuntime.notFunctionError(x, functionName);
</span>
<span class='uc' id='L555' title='3|3|3 - Total: 3'>        return (Function)x;
</span>    }

    /**
     * Utility method which dynamically binds a Context to the current thread,
     * if none already exists.
     */
    public static Object callMethod(ContextFactory factory,
                                    final Scriptable thisObj,
                                    final Function f, final Object[] args,
                                    final long argsToWrap)
    {
<span class='uc' id='L567' title='2|2|2 - Total: 2'>        if (f == null) {
</span>            // See comments in getFunction
<span class='uc' id='L569' title='2|2|2 - Total: 2'>            return null;
</span>        }
<span class='upc' id='L571' title='1|1|1 - Total: 2'>        if (factory == null) {
</span><span class='nc' id='L572' title='0|0|0 - Total: 2'>            factory = ContextFactory.getGlobal();
</span>        }

<span class='uc' id='L575' title='3|3|3 - Total: 3'>        final Scriptable scope = f.getParentScope();
</span><span class='uc' id='L576' title='2|2|2 - Total: 2'>        if (argsToWrap == 0) {
</span><span class='uc' id='L577' title='7|7|7 - Total: 7'>            return Context.call(factory, f, scope, thisObj, args);
</span>        }

<span class='uc' id='L580' title='2|2|2 - Total: 2'>        Context cx = Context.getCurrentContext();
</span><span class='upc' id='L581' title='1|1|1 - Total: 2'>        if (cx != null) {
</span><span class='uc' id='L582' title='8|8|8 - Total: 8'>            return doCall(cx, scope, thisObj, f, args, argsToWrap);
</span>        } else {
<span class='nc' id='L584' title='0|0|0 - Total: 11'>            return factory.call(new ContextAction() {
</span>                public Object run(Context cx)
                {
                    return doCall(cx, scope, thisObj, f, args, argsToWrap);
                }
            });
        }
    }

    private static Object doCall(Context cx, Scriptable scope,
                                 Scriptable thisObj, Function f,
                                 Object[] args, long argsToWrap)
    {
        // Wrap the rest of objects
<span class='uc' id='L598' title='2|2|2 - Total: 2'>        for (int i = 0; i != args.length; ++i) {
</span><span class='upc' id='L599' title='1|1|1 - Total: 2'>            if (0 != (argsToWrap & (1 << i))) {
</span><span class='uc' id='L600' title='4|4|4 - Total: 4'>                Object arg = args[i];
</span><span class='upc' id='L601' title='1|1|1 - Total: 2'>                if (!(arg instanceof Scriptable)) {
</span><span class='uc' id='L602' title='10|10|10 - Total: 10'>                    args[i] = cx.getWrapFactory().wrap(cx, scope, arg,
</span>                                                       null);
                }
            }
        }
<span class='uc' id='L607' title='7|7|7 - Total: 7'>        return f.call(cx, scope, thisObj, args);
</span>    }

    public static Scriptable runScript(final Script script)
    {
<span class='nc' id='L612' title='0|0|0 - Total: 8'>        return (Scriptable)ContextFactory.getGlobal().call(
</span>            new ContextAction() {
                public Object run(Context cx)
                {
                    ScriptableObject global = ScriptRuntime.getGlobal(cx);
                    script.exec(cx, global);
                    return global;
                }
            });
    }

    private static void generateCtor(ClassFileWriter cfw, String adapterName,
                                     String superName, Constructor<?> superCtor)
    {
<span class='uc' id='L626' title='2|2|2 - Total: 2'>        short locals = 3; // this + factory + delegee
</span><span class='uc' id='L627' title='3|3|3 - Total: 3'>        Class<?>[] parameters = superCtor.getParameterTypes();
</span>
        // Note that we swapped arguments in app-facing constructors to avoid
        // conflicting signatures with serial constructor defined below.
<span class='uc' id='L631' title='2|2|2 - Total: 2'>        if (parameters.length == 0) {
</span><span class='uc' id='L632' title='5|5|5 - Total: 5'>            cfw.startMethod("<init>",
</span>                        "(Lorg/mozilla/javascript/Scriptable;"
                        +"Lorg/mozilla/javascript/ContextFactory;)V",
                        ClassFileWriter.ACC_PUBLIC);

            // Invoke base class constructor
<span class='uc' id='L638' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L639' title='7|7|7 - Total: 7'>            cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, "<init>", "()V");
</span>        } else {
<span class='uc' id='L641' title='5|5|5 - Total: 5'>            StringBuilder sig = new StringBuilder(
</span>                    "(Lorg/mozilla/javascript/Scriptable;"
                    +"Lorg/mozilla/javascript/ContextFactory;");
<span class='uc' id='L644' title='3|3|3 - Total: 3'>            int marker = sig.length(); // lets us reuse buffer for super signature
</span><span class='uc' id='L645' title='2|2|2 - Total: 2'>            for (Class<?> c : parameters) {
</span><span class='uc' id='L646' title='4|4|4 - Total: 4'>                appendTypeString(sig, c);
</span>            }
<span class='uc' id='L648' title='4|4|4 - Total: 4'>            sig.append(")V");
</span><span class='uc' id='L649' title='6|6|6 - Total: 6'>            cfw.startMethod("<init>", sig.toString(), ClassFileWriter.ACC_PUBLIC);
</span>
            // Invoke base class constructor
<span class='uc' id='L652' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L653' title='2|2|2 - Total: 2'>            short paramOffset = 3;
</span><span class='uc' id='L654' title='2|2|2 - Total: 2'>            for (Class<?> parameter : parameters) {
</span><span class='uc' id='L655' title='8|8|8 - Total: 8'>                paramOffset += generatePushParam(cfw, paramOffset, parameter);
</span>            }
<span class='uc' id='L657' title='2|2|2 - Total: 2'>            locals = paramOffset;
</span><span class='uc' id='L658' title='5|5|5 - Total: 5'>            sig.delete(1, marker);
</span><span class='uc' id='L659' title='7|7|7 - Total: 7'>            cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, "<init>", sig.toString());
</span>        }

        // Save parameter in instance variable "delegee"
<span class='uc' id='L663' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L664' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_1);  // first arg: Scriptable delegee
</span><span class='uc' id='L665' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "delegee",
</span>                "Lorg/mozilla/javascript/Scriptable;");

        // Save parameter in instance variable "factory"
<span class='uc' id='L669' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L670' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_2);  // second arg: ContextFactory instance
</span><span class='uc' id='L671' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "factory",
</span>                "Lorg/mozilla/javascript/ContextFactory;");

<span class='uc' id='L674' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this for the following PUTFIELD for self
</span>        // create a wrapper object to be used as "this" in method calls
<span class='uc' id='L676' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_1);  // the Scriptable delegee
</span><span class='uc' id='L677' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L678' title='6|6|6 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                      "org/mozilla/javascript/JavaAdapter",
                      "createAdapterWrapper",
                      "(Lorg/mozilla/javascript/Scriptable;"
                      +"Ljava/lang/Object;"
                      +")Lorg/mozilla/javascript/Scriptable;");
<span class='uc' id='L684' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "self",
</span>                "Lorg/mozilla/javascript/Scriptable;");

<span class='uc' id='L687' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.RETURN);
</span><span class='uc' id='L688' title='3|3|3 - Total: 3'>        cfw.stopMethod(locals);
</span><span class='uc' id='L689' title='1|1|1 - Total: 1'>    }
</span>
    private static void generateSerialCtor(ClassFileWriter cfw,
                                           String adapterName,
                                           String superName)
    {
<span class='uc' id='L695' title='5|5|5 - Total: 5'>        cfw.startMethod("<init>",
</span>                        "(Lorg/mozilla/javascript/ContextFactory;"
                        +"Lorg/mozilla/javascript/Scriptable;"
                        +"Lorg/mozilla/javascript/Scriptable;"
                        +")V",
                        ClassFileWriter.ACC_PUBLIC);

        // Invoke base class constructor
<span class='uc' id='L703' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L704' title='6|6|6 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, "<init>", "()V");
</span>
        // Save parameter in instance variable "factory"
<span class='uc' id='L707' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L708' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_1);  // first arg: ContextFactory instance
</span><span class='uc' id='L709' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "factory",
</span>                "Lorg/mozilla/javascript/ContextFactory;");

        // Save parameter in instance variable "delegee"
<span class='uc' id='L713' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L714' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_2);  // second arg: Scriptable delegee
</span><span class='uc' id='L715' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "delegee",
</span>                "Lorg/mozilla/javascript/Scriptable;");
        // save self
<span class='uc' id='L718' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='uc' id='L719' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_3);  // third arg: Scriptable self
</span><span class='uc' id='L720' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "self",
</span>                "Lorg/mozilla/javascript/Scriptable;");

<span class='uc' id='L723' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.RETURN);
</span><span class='uc' id='L724' title='3|3|3 - Total: 3'>        cfw.stopMethod((short)4); // 4: this + factory + delegee + self
</span><span class='uc' id='L725' title='1|1|1 - Total: 1'>    }
</span>
    private static void generateEmptyCtor(ClassFileWriter cfw,
                                          String adapterName,
                                          String superName,
                                          String scriptClassName)
    {
<span class='nc' id='L732' title='0|0|0 - Total: 5'>        cfw.startMethod("<init>", "()V", ClassFileWriter.ACC_PUBLIC);
</span>
        // Invoke base class constructor
<span class='nc' id='L735' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='nc' id='L736' title='0|0|0 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, "<init>", "()V");
</span>
        // Set factory to null to use current global when necessary
<span class='nc' id='L739' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);
</span><span class='nc' id='L740' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ACONST_NULL);
</span><span class='nc' id='L741' title='0|0|0 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "factory",
</span>                "Lorg/mozilla/javascript/ContextFactory;");

        // Load script class
<span class='nc' id='L745' title='0|0|0 - Total: 4'>        cfw.add(ByteCode.NEW, scriptClassName);
</span><span class='nc' id='L746' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.DUP);
</span><span class='nc' id='L747' title='0|0|0 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESPECIAL, scriptClassName, "<init>", "()V");
</span>
        // Run script and save resulting scope
<span class='nc' id='L750' title='0|0|0 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                      "org/mozilla/javascript/JavaAdapter",
                      "runScript",
                      "(Lorg/mozilla/javascript/Script;"
                      +")Lorg/mozilla/javascript/Scriptable;");
<span class='nc' id='L755' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ASTORE_1);
</span>
        // Save the Scriptable in instance variable "delegee"
<span class='nc' id='L758' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='nc' id='L759' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_1);  // the Scriptable
</span><span class='nc' id='L760' title='0|0|0 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "delegee",
</span>                "Lorg/mozilla/javascript/Scriptable;");

<span class='nc' id='L763' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this for the following PUTFIELD for self
</span>        // create a wrapper object to be used as "this" in method calls
<span class='nc' id='L765' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_1);  // the Scriptable
</span><span class='nc' id='L766' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);  // this
</span><span class='nc' id='L767' title='0|0|0 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                      "org/mozilla/javascript/JavaAdapter",
                      "createAdapterWrapper",
                      "(Lorg/mozilla/javascript/Scriptable;"
                      +"Ljava/lang/Object;"
                      +")Lorg/mozilla/javascript/Scriptable;");
<span class='nc' id='L773' title='0|0|0 - Total: 6'>        cfw.add(ByteCode.PUTFIELD, adapterName, "self",
</span>                "Lorg/mozilla/javascript/Scriptable;");

<span class='nc' id='L776' title='0|0|0 - Total: 3'>        cfw.add(ByteCode.RETURN);
</span><span class='nc' id='L777' title='0|0|0 - Total: 3'>        cfw.stopMethod((short)2); // this + delegee
</span><span class='nc' id='L778' title='0|0|0 - Total: 1'>    }
</span>
    /**
     * Generates code to wrap Java arguments into Object[].
     * Non-primitive Java types are left as-is pending conversion
     * in the helper method. Leaves the array object on the top of the stack.
     */
    static void generatePushWrappedArgs(ClassFileWriter cfw,
                                        Class<?>[] argTypes,
                                        int arrayLength)
    {
        // push arguments
<span class='uc' id='L790' title='3|3|3 - Total: 3'>        cfw.addPush(arrayLength);
</span><span class='uc' id='L791' title='4|4|4 - Total: 4'>        cfw.add(ByteCode.ANEWARRAY, "java/lang/Object");
</span><span class='uc' id='L792' title='2|2|2 - Total: 2'>        int paramOffset = 1;
</span><span class='uc' id='L793' title='2|2|2 - Total: 2'>        for (int i = 0; i != argTypes.length; ++i) {
</span><span class='uc' id='L794' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.DUP); // duplicate array reference
</span><span class='uc' id='L795' title='3|3|3 - Total: 3'>            cfw.addPush(i);
</span><span class='uc' id='L796' title='9|9|9 - Total: 9'>            paramOffset += generateWrapArg(cfw, paramOffset, argTypes[i]);
</span><span class='uc' id='L797' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.AASTORE);
</span>        }
<span class='uc' id='L799' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Generates code to wrap Java argument into Object.
     * Non-primitive Java types are left unconverted pending conversion
     * in the helper method. Leaves the wrapper object on the top of the stack.
     */
    private static int generateWrapArg(ClassFileWriter cfw, int paramOffset,
                                       Class<?> argType)
    {
<span class='uc' id='L809' title='2|2|2 - Total: 2'>        int size = 1;
</span><span class='uc' id='L810' title='2|2|2 - Total: 2'>        if (!argType.isPrimitive()) {
</span><span class='uc' id='L811' title='5|5|5 - Total: 5'>            cfw.add(ByteCode.ALOAD, paramOffset);
</span>
<span class='upc' id='L813' title='1|1|1 - Total: 2'>        } else if (argType == Boolean.TYPE) {
</span>            // wrap boolean values with java.lang.Boolean.
<span class='nc' id='L815' title='0|0|0 - Total: 4'>            cfw.add(ByteCode.NEW, "java/lang/Boolean");
</span><span class='nc' id='L816' title='0|0|0 - Total: 3'>            cfw.add(ByteCode.DUP);
</span><span class='nc' id='L817' title='0|0|0 - Total: 4'>            cfw.add(ByteCode.ILOAD, paramOffset);
</span><span class='nc' id='L818' title='0|0|0 - Total: 7'>            cfw.addInvoke(ByteCode.INVOKESPECIAL, "java/lang/Boolean",
</span>                          "<init>", "(Z)V");

<span class='uc' id='L821' title='2|2|2 - Total: 2'>        } else if (argType == Character.TYPE) {
</span>            // Create a string of length 1 using the character parameter.
<span class='uc' id='L823' title='4|4|4 - Total: 4'>            cfw.add(ByteCode.ILOAD, paramOffset);
</span><span class='uc' id='L824' title='7|7|7 - Total: 7'>            cfw.addInvoke(ByteCode.INVOKESTATIC, "java/lang/String",
</span>                          "valueOf", "(C)Ljava/lang/String;");

        } else {
            // convert all numeric values to java.lang.Double.
<span class='uc' id='L829' title='4|4|4 - Total: 4'>            cfw.add(ByteCode.NEW, "java/lang/Double");
</span><span class='uc' id='L830' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.DUP);
</span><span class='uc' id='L831' title='3|3|3 - Total: 3'>            String typeName = argType.getName();
</span><span class='upc' id='L832' title='1|1|1 - Total: 5'>            switch (typeName.charAt(0)) {
</span>            case 'b':
            case 's':
            case 'i':
                // load an int value, convert to double.
<span class='uc' id='L837' title='4|4|4 - Total: 4'>                cfw.add(ByteCode.ILOAD, paramOffset);
</span><span class='uc' id='L838' title='3|3|3 - Total: 3'>                cfw.add(ByteCode.I2D);
</span><span class='uc' id='L839' title='1|1|1 - Total: 1'>                break;
</span>            case 'l':
                // load a long, convert to double.
<span class='nc' id='L842' title='0|0|0 - Total: 4'>                cfw.add(ByteCode.LLOAD, paramOffset);
</span><span class='nc' id='L843' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.L2D);
</span><span class='nc' id='L844' title='0|0|0 - Total: 2'>                size = 2;
</span><span class='nc' id='L845' title='0|0|0 - Total: 1'>                break;
</span>            case 'f':
                // load a float, convert to double.
<span class='nc' id='L848' title='0|0|0 - Total: 4'>                cfw.add(ByteCode.FLOAD, paramOffset);
</span><span class='nc' id='L849' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.F2D);
</span><span class='nc' id='L850' title='0|0|0 - Total: 1'>                break;
</span>            case 'd':
<span class='nc' id='L852' title='0|0|0 - Total: 4'>                cfw.add(ByteCode.DLOAD, paramOffset);
</span><span class='nc' id='L853' title='0|0|0 - Total: 2'>                size = 2;
</span>                break;
            }
<span class='uc' id='L856' title='6|6|6 - Total: 6'>            cfw.addInvoke(ByteCode.INVOKESPECIAL, "java/lang/Double",
</span>                          "<init>", "(D)V");
        }
<span class='uc' id='L859' title='2|2|2 - Total: 2'>        return size;
</span>    }

    /**
     * Generates code to convert a wrapped value type to a primitive type.
     * Handles unwrapping java.lang.Boolean, and java.lang.Number types.
     * Generates the appropriate RETURN bytecode.
     */
    static void generateReturnResult(ClassFileWriter cfw, Class<?> retType,
                                     boolean callConvertResult)
    {
        // wrap boolean values with java.lang.Boolean, convert all other
        // primitive values to java.lang.Double.
<span class='uc' id='L872' title='2|2|2 - Total: 2'>        if (retType == Void.TYPE) {
</span><span class='uc' id='L873' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.POP);
</span><span class='uc' id='L874' title='4|4|4 - Total: 4'>            cfw.add(ByteCode.RETURN);
</span>
<span class='uc' id='L876' title='2|2|2 - Total: 2'>        } else if (retType == Boolean.TYPE) {
</span><span class='uc' id='L877' title='6|6|6 - Total: 6'>            cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                          "org/mozilla/javascript/Context",
                          "toBoolean", "(Ljava/lang/Object;)Z");
<span class='uc' id='L880' title='4|4|4 - Total: 4'>            cfw.add(ByteCode.IRETURN);
</span>
<span class='upc' id='L882' title='1|1|1 - Total: 2'>        } else if (retType == Character.TYPE) {
</span>            // characters are represented as strings in JavaScript.
            // return the first character.
            // first convert the value to a string if possible.
<span class='nc' id='L886' title='0|0|0 - Total: 6'>            cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                          "org/mozilla/javascript/Context",
                          "toString",
                          "(Ljava/lang/Object;)Ljava/lang/String;");
<span class='nc' id='L890' title='0|0|0 - Total: 3'>            cfw.add(ByteCode.ICONST_0);
</span><span class='nc' id='L891' title='0|0|0 - Total: 6'>            cfw.addInvoke(ByteCode.INVOKEVIRTUAL, "java/lang/String",
</span>                          "charAt", "(I)C");
<span class='nc' id='L893' title='0|0|0 - Total: 4'>            cfw.add(ByteCode.IRETURN);
</span>
<span class='uc' id='L895' title='2|2|2 - Total: 2'>        } else if (retType.isPrimitive()) {
</span><span class='uc' id='L896' title='6|6|6 - Total: 6'>            cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                          "org/mozilla/javascript/Context",
                          "toNumber", "(Ljava/lang/Object;)D");
<span class='uc' id='L899' title='3|3|3 - Total: 3'>            String typeName = retType.getName();
</span><span class='upc' id='L900' title='1|1|1 - Total: 5'>            switch (typeName.charAt(0)) {
</span>            case 'b':
            case 's':
            case 'i':
<span class='uc' id='L904' title='3|3|3 - Total: 3'>                cfw.add(ByteCode.D2I);
</span><span class='uc' id='L905' title='3|3|3 - Total: 3'>                cfw.add(ByteCode.IRETURN);
</span><span class='uc' id='L906' title='1|1|1 - Total: 1'>                break;
</span>            case 'l':
<span class='nc' id='L908' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.D2L);
</span><span class='nc' id='L909' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.LRETURN);
</span><span class='nc' id='L910' title='0|0|0 - Total: 1'>                break;
</span>            case 'f':
<span class='nc' id='L912' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.D2F);
</span><span class='nc' id='L913' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.FRETURN);
</span><span class='nc' id='L914' title='0|0|0 - Total: 1'>                break;
</span>            case 'd':
<span class='nc' id='L916' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.DRETURN);
</span><span class='nc' id='L917' title='0|0|0 - Total: 1'>                break;
</span>            default:
<span class='nc' id='L919' title='0|0|0 - Total: 8'>                throw new RuntimeException("Unexpected return type " +
</span><span class='nc' id='L920' title='0|0|0 - Total: 5'>                                           retType.toString());
</span>            }

<span class='uc' id='L923' title='1|1|1 - Total: 1'>        } else {
</span><span class='uc' id='L924' title='3|3|3 - Total: 3'>            String retTypeStr = retType.getName();
</span><span class='uc' id='L925' title='2|2|2 - Total: 2'>            if (callConvertResult) {
</span><span class='uc' id='L926' title='3|3|3 - Total: 3'>                cfw.addLoadConstant(retTypeStr);
</span><span class='uc' id='L927' title='6|6|6 - Total: 6'>                cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                              "java/lang/Class",
                              "forName",
                              "(Ljava/lang/String;)Ljava/lang/Class;");

<span class='uc' id='L932' title='6|6|6 - Total: 6'>                cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                              "org/mozilla/javascript/JavaAdapter",
                              "convertResult",
                              "(Ljava/lang/Object;"
                              +"Ljava/lang/Class;"
                              +")Ljava/lang/Object;");
            }
            // Now cast to return type
<span class='uc' id='L940' title='4|4|4 - Total: 4'>            cfw.add(ByteCode.CHECKCAST, retTypeStr);
</span><span class='uc' id='L941' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.ARETURN);
</span>        }
<span class='uc' id='L943' title='1|1|1 - Total: 1'>    }
</span>
    private static void generateMethod(ClassFileWriter cfw, String genName,
                                       String methodName, Class<?>[] parms,
                                       Class<?> returnType, boolean convertResult)
    {
<span class='uc' id='L949' title='4|4|4 - Total: 4'>        StringBuilder sb = new StringBuilder();
</span><span class='uc' id='L950' title='5|5|5 - Total: 5'>        int paramsEnd = appendMethodSignature(parms, returnType, sb);
</span><span class='uc' id='L951' title='3|3|3 - Total: 3'>        String methodSignature = sb.toString();
</span><span class='uc' id='L952' title='5|5|5 - Total: 5'>        cfw.startMethod(methodName, methodSignature,
</span>                        ClassFileWriter.ACC_PUBLIC);

        // Prepare stack to call method

        // push factory
<span class='uc' id='L958' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);
</span><span class='uc' id='L959' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.GETFIELD, genName, "factory",
</span>                "Lorg/mozilla/javascript/ContextFactory;");

        // push self
<span class='uc' id='L963' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);
</span><span class='uc' id='L964' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.GETFIELD, genName, "self",
</span>                "Lorg/mozilla/javascript/Scriptable;");

        // push function
<span class='uc' id='L968' title='3|3|3 - Total: 3'>        cfw.add(ByteCode.ALOAD_0);
</span><span class='uc' id='L969' title='6|6|6 - Total: 6'>        cfw.add(ByteCode.GETFIELD, genName, "delegee",
</span>                "Lorg/mozilla/javascript/Scriptable;");
<span class='uc' id='L971' title='3|3|3 - Total: 3'>        cfw.addPush(methodName);
</span><span class='uc' id='L972' title='6|6|6 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                      "org/mozilla/javascript/JavaAdapter",
                      "getFunction",
                      "(Lorg/mozilla/javascript/Scriptable;"
                      +"Ljava/lang/String;"
                      +")Lorg/mozilla/javascript/Function;");

        // push arguments
<span class='uc' id='L980' title='5|5|5 - Total: 5'>        generatePushWrappedArgs(cfw, parms, parms.length);
</span>
        // push bits to indicate which parameters should be wrapped
<span class='upc' id='L983' title='1|1|1 - Total: 2'>        if (parms.length > 64) {
</span>            // If it will be an issue, then passing a static boolean array
            // can be an option, but for now using simple bitmask
<span class='nc' id='L986' title='0|0|0 - Total: 3'>            throw Context.reportRuntimeError0(
</span>                "JavaAdapter can not subclass methods with more then"
                +" 64 arguments.");
        }
<span class='uc' id='L990' title='2|2|2 - Total: 2'>        long convertionMask = 0;
</span><span class='uc' id='L991' title='2|2|2 - Total: 2'>        for (int i = 0; i != parms.length; ++i) {
</span><span class='uc' id='L992' title='2|2|2 - Total: 2'>            if (!parms[i].isPrimitive()) {
</span><span class='uc' id='L993' title='7|7|7 - Total: 7'>                convertionMask |= (1 << i);
</span>            }
        }
<span class='uc' id='L996' title='3|3|3 - Total: 3'>        cfw.addPush(convertionMask);
</span>
        // go through utility method, which creates a Context to run the
        // method in.
<span class='uc' id='L1000' title='6|6|6 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESTATIC,
</span>                      "org/mozilla/javascript/JavaAdapter",
                      "callMethod",
                      "(Lorg/mozilla/javascript/ContextFactory;"
                      +"Lorg/mozilla/javascript/Scriptable;"
                      +"Lorg/mozilla/javascript/Function;"
                      +"[Ljava/lang/Object;"
                      +"J"
                      +")Ljava/lang/Object;");

<span class='uc' id='L1010' title='4|4|4 - Total: 4'>        generateReturnResult(cfw, returnType, convertResult);
</span>
<span class='uc' id='L1012' title='4|4|4 - Total: 4'>        cfw.stopMethod((short)paramsEnd);
</span><span class='uc' id='L1013' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Generates code to push typed parameters onto the operand stack
     * prior to a direct Java method call.
     */
    private static int generatePushParam(ClassFileWriter cfw, int paramOffset,
                                         Class<?> paramType)
    {
<span class='uc' id='L1022' title='2|2|2 - Total: 2'>        if (!paramType.isPrimitive()) {
</span><span class='uc' id='L1023' title='3|3|3 - Total: 3'>            cfw.addALoad(paramOffset);
</span><span class='uc' id='L1024' title='2|2|2 - Total: 2'>            return 1;
</span>        }
<span class='uc' id='L1026' title='3|3|3 - Total: 3'>        String typeName = paramType.getName();
</span><span class='upc' id='L1027' title='2|2|2 - Total: 5'>        switch (typeName.charAt(0)) {
</span>        case 'z':
        case 'b':
        case 'c':
        case 's':
        case 'i':
            // load an int value, convert to double.
<span class='uc' id='L1034' title='3|3|3 - Total: 3'>            cfw.addILoad(paramOffset);
</span><span class='uc' id='L1035' title='2|2|2 - Total: 2'>            return 1;
</span>        case 'l':
            // load a long, convert to double.
<span class='nc' id='L1038' title='0|0|0 - Total: 3'>            cfw.addLLoad(paramOffset);
</span><span class='nc' id='L1039' title='0|0|0 - Total: 2'>            return 2;
</span>        case 'f':
            // load a float, convert to double.
<span class='uc' id='L1042' title='3|3|3 - Total: 3'>            cfw.addFLoad(paramOffset);
</span><span class='uc' id='L1043' title='2|2|2 - Total: 2'>            return 1;
</span>        case 'd':
<span class='nc' id='L1045' title='0|0|0 - Total: 3'>            cfw.addDLoad(paramOffset);
</span><span class='nc' id='L1046' title='0|0|0 - Total: 2'>            return 2;
</span>        }
<span class='nc' id='L1048' title='0|0|0 - Total: 2'>        throw Kit.codeBug();
</span>    }

    /**
     * Generates code to return a Java type, after calling a Java method
     * that returns the same type.
     * Generates the appropriate RETURN bytecode.
     */
    private static void generatePopResult(ClassFileWriter cfw,
                                          Class<?> retType)
    {
<span class='upc' id='L1059' title='1|1|1 - Total: 2'>        if (retType.isPrimitive()) {
</span><span class='nc' id='L1060' title='0|0|0 - Total: 3'>            String typeName = retType.getName();
</span><span class='nc' id='L1061' title='0|0|0 - Total: 5'>            switch (typeName.charAt(0)) {
</span>            case 'b':
            case 'c':
            case 's':
            case 'i':
            case 'z':
<span class='nc' id='L1067' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.IRETURN);
</span><span class='nc' id='L1068' title='0|0|0 - Total: 1'>                break;
</span>            case 'l':
<span class='nc' id='L1070' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.LRETURN);
</span><span class='nc' id='L1071' title='0|0|0 - Total: 1'>                break;
</span>            case 'f':
<span class='nc' id='L1073' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.FRETURN);
</span><span class='nc' id='L1074' title='0|0|0 - Total: 1'>                break;
</span>            case 'd':
<span class='nc' id='L1076' title='0|0|0 - Total: 3'>                cfw.add(ByteCode.DRETURN);
</span>                break;
            }
<span class='nc' id='L1079' title='0|0|0 - Total: 1'>        } else {
</span><span class='uc' id='L1080' title='3|3|3 - Total: 3'>            cfw.add(ByteCode.ARETURN);
</span>        }
<span class='uc' id='L1082' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Generates a method called "super$methodName()" which can be called
     * from JavaScript that is equivalent to calling "super.methodName()"
     * from Java. Eventually, this may be supported directly in JavaScript.
     */
    private static void generateSuper(ClassFileWriter cfw,
                                      String genName, String superName,
                                      String methodName, String methodSignature,
                                      Class<?>[] parms, Class<?> returnType)
    {
<span class='uc' id='L1094' title='12|12|12 - Total: 12'>        cfw.startMethod("super$" + methodName, methodSignature,
</span>                        ClassFileWriter.ACC_PUBLIC);

        // push "this"
<span class='uc' id='L1098' title='4|4|4 - Total: 4'>        cfw.add(ByteCode.ALOAD, 0);
</span>
        // push the rest of the parameters.
<span class='uc' id='L1101' title='2|2|2 - Total: 2'>        int paramOffset = 1;
</span><span class='uc' id='L1102' title='2|2|2 - Total: 2'>        for (Class<?> parm : parms) {
</span><span class='uc' id='L1103' title='7|7|7 - Total: 7'>            paramOffset += generatePushParam(cfw, paramOffset, parm);
</span>        }

        // call the superclass implementation of the method.
<span class='uc' id='L1107' title='6|6|6 - Total: 6'>        cfw.addInvoke(ByteCode.INVOKESPECIAL,
</span>                      superName,
                      methodName,
                      methodSignature);

        // now, handle the return type appropriately.
<span class='uc' id='L1113' title='2|2|2 - Total: 2'>        Class<?> retType = returnType;
</span><span class='upc' id='L1114' title='1|1|1 - Total: 2'>        if (!retType.equals(Void.TYPE)) {
</span><span class='uc' id='L1115' title='4|4|4 - Total: 4'>            generatePopResult(cfw, retType);
</span>        } else {
<span class='nc' id='L1117' title='0|0|0 - Total: 3'>            cfw.add(ByteCode.RETURN);
</span>        }
<span class='uc' id='L1119' title='6|6|6 - Total: 6'>        cfw.stopMethod((short)(paramOffset + 1));
</span><span class='uc' id='L1120' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Returns a fully qualified method name concatenated with its signature.
     */
    private static String getMethodSignature(Method method, Class<?>[] argTypes)
    {
<span class='uc' id='L1127' title='4|4|4 - Total: 4'>        StringBuilder sb = new StringBuilder();
</span><span class='uc' id='L1128' title='6|6|6 - Total: 6'>        appendMethodSignature(argTypes, method.getReturnType(), sb);
</span><span class='uc' id='L1129' title='3|3|3 - Total: 3'>        return sb.toString();
</span>    }

    static int appendMethodSignature(Class<?>[] argTypes,
                                     Class<?> returnType,
                                     StringBuilder sb)
    {
<span class='uc' id='L1136' title='4|4|4 - Total: 4'>        sb.append('(');
</span><span class='uc' id='L1137' title='5|5|5 - Total: 5'>        int firstLocal = 1 + argTypes.length; // includes this.
</span><span class='uc' id='L1138' title='2|2|2 - Total: 2'>        for (Class<?> type : argTypes) {
</span><span class='uc' id='L1139' title='4|4|4 - Total: 4'>            appendTypeString(sb, type);
</span><span class='upc' id='L1140' title='3|3|3 - Total: 4'>            if (type == Long.TYPE || type == Double.TYPE) {
</span>                // adjust for double slot
<span class='uc' id='L1142' title='1|1|1 - Total: 1'>                ++firstLocal;
</span>            }
        }
<span class='uc' id='L1145' title='4|4|4 - Total: 4'>        sb.append(')');
</span><span class='uc' id='L1146' title='4|4|4 - Total: 4'>        appendTypeString(sb, returnType);
</span><span class='uc' id='L1147' title='2|2|2 - Total: 2'>        return firstLocal;
</span>    }

    private static StringBuilder appendTypeString(StringBuilder sb, Class<?> type)
    {
<span class='uc' id='L1152' title='2|2|2 - Total: 2'>        while (type.isArray()) {
</span><span class='uc' id='L1153' title='4|4|4 - Total: 4'>            sb.append('[');
</span><span class='uc' id='L1154' title='4|4|4 - Total: 4'>            type = type.getComponentType();
</span>        }
<span class='uc' id='L1156' title='2|2|2 - Total: 2'>        if (type.isPrimitive()) {
</span>            char typeLetter;
<span class='uc' id='L1158' title='2|2|2 - Total: 2'>            if (type == Boolean.TYPE) {
</span><span class='uc' id='L1159' title='3|3|3 - Total: 3'>                typeLetter = 'Z';
</span><span class='uc' id='L1160' title='2|2|2 - Total: 2'>            } else if (type == Long.TYPE) {
</span><span class='uc' id='L1161' title='3|3|3 - Total: 3'>                typeLetter = 'J';
</span>            } else {
<span class='uc' id='L1163' title='3|3|3 - Total: 3'>                String typeName = type.getName();
</span><span class='uc' id='L1164' title='5|5|5 - Total: 5'>                typeLetter = Character.toUpperCase(typeName.charAt(0));
</span>            }
<span class='uc' id='L1166' title='4|4|4 - Total: 4'>            sb.append(typeLetter);
</span><span class='uc' id='L1167' title='1|1|1 - Total: 1'>        } else {
</span><span class='uc' id='L1168' title='4|4|4 - Total: 4'>            sb.append('L');
</span><span class='uc' id='L1169' title='8|8|8 - Total: 8'>            sb.append(type.getName().replace('.', '/'));
</span><span class='uc' id='L1170' title='4|4|4 - Total: 4'>            sb.append(';');
</span>        }
<span class='uc' id='L1172' title='2|2|2 - Total: 2'>        return sb;
</span>    }

    static int[] getArgsToConvert(Class<?>[] argTypes)
    {
<span class='nc' id='L1177' title='0|0|0 - Total: 2'>        int count = 0;
</span><span class='nc' id='L1178' title='0|0|0 - Total: 2'>        for (int i = 0; i != argTypes.length; ++i) {
</span><span class='nc' id='L1179' title='0|0|0 - Total: 2'>            if (!argTypes[i].isPrimitive())
</span><span class='nc' id='L1180' title='0|0|0 - Total: 1'>                ++count;
</span>        }
<span class='nc' id='L1182' title='0|0|0 - Total: 2'>        if (count == 0)
</span><span class='nc' id='L1183' title='0|0|0 - Total: 2'>            return null;
</span><span class='nc' id='L1184' title='0|0|0 - Total: 3'>        int[] array = new int[count];
</span><span class='nc' id='L1185' title='0|0|0 - Total: 2'>        count = 0;
</span><span class='nc' id='L1186' title='0|0|0 - Total: 2'>        for (int i = 0; i != argTypes.length; ++i) {
</span><span class='nc' id='L1187' title='0|0|0 - Total: 2'>            if (!argTypes[i].isPrimitive())
</span><span class='nc' id='L1188' title='0|0|0 - Total: 5'>                array[count++] = i;
</span>        }
<span class='nc' id='L1190' title='0|0|0 - Total: 2'>        return array;
</span>    }

<span class='uc' id='L1193' title='3|3|3 - Total: 3'>    private static final Object FTAG = "JavaAdapter";
</span>    private static final int Id_JavaAdapter = 1;
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>