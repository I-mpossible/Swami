<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.Parser.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.Parser.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import org.mozilla.javascript.ast.ArrayComprehension;
import org.mozilla.javascript.ast.ArrayComprehensionLoop;
import org.mozilla.javascript.ast.ArrayLiteral;
import org.mozilla.javascript.ast.Assignment;
import org.mozilla.javascript.ast.AstNode;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.Block;
import org.mozilla.javascript.ast.BreakStatement;
import org.mozilla.javascript.ast.CatchClause;
import org.mozilla.javascript.ast.Comment;
import org.mozilla.javascript.ast.ConditionalExpression;
import org.mozilla.javascript.ast.ContinueStatement;
import org.mozilla.javascript.ast.DestructuringForm;
import org.mozilla.javascript.ast.DoLoop;
import org.mozilla.javascript.ast.ElementGet;
import org.mozilla.javascript.ast.EmptyExpression;
import org.mozilla.javascript.ast.EmptyStatement;
import org.mozilla.javascript.ast.ErrorNode;
import org.mozilla.javascript.ast.ExpressionStatement;
import org.mozilla.javascript.ast.ForInLoop;
import org.mozilla.javascript.ast.ForLoop;
import org.mozilla.javascript.ast.FunctionCall;
import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.ast.GeneratorExpression;
import org.mozilla.javascript.ast.GeneratorExpressionLoop;
import org.mozilla.javascript.ast.IdeErrorReporter;
import org.mozilla.javascript.ast.IfStatement;
import org.mozilla.javascript.ast.InfixExpression;
import org.mozilla.javascript.ast.Jump;
import org.mozilla.javascript.ast.KeywordLiteral;
import org.mozilla.javascript.ast.Label;
import org.mozilla.javascript.ast.LabeledStatement;
import org.mozilla.javascript.ast.LetNode;
import org.mozilla.javascript.ast.Loop;
import org.mozilla.javascript.ast.Name;
import org.mozilla.javascript.ast.NewExpression;
import org.mozilla.javascript.ast.NumberLiteral;
import org.mozilla.javascript.ast.ObjectLiteral;
import org.mozilla.javascript.ast.ObjectProperty;
import org.mozilla.javascript.ast.ParenthesizedExpression;
import org.mozilla.javascript.ast.PropertyGet;
import org.mozilla.javascript.ast.RegExpLiteral;
import org.mozilla.javascript.ast.ReturnStatement;
import org.mozilla.javascript.ast.Scope;
import org.mozilla.javascript.ast.ScriptNode;
import org.mozilla.javascript.ast.StringLiteral;
import org.mozilla.javascript.ast.SwitchCase;
import org.mozilla.javascript.ast.SwitchStatement;
import org.mozilla.javascript.ast.Symbol;
import org.mozilla.javascript.ast.ThrowStatement;
import org.mozilla.javascript.ast.TryStatement;
import org.mozilla.javascript.ast.UnaryExpression;
import org.mozilla.javascript.ast.VariableDeclaration;
import org.mozilla.javascript.ast.VariableInitializer;
import org.mozilla.javascript.ast.WhileLoop;
import org.mozilla.javascript.ast.WithStatement;
import org.mozilla.javascript.ast.XmlDotQuery;
import org.mozilla.javascript.ast.XmlElemRef;
import org.mozilla.javascript.ast.XmlExpression;
import org.mozilla.javascript.ast.XmlLiteral;
import org.mozilla.javascript.ast.XmlMemberGet;
import org.mozilla.javascript.ast.XmlPropRef;
import org.mozilla.javascript.ast.XmlRef;
import org.mozilla.javascript.ast.XmlString;
import org.mozilla.javascript.ast.Yield;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

/**
 * This class implements the JavaScript parser.<p>
 *
 * It is based on the SpiderMonkey C source files jsparse.c and jsparse.h in the
 * jsref package.<p>
 *
 * The parser generates an {@link AstRoot} parse tree representing the source
 * code.  No tree rewriting is permitted at this stage, so that the parse tree
 * is a faithful representation of the source for frontend processing tools and
 * IDEs.<p>
 *
 * This parser implementation is not intended to be reused after a parse
 * finishes, and will throw an IllegalStateException() if invoked again.<p>
 *
 * @see TokenStream
 *
 * @author Mike McCabe
 * @author Brendan Eich
 */
public class Parser
{
    /**
     * Maximum number of allowed function or constructor arguments,
     * to follow SpiderMonkey.
     */
    public static final int ARGC_LIMIT = 1 << 16;

    // TokenInformation flags : currentFlaggedToken stores them together
    // with token type
    final static int
        CLEAR_TI_MASK    = 0xFFFF,  // mask to clear token information bits
        TI_AFTER_EOL     = 1 << 16, // first token of the source line
        TI_CHECK_LABEL   = 1 << 17; // indicates to check for label

    CompilerEnvirons compilerEnv;
    private ErrorReporter errorReporter;
    private IdeErrorReporter errorCollector;
    private String sourceURI;
    private char[] sourceChars;

    boolean calledByCompileFunction;  // ugly - set directly by Context
    private boolean parseFinished;  // set when finished to prevent reuse

    private TokenStream ts;
<span class='bc' id='L130' title='0|3|3 - Total: 3'>    private int currentFlaggedToken = Token.EOF;
</span>    private int currentToken;
    private int syntaxErrorCount;

    private List<Comment> scannedComments;
    private Comment currentJsDocComment;

    protected int nestingOfFunction;
    private LabeledStatement currentLabel;
    private boolean inDestructuringAssignment;
    protected boolean inUseStrictDirective;

    // The following are per function variables and should be saved/restored
    // during function parsing.  See PerFunctionVariables class below.
    ScriptNode currentScriptOrFn;
    Scope currentScope;
    private int endFlags;
    private boolean inForInit;  // bound temporarily during forStatement()
    private Map<String,LabeledStatement> labelSet;
    private List<Loop> loopSet;
    private List<Jump> loopAndSwitchSet;
    // end of per function variables

    // Lacking 2-token lookahead, labels become a problem.
    // These vars store the token info of the last matched name,
    // iff it wasn't the last matched token.
    private int prevNameTokenStart;
<span class='bc' id='L157' title='0|3|3 - Total: 3'>    private String prevNameTokenString = "";
</span>    private int prevNameTokenLineno;

    private boolean defaultUseStrictDirective;

    // Exception to unwind
    private static class ParserException extends RuntimeException
    {
        static final long serialVersionUID = 5882582646773765630L;
    }

    public Parser() {
<span class='bc' id='L169' title='0|5|5 - Total: 5'>        this(new CompilerEnvirons());
</span><span class='bc' id='L170' title='0|1|1 - Total: 1'>    }
</span>
    public Parser(CompilerEnvirons compilerEnv) {
<span class='bc' id='L173' title='0|5|5 - Total: 5'>        this(compilerEnv, compilerEnv.getErrorReporter());
</span><span class='bc' id='L174' title='0|1|1 - Total: 1'>    }
</span>
<span class='bc' id='L176' title='0|2|2 - Total: 2'>    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {
</span><span class='bc' id='L177' title='0|3|3 - Total: 3'>        this.compilerEnv = compilerEnv;
</span><span class='bc' id='L178' title='0|3|3 - Total: 3'>        this.errorReporter = errorReporter;
</span><span class='bc' id='L179' title='0|2|2 - Total: 2'>        if (errorReporter instanceof IdeErrorReporter) {
</span><span class='bc' id='L180' title='0|4|4 - Total: 4'>            errorCollector = (IdeErrorReporter)errorReporter;
</span>        }
<span class='bc' id='L182' title='0|1|1 - Total: 1'>    }
</span>
    // Add a strict warning on the last matched token.
    void addStrictWarning(String messageId, String messageArg) {
<span class='bc' id='L186' title='0|4|4 - Total: 4'>        int beg = -1, end = -1;
</span><span class='bc' id='L187' title='0|2|2 - Total: 2'>        if (ts != null) {
</span><span class='bc' id='L188' title='0|4|4 - Total: 4'>            beg = ts.tokenBeg;
</span><span class='bc' id='L189' title='0|8|8 - Total: 8'>            end = ts.tokenEnd - ts.tokenBeg;
</span>        }
<span class='bc' id='L191' title='0|6|6 - Total: 6'>        addStrictWarning(messageId, messageArg, beg, end);
</span><span class='bc' id='L192' title='0|1|1 - Total: 1'>    }
</span>
    void addStrictWarning(String messageId, String messageArg,
                          int position, int length) {
<span class='bc' id='L196' title='0|2|2 - Total: 2'>        if (compilerEnv.isStrictMode())
</span><span class='bc' id='L197' title='0|6|6 - Total: 6'>            addWarning(messageId, messageArg, position, length);
</span><span class='bc' id='L198' title='0|1|1 - Total: 1'>    }
</span>
    void addWarning(String messageId, String messageArg) {
<span class='bc' id='L201' title='0|4|4 - Total: 4'>        int beg = -1, end = -1;
</span><span class='bpc' id='L202' title='0|1|1 - Total: 2'>        if (ts != null) {
</span><span class='bc' id='L203' title='0|4|4 - Total: 4'>            beg = ts.tokenBeg;
</span><span class='bc' id='L204' title='0|8|8 - Total: 8'>            end = ts.tokenEnd - ts.tokenBeg;
</span>        }
<span class='bc' id='L206' title='0|6|6 - Total: 6'>        addWarning(messageId, messageArg, beg, end);
</span><span class='bc' id='L207' title='0|1|1 - Total: 1'>    }
</span>
    void addWarning(String messageId, int position, int length) {
<span class='nc' id='L210' title='0|0|0 - Total: 6'>        addWarning(messageId, null, position, length);
</span><span class='nc' id='L211' title='0|0|0 - Total: 1'>    }
</span>
    void addWarning(String messageId, String messageArg,
                    int position, int length)
    {
<span class='bc' id='L216' title='0|5|5 - Total: 5'>        String message = lookupMessage(messageId, messageArg);
</span><span class='bpc' id='L217' title='0|1|1 - Total: 2'>        if (compilerEnv.reportWarningAsError()) {
</span><span class='nc' id='L218' title='0|0|0 - Total: 7'>            addError(messageId, messageArg, position, length);
</span><span class='bc' id='L219' title='0|2|2 - Total: 2'>        } else if (errorCollector != null) {
</span><span class='bc' id='L220' title='0|9|9 - Total: 9'>            errorCollector.warning(message, sourceURI, position, length);
</span>        } else {
<span class='bc' id='L222' title='0|11|11 - Total: 11'>            errorReporter.warning(message, sourceURI, ts.getLineno(),
</span><span class='bc' id='L223' title='0|4|4 - Total: 4'>                                  ts.getLine(), ts.getOffset());
</span>        }
<span class='bc' id='L225' title='0|1|1 - Total: 1'>    }
</span>
    void addError(String messageId) {
<span class='nc' id='L228' title='0|0|0 - Total: 13'>        addError(messageId, ts.tokenBeg, ts.tokenEnd - ts.tokenBeg);
</span><span class='nc' id='L229' title='0|0|0 - Total: 1'>    }
</span>
    void addError(String messageId, int position, int length) {
<span class='nc' id='L232' title='0|0|0 - Total: 6'>        addError(messageId, null, position, length);
</span><span class='nc' id='L233' title='0|0|0 - Total: 1'>    }
</span>
    void addError(String messageId, String messageArg) {
<span class='nc' id='L236' title='0|0|0 - Total: 14'>        addError(messageId, messageArg, ts.tokenBeg,
</span>                 ts.tokenEnd - ts.tokenBeg);
<span class='nc' id='L238' title='0|0|0 - Total: 1'>    }
</span>
    void addError(String messageId, int c) {
<span class='bc' id='L241' title='0|4|4 - Total: 4'>        String messageArg = Character.toString ((char) c);
</span><span class='nc' id='L242' title='0|0|0 - Total: 14'>        addError(messageId, messageArg, ts.tokenBeg,
</span>                 ts.tokenEnd - ts.tokenBeg);
<span class='nc' id='L244' title='0|0|0 - Total: 1'>    }
</span>
    void addError(String messageId, String messageArg, int position, int length)
    {
<span class='bc' id='L248' title='0|6|6 - Total: 6'>        ++syntaxErrorCount;
</span><span class='bc' id='L249' title='0|5|5 - Total: 5'>        String message = lookupMessage(messageId, messageArg);
</span><span class='bpc' id='L250' title='0|1|1 - Total: 2'>        if (errorCollector != null) {
</span><span class='nc' id='L251' title='0|0|0 - Total: 9'>            errorCollector.error(message, sourceURI, position, length);
</span>        } else {
<span class='bc' id='L253' title='0|4|4 - Total: 4'>            int lineno = 1, offset = 1;
</span><span class='bc' id='L254' title='0|2|2 - Total: 2'>            String line = "";
</span><span class='bc' id='L255' title='0|2|2 - Total: 2'>            if (ts != null) {  // happens in some regression tests
</span><span class='bc' id='L256' title='0|4|4 - Total: 4'>                lineno = ts.getLineno();
</span><span class='bc' id='L257' title='0|4|4 - Total: 4'>                line = ts.getLine();
</span><span class='bc' id='L258' title='0|4|4 - Total: 4'>                offset = ts.getOffset();
</span>            }
<span class='bc' id='L260' title='0|9|9 - Total: 9'>            errorReporter.error(message, sourceURI, lineno, line, offset);
</span>        }
<span class='bc' id='L262' title='0|1|1 - Total: 1'>    }
</span>
    private void addStrictWarning(String messageId, String messageArg,
                                  int position, int length,
                                  int line, String lineSource, int lineOffset) {
<span class='bpc' id='L267' title='0|1|1 - Total: 2'>        if (compilerEnv.isStrictMode()) {
</span><span class='bc' id='L268' title='0|9|9 - Total: 9'>            addWarning(messageId, messageArg, position, length, line, lineSource, lineOffset);
</span>        }
<span class='bc' id='L270' title='0|1|1 - Total: 1'>    }
</span>
    private void addWarning(String messageId, String messageArg,
                            int position, int length,
                            int line, String lineSource, int lineOffset) {
<span class='bc' id='L275' title='0|5|5 - Total: 5'>        String message = lookupMessage(messageId, messageArg);
</span><span class='bpc' id='L276' title='0|1|1 - Total: 2'>        if (compilerEnv.reportWarningAsError()) {
</span><span class='nc' id='L277' title='0|0|0 - Total: 10'>            addError(messageId, messageArg, position, length, line, lineSource, lineOffset);
</span><span class='bc' id='L278' title='0|2|2 - Total: 2'>        } else if (errorCollector != null) {
</span><span class='bc' id='L279' title='0|9|9 - Total: 9'>            errorCollector.warning(message, sourceURI, position, length);
</span>        } else {
<span class='bc' id='L281' title='0|9|9 - Total: 9'>            errorReporter.warning(message, sourceURI, line, lineSource, lineOffset);
</span>        }
<span class='bc' id='L283' title='0|1|1 - Total: 1'>    }
</span>
    private void addError(String messageId, String messageArg,
                          int position, int length,
                          int line, String lineSource, int lineOffset) {
<span class='nc' id='L288' title='0|0|0 - Total: 6'>        ++syntaxErrorCount;
</span><span class='nc' id='L289' title='0|0|0 - Total: 5'>        String message = lookupMessage(messageId, messageArg);
</span><span class='nc' id='L290' title='0|0|0 - Total: 2'>        if (errorCollector != null) {
</span><span class='nc' id='L291' title='0|0|0 - Total: 9'>            errorCollector.error(message, sourceURI, position, length);
</span>        } else {
<span class='nc' id='L293' title='0|0|0 - Total: 9'>            errorReporter.error(message, sourceURI, line, lineSource, lineOffset);
</span>        }
<span class='nc' id='L295' title='0|0|0 - Total: 1'>    }
</span>
    String lookupMessage(String messageId) {
<span class='bc' id='L298' title='0|5|5 - Total: 5'>        return lookupMessage(messageId, null);
</span>    }

    String lookupMessage(String messageId, String messageArg) {
<span class='bc' id='L302' title='0|2|2 - Total: 2'>        return messageArg == null
</span><span class='bc' id='L303' title='0|4|4 - Total: 4'>            ? ScriptRuntime.getMessage0(messageId)
</span><span class='bc' id='L304' title='0|1|1 - Total: 1'>            : ScriptRuntime.getMessage1(messageId, messageArg);
</span>    }

    void reportError(String messageId) {
<span class='bc' id='L308' title='0|4|4 - Total: 4'>        reportError(messageId, null);
</span><span class='bc' id='L309' title='0|1|1 - Total: 1'>    }
</span>
    void reportError(String messageId, String messageArg) {
<span class='bc' id='L312' title='0|2|2 - Total: 2'>        if (ts == null) {  // happens in some regression tests
</span><span class='nc' id='L313' title='0|0|0 - Total: 7'>            reportError(messageId, messageArg, 1, 1);
</span>        } else {
<span class='bc' id='L315' title='0|14|14 - Total: 14'>            reportError(messageId, messageArg, ts.tokenBeg,
</span>                        ts.tokenEnd - ts.tokenBeg);
        }
<span class='bc' id='L318' title='0|1|1 - Total: 1'>    }
</span>
    void reportError(String messageId, int position, int length)
    {
<span class='nc' id='L322' title='0|0|0 - Total: 6'>        reportError(messageId, null, position, length);
</span><span class='nc' id='L323' title='0|0|0 - Total: 1'>    }
</span>
    void reportError(String messageId, String messageArg, int position,
                     int length)
    {
<span class='bc' id='L328' title='0|6|6 - Total: 6'>        addError(messageId, messageArg, position, length);
</span>
<span class='bc' id='L330' title='0|2|2 - Total: 2'>        if (!compilerEnv.recoverFromErrors()) {
</span><span class='bc' id='L331' title='0|5|5 - Total: 5'>            throw new ParserException();
</span>        }
<span class='bc' id='L333' title='0|1|1 - Total: 1'>    }
</span>
    // Computes the absolute end offset of node N.
    // Use with caution!  Assumes n.getPosition() is -absolute-, which
    // is only true before the node is added to its parent.
    private int getNodeEnd(AstNode n) {
<span class='bc' id='L339' title='0|6|6 - Total: 6'>        return n.getPosition() + n.getLength();
</span>    }

    private void recordComment(int lineno, String comment) {
<span class='bc' id='L343' title='0|2|2 - Total: 2'>        if (scannedComments == null) {
</span><span class='bc' id='L344' title='0|5|5 - Total: 5'>            scannedComments = new ArrayList<Comment>();
</span>        }
<span class='bc' id='L346' title='0|7|7 - Total: 7'>        Comment commentNode = new Comment(ts.tokenBeg,
</span><span class='bc' id='L347' title='0|7|7 - Total: 7'>                                          ts.getTokenLength(),
</span>                                          ts.commentType,
                                          comment);
<span class='bc' id='L350' title='0|2|2 - Total: 2'>        if (ts.commentType == Token.CommentType.JSDOC &&
</span><span class='bc' id='L351' title='0|2|2 - Total: 2'>            compilerEnv.isRecordingLocalJsDocComments()) {
</span><span class='bc' id='L352' title='0|3|3 - Total: 3'>            currentJsDocComment = commentNode;
</span>        }
<span class='bc' id='L354' title='0|3|3 - Total: 3'>        commentNode.setLineno(lineno);
</span><span class='bc' id='L355' title='0|5|5 - Total: 5'>        scannedComments.add(commentNode);
</span><span class='bc' id='L356' title='0|1|1 - Total: 1'>    }
</span>
    private Comment getAndResetJsDoc() {
<span class='bc' id='L359' title='0|3|3 - Total: 3'>        Comment saved = currentJsDocComment;
</span><span class='bc' id='L360' title='0|3|3 - Total: 3'>        currentJsDocComment = null;
</span><span class='bc' id='L361' title='0|2|2 - Total: 2'>        return saved;
</span>    }


    private int getNumberOfEols(String comment) {
<span class='bc' id='L366' title='0|2|2 - Total: 2'>      int lines = 0;
</span><span class='bc' id='L367' title='0|2|2 - Total: 2'>      for (int i = comment.length()-1; i >= 0; i--) {
</span><span class='bc' id='L368' title='0|2|2 - Total: 2'>        if (comment.charAt(i) == '\n') {
</span><span class='bc' id='L369' title='0|1|1 - Total: 1'>          lines++;
</span>        }
      }
<span class='bc' id='L372' title='0|2|2 - Total: 2'>      return lines;
</span>    }


    // Returns the next token without consuming it.
    // If previous token was consumed, calls scanner to get new token.
    // If previous token was -not- consumed, returns it (idempotent).
    //
    // This function will not return a newline (Token.EOL - instead, it
    // gobbles newlines until it finds a non-newline token, and flags
    // that token as appearing just after a newline.
    //
    // This function will also not return a Token.COMMENT.  Instead, it
    // records comments in the scannedComments list.  If the token
    // returned by this function immediately follows a jsdoc comment,
    // the token is flagged as such.
    //
    // Note that this function always returned the un-flagged token!
    // The flags, if any, are saved in currentFlaggedToken.
    private int peekToken()
        throws IOException
    {
        // By far the most common case:  last token hasn't been consumed,
        // so return already-peeked token.
<span class='bc' id='L396' title='0|2|2 - Total: 2'>        if (currentFlaggedToken != Token.EOF) {
</span><span class='bc' id='L397' title='0|3|3 - Total: 3'>            return currentToken;
</span>        }

<span class='bc' id='L400' title='0|4|4 - Total: 4'>        int lineno = ts.getLineno();
</span><span class='bc' id='L401' title='0|4|4 - Total: 4'>        int tt = ts.getToken();
</span><span class='bc' id='L402' title='0|2|2 - Total: 2'>        boolean sawEOL = false;
</span>
        // process comments and whitespace
<span class='bc' id='L405' title='0|4|4 - Total: 4'>        while (tt == Token.EOL || tt == Token.COMMENT) {
</span><span class='bc' id='L406' title='0|2|2 - Total: 2'>            if (tt == Token.EOL) {
</span><span class='bc' id='L407' title='0|1|1 - Total: 1'>                lineno++;
</span><span class='bc' id='L408' title='0|3|3 - Total: 3'>                sawEOL = true;
</span>            } else {
<span class='bc' id='L410' title='0|2|2 - Total: 2'>                if (compilerEnv.isRecordingComments()) {
</span><span class='bc' id='L411' title='0|4|4 - Total: 4'>                    String comment = ts.getAndResetCurrentComment();
</span><span class='bc' id='L412' title='0|4|4 - Total: 4'>                    recordComment(lineno, comment);
</span>                    // Comments may contain multiple lines, get the number
                    // of EoLs and increase the lineno
<span class='bc' id='L415' title='0|6|6 - Total: 6'>                    lineno += getNumberOfEols(comment);
</span>                }
            }
<span class='bc' id='L418' title='0|5|5 - Total: 5'>            tt = ts.getToken();
</span>        }

<span class='bc' id='L421' title='0|3|3 - Total: 3'>        currentToken = tt;
</span><span class='bc' id='L422' title='0|2|2 - Total: 2'>        currentFlaggedToken = tt | (sawEOL ? TI_AFTER_EOL : 0);
</span><span class='bc' id='L423' title='0|3|3 - Total: 3'>        return currentToken;  // return unflagged token
</span>    }

    private int peekFlaggedToken()
        throws IOException
    {
<span class='bc' id='L429' title='0|3|3 - Total: 3'>        peekToken();
</span><span class='bc' id='L430' title='0|3|3 - Total: 3'>        return currentFlaggedToken;
</span>    }

    private void consumeToken() {
<span class='bc' id='L434' title='0|3|3 - Total: 3'>        currentFlaggedToken = Token.EOF;
</span><span class='bc' id='L435' title='0|1|1 - Total: 1'>    }
</span>
    private int nextToken()
        throws IOException
    {
<span class='bc' id='L440' title='0|3|3 - Total: 3'>        int tt = peekToken();
</span><span class='bc' id='L441' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L442' title='0|2|2 - Total: 2'>        return tt;
</span>    }

    private int nextFlaggedToken()
        throws IOException
    {
<span class='nc' id='L448' title='0|0|0 - Total: 3'>        peekToken();
</span><span class='nc' id='L449' title='0|0|0 - Total: 3'>        int ttFlagged = currentFlaggedToken;
</span><span class='nc' id='L450' title='0|0|0 - Total: 2'>        consumeToken();
</span><span class='nc' id='L451' title='0|0|0 - Total: 2'>        return ttFlagged;
</span>    }

    private boolean matchToken(int toMatch)
        throws IOException
    {
<span class='bc' id='L457' title='0|2|2 - Total: 2'>        if (peekToken() != toMatch) {
</span><span class='bc' id='L458' title='0|2|2 - Total: 2'>            return false;
</span>        }
<span class='bc' id='L460' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L461' title='0|2|2 - Total: 2'>        return true;
</span>    }

    // Returns Token.EOL if the current token follows a newline, else returns
    // the current token.  Used in situations where we don't consider certain
    // token types valid if they are preceded by a newline.  One example is the
    // postfix ++ or -- operator, which has to be on the same line as its
    // operand.
    private int peekTokenOrEOL()
        throws IOException
    {
<span class='bc' id='L472' title='0|3|3 - Total: 3'>        int tt = peekToken();
</span>        // Check for last peeked token flags
<span class='bc' id='L474' title='0|2|2 - Total: 2'>        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {
</span><span class='bc' id='L475' title='0|2|2 - Total: 2'>            tt = Token.EOL;
</span>        }
<span class='bc' id='L477' title='0|2|2 - Total: 2'>        return tt;
</span>    }

    private boolean mustMatchToken(int toMatch, String messageId)
        throws IOException
    {
<span class='bc' id='L483' title='0|15|15 - Total: 15'>        return mustMatchToken(toMatch, messageId, ts.tokenBeg,
</span>                              ts.tokenEnd - ts.tokenBeg);
    }

    private boolean mustMatchToken(int toMatch, String msgId, int pos, int len)
        throws IOException
    {
<span class='bpc' id='L490' title='0|1|1 - Total: 2'>        if (matchToken(toMatch)) {
</span><span class='bc' id='L491' title='0|2|2 - Total: 2'>            return true;
</span>        }
<span class='nc' id='L493' title='0|0|0 - Total: 5'>        reportError(msgId, pos, len);
</span><span class='nc' id='L494' title='0|0|0 - Total: 2'>        return false;
</span>    }

    private void mustHaveXML() {
<span class='bc' id='L498' title='0|2|2 - Total: 2'>        if (!compilerEnv.isXmlAvailable()) {
</span><span class='nc' id='L499' title='0|0|0 - Total: 3'>            reportError("msg.XML.not.available");
</span>        }
<span class='bc' id='L501' title='0|1|1 - Total: 1'>    }
</span>
    public boolean eof() {
<span class='nc' id='L504' title='0|0|0 - Total: 4'>        return ts.eof();
</span>    }

    boolean insideFunction() {
<span class='bc' id='L508' title='0|2|2 - Total: 2'>        return nestingOfFunction != 0;
</span>    }

    void pushScope(Scope scope) {
<span class='bc' id='L512' title='0|3|3 - Total: 3'>        Scope parent = scope.getParentScope();
</span>        // During codegen, parent scope chain may already be initialized,
        // in which case we just need to set currentScope variable.
<span class='bc' id='L515' title='0|2|2 - Total: 2'>        if (parent != null) {
</span><span class='bpc' id='L516' title='0|1|1 - Total: 2'>            if (parent != currentScope)
</span><span class='nc' id='L517' title='0|0|0 - Total: 4'>                codeBug();
</span>        } else {
<span class='bc' id='L519' title='0|4|4 - Total: 4'>            currentScope.addChildScope(scope);
</span>        }
<span class='bc' id='L521' title='0|3|3 - Total: 3'>        currentScope = scope;
</span><span class='bc' id='L522' title='0|1|1 - Total: 1'>    }
</span>
    void popScope() {
<span class='bc' id='L525' title='0|5|5 - Total: 5'>        currentScope = currentScope.getParentScope();
</span><span class='bc' id='L526' title='0|1|1 - Total: 1'>    }
</span>
    private void enterLoop(Loop loop) {
<span class='bc' id='L529' title='0|2|2 - Total: 2'>        if (loopSet == null)
</span><span class='bc' id='L530' title='0|5|5 - Total: 5'>            loopSet = new ArrayList<Loop>();
</span><span class='bc' id='L531' title='0|5|5 - Total: 5'>        loopSet.add(loop);
</span><span class='bc' id='L532' title='0|2|2 - Total: 2'>        if (loopAndSwitchSet == null)
</span><span class='bc' id='L533' title='0|5|5 - Total: 5'>            loopAndSwitchSet = new ArrayList<Jump>();
</span><span class='bc' id='L534' title='0|5|5 - Total: 5'>        loopAndSwitchSet.add(loop);
</span><span class='bc' id='L535' title='0|3|3 - Total: 3'>        pushScope(loop);
</span><span class='bc' id='L536' title='0|2|2 - Total: 2'>        if (currentLabel != null) {
</span><span class='bc' id='L537' title='0|4|4 - Total: 4'>            currentLabel.setStatement(loop);
</span><span class='bc' id='L538' title='0|5|5 - Total: 5'>            currentLabel.getFirstLabel().setLoop(loop);
</span>            // This is the only time during parsing that we set a node's parent
            // before parsing the children.  In order for the child node offsets
            // to be correct, we adjust the loop's reported position back to an
            // absolute source offset, and restore it when we call exitLoop().
<span class='bc' id='L543' title='0|6|6 - Total: 6'>            loop.setRelative(-currentLabel.getPosition());
</span>        }
<span class='bc' id='L545' title='0|1|1 - Total: 1'>    }
</span>
    private void exitLoop() {
<span class='bc' id='L548' title='0|10|10 - Total: 10'>        Loop loop = loopSet.remove(loopSet.size() - 1);
</span><span class='bc' id='L549' title='0|9|9 - Total: 9'>        loopAndSwitchSet.remove(loopAndSwitchSet.size() - 1);
</span><span class='bc' id='L550' title='0|2|2 - Total: 2'>        if (loop.getParent() != null) {  // see comment in enterLoop
</span><span class='bc' id='L551' title='0|5|5 - Total: 5'>            loop.setRelative(loop.getParent().getPosition());
</span>        }
<span class='bc' id='L553' title='0|2|2 - Total: 2'>        popScope();
</span><span class='bc' id='L554' title='0|1|1 - Total: 1'>    }
</span>
    private void enterSwitch(SwitchStatement node) {
<span class='bc' id='L557' title='0|2|2 - Total: 2'>        if (loopAndSwitchSet == null)
</span><span class='bc' id='L558' title='0|5|5 - Total: 5'>            loopAndSwitchSet = new ArrayList<Jump>();
</span><span class='bc' id='L559' title='0|5|5 - Total: 5'>        loopAndSwitchSet.add(node);
</span><span class='bc' id='L560' title='0|1|1 - Total: 1'>    }
</span>
    private void exitSwitch() {
<span class='bc' id='L563' title='0|9|9 - Total: 9'>        loopAndSwitchSet.remove(loopAndSwitchSet.size() - 1);
</span><span class='bc' id='L564' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Builds a parse tree from the given source string.
     *
     * @return an {@link AstRoot} object representing the parsed program.  If
     * the parse fails, {@code null} will be returned.  (The parse failure will
     * result in a call to the {@link ErrorReporter} from
     * {@link CompilerEnvirons}.)
     */
    public AstRoot parse(String sourceString, String sourceURI, int lineno)
    {
<span class='bpc' id='L576' title='0|1|1 - Total: 2'>        if (parseFinished) throw new IllegalStateException("parser reused");
</span><span class='bc' id='L577' title='0|3|3 - Total: 3'>        this.sourceURI = sourceURI;
</span><span class='bc' id='L578' title='0|2|2 - Total: 2'>        if (compilerEnv.isIdeMode()) {
</span><span class='bc' id='L579' title='0|4|4 - Total: 4'>            this.sourceChars = sourceString.toCharArray();
</span>        }
<span class='bc' id='L581' title='0|9|9 - Total: 9'>        this.ts = new TokenStream(this, null, sourceString, lineno);
</span>        try {
<span class='bc' id='L583' title='0|5|5 - Total: 5'>            return parse();
</span><span class='nc' id='L584' title='0|0|0 - Total: 1'>        } catch (IOException iox) {
</span>            // Should never happen
<span class='nc' id='L586' title='0|0|0 - Total: 4'>            throw new IllegalStateException();
</span>        } finally {
<span class='bc' id='L588' title='0|7|7 - Total: 7'>            parseFinished = true;
</span><span class='bc' id='L589' title='0|2|2 - Total: 2'>        }
</span>    }

    /**
     * Builds a parse tree from the given sourcereader.
     * @see #parse(String,String,int)
     * @throws IOException if the {@link Reader} encounters an error
     */
    public AstRoot parse(Reader sourceReader, String sourceURI, int lineno)
        throws IOException
    {
<span class='bpc' id='L600' title='0|1|1 - Total: 2'>        if (parseFinished) throw new IllegalStateException("parser reused");
</span><span class='bc' id='L601' title='0|2|2 - Total: 2'>        if (compilerEnv.isIdeMode()) {
</span><span class='bc' id='L602' title='0|8|8 - Total: 8'>            return parse(readFully(sourceReader), sourceURI, lineno);
</span>        }
        try {
<span class='bc' id='L605' title='0|3|3 - Total: 3'>            this.sourceURI = sourceURI;
</span><span class='bc' id='L606' title='0|9|9 - Total: 9'>            ts = new TokenStream(this, sourceReader, null, lineno);
</span><span class='bc' id='L607' title='0|5|5 - Total: 5'>            return parse();
</span>        } finally {
<span class='bpc' id='L609' title='0|3|3 - Total: 7'>            parseFinished = true;
</span><span class='nc' id='L610' title='0|0|0 - Total: 2'>        }
</span>    }

    private AstRoot parse() throws IOException
    {
<span class='bc' id='L615' title='0|2|2 - Total: 2'>        int pos = 0;
</span><span class='bc' id='L616' title='0|5|5 - Total: 5'>        AstRoot root = new AstRoot(pos);
</span><span class='bc' id='L617' title='0|6|6 - Total: 6'>        currentScope = currentScriptOrFn = root;
</span>
<span class='bc' id='L619' title='0|4|4 - Total: 4'>        int baseLineno = ts.lineno;  // line number where source starts
</span><span class='bc' id='L620' title='0|2|2 - Total: 2'>        int end = pos;  // in case source is empty
</span>
<span class='bc' id='L622' title='0|2|2 - Total: 2'>        boolean inDirectivePrologue = true;
</span><span class='bc' id='L623' title='0|3|3 - Total: 3'>        boolean savedStrictMode = inUseStrictDirective;
</span>
<span class='bc' id='L625' title='0|4|4 - Total: 4'>        inUseStrictDirective = defaultUseStrictDirective;
</span><span class='bc' id='L626' title='0|2|2 - Total: 2'>        if (inUseStrictDirective) {
</span><span class='bc' id='L627' title='0|3|3 - Total: 3'>            root.setInStrictMode(true);
</span>        }

        try {
            for (;;) {
<span class='bc' id='L632' title='0|3|3 - Total: 3'>                int tt = peekToken();
</span><span class='bc' id='L633' title='0|2|2 - Total: 2'>                if (tt <= Token.EOF) {
</span><span class='bc' id='L634' title='0|1|1 - Total: 1'>                    break;
</span>                }

                AstNode n;
<span class='bc' id='L638' title='0|2|2 - Total: 2'>                if (tt == Token.FUNCTION) {
</span><span class='bc' id='L639' title='0|2|2 - Total: 2'>                    consumeToken();
</span>                    try {
<span class='bc' id='L641' title='0|2|2 - Total: 2'>                        n = function(calledByCompileFunction
</span>                                     ? FunctionNode.FUNCTION_EXPRESSION
                                     : FunctionNode.FUNCTION_STATEMENT);
<span class='nc' id='L644' title='0|0|0 - Total: 1'>                    } catch (ParserException e) {
</span><span class='nc' id='L645' title='0|0|0 - Total: 1'>                        break;
</span><span class='bc' id='L646' title='0|1|1 - Total: 1'>                    }
</span>                } else {
<span class='bc' id='L648' title='0|3|3 - Total: 3'>                    n = statement();
</span><span class='bc' id='L649' title='0|2|2 - Total: 2'>                    if (inDirectivePrologue) {
</span><span class='bc' id='L650' title='0|4|4 - Total: 4'>                        String directive = getDirective(n);
</span><span class='bc' id='L651' title='0|2|2 - Total: 2'>                        if (directive == null) {
</span><span class='bc' id='L652' title='0|3|3 - Total: 3'>                            inDirectivePrologue = false;
</span><span class='bc' id='L653' title='0|2|2 - Total: 2'>                        } else if (directive.equals("use strict")) {
</span><span class='bc' id='L654' title='0|3|3 - Total: 3'>                            inUseStrictDirective = true;
</span><span class='bc' id='L655' title='0|3|3 - Total: 3'>                            root.setInStrictMode(true);
</span>                        }
                    }

                }
<span class='bc' id='L660' title='0|4|4 - Total: 4'>                end = getNodeEnd(n);
</span><span class='bc' id='L661' title='0|3|3 - Total: 3'>                root.addChildToBack(n);
</span><span class='bc' id='L662' title='0|3|3 - Total: 3'>                n.setParent(root);
</span><span class='bc' id='L663' title='0|1|1 - Total: 1'>            }
</span><span class='bc' id='L664' title='0|1|1 - Total: 1'>        } catch (StackOverflowError ex) {
</span><span class='bc' id='L665' title='0|4|4 - Total: 4'>            String msg = lookupMessage("msg.too.deep.parser.recursion");
</span><span class='bpc' id='L666' title='0|1|1 - Total: 2'>            if (!compilerEnv.isIdeMode())
</span><span class='bc' id='L667' title='0|10|10 - Total: 10'>                throw Context.reportRuntimeError(msg, sourceURI,
</span>                                                 ts.lineno, null, 0);
        } finally {
<span class='bpc' id='L670' title='0|7|7 - Total: 10'>            inUseStrictDirective = savedStrictMode;
</span><span class='bpc' id='L671' title='0|3|3 - Total: 4'>        }
</span>
<span class='bc' id='L673' title='0|2|2 - Total: 2'>        if (this.syntaxErrorCount != 0) {
</span><span class='bc' id='L674' title='0|4|4 - Total: 4'>            String msg = String.valueOf(this.syntaxErrorCount);
</span><span class='bc' id='L675' title='0|5|5 - Total: 5'>            msg = lookupMessage("msg.got.syntax.errors", msg);
</span><span class='bpc' id='L676' title='0|1|1 - Total: 2'>            if (!compilerEnv.isIdeMode())
</span><span class='bc' id='L677' title='0|10|10 - Total: 10'>                throw errorReporter.runtimeError(msg, sourceURI, baseLineno,
</span>                                                 null, 0);
        }

        // add comments to root in lexical order
<span class='bc' id='L682' title='0|2|2 - Total: 2'>        if (scannedComments != null) {
</span>            // If we find a comment beyond end of our last statement or
            // function, extend the root bounds to the end of that comment.
<span class='bc' id='L685' title='0|6|6 - Total: 6'>            int last = scannedComments.size() - 1;
</span><span class='bc' id='L686' title='0|10|10 - Total: 10'>            end = Math.max(end, getNodeEnd(scannedComments.get(last)));
</span><span class='bc' id='L687' title='0|2|2 - Total: 2'>            for (Comment c : scannedComments) {
</span><span class='bc' id='L688' title='0|3|3 - Total: 3'>                root.addComment(c);
</span><span class='bc' id='L689' title='0|1|1 - Total: 1'>            }
</span>        }

<span class='bc' id='L692' title='0|5|5 - Total: 5'>        root.setLength(end - pos);
</span><span class='bc' id='L693' title='0|4|4 - Total: 4'>        root.setSourceName(sourceURI);
</span><span class='bc' id='L694' title='0|3|3 - Total: 3'>        root.setBaseLineno(baseLineno);
</span><span class='bc' id='L695' title='0|5|5 - Total: 5'>        root.setEndLineno(ts.lineno);
</span><span class='bc' id='L696' title='0|2|2 - Total: 2'>        return root;
</span>    }

    private AstNode parseFunctionBody(int type, FunctionNode fnNode)
        throws IOException
    {
<span class='bc' id='L702' title='0|2|2 - Total: 2'>        boolean isExpressionClosure = false;
</span><span class='bc' id='L703' title='0|2|2 - Total: 2'>        if (!matchToken(Token.LC)) {
</span><span class='bpc' id='L704' title='0|3|3 - Total: 4'>            if (compilerEnv.getLanguageVersion() < Context.VERSION_1_8 && type != FunctionNode.ARROW_FUNCTION) {
</span><span class='nc' id='L705' title='0|0|0 - Total: 4'>                reportError("msg.no.brace.body");
</span>            } else {
<span class='bc' id='L707' title='0|2|2 - Total: 2'>                isExpressionClosure = true;
</span>            }
        }
<span class='bc' id='L710' title='0|2|2 - Total: 2'>        boolean isArrow = type == FunctionNode.ARROW_FUNCTION;
</span><span class='bc' id='L711' title='0|6|6 - Total: 6'>        ++nestingOfFunction;
</span><span class='bc' id='L712' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span><span class='bc' id='L713' title='0|5|5 - Total: 5'>        Block pn = new Block(pos);  // starts at LC position
</span>
<span class='bc' id='L715' title='0|2|2 - Total: 2'>        boolean inDirectivePrologue = true;
</span><span class='bc' id='L716' title='0|3|3 - Total: 3'>        boolean savedStrictMode = inUseStrictDirective;
</span>        // Don't set 'inUseStrictDirective' to false: inherit strict mode.

<span class='bc' id='L719' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span>        try {
<span class='bc' id='L721' title='0|2|2 - Total: 2'>            if (isExpressionClosure) {
</span><span class='bc' id='L722' title='0|3|3 - Total: 3'>                AstNode returnValue = assignExpr();
</span><span class='bc' id='L723' title='0|9|9 - Total: 9'>                ReturnStatement n = new ReturnStatement(returnValue.getPosition(), returnValue.getLength(), returnValue);
</span>                // expression closure flag is required on both nodes
<span class='bc' id='L725' title='0|4|4 - Total: 4'>                n.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);
</span><span class='bc' id='L726' title='0|4|4 - Total: 4'>                pn.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);
</span><span class='bc' id='L727' title='0|2|2 - Total: 2'>                if (isArrow) {
</span><span class='bc' id='L728' title='0|4|4 - Total: 4'>                    n.putProp(Node.ARROW_FUNCTION_PROP, Boolean.TRUE);
</span>                }
<span class='bc' id='L730' title='0|3|3 - Total: 3'>                pn.addStatement(n);
</span><span class='bc' id='L731' title='0|1|1 - Total: 1'>            } else {
</span>                bodyLoop: for (;;) {
                    AstNode n;
<span class='bc' id='L734' title='0|3|3 - Total: 3'>                    int tt = peekToken();
</span><span class='bc' id='L735' title='0|3|3 - Total: 3'>                    switch (tt) {
</span>                        case Token.ERROR:
                        case Token.EOF:
                        case Token.RC:
<span class='bc' id='L739' title='0|1|1 - Total: 1'>                            break bodyLoop;
</span>
                        case Token.FUNCTION:
<span class='bc' id='L742' title='0|2|2 - Total: 2'>                            consumeToken();
</span><span class='bc' id='L743' title='0|4|4 - Total: 4'>                            n = function(FunctionNode.FUNCTION_STATEMENT);
</span><span class='bc' id='L744' title='0|1|1 - Total: 1'>                            break;
</span>                        default:
<span class='bc' id='L746' title='0|3|3 - Total: 3'>                            n = statement();
</span><span class='bc' id='L747' title='0|2|2 - Total: 2'>                            if (inDirectivePrologue) {
</span><span class='bc' id='L748' title='0|4|4 - Total: 4'>                                String directive = getDirective(n);
</span><span class='bc' id='L749' title='0|2|2 - Total: 2'>                                if (directive == null) {
</span><span class='bc' id='L750' title='0|3|3 - Total: 3'>                                    inDirectivePrologue = false;
</span><span class='bc' id='L751' title='0|2|2 - Total: 2'>                                } else if (directive.equals("use strict")) {
</span><span class='bc' id='L752' title='0|3|3 - Total: 3'>                                    inUseStrictDirective = true;
</span><span class='bc' id='L753' title='0|3|3 - Total: 3'>                                    fnNode.setInStrictMode(true);
</span><span class='bpc' id='L754' title='0|1|1 - Total: 2'>                                    if (!savedStrictMode) {
</span><span class='bc' id='L755' title='0|2|2 - Total: 2'>                                        setRequiresActivation();
</span>                                    }
                                }
                            }
                            break;
                    }
<span class='bc' id='L761' title='0|3|3 - Total: 3'>                    pn.addStatement(n);
</span><span class='bc' id='L762' title='0|1|1 - Total: 1'>                }
</span>            }
<span class='nc' id='L764' title='0|0|0 - Total: 1'>        } catch (ParserException e) {
</span>            // Ignore it
        } finally {
<span class='bpc' id='L767' title='0|13|13 - Total: 19'>            --nestingOfFunction;
</span><span class='bpc' id='L768' title='0|6|6 - Total: 9'>            inUseStrictDirective = savedStrictMode;
</span><span class='bpc' id='L769' title='0|3|3 - Total: 4'>        }
</span>
<span class='bc' id='L771' title='0|4|4 - Total: 4'>        int end = ts.tokenEnd;
</span><span class='bc' id='L772' title='0|3|3 - Total: 3'>        getAndResetJsDoc();
</span><span class='bpc' id='L773' title='0|3|3 - Total: 4'>        if (!isExpressionClosure && mustMatchToken(Token.RC, "msg.no.brace.after.body"))
</span><span class='bc' id='L774' title='0|4|4 - Total: 4'>            end = ts.tokenEnd;
</span><span class='bc' id='L775' title='0|5|5 - Total: 5'>        pn.setLength(end - pos);
</span><span class='bc' id='L776' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private String getDirective(AstNode n) {
<span class='bc' id='L780' title='0|2|2 - Total: 2'>        if (n instanceof ExpressionStatement) {
</span><span class='bc' id='L781' title='0|4|4 - Total: 4'>            AstNode e = ((ExpressionStatement) n).getExpression();
</span><span class='bc' id='L782' title='0|2|2 - Total: 2'>            if (e instanceof StringLiteral) {
</span><span class='bc' id='L783' title='0|4|4 - Total: 4'>                return ((StringLiteral) e).getValue();
</span>            }
        }
<span class='bc' id='L786' title='0|2|2 - Total: 2'>        return null;
</span>    }

    private void  parseFunctionParams(FunctionNode fnNode)
        throws IOException
    {
<span class='bc' id='L792' title='0|2|2 - Total: 2'>        if (matchToken(Token.RP)) {
</span><span class='bc' id='L793' title='0|8|8 - Total: 8'>            fnNode.setRp(ts.tokenBeg - fnNode.getPosition());
</span><span class='bc' id='L794' title='0|1|1 - Total: 1'>            return;
</span>        }
        // Would prefer not to call createDestructuringAssignment until codegen,
        // but the symbol definitions have to happen now, before body is parsed.
<span class='bc' id='L798' title='0|2|2 - Total: 2'>        Map<String, Node> destructuring = null;
</span><span class='bc' id='L799' title='0|4|4 - Total: 4'>        Set<String> paramNames = new HashSet<String>();
</span>        do {
<span class='bc' id='L801' title='0|3|3 - Total: 3'>            int tt = peekToken();
</span><span class='bc' id='L802' title='0|4|4 - Total: 4'>            if (tt == Token.LB || tt == Token.LC) {
</span><span class='bc' id='L803' title='0|3|3 - Total: 3'>                AstNode expr = destructuringPrimaryExpr();
</span><span class='bc' id='L804' title='0|3|3 - Total: 3'>                markDestructuring(expr);
</span><span class='bc' id='L805' title='0|3|3 - Total: 3'>                fnNode.addParam(expr);
</span>                // Destructuring assignment for parameters: add a dummy
                // parameter name, and add a statement to the body to initialize
                // variables from the destructuring assignment
<span class='bpc' id='L809' title='0|1|1 - Total: 2'>                if (destructuring == null) {
</span><span class='bc' id='L810' title='0|4|4 - Total: 4'>                    destructuring = new HashMap<String, Node>();
</span>                }
<span class='bc' id='L812' title='0|4|4 - Total: 4'>                String pname = currentScriptOrFn.getNextTempName();
</span><span class='bc' id='L813' title='0|5|5 - Total: 5'>                defineSymbol(Token.LP, pname, false);
</span><span class='bc' id='L814' title='0|5|5 - Total: 5'>                destructuring.put(pname, expr);
</span><span class='bc' id='L815' title='0|1|1 - Total: 1'>            } else {
</span><span class='bpc' id='L816' title='0|1|1 - Total: 2'>                if (mustMatchToken(Token.NAME, "msg.no.parm")) {
</span><span class='bc' id='L817' title='0|3|3 - Total: 3'>                    Name paramNameNode = createNameNode();
</span><span class='bc' id='L818' title='0|3|3 - Total: 3'>                    Comment jsdocNodeForName = getAndResetJsDoc();
</span><span class='bc' id='L819' title='0|2|2 - Total: 2'>                    if (jsdocNodeForName != null) {
</span><span class='bc' id='L820' title='0|3|3 - Total: 3'>                      paramNameNode.setJsDocNode(jsdocNodeForName);
</span>                    }
<span class='bc' id='L822' title='0|3|3 - Total: 3'>                    fnNode.addParam(paramNameNode);
</span><span class='bc' id='L823' title='0|4|4 - Total: 4'>                    String paramName = ts.getString();
</span><span class='bc' id='L824' title='0|4|4 - Total: 4'>                    defineSymbol(Token.LP, paramName);
</span><span class='bc' id='L825' title='0|2|2 - Total: 2'>                    if (this.inUseStrictDirective) {
</span><span class='bc' id='L826' title='0|2|2 - Total: 2'>                        if ("eval".equals(paramName) ||
</span><span class='bpc' id='L827' title='0|1|1 - Total: 2'>                            "arguments".equals(paramName))
</span>                        {
<span class='nc' id='L829' title='0|0|0 - Total: 4'>                            reportError("msg.bad.id.strict", paramName);
</span>                        }
<span class='bpc' id='L831' title='0|1|1 - Total: 2'>                        if (paramNames.contains(paramName))
</span><span class='nc' id='L832' title='0|0|0 - Total: 4'>                            addError("msg.dup.param.strict", paramName);
</span><span class='bc' id='L833' title='0|4|4 - Total: 4'>                        paramNames.add(paramName);
</span>                    }
<span class='bc' id='L835' title='0|1|1 - Total: 1'>                } else {
</span><span class='nc' id='L836' title='0|0|0 - Total: 4'>                    fnNode.addParam(makeErrorNode());
</span>                }
            }
<span class='bc' id='L839' title='0|2|2 - Total: 2'>        } while (matchToken(Token.COMMA));
</span>
<span class='bc' id='L841' title='0|2|2 - Total: 2'>        if (destructuring != null) {
</span><span class='bc' id='L842' title='0|5|5 - Total: 5'>            Node destructuringNode = new Node(Token.COMMA);
</span>            // Add assignment helper for each destructuring parameter
<span class='bc' id='L844' title='0|2|2 - Total: 2'>            for (Map.Entry<String, Node> param: destructuring.entrySet()) {
</span><span class='bc' id='L845' title='0|5|5 - Total: 5'>                Node assign = createDestructuringAssignment(Token.VAR,
</span><span class='bc' id='L846' title='0|7|7 - Total: 7'>                        param.getValue(), createName(param.getKey()));
</span><span class='bc' id='L847' title='0|3|3 - Total: 3'>                destructuringNode.addChildToBack(assign);
</span>
<span class='bc' id='L849' title='0|1|1 - Total: 1'>            }
</span><span class='bc' id='L850' title='0|4|4 - Total: 4'>            fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode);
</span>        }

<span class='bpc' id='L853' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.RP, "msg.no.paren.after.parms")) {
</span><span class='bc' id='L854' title='0|8|8 - Total: 8'>            fnNode.setRp(ts.tokenBeg - fnNode.getPosition());
</span>        }
<span class='bc' id='L856' title='0|1|1 - Total: 1'>    }
</span>
    private FunctionNode function(int type)
        throws IOException
    {
<span class='bc' id='L861' title='0|2|2 - Total: 2'>        int syntheticType = type;
</span><span class='bc' id='L862' title='0|4|4 - Total: 4'>        int baseLineno = ts.lineno;  // line number where source starts
</span><span class='bc' id='L863' title='0|4|4 - Total: 4'>        int functionSourceStart = ts.tokenBeg;  // start of "function" kwd
</span><span class='bc' id='L864' title='0|2|2 - Total: 2'>        Name name = null;
</span><span class='bc' id='L865' title='0|2|2 - Total: 2'>        AstNode memberExprNode = null;
</span>
<span class='bc' id='L867' title='0|2|2 - Total: 2'>        if (matchToken(Token.NAME)) {
</span><span class='bc' id='L868' title='0|5|5 - Total: 5'>            name = createNameNode(true, Token.NAME);
</span><span class='bc' id='L869' title='0|2|2 - Total: 2'>            if (inUseStrictDirective) {
</span><span class='bc' id='L870' title='0|3|3 - Total: 3'>                String id = name.getIdentifier();
</span><span class='bpc' id='L871' title='0|2|2 - Total: 4'>                if ("eval".equals(id)|| "arguments".equals(id)) {
</span><span class='nc' id='L872' title='0|0|0 - Total: 4'>                    reportError("msg.bad.id.strict", id);
</span>                }
            }
<span class='bpc' id='L875' title='0|1|1 - Total: 2'>            if (!matchToken(Token.LP)) {
</span><span class='nc' id='L876' title='0|0|0 - Total: 2'>                if (compilerEnv.isAllowMemberExprAsFunctionName()) {
</span><span class='nc' id='L877' title='0|0|0 - Total: 2'>                    AstNode memberExprHead = name;
</span><span class='nc' id='L878' title='0|0|0 - Total: 2'>                    name = null;
</span><span class='nc' id='L879' title='0|0|0 - Total: 5'>                    memberExprNode = memberExprTail(false, memberExprHead);
</span>                }
<span class='nc' id='L881' title='0|0|0 - Total: 6'>                mustMatchToken(Token.LP, "msg.no.paren.parms");
</span>            }
<span class='bc' id='L883' title='0|2|2 - Total: 2'>        } else if (matchToken(Token.LP)) {
</span>            // Anonymous function:  leave name as null
        } else {
<span class='bpc' id='L886' title='0|1|1 - Total: 2'>            if (compilerEnv.isAllowMemberExprAsFunctionName()) {
</span>                // Note that memberExpr can not start with '(' like
                // in function (1+2).toString(), because 'function (' already
                // processed as anonymous function
<span class='nc' id='L890' title='0|0|0 - Total: 4'>                memberExprNode = memberExpr(false);
</span>            }
<span class='nc' id='L892' title='0|0|0 - Total: 5'>            mustMatchToken(Token.LP, "msg.no.paren.parms");
</span>        }
<span class='bpc' id='L894' title='0|1|1 - Total: 2'>        int lpPos = currentToken == Token.LP ? ts.tokenBeg : -1;
</span>
<span class='bpc' id='L896' title='0|1|1 - Total: 2'>        if (memberExprNode != null) {
</span><span class='nc' id='L897' title='0|0|0 - Total: 2'>            syntheticType = FunctionNode.FUNCTION_EXPRESSION;
</span>        }

<span class='bc' id='L900' title='0|4|4 - Total: 4'>        if (syntheticType != FunctionNode.FUNCTION_EXPRESSION
</span><span class='bpc' id='L901' title='0|1|1 - Total: 2'>            && name != null && name.length() > 0) {
</span>            // Function statements define a symbol in the enclosing scope
<span class='bc' id='L903' title='0|5|5 - Total: 5'>            defineSymbol(Token.FUNCTION, name.getIdentifier());
</span>        }

<span class='bc' id='L906' title='0|6|6 - Total: 6'>        FunctionNode fnNode = new FunctionNode(functionSourceStart, name);
</span><span class='bc' id='L907' title='0|3|3 - Total: 3'>        fnNode.setFunctionType(type);
</span><span class='bpc' id='L908' title='0|1|1 - Total: 2'>        if (lpPos != -1)
</span><span class='bc' id='L909' title='0|5|5 - Total: 5'>            fnNode.setLp(lpPos - functionSourceStart);
</span>
<span class='bc' id='L911' title='0|4|4 - Total: 4'>        fnNode.setJsDocNode(getAndResetJsDoc());
</span>
<span class='bc' id='L913' title='0|6|6 - Total: 6'>        PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);
</span>        try {
<span class='bc' id='L915' title='0|3|3 - Total: 3'>            parseFunctionParams(fnNode);
</span><span class='bc' id='L916' title='0|6|6 - Total: 6'>            fnNode.setBody(parseFunctionBody(type, fnNode));
</span><span class='bc' id='L917' title='0|6|6 - Total: 6'>            fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);
</span><span class='bc' id='L918' title='0|7|7 - Total: 7'>            fnNode.setLength(ts.tokenEnd - functionSourceStart);
</span>
<span class='bpc' id='L920' title='0|1|1 - Total: 2'>            if (compilerEnv.isStrictMode()
</span><span class='nc' id='L921' title='0|0|0 - Total: 2'>                && !fnNode.getBody().hasConsistentReturnUsage()) {
</span><span class='nc' id='L922' title='0|0|0 - Total: 4'>                String msg = (name != null && name.length() > 0)
</span>                           ? "msg.no.return.value"
                           : "msg.anon.no.return.value";
<span class='nc' id='L925' title='0|0|0 - Total: 2'>                addStrictWarning(msg, name == null ? "" : name.getIdentifier());
</span>            }
        } finally {
<span class='bc' id='L928' title='0|5|5 - Total: 5'>            savedVars.restore();
</span><span class='bc' id='L929' title='0|3|3 - Total: 3'>        }
</span>
<span class='bpc' id='L931' title='0|1|1 - Total: 2'>        if (memberExprNode != null) {
</span>            // TODO(stevey): fix missing functionality
<span class='nc' id='L933' title='0|0|0 - Total: 2'>            Kit.codeBug();
</span><span class='nc' id='L934' title='0|0|0 - Total: 3'>            fnNode.setMemberExprNode(memberExprNode);  // rewrite later
</span>            /* old code:
            if (memberExprNode != null) {
                pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
                if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
                    // XXX check JScript behavior: should it be createExprStatement?
                    pn = nf.createExprStatementNoReturn(pn, baseLineno);
                }
            }
            */
        }

<span class='bc' id='L946' title='0|4|4 - Total: 4'>        fnNode.setSourceName(sourceURI);
</span><span class='bc' id='L947' title='0|3|3 - Total: 3'>        fnNode.setBaseLineno(baseLineno);
</span><span class='bc' id='L948' title='0|5|5 - Total: 5'>        fnNode.setEndLineno(ts.lineno);
</span>
        // Set the parent scope.  Needed for finding undeclared vars.
        // Have to wait until after parsing the function to set its parent
        // scope, since defineSymbol needs the defining-scope check to stop
        // at the function boundary when checking for redeclarations.
<span class='bpc' id='L954' title='0|1|1 - Total: 2'>        if (compilerEnv.isIdeMode()) {
</span><span class='nc' id='L955' title='0|0|0 - Total: 4'>            fnNode.setParentScope(currentScope);
</span>        }
<span class='bc' id='L957' title='0|2|2 - Total: 2'>        return fnNode;
</span>    }

    private AstNode arrowFunction(AstNode params) throws IOException {
<span class='bc' id='L961' title='0|4|4 - Total: 4'>        int baseLineno = ts.lineno;  // line number where source starts
</span><span class='bpc' id='L962' title='0|1|1 - Total: 2'>        int functionSourceStart = params != null ? params.getPosition() : -1;  // start of "function" kwd
</span>
<span class='bc' id='L964' title='0|5|5 - Total: 5'>        FunctionNode fnNode = new FunctionNode(functionSourceStart);
</span><span class='bc' id='L965' title='0|3|3 - Total: 3'>        fnNode.setFunctionType(FunctionNode.ARROW_FUNCTION);
</span><span class='bc' id='L966' title='0|4|4 - Total: 4'>        fnNode.setJsDocNode(getAndResetJsDoc());
</span>
        // Would prefer not to call createDestructuringAssignment until codegen,
        // but the symbol definitions have to happen now, before body is parsed.
<span class='bc' id='L970' title='0|4|4 - Total: 4'>        Map<String, Node> destructuring = new HashMap<String, Node>();
</span><span class='bc' id='L971' title='0|4|4 - Total: 4'>        Set<String> paramNames = new HashSet<String>();
</span>
<span class='bc' id='L973' title='0|6|6 - Total: 6'>        PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);
</span>        try {
<span class='bc' id='L975' title='0|2|2 - Total: 2'>            if (params instanceof ParenthesizedExpression) {
</span><span class='bc' id='L976' title='0|5|5 - Total: 5'>                fnNode.setParens(0, params.getLength());
</span><span class='bc' id='L977' title='0|4|4 - Total: 4'>                AstNode p = ((ParenthesizedExpression)params).getExpression();
</span><span class='bc' id='L978' title='0|2|2 - Total: 2'>                if (!(p instanceof EmptyExpression)) {
</span><span class='bc' id='L979' title='0|6|6 - Total: 6'>                    arrowFunctionParams(fnNode, p, destructuring, paramNames);
</span>                }
<span class='bc' id='L981' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L982' title='0|6|6 - Total: 6'>                arrowFunctionParams(fnNode, params, destructuring, paramNames);
</span>            }

<span class='bc' id='L985' title='0|2|2 - Total: 2'>            if (!destructuring.isEmpty()) {
</span><span class='bc' id='L986' title='0|5|5 - Total: 5'>                Node destructuringNode = new Node(Token.COMMA);
</span>                // Add assignment helper for each destructuring parameter
<span class='bc' id='L988' title='0|2|2 - Total: 2'>                for (Map.Entry<String, Node> param: destructuring.entrySet()) {
</span><span class='bc' id='L989' title='0|5|5 - Total: 5'>                    Node assign = createDestructuringAssignment(Token.VAR,
</span><span class='bc' id='L990' title='0|7|7 - Total: 7'>                                                                param.getValue(), createName(param.getKey()));
</span><span class='bc' id='L991' title='0|3|3 - Total: 3'>                    destructuringNode.addChildToBack(assign);
</span>
<span class='bc' id='L993' title='0|1|1 - Total: 1'>                }
</span><span class='bc' id='L994' title='0|4|4 - Total: 4'>                fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode);
</span>            }
                
<span class='bc' id='L997' title='0|6|6 - Total: 6'>            fnNode.setBody(parseFunctionBody(FunctionNode.ARROW_FUNCTION, fnNode));
</span><span class='bc' id='L998' title='0|6|6 - Total: 6'>            fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);
</span><span class='bc' id='L999' title='0|7|7 - Total: 7'>            fnNode.setLength(ts.tokenEnd - functionSourceStart);
</span>        } finally {
<span class='bc' id='L1001' title='0|5|5 - Total: 5'>            savedVars.restore();
</span><span class='bc' id='L1002' title='0|3|3 - Total: 3'>        }
</span>
<span class='bpc' id='L1004' title='0|1|1 - Total: 2'>        if (fnNode.isGenerator()) {
</span><span class='nc' id='L1005' title='0|0|0 - Total: 3'>            reportError("msg.arrowfunction.generator");
</span><span class='nc' id='L1006' title='0|0|0 - Total: 3'>            return makeErrorNode();
</span>        }

<span class='bc' id='L1009' title='0|4|4 - Total: 4'>        fnNode.setSourceName(sourceURI);
</span><span class='bc' id='L1010' title='0|3|3 - Total: 3'>        fnNode.setBaseLineno(baseLineno);
</span><span class='bc' id='L1011' title='0|5|5 - Total: 5'>        fnNode.setEndLineno(ts.lineno);
</span>
<span class='bc' id='L1013' title='0|2|2 - Total: 2'>        return fnNode;
</span>    }

    private void arrowFunctionParams(FunctionNode fnNode, AstNode params, Map<String, Node> destructuring, Set<String> paramNames) {
<span class='bc' id='L1017' title='0|4|4 - Total: 4'>        if (params instanceof ArrayLiteral || params instanceof ObjectLiteral) {
</span><span class='bc' id='L1018' title='0|3|3 - Total: 3'>            markDestructuring(params);
</span><span class='bc' id='L1019' title='0|3|3 - Total: 3'>            fnNode.addParam(params);
</span><span class='bc' id='L1020' title='0|4|4 - Total: 4'>            String pname = currentScriptOrFn.getNextTempName();
</span><span class='bc' id='L1021' title='0|5|5 - Total: 5'>            defineSymbol(Token.LP, pname, false);
</span><span class='bc' id='L1022' title='0|5|5 - Total: 5'>            destructuring.put(pname, params);
</span><span class='bpc' id='L1023' title='0|3|3 - Total: 4'>        } else if (params instanceof InfixExpression && params.getType() == Token.COMMA) {
</span><span class='bc' id='L1024' title='0|8|8 - Total: 8'>            arrowFunctionParams(fnNode, ((InfixExpression)params).getLeft(), destructuring, paramNames);
</span><span class='bc' id='L1025' title='0|9|9 - Total: 9'>            arrowFunctionParams(fnNode, ((InfixExpression)params).getRight(), destructuring, paramNames);
</span><span class='bpc' id='L1026' title='0|1|1 - Total: 2'>        } else if (params instanceof Name) {
</span><span class='bc' id='L1027' title='0|3|3 - Total: 3'>            fnNode.addParam(params);
</span><span class='bc' id='L1028' title='0|4|4 - Total: 4'>            String paramName = ((Name)params).getIdentifier();
</span><span class='bc' id='L1029' title='0|4|4 - Total: 4'>            defineSymbol(Token.LP, paramName);
</span>
<span class='bc' id='L1031' title='0|2|2 - Total: 2'>            if (this.inUseStrictDirective) {
</span><span class='bc' id='L1032' title='0|2|2 - Total: 2'>                if ("eval".equals(paramName) ||
</span><span class='bc' id='L1033' title='0|2|2 - Total: 2'>                    "arguments".equals(paramName))
</span>                    {
<span class='nc' id='L1035' title='0|0|0 - Total: 4'>                        reportError("msg.bad.id.strict", paramName);
</span>                    }
<span class='bc' id='L1037' title='0|2|2 - Total: 2'>                if (paramNames.contains(paramName))
</span><span class='nc' id='L1038' title='0|0|0 - Total: 4'>                    addError("msg.dup.param.strict", paramName);
</span><span class='bc' id='L1039' title='0|4|4 - Total: 4'>                paramNames.add(paramName);
</span>            }
<span class='bc' id='L1041' title='0|1|1 - Total: 1'>        } else {
</span><span class='nc' id='L1042' title='0|0|0 - Total: 7'>            reportError("msg.no.parm", params.getPosition(), params.getLength());
</span><span class='nc' id='L1043' title='0|0|0 - Total: 4'>            fnNode.addParam(makeErrorNode());
</span>        }
<span class='bc' id='L1045' title='0|1|1 - Total: 1'>    }
</span>
    // This function does not match the closing RC: the caller matches
    // the RC so it can provide a suitable error message if not matched.
    // This means it's up to the caller to set the length of the node to
    // include the closing RC.  The node start pos is set to the
    // absolute buffer start position, and the caller should fix it up
    // to be relative to the parent node.  All children of this block
    // node are given relative start positions and correct lengths.

    private AstNode statements(AstNode parent) throws IOException {
<span class='bpc' id='L1056' title='0|1|1 - Total: 2'>        if (currentToken != Token.LC  // assertion can be invalid in bad code
</span><span class='nc' id='L1057' title='0|0|0 - Total: 2'>            && !compilerEnv.isIdeMode()) codeBug();
</span><span class='bc' id='L1058' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span><span class='bc' id='L1059' title='0|2|2 - Total: 2'>        AstNode block = parent != null ? parent : new Block(pos);
</span><span class='bc' id='L1060' title='0|5|5 - Total: 5'>        block.setLineno(ts.lineno);
</span>
        int tt;
<span class='bpc' id='L1063' title='0|3|3 - Total: 4'>        while ((tt = peekToken()) > Token.EOF && tt != Token.RC) {
</span><span class='bc' id='L1064' title='0|5|5 - Total: 5'>            block.addChild(statement());
</span>        }
<span class='bc' id='L1066' title='0|7|7 - Total: 7'>        block.setLength(ts.tokenBeg - pos);
</span><span class='bc' id='L1067' title='0|2|2 - Total: 2'>        return block;
</span>    }

    private AstNode statements() throws IOException {
<span class='bc' id='L1071' title='0|4|4 - Total: 4'>        return statements(null);
</span>    }

    private static class ConditionData {
        AstNode condition;
        int lp = -1;
        int rp = -1;
    }

    // parse and return a parenthesized expression
    private ConditionData condition()
        throws IOException
    {
<span class='bc' id='L1084' title='0|5|5 - Total: 5'>        ConditionData data = new ConditionData();
</span>
<span class='bpc' id='L1086' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.LP, "msg.no.paren.cond"))
</span><span class='bc' id='L1087' title='0|5|5 - Total: 5'>            data.lp = ts.tokenBeg;
</span>
<span class='bc' id='L1089' title='0|4|4 - Total: 4'>        data.condition = expr();
</span>
<span class='bpc' id='L1091' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.RP, "msg.no.paren.after.cond"))
</span><span class='bc' id='L1092' title='0|5|5 - Total: 5'>            data.rp = ts.tokenBeg;
</span>
        // Report strict warning on code like "if (a = 7) ...". Suppress the
        // warning if the condition is parenthesized, like "if ((a = 7)) ...".
<span class='bc' id='L1096' title='0|2|2 - Total: 2'>        if (data.condition instanceof Assignment) {
</span><span class='bc' id='L1097' title='0|6|6 - Total: 6'>            addStrictWarning("msg.equal.as.assign", "",
</span><span class='bc' id='L1098' title='0|3|3 - Total: 3'>                             data.condition.getPosition(),
</span><span class='bc' id='L1099' title='0|1|1 - Total: 1'>                             data.condition.getLength());
</span>        }
<span class='bc' id='L1101' title='0|2|2 - Total: 2'>        return data;
</span>    }

    private AstNode statement()
        throws IOException
    {
<span class='bc' id='L1107' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span>        try {
<span class='bc' id='L1109' title='0|3|3 - Total: 3'>            AstNode pn = statementHelper();
</span><span class='bpc' id='L1110' title='0|1|1 - Total: 2'>            if (pn != null) {
</span><span class='bpc' id='L1111' title='0|3|3 - Total: 4'>                if (compilerEnv.isStrictMode() && !pn.hasSideEffects()) {
</span><span class='nc' id='L1112' title='0|0|0 - Total: 3'>                    int beg = pn.getPosition();
</span><span class='nc' id='L1113' title='0|0|0 - Total: 6'>                    beg = Math.max(beg, lineBeginningFor(beg));
</span><span class='nc' id='L1114' title='0|0|0 - Total: 2'>                    addStrictWarning(pn instanceof EmptyStatement
</span>                                     ? "msg.extra.trailing.semi"
                                     : "msg.no.side.effects",
<span class='nc' id='L1117' title='0|0|0 - Total: 3'>                                     "", beg, nodeEnd(pn) - beg);
</span>                }
<span class='bc' id='L1119' title='0|2|2 - Total: 2'>                return pn;
</span>            }
<span class='bc' id='L1121' title='0|1|1 - Total: 1'>        } catch (ParserException e) {
</span>            // an ErrorNode was added to the ErrorReporter
<span class='nc' id='L1123' title='0|0|0 - Total: 1'>        }
</span>
        // error:  skip ahead to a probable statement boundary
        guessingStatementEnd: for (;;) {
<span class='bc' id='L1127' title='0|3|3 - Total: 3'>            int tt = peekTokenOrEOL();
</span><span class='bc' id='L1128' title='0|2|2 - Total: 2'>            consumeToken();
</span><span class='bc' id='L1129' title='0|2|2 - Total: 2'>            switch (tt) {
</span>              case Token.ERROR:
              case Token.EOF:
              case Token.EOL:
              case Token.SEMI:
<span class='bc' id='L1134' title='0|1|1 - Total: 1'>                break guessingStatementEnd;
</span>            }
<span class='bc' id='L1136' title='0|1|1 - Total: 1'>        }
</span>        // We don't make error nodes explicitly part of the tree;
        // they get added to the ErrorReporter.  May need to do
        // something different here.
<span class='bc' id='L1140' title='0|10|10 - Total: 10'>        return new EmptyStatement(pos, ts.tokenBeg - pos);
</span>    }

    private AstNode statementHelper()
        throws IOException
    {
        // If the statement is set, then it's been told its label by now.
<span class='bc' id='L1147' title='0|4|4 - Total: 4'>        if (currentLabel != null && currentLabel.getStatement() != null)
</span><span class='bc' id='L1148' title='0|3|3 - Total: 3'>            currentLabel = null;
</span>
<span class='bc' id='L1150' title='0|2|2 - Total: 2'>        AstNode pn = null;
</span><span class='bc' id='L1151' title='0|7|7 - Total: 7'>        int tt = peekToken(), pos = ts.tokenBeg;
</span>
<span class='bpc' id='L1153' title='0|20|20 - Total: 21'>        switch (tt) {
</span>          case Token.IF:
<span class='bc' id='L1155' title='0|3|3 - Total: 3'>              return ifStatement();
</span>
          case Token.SWITCH:
<span class='bc' id='L1158' title='0|3|3 - Total: 3'>              return switchStatement();
</span>
          case Token.WHILE:
<span class='bc' id='L1161' title='0|3|3 - Total: 3'>              return whileLoop();
</span>
          case Token.DO:
<span class='bc' id='L1164' title='0|3|3 - Total: 3'>              return doLoop();
</span>
          case Token.FOR:
<span class='bc' id='L1167' title='0|3|3 - Total: 3'>              return forLoop();
</span>
          case Token.TRY:
<span class='bc' id='L1170' title='0|3|3 - Total: 3'>              return tryStatement();
</span>
          case Token.THROW:
<span class='bc' id='L1173' title='0|3|3 - Total: 3'>              pn = throwStatement();
</span><span class='bc' id='L1174' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.BREAK:
<span class='bc' id='L1177' title='0|3|3 - Total: 3'>              pn = breakStatement();
</span><span class='bc' id='L1178' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.CONTINUE:
<span class='bc' id='L1181' title='0|3|3 - Total: 3'>              pn = continueStatement();
</span><span class='bc' id='L1182' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.WITH:
<span class='bpc' id='L1185' title='0|1|1 - Total: 2'>              if (this.inUseStrictDirective) {
</span><span class='nc' id='L1186' title='0|0|0 - Total: 3'>                  reportError("msg.no.with.strict");
</span>              }
<span class='bc' id='L1188' title='0|3|3 - Total: 3'>              return withStatement();
</span>
          case Token.CONST:
          case Token.VAR:
<span class='bc' id='L1192' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L1193' title='0|4|4 - Total: 4'>              int lineno = ts.lineno;
</span><span class='bc' id='L1194' title='0|9|9 - Total: 9'>              pn = variables(currentToken, ts.tokenBeg, true);
</span><span class='bc' id='L1195' title='0|3|3 - Total: 3'>              pn.setLineno(lineno);
</span><span class='bc' id='L1196' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.LET:
<span class='bc' id='L1199' title='0|3|3 - Total: 3'>              pn = letStatement();
</span><span class='bc' id='L1200' title='0|2|2 - Total: 2'>              if (pn instanceof VariableDeclaration
</span><span class='bc' id='L1201' title='0|2|2 - Total: 2'>                  && peekToken() == Token.SEMI)
</span><span class='bc' id='L1202' title='0|1|1 - Total: 1'>                  break;
</span><span class='bc' id='L1203' title='0|2|2 - Total: 2'>              return pn;
</span>
          case Token.RETURN:
          case Token.YIELD:
<span class='bc' id='L1207' title='0|5|5 - Total: 5'>              pn = returnOrYield(tt, false);
</span><span class='bc' id='L1208' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.DEBUGGER:
<span class='bc' id='L1211' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L1212' title='0|15|15 - Total: 15'>              pn = new KeywordLiteral(ts.tokenBeg,
</span>                                      ts.tokenEnd - ts.tokenBeg, tt);
<span class='bc' id='L1214' title='0|5|5 - Total: 5'>              pn.setLineno(ts.lineno);
</span><span class='bc' id='L1215' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.LC:
<span class='bc' id='L1218' title='0|3|3 - Total: 3'>              return block();
</span>
          case Token.ERROR:
<span class='nc' id='L1221' title='0|0|0 - Total: 2'>              consumeToken();
</span><span class='nc' id='L1222' title='0|0|0 - Total: 3'>              return makeErrorNode();
</span>
          case Token.SEMI:
<span class='bc' id='L1225' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L1226' title='0|4|4 - Total: 4'>              pos = ts.tokenBeg;
</span><span class='bc' id='L1227' title='0|10|10 - Total: 10'>              pn = new EmptyStatement(pos, ts.tokenEnd - pos);
</span><span class='bc' id='L1228' title='0|5|5 - Total: 5'>              pn.setLineno(ts.lineno);
</span><span class='bc' id='L1229' title='0|2|2 - Total: 2'>              return pn;
</span>
          case Token.FUNCTION:
<span class='bc' id='L1232' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L1233' title='0|4|4 - Total: 4'>              return function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);
</span>
          case Token.DEFAULT :
<span class='bc' id='L1236' title='0|3|3 - Total: 3'>              pn = defaultXmlNamespace();
</span><span class='bc' id='L1237' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.NAME:
<span class='bc' id='L1240' title='0|3|3 - Total: 3'>              pn = nameOrLabel();
</span><span class='bc' id='L1241' title='0|2|2 - Total: 2'>              if (pn instanceof ExpressionStatement)
</span><span class='bc' id='L1242' title='0|1|1 - Total: 1'>                  break;
</span><span class='bc' id='L1243' title='0|2|2 - Total: 2'>              return pn;  // LabeledStatement
</span>
          default:
<span class='bc' id='L1246' title='0|4|4 - Total: 4'>              lineno = ts.lineno;
</span><span class='bc' id='L1247' title='0|2|2 - Total: 2'>              pn = new ExpressionStatement(expr(), !insideFunction());
</span><span class='bc' id='L1248' title='0|3|3 - Total: 3'>              pn.setLineno(lineno);
</span>              break;
        }

<span class='bc' id='L1252' title='0|3|3 - Total: 3'>        autoInsertSemicolon(pn);
</span><span class='bc' id='L1253' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private void autoInsertSemicolon(AstNode pn) throws IOException {
<span class='bc' id='L1257' title='0|3|3 - Total: 3'>        int ttFlagged = peekFlaggedToken();
</span><span class='bc' id='L1258' title='0|3|3 - Total: 3'>        int pos = pn.getPosition();
</span><span class='bc' id='L1259' title='0|3|3 - Total: 3'>        switch (ttFlagged & CLEAR_TI_MASK) {
</span>          case Token.SEMI:
              // Consume ';' as a part of expression
<span class='bc' id='L1262' title='0|2|2 - Total: 2'>              consumeToken();
</span>              // extend the node bounds to include the semicolon.
<span class='bc' id='L1264' title='0|7|7 - Total: 7'>              pn.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L1265' title='0|1|1 - Total: 1'>              break;
</span>          case Token.ERROR:
          case Token.EOF:
          case Token.RC:
              // Autoinsert ;
<span class='bc' id='L1270' title='0|6|6 - Total: 6'>              warnMissingSemi(pos, nodeEnd(pn));
</span><span class='bc' id='L1271' title='0|1|1 - Total: 1'>              break;
</span>          default:
<span class='bc' id='L1273' title='0|2|2 - Total: 2'>              if ((ttFlagged & TI_AFTER_EOL) == 0) {
</span>                  // Report error if no EOL or autoinsert ; otherwise
<span class='bc' id='L1275' title='0|4|4 - Total: 4'>                  reportError("msg.no.semi.stmt");
</span>              } else {
<span class='bc' id='L1277' title='0|6|6 - Total: 6'>                  warnMissingSemi(pos, nodeEnd(pn));
</span>              }
              break;
        }
<span class='bc' id='L1281' title='0|1|1 - Total: 1'>    }
</span>
    private IfStatement ifStatement()
        throws IOException
    {
<span class='bpc' id='L1286' title='0|1|1 - Total: 2'>        if (currentToken != Token.IF) codeBug();
</span><span class='bc' id='L1287' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1288' title='0|10|10 - Total: 10'>        int pos = ts.tokenBeg, lineno = ts.lineno, elsePos = -1;
</span><span class='bc' id='L1289' title='0|3|3 - Total: 3'>        ConditionData data = condition();
</span><span class='bc' id='L1290' title='0|5|5 - Total: 5'>        AstNode ifTrue = statement(), ifFalse = null;
</span><span class='bc' id='L1291' title='0|2|2 - Total: 2'>        if (matchToken(Token.ELSE)) {
</span><span class='bc' id='L1292' title='0|6|6 - Total: 6'>            elsePos = ts.tokenBeg - pos;
</span><span class='bc' id='L1293' title='0|3|3 - Total: 3'>            ifFalse = statement();
</span>        }
<span class='bc' id='L1295' title='0|2|2 - Total: 2'>        int end = getNodeEnd(ifFalse != null ? ifFalse : ifTrue);
</span><span class='bc' id='L1296' title='0|8|8 - Total: 8'>        IfStatement pn = new IfStatement(pos, end - pos);
</span><span class='bc' id='L1297' title='0|4|4 - Total: 4'>        pn.setCondition(data.condition);
</span><span class='bc' id='L1298' title='0|10|10 - Total: 10'>        pn.setParens(data.lp - pos, data.rp - pos);
</span><span class='bc' id='L1299' title='0|3|3 - Total: 3'>        pn.setThenPart(ifTrue);
</span><span class='bc' id='L1300' title='0|3|3 - Total: 3'>        pn.setElsePart(ifFalse);
</span><span class='bc' id='L1301' title='0|3|3 - Total: 3'>        pn.setElsePosition(elsePos);
</span><span class='bc' id='L1302' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1303' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private SwitchStatement switchStatement()
        throws IOException
    {
<span class='bpc' id='L1309' title='0|1|1 - Total: 2'>        if (currentToken != Token.SWITCH) codeBug();
</span><span class='bc' id='L1310' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1311' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span>
<span class='bc' id='L1313' title='0|5|5 - Total: 5'>        SwitchStatement pn = new SwitchStatement(pos);
</span><span class='bpc' id='L1314' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.LP, "msg.no.paren.switch"))
</span><span class='bc' id='L1315' title='0|7|7 - Total: 7'>            pn.setLp(ts.tokenBeg - pos);
</span><span class='bc' id='L1316' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span>
<span class='bc' id='L1318' title='0|3|3 - Total: 3'>        AstNode discriminant = expr();
</span><span class='bc' id='L1319' title='0|3|3 - Total: 3'>        pn.setExpression(discriminant);
</span><span class='bc' id='L1320' title='0|3|3 - Total: 3'>        enterSwitch(pn);
</span>
        try {
<span class='bpc' id='L1323' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.RP, "msg.no.paren.after.switch"))
</span><span class='bc' id='L1324' title='0|7|7 - Total: 7'>                pn.setRp(ts.tokenBeg - pos);
</span>
<span class='bc' id='L1326' title='0|5|5 - Total: 5'>            mustMatchToken(Token.LC, "msg.no.brace.switch");
</span>
<span class='bc' id='L1328' title='0|2|2 - Total: 2'>            boolean hasDefault = false;
</span>            int tt;
            switchLoop: for (;;) {
<span class='bc' id='L1331' title='0|3|3 - Total: 3'>                tt = nextToken();
</span><span class='bc' id='L1332' title='0|4|4 - Total: 4'>                int casePos = ts.tokenBeg;
</span><span class='bc' id='L1333' title='0|4|4 - Total: 4'>                int caseLineno = ts.lineno;
</span><span class='bc' id='L1334' title='0|2|2 - Total: 2'>                AstNode caseExpression = null;
</span><span class='bpc' id='L1335' title='0|3|3 - Total: 4'>                switch (tt) {
</span>                    case Token.RC:
<span class='bc' id='L1337' title='0|7|7 - Total: 7'>                        pn.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L1338' title='0|1|1 - Total: 1'>                        break switchLoop;
</span>
                    case Token.CASE:
<span class='bc' id='L1341' title='0|3|3 - Total: 3'>                        caseExpression = expr();
</span><span class='bc' id='L1342' title='0|5|5 - Total: 5'>                        mustMatchToken(Token.COLON, "msg.no.colon.case");
</span><span class='bc' id='L1343' title='0|1|1 - Total: 1'>                        break;
</span>
                    case Token.DEFAULT:
<span class='bpc' id='L1346' title='0|1|1 - Total: 2'>                        if (hasDefault) {
</span><span class='nc' id='L1347' title='0|0|0 - Total: 3'>                            reportError("msg.double.switch.default");
</span>                        }
<span class='bc' id='L1349' title='0|2|2 - Total: 2'>                        hasDefault = true;
</span><span class='bc' id='L1350' title='0|2|2 - Total: 2'>                        caseExpression = null;
</span><span class='bc' id='L1351' title='0|5|5 - Total: 5'>                        mustMatchToken(Token.COLON, "msg.no.colon.case");
</span><span class='bc' id='L1352' title='0|1|1 - Total: 1'>                        break;
</span>
                    default:
<span class='nc' id='L1355' title='0|0|0 - Total: 3'>                        reportError("msg.bad.switch");
</span><span class='nc' id='L1356' title='0|0|0 - Total: 1'>                        break switchLoop;
</span>                }

<span class='bc' id='L1359' title='0|5|5 - Total: 5'>                SwitchCase caseNode = new SwitchCase(casePos);
</span><span class='bc' id='L1360' title='0|3|3 - Total: 3'>                caseNode.setExpression(caseExpression);
</span><span class='bc' id='L1361' title='0|7|7 - Total: 7'>                caseNode.setLength(ts.tokenEnd - pos);  // include colon
</span><span class='bc' id='L1362' title='0|3|3 - Total: 3'>                caseNode.setLineno(caseLineno);
</span>
<span class='bpc' id='L1364' title='0|7|7 - Total: 8'>                while ((tt = peekToken()) != Token.RC
</span>                       && tt != Token.CASE
                       && tt != Token.DEFAULT
                       && tt != Token.EOF)
                {
<span class='bc' id='L1369' title='0|5|5 - Total: 5'>                    caseNode.addStatement(statement());  // updates length
</span>                }
<span class='bc' id='L1371' title='0|3|3 - Total: 3'>                pn.addCase(caseNode);
</span><span class='bc' id='L1372' title='0|1|1 - Total: 1'>            }
</span>        } finally {
<span class='bc' id='L1374' title='0|5|5 - Total: 5'>            exitSwitch();
</span><span class='bc' id='L1375' title='0|3|3 - Total: 3'>        }
</span><span class='bc' id='L1376' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private WhileLoop whileLoop()
        throws IOException
    {
<span class='bpc' id='L1382' title='0|1|1 - Total: 2'>        if (currentToken != Token.WHILE) codeBug();
</span><span class='bc' id='L1383' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1384' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span><span class='bc' id='L1385' title='0|5|5 - Total: 5'>        WhileLoop pn = new WhileLoop(pos);
</span><span class='bc' id='L1386' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span><span class='bc' id='L1387' title='0|3|3 - Total: 3'>        enterLoop(pn);
</span>        try {
<span class='bc' id='L1389' title='0|3|3 - Total: 3'>            ConditionData data = condition();
</span><span class='bc' id='L1390' title='0|4|4 - Total: 4'>            pn.setCondition(data.condition);
</span><span class='bc' id='L1391' title='0|10|10 - Total: 10'>            pn.setParens(data.lp - pos, data.rp - pos);
</span><span class='bc' id='L1392' title='0|3|3 - Total: 3'>            AstNode body = statement();
</span><span class='bc' id='L1393' title='0|7|7 - Total: 7'>            pn.setLength(getNodeEnd(body) - pos);
</span><span class='bc' id='L1394' title='0|3|3 - Total: 3'>            pn.setBody(body);
</span>        } finally {
<span class='bc' id='L1396' title='0|5|5 - Total: 5'>            exitLoop();
</span><span class='bc' id='L1397' title='0|3|3 - Total: 3'>        }
</span><span class='bc' id='L1398' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private DoLoop doLoop()
        throws IOException
    {
<span class='bpc' id='L1404' title='0|1|1 - Total: 2'>        if (currentToken != Token.DO) codeBug();
</span><span class='bc' id='L1405' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1406' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg, end;
</span><span class='bc' id='L1407' title='0|5|5 - Total: 5'>        DoLoop pn = new DoLoop(pos);
</span><span class='bc' id='L1408' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span><span class='bc' id='L1409' title='0|3|3 - Total: 3'>        enterLoop(pn);
</span>        try {
<span class='bc' id='L1411' title='0|3|3 - Total: 3'>            AstNode body = statement();
</span><span class='bc' id='L1412' title='0|5|5 - Total: 5'>            mustMatchToken(Token.WHILE, "msg.no.while.do");
</span><span class='bc' id='L1413' title='0|7|7 - Total: 7'>            pn.setWhilePosition(ts.tokenBeg - pos);
</span><span class='bc' id='L1414' title='0|3|3 - Total: 3'>            ConditionData data = condition();
</span><span class='bc' id='L1415' title='0|4|4 - Total: 4'>            pn.setCondition(data.condition);
</span><span class='bc' id='L1416' title='0|10|10 - Total: 10'>            pn.setParens(data.lp - pos, data.rp - pos);
</span><span class='bc' id='L1417' title='0|4|4 - Total: 4'>            end = getNodeEnd(body);
</span><span class='bc' id='L1418' title='0|3|3 - Total: 3'>            pn.setBody(body);
</span>        } finally {
<span class='bc' id='L1420' title='0|5|5 - Total: 5'>            exitLoop();
</span><span class='bc' id='L1421' title='0|3|3 - Total: 3'>        }
</span>        // Always auto-insert semicolon to follow SpiderMonkey:
        // It is required by ECMAScript but is ignored by the rest of
        // world, see bug 238945
<span class='bc' id='L1425' title='0|2|2 - Total: 2'>        if (matchToken(Token.SEMI)) {
</span><span class='bc' id='L1426' title='0|4|4 - Total: 4'>            end = ts.tokenEnd;
</span>        }
<span class='bc' id='L1428' title='0|5|5 - Total: 5'>        pn.setLength(end - pos);
</span><span class='bc' id='L1429' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private Loop forLoop()
        throws IOException
    {
<span class='bpc' id='L1435' title='0|1|1 - Total: 2'>        if (currentToken != Token.FOR) codeBug();
</span><span class='bc' id='L1436' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1437' title='0|8|8 - Total: 8'>        int forPos = ts.tokenBeg, lineno = ts.lineno;
</span><span class='bc' id='L1438' title='0|6|6 - Total: 6'>        boolean isForEach = false, isForIn = false, isForOf = false;
</span><span class='bc' id='L1439' title='0|8|8 - Total: 8'>        int eachPos = -1, inPos = -1, lp = -1, rp = -1;
</span><span class='bc' id='L1440' title='0|2|2 - Total: 2'>        AstNode init = null;  // init is also foo in 'foo in object'
</span><span class='bc' id='L1441' title='0|2|2 - Total: 2'>        AstNode cond = null;  // cond is also object in 'foo in object'
</span><span class='bc' id='L1442' title='0|2|2 - Total: 2'>        AstNode incr = null;
</span><span class='bc' id='L1443' title='0|2|2 - Total: 2'>        Loop pn = null;
</span>
<span class='bc' id='L1445' title='0|4|4 - Total: 4'>        Scope tempScope = new Scope();
</span><span class='bc' id='L1446' title='0|3|3 - Total: 3'>        pushScope(tempScope);  // decide below what AST class to use
</span>        try {
            // See if this is a for each () instead of just a for ()
<span class='bc' id='L1449' title='0|2|2 - Total: 2'>            if (matchToken(Token.NAME)) {
</span><span class='bpc' id='L1450' title='0|1|1 - Total: 2'>                if ("each".equals(ts.getString())) {
</span><span class='bc' id='L1451' title='0|2|2 - Total: 2'>                    isForEach = true;
</span><span class='bc' id='L1452' title='0|7|7 - Total: 7'>                    eachPos = ts.tokenBeg - forPos;
</span>                } else {
<span class='nc' id='L1454' title='0|0|0 - Total: 3'>                    reportError("msg.no.paren.for");
</span>                }
            }

<span class='bpc' id='L1458' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.LP, "msg.no.paren.for"))
</span><span class='bc' id='L1459' title='0|6|6 - Total: 6'>                lp = ts.tokenBeg - forPos;
</span><span class='bc' id='L1460' title='0|3|3 - Total: 3'>            int tt = peekToken();
</span>
<span class='bc' id='L1462' title='0|4|4 - Total: 4'>            init = forLoopInit(tt);
</span><span class='bc' id='L1463' title='0|2|2 - Total: 2'>            if (matchToken(Token.IN)) {
</span><span class='bc' id='L1464' title='0|2|2 - Total: 2'>                isForIn = true;
</span><span class='bc' id='L1465' title='0|6|6 - Total: 6'>                inPos = ts.tokenBeg - forPos;
</span><span class='bc' id='L1466' title='0|4|4 - Total: 4'>                cond = expr();  // object over which we're iterating
</span><span class='bc' id='L1467' title='0|2|2 - Total: 2'>            } else if (compilerEnv.getLanguageVersion() >= Context.VERSION_ES6 &&
</span><span class='bpc' id='L1468' title='0|3|3 - Total: 4'>                       matchToken(Token.NAME) && "of".equals(ts.getString())) {
</span><span class='bc' id='L1469' title='0|2|2 - Total: 2'>                isForOf = true;
</span><span class='bc' id='L1470' title='0|6|6 - Total: 6'>                inPos = ts.tokenBeg - forPos;
</span><span class='bc' id='L1471' title='0|4|4 - Total: 4'>                cond = expr();  // object over which we're iterating
</span>            } else {  // ordinary for-loop
<span class='bc' id='L1473' title='0|5|5 - Total: 5'>                mustMatchToken(Token.SEMI, "msg.no.semi.for");
</span><span class='bc' id='L1474' title='0|2|2 - Total: 2'>                if (peekToken() == Token.SEMI) {
</span>                    // no loop condition
<span class='bc' id='L1476' title='0|8|8 - Total: 8'>                    cond = new EmptyExpression(ts.tokenBeg, 1);
</span><span class='bc' id='L1477' title='0|6|6 - Total: 6'>                    cond.setLineno(ts.lineno);
</span>                } else {
<span class='bc' id='L1479' title='0|3|3 - Total: 3'>                    cond = expr();
</span>                }

<span class='bc' id='L1482' title='0|5|5 - Total: 5'>                mustMatchToken(Token.SEMI, "msg.no.semi.for.cond");
</span><span class='bc' id='L1483' title='0|4|4 - Total: 4'>                int tmpPos = ts.tokenEnd;
</span><span class='bc' id='L1484' title='0|2|2 - Total: 2'>                if (peekToken() == Token.RP) {
</span><span class='bc' id='L1485' title='0|6|6 - Total: 6'>                    incr = new EmptyExpression(tmpPos, 1);
</span><span class='bc' id='L1486' title='0|6|6 - Total: 6'>                    incr.setLineno(ts.lineno);
</span>                } else {
<span class='bc' id='L1488' title='0|3|3 - Total: 3'>                    incr = expr();
</span>                }
            }

<span class='bpc' id='L1492' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.RP, "msg.no.paren.for.ctrl"))
</span><span class='bc' id='L1493' title='0|6|6 - Total: 6'>                rp = ts.tokenBeg - forPos;
</span>
<span class='bc' id='L1495' title='0|4|4 - Total: 4'>            if (isForIn || isForOf) {
</span><span class='bc' id='L1496' title='0|5|5 - Total: 5'>                ForInLoop fis = new ForInLoop(forPos);
</span><span class='bc' id='L1497' title='0|2|2 - Total: 2'>                if (init instanceof VariableDeclaration) {
</span>                    // check that there was only one variable given
<span class='bc' id='L1499' title='0|2|2 - Total: 2'>                    if (((VariableDeclaration)init).getVariables().size() > 1) {
</span><span class='nc' id='L1500' title='0|0|0 - Total: 3'>                        reportError("msg.mult.index");
</span>                    }
                }
<span class='bc' id='L1503' title='0|4|4 - Total: 4'>                if (isForOf && isForEach) {
</span><span class='nc' id='L1504' title='0|0|0 - Total: 3'>                    reportError("msg.invalid.for.each");
</span>                }
<span class='bc' id='L1506' title='0|3|3 - Total: 3'>                fis.setIterator(init);
</span><span class='bc' id='L1507' title='0|3|3 - Total: 3'>                fis.setIteratedObject(cond);
</span><span class='bc' id='L1508' title='0|3|3 - Total: 3'>                fis.setInPosition(inPos);
</span><span class='bc' id='L1509' title='0|3|3 - Total: 3'>                fis.setIsForEach(isForEach);
</span><span class='bc' id='L1510' title='0|3|3 - Total: 3'>                fis.setEachPosition(eachPos);
</span><span class='bc' id='L1511' title='0|3|3 - Total: 3'>                fis.setIsForOf(isForOf);
</span><span class='bc' id='L1512' title='0|2|2 - Total: 2'>                pn = fis;
</span><span class='bc' id='L1513' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L1514' title='0|5|5 - Total: 5'>                ForLoop fl = new ForLoop(forPos);
</span><span class='bc' id='L1515' title='0|3|3 - Total: 3'>                fl.setInitializer(init);
</span><span class='bc' id='L1516' title='0|3|3 - Total: 3'>                fl.setCondition(cond);
</span><span class='bc' id='L1517' title='0|3|3 - Total: 3'>                fl.setIncrement(incr);
</span><span class='bc' id='L1518' title='0|2|2 - Total: 2'>                pn = fl;
</span>            }

            // replace temp scope with the new loop object
<span class='bc' id='L1522' title='0|4|4 - Total: 4'>            currentScope.replaceWith(pn);
</span><span class='bc' id='L1523' title='0|2|2 - Total: 2'>            popScope();
</span>
            // We have to parse the body -after- creating the loop node,
            // so that the loop node appears in the loopSet, allowing
            // break/continue statements to find the enclosing loop.
<span class='bc' id='L1528' title='0|3|3 - Total: 3'>            enterLoop(pn);
</span>            try {
<span class='bc' id='L1530' title='0|3|3 - Total: 3'>                AstNode body = statement();
</span><span class='bc' id='L1531' title='0|7|7 - Total: 7'>                pn.setLength(getNodeEnd(body) - forPos);
</span><span class='bc' id='L1532' title='0|3|3 - Total: 3'>                pn.setBody(body);
</span>            } finally {
<span class='bc' id='L1534' title='0|5|5 - Total: 5'>                exitLoop();
</span><span class='bc' id='L1535' title='0|3|3 - Total: 3'>            }
</span>
        } finally {
<span class='bpc' id='L1538' title='0|3|3 - Total: 4'>            if (currentScope == tempScope) {
</span><span class='bpc' id='L1539' title='0|2|2 - Total: 5'>                popScope();
</span>            }
<span class='bc' id='L1541' title='0|2|2 - Total: 2'>        }
</span><span class='bc' id='L1542' title='0|4|4 - Total: 4'>        pn.setParens(lp, rp);
</span><span class='bc' id='L1543' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1544' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode forLoopInit(int tt) throws IOException {
        try {
<span class='bc' id='L1549' title='0|3|3 - Total: 3'>            inForInit = true;  // checked by variables() and relExpr()
</span><span class='bc' id='L1550' title='0|2|2 - Total: 2'>            AstNode init = null;
</span><span class='bc' id='L1551' title='0|2|2 - Total: 2'>            if (tt == Token.SEMI) {
</span><span class='bc' id='L1552' title='0|8|8 - Total: 8'>                init = new EmptyExpression(ts.tokenBeg, 1);
</span><span class='bc' id='L1553' title='0|6|6 - Total: 6'>                init.setLineno(ts.lineno);
</span><span class='bc' id='L1554' title='0|4|4 - Total: 4'>            } else if (tt == Token.VAR || tt == Token.LET) {
</span><span class='bc' id='L1555' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L1556' title='0|9|9 - Total: 9'>                init = variables(tt, ts.tokenBeg, false);
</span>            } else {
<span class='bc' id='L1558' title='0|3|3 - Total: 3'>                init = expr();
</span><span class='bc' id='L1559' title='0|3|3 - Total: 3'>                markDestructuring(init);
</span>            }
<span class='bc' id='L1561' title='0|4|4 - Total: 4'>            return init;
</span>        } finally {
<span class='bc' id='L1563' title='0|7|7 - Total: 7'>            inForInit = false;
</span><span class='bc' id='L1564' title='0|2|2 - Total: 2'>        }
</span>    }

    private TryStatement tryStatement()
        throws IOException
    {
<span class='bpc' id='L1570' title='0|1|1 - Total: 2'>        if (currentToken != Token.TRY) codeBug();
</span><span class='bc' id='L1571' title='0|2|2 - Total: 2'>        consumeToken();
</span>
        // Pull out JSDoc info and reset it before recursing.
<span class='bc' id='L1574' title='0|3|3 - Total: 3'>        Comment jsdocNode = getAndResetJsDoc();
</span>
<span class='bc' id='L1576' title='0|10|10 - Total: 10'>        int tryPos = ts.tokenBeg, lineno = ts.lineno, finallyPos = -1;
</span><span class='bc' id='L1577' title='0|2|2 - Total: 2'>        if (peekToken() != Token.LC) {
</span><span class='nc' id='L1578' title='0|0|0 - Total: 3'>            reportError("msg.no.brace.try");
</span>        }
<span class='bc' id='L1580' title='0|3|3 - Total: 3'>        AstNode tryBlock = statement();
</span><span class='bc' id='L1581' title='0|4|4 - Total: 4'>        int tryEnd = getNodeEnd(tryBlock);
</span>
<span class='bc' id='L1583' title='0|2|2 - Total: 2'>        List<CatchClause> clauses = null;
</span>
<span class='bc' id='L1585' title='0|2|2 - Total: 2'>        boolean sawDefaultCatch = false;
</span><span class='bc' id='L1586' title='0|3|3 - Total: 3'>        int peek = peekToken();
</span><span class='bc' id='L1587' title='0|2|2 - Total: 2'>        if (peek == Token.CATCH) {
</span><span class='bc' id='L1588' title='0|2|2 - Total: 2'>            while (matchToken(Token.CATCH)) {
</span><span class='bc' id='L1589' title='0|4|4 - Total: 4'>                int catchLineNum = ts.lineno;
</span><span class='bc' id='L1590' title='0|2|2 - Total: 2'>                if (sawDefaultCatch) {
</span><span class='nc' id='L1591' title='0|0|0 - Total: 3'>                    reportError("msg.catch.unreachable");
</span>                }
<span class='bc' id='L1593' title='0|10|10 - Total: 10'>                int catchPos = ts.tokenBeg, lp = -1, rp = -1, guardPos = -1;
</span><span class='bpc' id='L1594' title='0|1|1 - Total: 2'>                if (mustMatchToken(Token.LP, "msg.no.paren.catch"))
</span><span class='bc' id='L1595' title='0|4|4 - Total: 4'>                    lp = ts.tokenBeg;
</span>
<span class='bc' id='L1597' title='0|5|5 - Total: 5'>                mustMatchToken(Token.NAME, "msg.bad.catchcond");
</span>
<span class='bc' id='L1599' title='0|3|3 - Total: 3'>                Name varName = createNameNode();
</span><span class='bc' id='L1600' title='0|3|3 - Total: 3'>                Comment jsdocNodeForName = getAndResetJsDoc();
</span><span class='bc' id='L1601' title='0|2|2 - Total: 2'>                if (jsdocNodeForName != null) {
</span><span class='bc' id='L1602' title='0|3|3 - Total: 3'>                  varName.setJsDocNode(jsdocNodeForName);
</span>                }
<span class='bc' id='L1604' title='0|3|3 - Total: 3'>                String varNameString = varName.getIdentifier();
</span><span class='bc' id='L1605' title='0|2|2 - Total: 2'>                if (inUseStrictDirective) {
</span><span class='bpc' id='L1606' title='0|1|1 - Total: 2'>                    if ("eval".equals(varNameString) ||
</span><span class='bpc' id='L1607' title='0|1|1 - Total: 2'>                        "arguments".equals(varNameString))
</span>                    {
<span class='nc' id='L1609' title='0|0|0 - Total: 4'>                        reportError("msg.bad.id.strict", varNameString);
</span>                    }
                }

<span class='bc' id='L1613' title='0|2|2 - Total: 2'>                AstNode catchCond = null;
</span><span class='bc' id='L1614' title='0|2|2 - Total: 2'>                if (matchToken(Token.IF)) {
</span><span class='bc' id='L1615' title='0|4|4 - Total: 4'>                    guardPos = ts.tokenBeg;
</span><span class='bc' id='L1616' title='0|4|4 - Total: 4'>                    catchCond = expr();
</span>                } else {
<span class='bc' id='L1618' title='0|2|2 - Total: 2'>                    sawDefaultCatch = true;
</span>                }

<span class='bpc' id='L1621' title='0|1|1 - Total: 2'>                if (mustMatchToken(Token.RP, "msg.bad.catchcond"))
</span><span class='bc' id='L1622' title='0|4|4 - Total: 4'>                    rp = ts.tokenBeg;
</span><span class='bc' id='L1623' title='0|5|5 - Total: 5'>                mustMatchToken(Token.LC, "msg.no.brace.catchblock");
</span>
<span class='bc' id='L1625' title='0|4|4 - Total: 4'>                Block catchBlock = (Block)statements();
</span><span class='bc' id='L1626' title='0|4|4 - Total: 4'>                tryEnd = getNodeEnd(catchBlock);
</span><span class='bc' id='L1627' title='0|5|5 - Total: 5'>                CatchClause catchNode = new CatchClause(catchPos);
</span><span class='bc' id='L1628' title='0|3|3 - Total: 3'>                catchNode.setVarName(varName);
</span><span class='bc' id='L1629' title='0|3|3 - Total: 3'>                catchNode.setCatchCondition(catchCond);
</span><span class='bc' id='L1630' title='0|3|3 - Total: 3'>                catchNode.setBody(catchBlock);
</span><span class='bc' id='L1631' title='0|2|2 - Total: 2'>                if (guardPos != -1) {
</span><span class='bc' id='L1632' title='0|5|5 - Total: 5'>                    catchNode.setIfPosition(guardPos - catchPos);
</span>                }
<span class='bc' id='L1634' title='0|4|4 - Total: 4'>                catchNode.setParens(lp, rp);
</span><span class='bc' id='L1635' title='0|3|3 - Total: 3'>                catchNode.setLineno(catchLineNum);
</span>
<span class='bpc' id='L1637' title='0|1|1 - Total: 2'>                if (mustMatchToken(Token.RC, "msg.no.brace.after.body"))
</span><span class='bc' id='L1638' title='0|4|4 - Total: 4'>                    tryEnd = ts.tokenEnd;
</span><span class='bc' id='L1639' title='0|5|5 - Total: 5'>                catchNode.setLength(tryEnd - catchPos);
</span><span class='bc' id='L1640' title='0|2|2 - Total: 2'>                if (clauses == null)
</span><span class='bc' id='L1641' title='0|4|4 - Total: 4'>                    clauses = new ArrayList<CatchClause>();
</span><span class='bc' id='L1642' title='0|4|4 - Total: 4'>                clauses.add(catchNode);
</span><span class='bc' id='L1643' title='0|1|1 - Total: 1'>            }
</span><span class='bpc' id='L1644' title='0|1|1 - Total: 2'>        } else if (peek != Token.FINALLY) {
</span><span class='nc' id='L1645' title='0|0|0 - Total: 5'>            mustMatchToken(Token.FINALLY, "msg.try.no.catchfinally");
</span>        }

<span class='bc' id='L1648' title='0|2|2 - Total: 2'>        AstNode finallyBlock = null;
</span><span class='bc' id='L1649' title='0|2|2 - Total: 2'>        if (matchToken(Token.FINALLY)) {
</span><span class='bc' id='L1650' title='0|4|4 - Total: 4'>            finallyPos = ts.tokenBeg;
</span><span class='bc' id='L1651' title='0|3|3 - Total: 3'>            finallyBlock = statement();
</span><span class='bc' id='L1652' title='0|4|4 - Total: 4'>            tryEnd = getNodeEnd(finallyBlock);
</span>        }

<span class='bc' id='L1655' title='0|8|8 - Total: 8'>        TryStatement pn = new TryStatement(tryPos, tryEnd - tryPos);
</span><span class='bc' id='L1656' title='0|3|3 - Total: 3'>        pn.setTryBlock(tryBlock);
</span><span class='bc' id='L1657' title='0|3|3 - Total: 3'>        pn.setCatchClauses(clauses);
</span><span class='bc' id='L1658' title='0|3|3 - Total: 3'>        pn.setFinallyBlock(finallyBlock);
</span><span class='bc' id='L1659' title='0|2|2 - Total: 2'>        if (finallyPos != -1) {
</span><span class='bc' id='L1660' title='0|5|5 - Total: 5'>            pn.setFinallyPosition(finallyPos - tryPos);
</span>        }
<span class='bc' id='L1662' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span>
<span class='bpc' id='L1664' title='0|1|1 - Total: 2'>        if (jsdocNode != null) {
</span><span class='nc' id='L1665' title='0|0|0 - Total: 3'>            pn.setJsDocNode(jsdocNode);
</span>        }

<span class='bc' id='L1668' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private ThrowStatement throwStatement()
        throws IOException
    {
<span class='bpc' id='L1674' title='0|1|1 - Total: 2'>        if (currentToken != Token.THROW) codeBug();
</span><span class='bc' id='L1675' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1676' title='0|8|8 - Total: 8'>        int pos = ts.tokenBeg, lineno = ts.lineno;
</span><span class='bc' id='L1677' title='0|2|2 - Total: 2'>        if (peekTokenOrEOL() == Token.EOL) {
</span>            // ECMAScript does not allow new lines before throw expression,
            // see bug 256617
<span class='nc' id='L1680' title='0|0|0 - Total: 3'>            reportError("msg.bad.throw.eol");
</span>        }
<span class='bc' id='L1682' title='0|3|3 - Total: 3'>        AstNode expr = expr();
</span><span class='bc' id='L1683' title='0|9|9 - Total: 9'>        ThrowStatement pn = new ThrowStatement(pos, getNodeEnd(expr), expr);
</span><span class='bc' id='L1684' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1685' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    // If we match a NAME, consume the token and return the statement
    // with that label.  If the name does not match an existing label,
    // reports an error.  Returns the labeled statement node, or null if
    // the peeked token was not a name.  Side effect:  sets scanner token
    // information for the label identifier (tokenBeg, tokenEnd, etc.)

    private LabeledStatement matchJumpLabelName()
        throws IOException
    {
<span class='bc' id='L1697' title='0|2|2 - Total: 2'>        LabeledStatement label = null;
</span>
<span class='bc' id='L1699' title='0|2|2 - Total: 2'>        if (peekTokenOrEOL() == Token.NAME) {
</span><span class='bc' id='L1700' title='0|2|2 - Total: 2'>            consumeToken();
</span><span class='bpc' id='L1701' title='0|1|1 - Total: 2'>            if (labelSet != null) {
</span><span class='bc' id='L1702' title='0|8|8 - Total: 8'>                label = labelSet.get(ts.getString());
</span>            }
<span class='bpc' id='L1704' title='0|1|1 - Total: 2'>            if (label == null) {
</span><span class='nc' id='L1705' title='0|0|0 - Total: 3'>                reportError("msg.undef.label");
</span>            }
        }

<span class='bc' id='L1709' title='0|2|2 - Total: 2'>        return label;
</span>    }

    private BreakStatement breakStatement()
        throws IOException
    {
<span class='bpc' id='L1715' title='0|1|1 - Total: 2'>        if (currentToken != Token.BREAK) codeBug();
</span><span class='bc' id='L1716' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1717' title='0|12|12 - Total: 12'>        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;
</span><span class='bc' id='L1718' title='0|2|2 - Total: 2'>        Name breakLabel = null;
</span><span class='bc' id='L1719' title='0|2|2 - Total: 2'>        if (peekTokenOrEOL() == Token.NAME) {
</span><span class='bc' id='L1720' title='0|3|3 - Total: 3'>            breakLabel = createNameNode();
</span><span class='bc' id='L1721' title='0|4|4 - Total: 4'>            end = getNodeEnd(breakLabel);
</span>        }

        // matchJumpLabelName only matches if there is one
<span class='bc' id='L1725' title='0|3|3 - Total: 3'>        LabeledStatement labels = matchJumpLabelName();
</span>        // always use first label as target
<span class='bc' id='L1727' title='0|2|2 - Total: 2'>        Jump breakTarget = labels == null ? null : labels.getFirstLabel();
</span>
<span class='bpc' id='L1729' title='0|3|3 - Total: 4'>        if (breakTarget == null && breakLabel == null) {
</span><span class='bpc' id='L1730' title='0|3|3 - Total: 4'>            if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {
</span><span class='bpc' id='L1731' title='0|1|1 - Total: 2'>                if (breakLabel == null) {
</span><span class='nc' id='L1732' title='0|0|0 - Total: 8'>                    reportError("msg.bad.break", pos, end - pos);
</span>                }
            } else {
<span class='bc' id='L1735' title='0|10|10 - Total: 10'>                breakTarget = loopAndSwitchSet.get(loopAndSwitchSet.size() - 1);
</span>            }
        }

<span class='bc' id='L1739' title='0|8|8 - Total: 8'>        BreakStatement pn = new BreakStatement(pos, end - pos);
</span><span class='bc' id='L1740' title='0|3|3 - Total: 3'>        pn.setBreakLabel(breakLabel);
</span>        // can be null if it's a bad break in error-recovery mode
<span class='bpc' id='L1742' title='0|1|1 - Total: 2'>        if (breakTarget != null)
</span><span class='bc' id='L1743' title='0|3|3 - Total: 3'>            pn.setBreakTarget(breakTarget);
</span><span class='bc' id='L1744' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1745' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private ContinueStatement continueStatement()
        throws IOException
    {
<span class='bpc' id='L1751' title='0|1|1 - Total: 2'>        if (currentToken != Token.CONTINUE) codeBug();
</span><span class='bc' id='L1752' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1753' title='0|12|12 - Total: 12'>        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;
</span><span class='bc' id='L1754' title='0|2|2 - Total: 2'>        Name label = null;
</span><span class='bc' id='L1755' title='0|2|2 - Total: 2'>        if (peekTokenOrEOL() == Token.NAME) {
</span><span class='bc' id='L1756' title='0|3|3 - Total: 3'>            label = createNameNode();
</span><span class='bc' id='L1757' title='0|4|4 - Total: 4'>            end = getNodeEnd(label);
</span>        }

        // matchJumpLabelName only matches if there is one
<span class='bc' id='L1761' title='0|3|3 - Total: 3'>        LabeledStatement labels = matchJumpLabelName();
</span><span class='bc' id='L1762' title='0|2|2 - Total: 2'>        Loop target = null;
</span><span class='bpc' id='L1763' title='0|3|3 - Total: 4'>        if (labels == null && label == null) {
</span><span class='bpc' id='L1764' title='0|3|3 - Total: 4'>            if (loopSet == null || loopSet.size() == 0) {
</span><span class='nc' id='L1765' title='0|0|0 - Total: 4'>                reportError("msg.continue.outside");
</span>            } else {
<span class='bc' id='L1767' title='0|11|11 - Total: 11'>                target = loopSet.get(loopSet.size() - 1);
</span>            }
        } else {
<span class='bpc' id='L1770' title='0|2|2 - Total: 4'>            if (labels == null || !(labels.getStatement() instanceof Loop)) {
</span><span class='nc' id='L1771' title='0|0|0 - Total: 7'>                reportError("msg.continue.nonloop", pos, end - pos);
</span>            }
<span class='bpc' id='L1773' title='0|1|1 - Total: 2'>            target = labels == null ? null : (Loop)labels.getStatement();
</span>        }

<span class='bc' id='L1776' title='0|8|8 - Total: 8'>        ContinueStatement pn = new ContinueStatement(pos, end - pos);
</span><span class='bpc' id='L1777' title='0|1|1 - Total: 2'>        if (target != null)  // can be null in error-recovery mode
</span><span class='bc' id='L1778' title='0|3|3 - Total: 3'>            pn.setTarget(target);
</span><span class='bc' id='L1779' title='0|3|3 - Total: 3'>        pn.setLabel(label);
</span><span class='bc' id='L1780' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1781' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private WithStatement withStatement()
        throws IOException
    {
<span class='bpc' id='L1787' title='0|1|1 - Total: 2'>        if (currentToken != Token.WITH) codeBug();
</span><span class='bc' id='L1788' title='0|2|2 - Total: 2'>        consumeToken();
</span>
<span class='bc' id='L1790' title='0|3|3 - Total: 3'>        Comment withComment = getAndResetJsDoc();
</span>
<span class='bc' id='L1792' title='0|12|12 - Total: 12'>        int lineno = ts.lineno, pos = ts.tokenBeg, lp = -1, rp = -1;
</span><span class='bpc' id='L1793' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.LP, "msg.no.paren.with"))
</span><span class='bc' id='L1794' title='0|4|4 - Total: 4'>            lp = ts.tokenBeg;
</span>
<span class='bc' id='L1796' title='0|3|3 - Total: 3'>        AstNode obj = expr();
</span>
<span class='bpc' id='L1798' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.RP, "msg.no.paren.after.with"))
</span><span class='bc' id='L1799' title='0|4|4 - Total: 4'>            rp = ts.tokenBeg;
</span>
<span class='bc' id='L1801' title='0|3|3 - Total: 3'>        AstNode body = statement();
</span>
<span class='bc' id='L1803' title='0|10|10 - Total: 10'>        WithStatement pn = new WithStatement(pos, getNodeEnd(body) - pos);
</span><span class='bc' id='L1804' title='0|3|3 - Total: 3'>        pn.setJsDocNode(withComment);
</span><span class='bc' id='L1805' title='0|3|3 - Total: 3'>        pn.setExpression(obj);
</span><span class='bc' id='L1806' title='0|3|3 - Total: 3'>        pn.setStatement(body);
</span><span class='bc' id='L1807' title='0|4|4 - Total: 4'>        pn.setParens(lp, rp);
</span><span class='bc' id='L1808' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1809' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode letStatement()
        throws IOException
    {
<span class='bpc' id='L1815' title='0|1|1 - Total: 2'>        if (currentToken != Token.LET) codeBug();
</span><span class='bc' id='L1816' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1817' title='0|8|8 - Total: 8'>        int lineno = ts.lineno, pos = ts.tokenBeg;
</span>        AstNode pn;
<span class='bc' id='L1819' title='0|2|2 - Total: 2'>        if (peekToken() == Token.LP) {
</span><span class='bc' id='L1820' title='0|6|6 - Total: 6'>            pn = let(true, pos);
</span>        } else {
<span class='bc' id='L1822' title='0|6|6 - Total: 6'>            pn = variables(Token.LET, pos, true);  // else, e.g.: let x=6, y=7;
</span>        }
<span class='bc' id='L1824' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L1825' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    /**
     * Returns whether or not the bits in the mask have changed to all set.
     * @param before bits before change
     * @param after bits after change
     * @param mask mask for bits
     * @return {@code true} if all the bits in the mask are set in "after"
     *          but not in "before"
     */
    private static final boolean nowAllSet(int before, int after, int mask) {
<span class='bpc' id='L1837' title='0|3|3 - Total: 4'>        return ((before & mask) != mask) && ((after & mask) == mask);
</span>    }

    private AstNode returnOrYield(int tt, boolean exprContext)
        throws IOException
    {
<span class='bc' id='L1843' title='0|2|2 - Total: 2'>        if (!insideFunction()) {
</span><span class='bpc' id='L1844' title='0|1|1 - Total: 2'>            reportError(tt == Token.RETURN ? "msg.bad.return"
</span>                                           : "msg.bad.yield");
        }
<span class='bc' id='L1847' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1848' title='0|12|12 - Total: 12'>        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;
</span>
<span class='bc' id='L1850' title='0|2|2 - Total: 2'>        AstNode e = null;
</span>        // This is ugly, but we don't want to require a semicolon.
<span class='bc' id='L1852' title='0|2|2 - Total: 2'>        switch (peekTokenOrEOL()) {
</span>          case Token.SEMI: case Token.RC:  case Token.RB:    case Token.RP:
          case Token.EOF:  case Token.EOL: case Token.ERROR: case Token.YIELD:
<span class='bc' id='L1855' title='0|1|1 - Total: 1'>            break;
</span>          default:
<span class='bc' id='L1857' title='0|3|3 - Total: 3'>            e = expr();
</span><span class='bc' id='L1858' title='0|4|4 - Total: 4'>            end = getNodeEnd(e);
</span>        }

<span class='bc' id='L1861' title='0|3|3 - Total: 3'>        int before = endFlags;
</span>        AstNode ret;

<span class='bc' id='L1864' title='0|2|2 - Total: 2'>        if (tt == Token.RETURN) {
</span><span class='bc' id='L1865' title='0|2|2 - Total: 2'>            endFlags |= e == null ? Node.END_RETURNS : Node.END_RETURNS_VALUE;
</span><span class='bc' id='L1866' title='0|9|9 - Total: 9'>            ret = new ReturnStatement(pos, end - pos, e);
</span>
            // see if we need a strict mode warning
<span class='bc' id='L1869' title='0|2|2 - Total: 2'>            if (nowAllSet(before, endFlags,
</span>                    Node.END_RETURNS|Node.END_RETURNS_VALUE))
<span class='bc' id='L1871' title='0|9|9 - Total: 9'>                addStrictWarning("msg.return.inconsistent", "", pos, end - pos);
</span>        } else {
<span class='bpc' id='L1873' title='0|1|1 - Total: 2'>            if (!insideFunction())
</span><span class='nc' id='L1874' title='0|0|0 - Total: 3'>                reportError("msg.bad.yield");
</span><span class='bc' id='L1875' title='0|6|6 - Total: 6'>            endFlags |= Node.END_YIELDS;
</span><span class='bc' id='L1876' title='0|9|9 - Total: 9'>            ret = new Yield(pos, end - pos, e);
</span><span class='bc' id='L1877' title='0|2|2 - Total: 2'>            setRequiresActivation();
</span><span class='bc' id='L1878' title='0|2|2 - Total: 2'>            setIsGenerator();
</span><span class='bc' id='L1879' title='0|2|2 - Total: 2'>            if (!exprContext) {
</span><span class='bc' id='L1880' title='0|5|5 - Total: 5'>                ret = new ExpressionStatement(ret);
</span>            }
        }

        // see if we are mixing yields and value returns.
<span class='bpc' id='L1885' title='0|1|1 - Total: 2'>        if (insideFunction()
</span><span class='bc' id='L1886' title='0|2|2 - Total: 2'>            && nowAllSet(before, endFlags,
</span>                    Node.END_YIELDS|Node.END_RETURNS_VALUE)) {
<span class='bc' id='L1888' title='0|5|5 - Total: 5'>            Name name = ((FunctionNode)currentScriptOrFn).getFunctionName();
</span><span class='bpc' id='L1889' title='0|1|1 - Total: 4'>            if (name == null || name.length() == 0)
</span><span class='nc' id='L1890' title='0|0|0 - Total: 5'>                addError("msg.anon.generator.returns", "");
</span>            else
<span class='nc' id='L1892' title='0|0|0 - Total: 5'>                addError("msg.generator.returns", name.getIdentifier());
</span>        }

<span class='bc' id='L1895' title='0|3|3 - Total: 3'>        ret.setLineno(lineno);
</span><span class='bc' id='L1896' title='0|2|2 - Total: 2'>        return ret;
</span>    }

    private AstNode block()
        throws IOException
    {
<span class='bpc' id='L1902' title='0|1|1 - Total: 2'>        if (currentToken != Token.LC) codeBug();
</span><span class='bc' id='L1903' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1904' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span><span class='bc' id='L1905' title='0|5|5 - Total: 5'>        Scope block = new Scope(pos);
</span><span class='bc' id='L1906' title='0|5|5 - Total: 5'>        block.setLineno(ts.lineno);
</span><span class='bc' id='L1907' title='0|3|3 - Total: 3'>        pushScope(block);
</span>        try {
<span class='bc' id='L1909' title='0|4|4 - Total: 4'>            statements(block);
</span><span class='bc' id='L1910' title='0|5|5 - Total: 5'>            mustMatchToken(Token.RC, "msg.no.brace.block");
</span><span class='bc' id='L1911' title='0|7|7 - Total: 7'>            block.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L1912' title='0|4|4 - Total: 4'>            return block;
</span>        } finally {
<span class='bc' id='L1914' title='0|5|5 - Total: 5'>            popScope();
</span><span class='bc' id='L1915' title='0|2|2 - Total: 2'>        }
</span>    }

    private AstNode defaultXmlNamespace()
        throws IOException
    {
<span class='bpc' id='L1921' title='0|1|1 - Total: 2'>        if (currentToken != Token.DEFAULT) codeBug();
</span><span class='bc' id='L1922' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1923' title='0|2|2 - Total: 2'>        mustHaveXML();
</span><span class='bc' id='L1924' title='0|2|2 - Total: 2'>        setRequiresActivation();
</span><span class='bc' id='L1925' title='0|8|8 - Total: 8'>        int lineno = ts.lineno, pos = ts.tokenBeg;
</span>
<span class='bpc' id='L1927' title='0|2|2 - Total: 4'>        if (!(matchToken(Token.NAME) && "xml".equals(ts.getString()))) {
</span><span class='nc' id='L1928' title='0|0|0 - Total: 3'>            reportError("msg.bad.namespace");
</span>        }
<span class='bpc' id='L1930' title='0|2|2 - Total: 4'>        if (!(matchToken(Token.NAME) && "namespace".equals(ts.getString()))) {
</span><span class='nc' id='L1931' title='0|0|0 - Total: 3'>            reportError("msg.bad.namespace");
</span>        }
<span class='bpc' id='L1933' title='0|1|1 - Total: 2'>        if (!matchToken(Token.ASSIGN)) {
</span><span class='nc' id='L1934' title='0|0|0 - Total: 3'>            reportError("msg.bad.namespace");
</span>        }

<span class='bc' id='L1937' title='0|3|3 - Total: 3'>        AstNode e = expr();
</span><span class='bc' id='L1938' title='0|10|10 - Total: 10'>        UnaryExpression dxmln = new UnaryExpression(pos, getNodeEnd(e) - pos);
</span><span class='bc' id='L1939' title='0|3|3 - Total: 3'>        dxmln.setOperator(Token.DEFAULTNAMESPACE);
</span><span class='bc' id='L1940' title='0|3|3 - Total: 3'>        dxmln.setOperand(e);
</span><span class='bc' id='L1941' title='0|3|3 - Total: 3'>        dxmln.setLineno(lineno);
</span>
<span class='bc' id='L1943' title='0|6|6 - Total: 6'>        ExpressionStatement es = new ExpressionStatement(dxmln, true);
</span><span class='bc' id='L1944' title='0|2|2 - Total: 2'>        return es;
</span>    }

    private void recordLabel(Label label, LabeledStatement bundle)
        throws IOException
    {
        // current token should be colon that primaryExpr left untouched
<span class='bpc' id='L1951' title='0|1|1 - Total: 2'>        if (peekToken() != Token.COLON) codeBug();
</span><span class='bc' id='L1952' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L1953' title='0|3|3 - Total: 3'>        String name = label.getName();
</span><span class='bc' id='L1954' title='0|2|2 - Total: 2'>        if (labelSet == null) {
</span><span class='bc' id='L1955' title='0|6|6 - Total: 6'>            labelSet = new HashMap<String,LabeledStatement>();
</span>        } else {
<span class='bc' id='L1957' title='0|6|6 - Total: 6'>            LabeledStatement ls = labelSet.get(name);
</span><span class='bpc' id='L1958' title='0|1|1 - Total: 2'>            if (ls != null) {
</span><span class='nc' id='L1959' title='0|0|0 - Total: 2'>                if (compilerEnv.isIdeMode()) {
</span><span class='nc' id='L1960' title='0|0|0 - Total: 4'>                    Label dup = ls.getLabelByName(name);
</span><span class='nc' id='L1961' title='0|0|0 - Total: 4'>                    reportError("msg.dup.label",
</span><span class='nc' id='L1962' title='0|0|0 - Total: 3'>                                dup.getAbsolutePosition(), dup.getLength());
</span>                }
<span class='nc' id='L1964' title='0|0|0 - Total: 4'>                reportError("msg.dup.label",
</span><span class='nc' id='L1965' title='0|0|0 - Total: 3'>                            label.getPosition(), label.getLength());
</span>            }
        }
<span class='bc' id='L1968' title='0|3|3 - Total: 3'>        bundle.addLabel(label);
</span><span class='bc' id='L1969' title='0|6|6 - Total: 6'>        labelSet.put(name, bundle);
</span><span class='bc' id='L1970' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Found a name in a statement context.  If it's a label, we gather
     * up any following labels and the next non-label statement into a
     * {@link LabeledStatement} "bundle" and return that.  Otherwise we parse
     * an expression and return it wrapped in an {@link ExpressionStatement}.
     */
    private AstNode nameOrLabel()
        throws IOException
    {
<span class='bpc' id='L1981' title='0|1|1 - Total: 2'>        if (currentToken != Token.NAME) throw codeBug();
</span><span class='bc' id='L1982' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span>
        // set check for label and call down to primaryExpr
<span class='bc' id='L1985' title='0|6|6 - Total: 6'>        currentFlaggedToken |= TI_CHECK_LABEL;
</span><span class='bc' id='L1986' title='0|3|3 - Total: 3'>        AstNode expr = expr();
</span>
<span class='bc' id='L1988' title='0|2|2 - Total: 2'>        if (expr.getType() != Token.LABEL) {
</span><span class='bc' id='L1989' title='0|2|2 - Total: 2'>            AstNode n = new ExpressionStatement(expr, !insideFunction());
</span><span class='bc' id='L1990' title='0|4|4 - Total: 4'>            n.lineno = expr.lineno;
</span><span class='bc' id='L1991' title='0|2|2 - Total: 2'>            return n;
</span>        }

<span class='bc' id='L1994' title='0|5|5 - Total: 5'>        LabeledStatement bundle = new LabeledStatement(pos);
</span><span class='bc' id='L1995' title='0|5|5 - Total: 5'>        recordLabel((Label)expr, bundle);
</span><span class='bc' id='L1996' title='0|5|5 - Total: 5'>        bundle.setLineno(ts.lineno);
</span>        // look for more labels
<span class='bc' id='L1998' title='0|2|2 - Total: 2'>        AstNode stmt = null;
</span><span class='bc' id='L1999' title='0|2|2 - Total: 2'>        while (peekToken() == Token.NAME) {
</span><span class='bc' id='L2000' title='0|6|6 - Total: 6'>            currentFlaggedToken |= TI_CHECK_LABEL;
</span><span class='bc' id='L2001' title='0|3|3 - Total: 3'>            expr = expr();
</span><span class='bc' id='L2002' title='0|2|2 - Total: 2'>            if (expr.getType() != Token.LABEL) {
</span><span class='bpc' id='L2003' title='0|1|1 - Total: 2'>                stmt = new ExpressionStatement(expr, !insideFunction());
</span><span class='bc' id='L2004' title='0|3|3 - Total: 3'>                autoInsertSemicolon(stmt);
</span><span class='bc' id='L2005' title='0|1|1 - Total: 1'>                break;
</span>            }
<span class='bc' id='L2007' title='0|6|6 - Total: 6'>            recordLabel((Label)expr, bundle);
</span>        }

        // no more labels; now parse the labeled statement
        try {
<span class='bc' id='L2012' title='0|3|3 - Total: 3'>            currentLabel = bundle;
</span><span class='bc' id='L2013' title='0|2|2 - Total: 2'>            if (stmt == null) {
</span><span class='bc' id='L2014' title='0|3|3 - Total: 3'>                stmt = statementHelper();
</span>            }
        } finally {
<span class='bc' id='L2017' title='0|7|7 - Total: 7'>            currentLabel = null;
</span>            // remove the labels for this statement from the global set
<span class='bc' id='L2019' title='0|4|4 - Total: 4'>            for (Label lb : bundle.getLabels()) {
</span><span class='bc' id='L2020' title='0|12|12 - Total: 12'>                labelSet.remove(lb.getName());
</span><span class='bc' id='L2021' title='0|2|2 - Total: 2'>            }
</span><span class='bc' id='L2022' title='0|3|3 - Total: 3'>        }
</span>
        // If stmt has parent assigned its position already is relative
        // (See bug #710225)
<span class='bc' id='L2026' title='0|2|2 - Total: 2'>        bundle.setLength(stmt.getParent() == null
</span><span class='bc' id='L2027' title='0|6|6 - Total: 6'>                     ? getNodeEnd(stmt) - pos
</span><span class='bc' id='L2028' title='0|1|1 - Total: 1'>                     : getNodeEnd(stmt));
</span><span class='bc' id='L2029' title='0|3|3 - Total: 3'>        bundle.setStatement(stmt);
</span><span class='bc' id='L2030' title='0|2|2 - Total: 2'>        return bundle;
</span>    }

    /**
     * Parse a 'var' or 'const' statement, or a 'var' init list in a for
     * statement.
     * @param declType A token value: either VAR, CONST, or LET depending on
     * context.
     * @param pos the position where the node should start.  It's sometimes
     * the var/const/let keyword, and other times the beginning of the first
     * token in the first variable declaration.
     * @return the parsed variable list
     */
    private VariableDeclaration variables(int declType, int pos, boolean isStatement)
        throws IOException
    {
        int end;
<span class='bc' id='L2047' title='0|5|5 - Total: 5'>        VariableDeclaration pn = new VariableDeclaration(pos);
</span><span class='bc' id='L2048' title='0|4|4 - Total: 4'>        pn.setType(declType);
</span><span class='bc' id='L2049' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span><span class='bc' id='L2050' title='0|3|3 - Total: 3'>        Comment varjsdocNode = getAndResetJsDoc();
</span><span class='bc' id='L2051' title='0|2|2 - Total: 2'>        if (varjsdocNode != null) {
</span><span class='bc' id='L2052' title='0|3|3 - Total: 3'>            pn.setJsDocNode(varjsdocNode);
</span>        }
        // Example:
        // var foo = {a: 1, b: 2}, bar = [3, 4];
        // var {b: s2, a: s1} = foo, x = 6, y, [s3, s4] = bar;
        for (;;) {
<span class='bc' id='L2058' title='0|2|2 - Total: 2'>            AstNode destructuring = null;
</span><span class='bc' id='L2059' title='0|2|2 - Total: 2'>            Name name = null;
</span><span class='bc' id='L2060' title='0|7|7 - Total: 7'>            int tt = peekToken(), kidPos = ts.tokenBeg;
</span><span class='bc' id='L2061' title='0|4|4 - Total: 4'>            end = ts.tokenEnd;
</span>
<span class='bc' id='L2063' title='0|4|4 - Total: 4'>            if (tt == Token.LB || tt == Token.LC) {
</span>                // Destructuring assignment, e.g., var [a,b] = ...
<span class='bc' id='L2065' title='0|3|3 - Total: 3'>                destructuring = destructuringPrimaryExpr();
</span><span class='bc' id='L2066' title='0|4|4 - Total: 4'>                end = getNodeEnd(destructuring);
</span><span class='bc' id='L2067' title='0|2|2 - Total: 2'>                if (!(destructuring instanceof DestructuringForm))
</span><span class='nc' id='L2068' title='0|0|0 - Total: 7'>                    reportError("msg.bad.assign.left", kidPos, end - kidPos);
</span><span class='bc' id='L2069' title='0|4|4 - Total: 4'>                markDestructuring(destructuring);
</span>            } else {
                // Simple variable name
<span class='bc' id='L2072' title='0|5|5 - Total: 5'>                mustMatchToken(Token.NAME, "msg.bad.var");
</span><span class='bc' id='L2073' title='0|3|3 - Total: 3'>                name = createNameNode();
</span><span class='bc' id='L2074' title='0|5|5 - Total: 5'>                name.setLineno(ts.getLineno());
</span><span class='bc' id='L2075' title='0|2|2 - Total: 2'>                if (inUseStrictDirective) {
</span><span class='bc' id='L2076' title='0|4|4 - Total: 4'>                    String id = ts.getString();
</span><span class='bpc' id='L2077' title='0|2|2 - Total: 4'>                    if ("eval".equals(id) || "arguments".equals(ts.getString()))
</span>                    {
<span class='nc' id='L2079' title='0|0|0 - Total: 4'>                        reportError("msg.bad.id.strict", id);
</span>                    }
                }
<span class='bc' id='L2082' title='0|8|8 - Total: 8'>                defineSymbol(declType, ts.getString(), inForInit);
</span>            }

<span class='bc' id='L2085' title='0|4|4 - Total: 4'>            int lineno = ts.lineno;
</span>
<span class='bc' id='L2087' title='0|3|3 - Total: 3'>            Comment jsdocNode = getAndResetJsDoc();
</span>
<span class='bc' id='L2089' title='0|2|2 - Total: 2'>            AstNode init = null;
</span><span class='bc' id='L2090' title='0|2|2 - Total: 2'>            if (matchToken(Token.ASSIGN)) {
</span><span class='bc' id='L2091' title='0|3|3 - Total: 3'>                init = assignExpr();
</span><span class='bc' id='L2092' title='0|4|4 - Total: 4'>                end = getNodeEnd(init);
</span>            }

<span class='bc' id='L2095' title='0|8|8 - Total: 8'>            VariableInitializer vi = new VariableInitializer(kidPos, end - kidPos);
</span><span class='bc' id='L2096' title='0|2|2 - Total: 2'>            if (destructuring != null) {
</span><span class='bpc' id='L2097' title='0|3|3 - Total: 4'>                if (init == null && !inForInit) {
</span><span class='nc' id='L2098' title='0|0|0 - Total: 3'>                    reportError("msg.destruct.assign.no.init");
</span>                }
<span class='bc' id='L2100' title='0|4|4 - Total: 4'>                vi.setTarget(destructuring);
</span>            } else {
<span class='bc' id='L2102' title='0|3|3 - Total: 3'>                vi.setTarget(name);
</span>            }
<span class='bc' id='L2104' title='0|3|3 - Total: 3'>            vi.setInitializer(init);
</span><span class='bc' id='L2105' title='0|4|4 - Total: 4'>            vi.setType(declType);
</span><span class='bc' id='L2106' title='0|3|3 - Total: 3'>            vi.setJsDocNode(jsdocNode);
</span><span class='bc' id='L2107' title='0|3|3 - Total: 3'>            vi.setLineno(lineno);
</span><span class='bc' id='L2108' title='0|3|3 - Total: 3'>            pn.addVariable(vi);
</span>
<span class='bc' id='L2110' title='0|2|2 - Total: 2'>            if (!matchToken(Token.COMMA))
</span><span class='bc' id='L2111' title='0|1|1 - Total: 1'>                break;
</span><span class='bc' id='L2112' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2113' title='0|5|5 - Total: 5'>        pn.setLength(end - pos);
</span><span class='bc' id='L2114' title='0|3|3 - Total: 3'>        pn.setIsStatement(isStatement);
</span><span class='bc' id='L2115' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    // have to pass in 'let' kwd position to compute kid offsets properly
    private AstNode let(boolean isStatement, int pos)
        throws IOException
    {
<span class='bc' id='L2122' title='0|5|5 - Total: 5'>        LetNode pn = new LetNode(pos);
</span><span class='bc' id='L2123' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span><span class='bpc' id='L2124' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.LP, "msg.no.paren.after.let"))
</span><span class='bc' id='L2125' title='0|7|7 - Total: 7'>            pn.setLp(ts.tokenBeg - pos);
</span><span class='bc' id='L2126' title='0|3|3 - Total: 3'>        pushScope(pn);
</span>        try {
<span class='bc' id='L2128' title='0|8|8 - Total: 8'>            VariableDeclaration vars = variables(Token.LET, ts.tokenBeg, isStatement);
</span><span class='bc' id='L2129' title='0|3|3 - Total: 3'>            pn.setVariables(vars);
</span><span class='bpc' id='L2130' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.RP, "msg.no.paren.let")) {
</span><span class='bc' id='L2131' title='0|7|7 - Total: 7'>                pn.setRp(ts.tokenBeg - pos);
</span>            }
<span class='bc' id='L2133' title='0|4|4 - Total: 4'>            if (isStatement && peekToken() == Token.LC) {
</span>                // let statement
<span class='bc' id='L2135' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L2136' title='0|4|4 - Total: 4'>                int beg = ts.tokenBeg;  // position stmt at LC
</span><span class='bc' id='L2137' title='0|3|3 - Total: 3'>                AstNode stmt = statements();
</span><span class='bc' id='L2138' title='0|5|5 - Total: 5'>                mustMatchToken(Token.RC, "msg.no.curly.let");
</span><span class='bc' id='L2139' title='0|7|7 - Total: 7'>                stmt.setLength(ts.tokenEnd - beg);
</span><span class='bc' id='L2140' title='0|7|7 - Total: 7'>                pn.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L2141' title='0|3|3 - Total: 3'>                pn.setBody(stmt);
</span><span class='bc' id='L2142' title='0|4|4 - Total: 4'>                pn.setType(Token.LET);
</span><span class='bc' id='L2143' title='0|1|1 - Total: 1'>            } else {
</span>                // let expression
<span class='bc' id='L2145' title='0|3|3 - Total: 3'>                AstNode expr = expr();
</span><span class='bc' id='L2146' title='0|7|7 - Total: 7'>                pn.setLength(getNodeEnd(expr) - pos);
</span><span class='bc' id='L2147' title='0|3|3 - Total: 3'>                pn.setBody(expr);
</span><span class='bc' id='L2148' title='0|2|2 - Total: 2'>                if (isStatement) {
</span>                    // let expression in statement context
<span class='bc' id='L2150' title='0|4|4 - Total: 4'>                    ExpressionStatement es =
</span><span class='bc' id='L2151' title='0|2|2 - Total: 2'>                            new ExpressionStatement(pn, !insideFunction());
</span><span class='bc' id='L2152' title='0|4|4 - Total: 4'>                    es.setLineno(pn.getLineno());
</span><span class='bc' id='L2153' title='0|4|4 - Total: 4'>                    return es;
</span>                }
            }
        } finally {
<span class='bc' id='L2157' title='0|7|7 - Total: 7'>            popScope();
</span><span class='bc' id='L2158' title='0|3|3 - Total: 3'>        }
</span><span class='bc' id='L2159' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    void defineSymbol(int declType, String name) {
<span class='bc' id='L2163' title='0|5|5 - Total: 5'>        defineSymbol(declType, name, false);
</span><span class='bc' id='L2164' title='0|1|1 - Total: 1'>    }
</span>
    void defineSymbol(int declType, String name, boolean ignoreNotInBlock) {
<span class='bpc' id='L2167' title='0|1|1 - Total: 2'>        if (name == null) {
</span><span class='nc' id='L2168' title='0|0|0 - Total: 2'>            if (compilerEnv.isIdeMode()) {  // be robust in IDE-mode
</span><span class='nc' id='L2169' title='0|0|0 - Total: 1'>                return;
</span>            } else {
<span class='nc' id='L2171' title='0|0|0 - Total: 3'>                codeBug();
</span>            }
        }
<span class='bc' id='L2174' title='0|5|5 - Total: 5'>        Scope definingScope = currentScope.getDefiningScope(name);
</span><span class='bc' id='L2175' title='0|2|2 - Total: 2'>        Symbol symbol = definingScope != null
</span><span class='bc' id='L2176' title='0|4|4 - Total: 4'>                        ? definingScope.getSymbol(name)
</span>                        : null;
<span class='bc' id='L2178' title='0|2|2 - Total: 2'>        int symDeclType = symbol != null ? symbol.getDeclType() : -1;
</span><span class='bpc' id='L2179' title='0|9|9 - Total: 10'>        if (symbol != null
</span>            && (symDeclType == Token.CONST
                || declType == Token.CONST
                || (definingScope == currentScope && symDeclType == Token.LET)))
        {
<span class='bpc' id='L2184' title='0|3|3 - Total: 8'>            addError(symDeclType == Token.CONST ? "msg.const.redecl" :
</span>                     symDeclType == Token.LET ? "msg.let.redecl" :
                     symDeclType == Token.VAR ? "msg.var.redecl" :
                     symDeclType == Token.FUNCTION ? "msg.fn.redecl" :
                     "msg.parm.redecl", name);
<span class='nc' id='L2189' title='0|0|0 - Total: 1'>            return;
</span>        }
<span class='bpc' id='L2191' title='0|3|3 - Total: 4'>        switch (declType) {
</span>          case Token.LET:
<span class='bc' id='L2193' title='0|2|2 - Total: 2'>              if (!ignoreNotInBlock &&
</span><span class='bpc' id='L2194' title='0|3|3 - Total: 4'>                  ((currentScope.getType() == Token.IF) ||
</span>                   currentScope instanceof Loop)) {
<span class='nc' id='L2196' title='0|0|0 - Total: 3'>                  addError("msg.let.decl.not.in.block");
</span><span class='nc' id='L2197' title='0|0|0 - Total: 1'>                  return;
</span>              }
<span class='bc' id='L2199' title='0|8|8 - Total: 8'>              currentScope.putSymbol(new Symbol(declType, name));
</span><span class='bc' id='L2200' title='0|1|1 - Total: 1'>              return;
</span>
          case Token.VAR:
          case Token.CONST:
          case Token.FUNCTION:
<span class='bc' id='L2205' title='0|2|2 - Total: 2'>              if (symbol != null) {
</span><span class='bc' id='L2206' title='0|2|2 - Total: 2'>                  if (symDeclType == Token.VAR)
</span><span class='bc' id='L2207' title='0|5|5 - Total: 5'>                      addStrictWarning("msg.var.redecl", name);
</span><span class='bc' id='L2208' title='0|2|2 - Total: 2'>                  else if (symDeclType == Token.LP) {
</span><span class='bc' id='L2209' title='0|5|5 - Total: 5'>                      addStrictWarning("msg.var.hides.arg", name);
</span>                  }
              } else {
<span class='bc' id='L2212' title='0|8|8 - Total: 8'>                  currentScriptOrFn.putSymbol(new Symbol(declType, name));
</span>              }
<span class='bc' id='L2214' title='0|1|1 - Total: 1'>              return;
</span>
          case Token.LP:
<span class='bc' id='L2217' title='0|2|2 - Total: 2'>              if (symbol != null) {
</span>                  // must be duplicate parameter. Second parameter hides the
                  // first, so go ahead and add the second parameter
<span class='bc' id='L2220' title='0|4|4 - Total: 4'>                  addWarning("msg.dup.parms", name);
</span>              }
<span class='bc' id='L2222' title='0|8|8 - Total: 8'>              currentScriptOrFn.putSymbol(new Symbol(declType, name));
</span><span class='bc' id='L2223' title='0|1|1 - Total: 1'>              return;
</span>
          default:
<span class='nc' id='L2226' title='0|0|0 - Total: 3'>              throw codeBug();
</span>        }
    }

    private AstNode expr()
        throws IOException
    {
<span class='bc' id='L2233' title='0|3|3 - Total: 3'>        AstNode pn = assignExpr();
</span><span class='bc' id='L2234' title='0|3|3 - Total: 3'>        int pos = pn.getPosition();
</span><span class='bc' id='L2235' title='0|2|2 - Total: 2'>        while (matchToken(Token.COMMA)) {
</span><span class='bc' id='L2236' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span><span class='bpc' id='L2237' title='0|1|1 - Total: 4'>            if (compilerEnv.isStrictMode() && !pn.hasSideEffects())
</span><span class='nc' id='L2238' title='0|0|0 - Total: 7'>                addStrictWarning("msg.no.side.effects", "",
</span><span class='nc' id='L2239' title='0|0|0 - Total: 3'>                                 pos, nodeEnd(pn) - pos);
</span><span class='bpc' id='L2240' title='0|1|1 - Total: 2'>            if (peekToken() == Token.YIELD)
</span><span class='nc' id='L2241' title='0|0|0 - Total: 3'>                reportError("msg.yield.parenthesized");
</span><span class='bc' id='L2242' title='0|9|9 - Total: 9'>            pn = new InfixExpression(Token.COMMA, pn, assignExpr(), opPos);
</span><span class='bc' id='L2243' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2244' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode assignExpr()
        throws IOException
    {
<span class='bc' id='L2250' title='0|3|3 - Total: 3'>        int tt = peekToken();
</span><span class='bc' id='L2251' title='0|2|2 - Total: 2'>        if (tt == Token.YIELD) {
</span><span class='bc' id='L2252' title='0|5|5 - Total: 5'>            return returnOrYield(tt, true);
</span>        }
<span class='bc' id='L2254' title='0|3|3 - Total: 3'>        AstNode pn = condExpr();
</span><span class='bc' id='L2255' title='0|2|2 - Total: 2'>        boolean hasEOL = false;
</span><span class='bc' id='L2256' title='0|3|3 - Total: 3'>        tt = peekTokenOrEOL();
</span><span class='bc' id='L2257' title='0|2|2 - Total: 2'>        if (tt == Token.EOL) {
</span><span class='bc' id='L2258' title='0|2|2 - Total: 2'>            hasEOL = true;
</span><span class='bc' id='L2259' title='0|3|3 - Total: 3'>            tt = peekToken();
</span>        }
<span class='bc' id='L2261' title='0|4|4 - Total: 4'>        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
</span><span class='bc' id='L2262' title='0|2|2 - Total: 2'>            if (inDestructuringAssignment) {
</span>                // default values inside destructuring assignments,
                // like 'var [a = 10] = b' or 'var {a: b = 10} = c',
                // are not supported
<span class='nc' id='L2266' title='0|0|0 - Total: 3'>                reportError("msg.destruct.default.vals");
</span>            }

<span class='bc' id='L2269' title='0|2|2 - Total: 2'>            consumeToken();
</span>
            // Pull out JSDoc info and reset it before recursing.
<span class='bc' id='L2272' title='0|3|3 - Total: 3'>            Comment jsdocNode = getAndResetJsDoc();
</span>
<span class='bc' id='L2274' title='0|3|3 - Total: 3'>            markDestructuring(pn);
</span><span class='bc' id='L2275' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span>
<span class='bc' id='L2277' title='0|9|9 - Total: 9'>            pn = new Assignment(tt, pn, assignExpr(), opPos);
</span>
<span class='bpc' id='L2279' title='0|1|1 - Total: 2'>            if (jsdocNode != null) {
</span><span class='nc' id='L2280' title='0|0|0 - Total: 3'>                pn.setJsDocNode(jsdocNode);
</span>            }
<span class='bc' id='L2282' title='0|2|2 - Total: 2'>        } else if (tt == Token.SEMI) {
</span>            // This may be dead code added intentionally, for JSDoc purposes.
            // For example: /** @type Number */ C.prototype.x;
<span class='bc' id='L2285' title='0|2|2 - Total: 2'>            if (currentJsDocComment != null) {
</span><span class='bc' id='L2286' title='0|5|5 - Total: 5'>                pn.setJsDocNode(getAndResetJsDoc());
</span>            }
<span class='bc' id='L2288' title='0|4|4 - Total: 4'>        } else if (!hasEOL && tt == Token.ARROW) {
</span><span class='bc' id='L2289' title='0|2|2 - Total: 2'>            consumeToken();
</span><span class='bc' id='L2290' title='0|4|4 - Total: 4'>            pn = arrowFunction(pn);
</span>        }
<span class='bc' id='L2292' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode condExpr()
        throws IOException
    {
<span class='bc' id='L2298' title='0|3|3 - Total: 3'>        AstNode pn = orExpr();
</span><span class='bc' id='L2299' title='0|2|2 - Total: 2'>        if (matchToken(Token.HOOK)) {
</span><span class='bc' id='L2300' title='0|4|4 - Total: 4'>            int line = ts.lineno;
</span><span class='bc' id='L2301' title='0|6|6 - Total: 6'>            int qmarkPos = ts.tokenBeg, colonPos = -1;
</span>            /*
             * Always accept the 'in' operator in the middle clause of a ternary,
             * where it's unambiguous, even if we might be parsing the init of a
             * for statement.
             */
<span class='bc' id='L2307' title='0|3|3 - Total: 3'>            boolean wasInForInit = inForInit;
</span><span class='bc' id='L2308' title='0|3|3 - Total: 3'>            inForInit = false;
</span>            AstNode ifTrue;
            try {
<span class='bc' id='L2311' title='0|3|3 - Total: 3'>                ifTrue = assignExpr();
</span>            } finally {
<span class='bpc' id='L2313' title='0|3|3 - Total: 7'>                inForInit = wasInForInit;
</span><span class='bpc' id='L2314' title='0|1|1 - Total: 3'>            }
</span><span class='bpc' id='L2315' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.COLON, "msg.no.colon.cond"))
</span><span class='bc' id='L2316' title='0|4|4 - Total: 4'>                colonPos = ts.tokenBeg;
</span><span class='bc' id='L2317' title='0|3|3 - Total: 3'>            AstNode ifFalse = assignExpr();
</span><span class='bc' id='L2318' title='0|9|9 - Total: 9'>            int beg = pn.getPosition(), len = getNodeEnd(ifFalse) - beg;
</span><span class='bc' id='L2319' title='0|6|6 - Total: 6'>            ConditionalExpression ce = new ConditionalExpression(beg, len);
</span><span class='bc' id='L2320' title='0|3|3 - Total: 3'>            ce.setLineno(line);
</span><span class='bc' id='L2321' title='0|3|3 - Total: 3'>            ce.setTestExpression(pn);
</span><span class='bc' id='L2322' title='0|3|3 - Total: 3'>            ce.setTrueExpression(ifTrue);
</span><span class='bc' id='L2323' title='0|3|3 - Total: 3'>            ce.setFalseExpression(ifFalse);
</span><span class='bc' id='L2324' title='0|5|5 - Total: 5'>            ce.setQuestionMarkPosition(qmarkPos - beg);
</span><span class='bc' id='L2325' title='0|5|5 - Total: 5'>            ce.setColonPosition(colonPos - beg);
</span><span class='bc' id='L2326' title='0|2|2 - Total: 2'>            pn = ce;
</span>        }
<span class='bc' id='L2328' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode orExpr()
        throws IOException
    {
<span class='bc' id='L2334' title='0|3|3 - Total: 3'>        AstNode pn = andExpr();
</span><span class='bc' id='L2335' title='0|2|2 - Total: 2'>        if (matchToken(Token.OR)) {
</span><span class='bc' id='L2336' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span><span class='bc' id='L2337' title='0|9|9 - Total: 9'>            pn = new InfixExpression(Token.OR, pn, orExpr(), opPos);
</span>        }
<span class='bc' id='L2339' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode andExpr()
        throws IOException
    {
<span class='bc' id='L2345' title='0|3|3 - Total: 3'>        AstNode pn = bitOrExpr();
</span><span class='bc' id='L2346' title='0|2|2 - Total: 2'>        if (matchToken(Token.AND)) {
</span><span class='bc' id='L2347' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span><span class='bc' id='L2348' title='0|9|9 - Total: 9'>            pn = new InfixExpression(Token.AND, pn, andExpr(), opPos);
</span>        }
<span class='bc' id='L2350' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode bitOrExpr()
        throws IOException
    {
<span class='bc' id='L2356' title='0|3|3 - Total: 3'>        AstNode pn = bitXorExpr();
</span><span class='bc' id='L2357' title='0|2|2 - Total: 2'>        while (matchToken(Token.BITOR)) {
</span><span class='bc' id='L2358' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span><span class='bc' id='L2359' title='0|9|9 - Total: 9'>            pn = new InfixExpression(Token.BITOR, pn, bitXorExpr(), opPos);
</span><span class='bc' id='L2360' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2361' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode bitXorExpr()
        throws IOException
    {
<span class='bc' id='L2367' title='0|3|3 - Total: 3'>        AstNode pn = bitAndExpr();
</span><span class='bc' id='L2368' title='0|2|2 - Total: 2'>        while (matchToken(Token.BITXOR)) {
</span><span class='bc' id='L2369' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span><span class='bc' id='L2370' title='0|9|9 - Total: 9'>            pn = new InfixExpression(Token.BITXOR, pn, bitAndExpr(), opPos);
</span><span class='bc' id='L2371' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2372' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode bitAndExpr()
        throws IOException
    {
<span class='bc' id='L2378' title='0|3|3 - Total: 3'>        AstNode pn = eqExpr();
</span><span class='bc' id='L2379' title='0|2|2 - Total: 2'>        while (matchToken(Token.BITAND)) {
</span><span class='bc' id='L2380' title='0|4|4 - Total: 4'>            int opPos = ts.tokenBeg;
</span><span class='bc' id='L2381' title='0|9|9 - Total: 9'>            pn = new InfixExpression(Token.BITAND, pn, eqExpr(), opPos);
</span><span class='bc' id='L2382' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2383' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode eqExpr()
        throws IOException
    {
<span class='bc' id='L2389' title='0|3|3 - Total: 3'>        AstNode pn = relExpr();
</span>        for (;;) {
<span class='bc' id='L2391' title='0|7|7 - Total: 7'>            int tt = peekToken(), opPos = ts.tokenBeg;
</span><span class='bc' id='L2392' title='0|2|2 - Total: 2'>            switch (tt) {
</span>              case Token.EQ:
              case Token.NE:
              case Token.SHEQ:
              case Token.SHNE:
<span class='bc' id='L2397' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L2398' title='0|2|2 - Total: 2'>                int parseToken = tt;
</span><span class='bpc' id='L2399' title='0|1|1 - Total: 2'>                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
</span>                    // JavaScript 1.2 uses shallow equality for == and != .
<span class='nc' id='L2401' title='0|0|0 - Total: 2'>                    if (tt == Token.EQ)
</span><span class='nc' id='L2402' title='0|0|0 - Total: 3'>                        parseToken = Token.SHEQ;
</span><span class='nc' id='L2403' title='0|0|0 - Total: 2'>                    else if (tt == Token.NE)
</span><span class='nc' id='L2404' title='0|0|0 - Total: 2'>                        parseToken = Token.SHNE;
</span>                }
<span class='bc' id='L2406' title='0|9|9 - Total: 9'>                pn = new InfixExpression(parseToken, pn, relExpr(), opPos);
</span><span class='bc' id='L2407' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L2409' title='0|1|1 - Total: 1'>            break;
</span>        }
<span class='bc' id='L2411' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode relExpr()
        throws IOException
    {
<span class='bc' id='L2417' title='0|3|3 - Total: 3'>        AstNode pn = shiftExpr();
</span>        for (;;) {
<span class='bc' id='L2419' title='0|7|7 - Total: 7'>            int tt = peekToken(), opPos = ts.tokenBeg;
</span><span class='bc' id='L2420' title='0|3|3 - Total: 3'>            switch (tt) {
</span>              case Token.IN:
<span class='bc' id='L2422' title='0|2|2 - Total: 2'>                if (inForInit)
</span><span class='bc' id='L2423' title='0|1|1 - Total: 1'>                    break;
</span>                // fall through
              case Token.INSTANCEOF:
              case Token.LE:
              case Token.LT:
              case Token.GE:
              case Token.GT:
<span class='bc' id='L2430' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L2431' title='0|9|9 - Total: 9'>                pn = new InfixExpression(tt, pn, shiftExpr(), opPos);
</span><span class='bc' id='L2432' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L2434' title='0|1|1 - Total: 1'>            break;
</span>        }
<span class='bc' id='L2436' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode shiftExpr()
        throws IOException
    {
<span class='bc' id='L2442' title='0|3|3 - Total: 3'>        AstNode pn = addExpr();
</span>        for (;;) {
<span class='bc' id='L2444' title='0|7|7 - Total: 7'>            int tt = peekToken(), opPos = ts.tokenBeg;
</span><span class='bc' id='L2445' title='0|2|2 - Total: 2'>            switch (tt) {
</span>              case Token.LSH:
              case Token.URSH:
              case Token.RSH:
<span class='bc' id='L2449' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L2450' title='0|9|9 - Total: 9'>                pn = new InfixExpression(tt, pn, addExpr(), opPos);
</span><span class='bc' id='L2451' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L2453' title='0|1|1 - Total: 1'>            break;
</span>        }
<span class='bc' id='L2455' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode addExpr()
        throws IOException
    {
<span class='bc' id='L2461' title='0|3|3 - Total: 3'>        AstNode pn = mulExpr();
</span>        for (;;) {
<span class='bc' id='L2463' title='0|7|7 - Total: 7'>            int tt = peekToken(), opPos = ts.tokenBeg;
</span><span class='bc' id='L2464' title='0|4|4 - Total: 4'>            if (tt == Token.ADD || tt == Token.SUB) {
</span><span class='bc' id='L2465' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L2466' title='0|9|9 - Total: 9'>                pn = new InfixExpression(tt, pn, mulExpr(), opPos);
</span><span class='bc' id='L2467' title='0|1|1 - Total: 1'>                continue;
</span>            }
            break;
        }
<span class='bc' id='L2471' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode mulExpr()
        throws IOException
    {
<span class='bc' id='L2477' title='0|3|3 - Total: 3'>        AstNode pn = unaryExpr();
</span>        for (;;) {
<span class='bc' id='L2479' title='0|7|7 - Total: 7'>            int tt = peekToken(), opPos = ts.tokenBeg;
</span><span class='bc' id='L2480' title='0|2|2 - Total: 2'>            switch (tt) {
</span>              case Token.MUL:
              case Token.DIV:
              case Token.MOD:
<span class='bc' id='L2484' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L2485' title='0|9|9 - Total: 9'>                pn = new InfixExpression(tt, pn, unaryExpr(), opPos);
</span><span class='bc' id='L2486' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L2488' title='0|1|1 - Total: 1'>            break;
</span>        }
<span class='bc' id='L2490' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode unaryExpr()
        throws IOException
    {
        AstNode node;
<span class='bc' id='L2497' title='0|3|3 - Total: 3'>        int tt = peekToken();
</span><span class='bc' id='L2498' title='0|4|4 - Total: 4'>        int line = ts.lineno;
</span>
<span class='bpc' id='L2500' title='0|7|7 - Total: 8'>        switch(tt) {
</span>          case Token.VOID:
          case Token.NOT:
          case Token.BITNOT:
          case Token.TYPEOF:
<span class='bc' id='L2505' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L2506' title='0|10|10 - Total: 10'>              node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());
</span><span class='bc' id='L2507' title='0|3|3 - Total: 3'>              node.setLineno(line);
</span><span class='bc' id='L2508' title='0|2|2 - Total: 2'>              return node;
</span>
          case Token.ADD:
<span class='bc' id='L2511' title='0|2|2 - Total: 2'>              consumeToken();
</span>              // Convert to special POS token in parse tree
<span class='bc' id='L2513' title='0|10|10 - Total: 10'>              node = new UnaryExpression(Token.POS, ts.tokenBeg, unaryExpr());
</span><span class='bc' id='L2514' title='0|3|3 - Total: 3'>              node.setLineno(line);
</span><span class='bc' id='L2515' title='0|2|2 - Total: 2'>              return node;
</span>
          case Token.SUB:
<span class='bc' id='L2518' title='0|2|2 - Total: 2'>              consumeToken();
</span>              // Convert to special NEG token in parse tree
<span class='bc' id='L2520' title='0|10|10 - Total: 10'>              node = new UnaryExpression(Token.NEG, ts.tokenBeg, unaryExpr());
</span><span class='bc' id='L2521' title='0|3|3 - Total: 3'>              node.setLineno(line);
</span><span class='bc' id='L2522' title='0|2|2 - Total: 2'>              return node;
</span>
          case Token.INC:
          case Token.DEC:
<span class='bc' id='L2526' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L2527' title='0|8|8 - Total: 8'>              UnaryExpression expr = new UnaryExpression(tt, ts.tokenBeg,
</span><span class='bc' id='L2528' title='0|3|3 - Total: 3'>                                                         memberExpr(true));
</span><span class='bc' id='L2529' title='0|3|3 - Total: 3'>              expr.setLineno(line);
</span><span class='bc' id='L2530' title='0|3|3 - Total: 3'>              checkBadIncDec(expr);
</span><span class='bc' id='L2531' title='0|2|2 - Total: 2'>              return expr;
</span>
          case Token.DELPROP:
<span class='bc' id='L2534' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L2535' title='0|10|10 - Total: 10'>              node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());
</span><span class='bc' id='L2536' title='0|3|3 - Total: 3'>              node.setLineno(line);
</span><span class='bc' id='L2537' title='0|2|2 - Total: 2'>              return node;
</span>
          case Token.ERROR:
<span class='nc' id='L2540' title='0|0|0 - Total: 2'>              consumeToken();
</span><span class='nc' id='L2541' title='0|0|0 - Total: 3'>              return makeErrorNode();
</span>
          case Token.LT:
              // XML stream encountered in expression.
<span class='bpc' id='L2545' title='0|1|1 - Total: 2'>              if (compilerEnv.isXmlAvailable()) {
</span><span class='bc' id='L2546' title='0|2|2 - Total: 2'>                  consumeToken();
</span><span class='bc' id='L2547' title='0|6|6 - Total: 6'>                  return memberExprTail(true, xmlInitializer());
</span>              }
              // Fall thru to the default handling of RELOP
              // fallthru

          default:
<span class='bc' id='L2553' title='0|4|4 - Total: 4'>              AstNode pn = memberExpr(true);
</span>              // Don't look across a newline boundary for a postfix incop.
<span class='bc' id='L2555' title='0|3|3 - Total: 3'>              tt = peekTokenOrEOL();
</span><span class='bc' id='L2556' title='0|4|4 - Total: 4'>              if (!(tt == Token.INC || tt == Token.DEC)) {
</span><span class='bc' id='L2557' title='0|2|2 - Total: 2'>                  return pn;
</span>              }
<span class='bc' id='L2559' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L2560' title='0|10|10 - Total: 10'>              UnaryExpression uexpr =
</span>                      new UnaryExpression(tt, ts.tokenBeg, pn, true);
<span class='bc' id='L2562' title='0|3|3 - Total: 3'>              uexpr.setLineno(line);
</span><span class='bc' id='L2563' title='0|3|3 - Total: 3'>              checkBadIncDec(uexpr);
</span><span class='bc' id='L2564' title='0|2|2 - Total: 2'>              return uexpr;
</span>        }
    }

    private AstNode xmlInitializer()
        throws IOException
    {
<span class='bpc' id='L2571' title='0|1|1 - Total: 2'>        if (currentToken != Token.LT) codeBug();
</span><span class='bc' id='L2572' title='0|8|8 - Total: 8'>        int pos = ts.tokenBeg, tt = ts.getFirstXMLToken();
</span><span class='bpc' id='L2573' title='0|3|3 - Total: 4'>        if (tt != Token.XML && tt != Token.XMLEND) {
</span><span class='nc' id='L2574' title='0|0|0 - Total: 3'>            reportError("msg.syntax");
</span><span class='nc' id='L2575' title='0|0|0 - Total: 3'>            return makeErrorNode();
</span>        }

<span class='bc' id='L2578' title='0|5|5 - Total: 5'>        XmlLiteral pn = new XmlLiteral(pos);
</span><span class='bc' id='L2579' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span>
<span class='bc' id='L2581' title='0|5|5 - Total: 5'>        for (;;tt = ts.getNextXMLToken()) {
</span><span class='bpc' id='L2582' title='0|2|2 - Total: 3'>            switch (tt) {
</span>              case Token.XML:
<span class='bc' id='L2584' title='0|11|11 - Total: 11'>                  pn.addFragment(new XmlString(ts.tokenBeg, ts.getString()));
</span><span class='bc' id='L2585' title='0|5|5 - Total: 5'>                  mustMatchToken(Token.LC, "msg.syntax");
</span><span class='bc' id='L2586' title='0|4|4 - Total: 4'>                  int beg = ts.tokenBeg;
</span><span class='bpc' id='L2587' title='0|1|1 - Total: 2'>                  AstNode expr = (peekToken() == Token.RC)
</span>                                 ? new EmptyExpression(beg, ts.tokenEnd - beg)
<span class='bc' id='L2589' title='0|2|2 - Total: 2'>                                 : expr();
</span><span class='bc' id='L2590' title='0|5|5 - Total: 5'>                  mustMatchToken(Token.RC, "msg.syntax");
</span><span class='bc' id='L2591' title='0|6|6 - Total: 6'>                  XmlExpression xexpr = new XmlExpression(beg, expr);
</span><span class='bc' id='L2592' title='0|5|5 - Total: 5'>                  xexpr.setIsXmlAttribute(ts.isXMLAttribute());
</span><span class='bc' id='L2593' title='0|7|7 - Total: 7'>                  xexpr.setLength(ts.tokenEnd - beg);
</span><span class='bc' id='L2594' title='0|3|3 - Total: 3'>                  pn.addFragment(xexpr);
</span><span class='bc' id='L2595' title='0|1|1 - Total: 1'>                  break;
</span>
              case Token.XMLEND:
<span class='bc' id='L2598' title='0|11|11 - Total: 11'>                  pn.addFragment(new XmlString(ts.tokenBeg, ts.getString()));
</span><span class='bc' id='L2599' title='0|2|2 - Total: 2'>                  return pn;
</span>
              default:
<span class='nc' id='L2602' title='0|0|0 - Total: 3'>                  reportError("msg.syntax");
</span><span class='nc' id='L2603' title='0|0|0 - Total: 3'>                  return makeErrorNode();
</span>            }
        }
    }

    private List<AstNode> argumentList()
        throws IOException
    {
<span class='bc' id='L2611' title='0|2|2 - Total: 2'>        if (matchToken(Token.RP))
</span><span class='bc' id='L2612' title='0|2|2 - Total: 2'>            return null;
</span>
<span class='bc' id='L2614' title='0|4|4 - Total: 4'>        List<AstNode> result = new ArrayList<AstNode>();
</span><span class='bc' id='L2615' title='0|3|3 - Total: 3'>        boolean wasInForInit = inForInit;
</span><span class='bc' id='L2616' title='0|3|3 - Total: 3'>        inForInit = false;
</span>        try {
            do {
<span class='bc' id='L2619' title='0|2|2 - Total: 2'>                if (peekToken() == Token.YIELD) {
</span><span class='nc' id='L2620' title='0|0|0 - Total: 3'>                    reportError("msg.yield.parenthesized");
</span>                }
<span class='bc' id='L2622' title='0|3|3 - Total: 3'>                AstNode en = assignExpr();
</span><span class='bc' id='L2623' title='0|2|2 - Total: 2'>                if (peekToken() == Token.FOR) {
</span>                    try {
<span class='bc' id='L2625' title='0|8|8 - Total: 8'>                        result.add(generatorExpression(en, 0, true));
</span>                    }
<span class='nc' id='L2627' title='0|0|0 - Total: 1'>                    catch(IOException ex) {
</span>                        // #TODO
<span class='bpc' id='L2629' title='0|1|1 - Total: 2'>                    }
</span>                }
                else {                           
<span class='bc' id='L2632' title='0|4|4 - Total: 4'>                    result.add(en);
</span>                }
<span class='bc' id='L2634' title='0|2|2 - Total: 2'>            } while (matchToken(Token.COMMA));
</span>        } finally {
<span class='bc' id='L2636' title='0|7|7 - Total: 7'>            inForInit = wasInForInit;
</span><span class='bc' id='L2637' title='0|3|3 - Total: 3'>        }
</span>
<span class='bc' id='L2639' title='0|5|5 - Total: 5'>        mustMatchToken(Token.RP, "msg.no.paren.arg");
</span><span class='bc' id='L2640' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Parse a new-expression, or if next token isn't {@link Token#NEW},
     * a primary expression.
     * @param allowCallSyntax passed down to {@link #memberExprTail}
     */
    private AstNode memberExpr(boolean allowCallSyntax)
        throws IOException
    {
<span class='bc' id='L2651' title='0|7|7 - Total: 7'>        int tt = peekToken(), lineno = ts.lineno;
</span>        AstNode pn;

<span class='bc' id='L2654' title='0|2|2 - Total: 2'>        if (tt != Token.NEW) {
</span><span class='bc' id='L2655' title='0|4|4 - Total: 4'>            pn = primaryExpr();
</span>        } else {
<span class='bc' id='L2657' title='0|2|2 - Total: 2'>            consumeToken();
</span><span class='bc' id='L2658' title='0|4|4 - Total: 4'>            int pos = ts.tokenBeg;
</span><span class='bc' id='L2659' title='0|5|5 - Total: 5'>            NewExpression nx = new NewExpression(pos);
</span>
<span class='bc' id='L2661' title='0|4|4 - Total: 4'>            AstNode target = memberExpr(false);
</span><span class='bc' id='L2662' title='0|4|4 - Total: 4'>            int end = getNodeEnd(target);
</span><span class='bc' id='L2663' title='0|3|3 - Total: 3'>            nx.setTarget(target);
</span>
<span class='bc' id='L2665' title='0|2|2 - Total: 2'>            int lp = -1;
</span><span class='bc' id='L2666' title='0|2|2 - Total: 2'>            if (matchToken(Token.LP)) {
</span><span class='bc' id='L2667' title='0|4|4 - Total: 4'>                lp = ts.tokenBeg;
</span><span class='bc' id='L2668' title='0|3|3 - Total: 3'>                List<AstNode> args = argumentList();
</span><span class='bpc' id='L2669' title='0|3|3 - Total: 4'>                if (args != null && args.size() > ARGC_LIMIT)
</span><span class='nc' id='L2670' title='0|0|0 - Total: 3'>                    reportError("msg.too.many.constructor.args");
</span><span class='bc' id='L2671' title='0|4|4 - Total: 4'>                int rp = ts.tokenBeg;
</span><span class='bc' id='L2672' title='0|4|4 - Total: 4'>                end = ts.tokenEnd;
</span><span class='bc' id='L2673' title='0|2|2 - Total: 2'>                if (args != null)
</span><span class='bc' id='L2674' title='0|3|3 - Total: 3'>                    nx.setArguments(args);
</span><span class='bc' id='L2675' title='0|8|8 - Total: 8'>                nx.setParens(lp - pos, rp - pos);
</span>            }

            // Experimental syntax: allow an object literal to follow a new
            // expression, which will mean a kind of anonymous class built with
            // the JavaAdapter.  the object literal will be passed as an
            // additional argument to the constructor.
<span class='bc' id='L2682' title='0|2|2 - Total: 2'>            if (matchToken(Token.LC)) {
</span><span class='bc' id='L2683' title='0|3|3 - Total: 3'>                ObjectLiteral initializer = objectLiteral();
</span><span class='bc' id='L2684' title='0|4|4 - Total: 4'>                end = getNodeEnd(initializer);
</span><span class='bc' id='L2685' title='0|3|3 - Total: 3'>                nx.setInitializer(initializer);
</span>            }
<span class='bc' id='L2687' title='0|5|5 - Total: 5'>            nx.setLength(end - pos);
</span><span class='bc' id='L2688' title='0|2|2 - Total: 2'>            pn = nx;
</span>        }
<span class='bc' id='L2690' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L2691' title='0|5|5 - Total: 5'>        AstNode tail = memberExprTail(allowCallSyntax, pn);
</span><span class='bc' id='L2692' title='0|2|2 - Total: 2'>        return tail;
</span>    }

    /**
     * Parse any number of "(expr)", "[expr]" ".expr", "..expr",
     * or ".(expr)" constructs trailing the passed expression.
     * @param pn the non-null parent node
     * @return the outermost (lexically last occurring) expression,
     * which will have the passed parent node as a descendant
     */
    private AstNode memberExprTail(boolean allowCallSyntax, AstNode pn)
        throws IOException
    {
        // we no longer return null for errors, so this won't be null
<span class='bpc' id='L2706' title='0|1|1 - Total: 2'>        if (pn == null) codeBug();
</span><span class='bc' id='L2707' title='0|3|3 - Total: 3'>        int pos = pn.getPosition();
</span>        int lineno;
      tailLoop:
        for (;;) {
<span class='bc' id='L2711' title='0|3|3 - Total: 3'>            int tt = peekToken();
</span><span class='bc' id='L2712' title='0|5|5 - Total: 5'>            switch (tt) {
</span>              case Token.DOT:
              case Token.DOTDOT:
<span class='bc' id='L2715' title='0|4|4 - Total: 4'>                  lineno = ts.lineno;
</span><span class='bc' id='L2716' title='0|5|5 - Total: 5'>                  pn = propertyAccess(tt, pn);
</span><span class='bc' id='L2717' title='0|3|3 - Total: 3'>                  pn.setLineno(lineno);
</span><span class='bc' id='L2718' title='0|1|1 - Total: 1'>                  break;
</span>
              case Token.DOTQUERY:
<span class='bc' id='L2721' title='0|2|2 - Total: 2'>                  consumeToken();
</span><span class='bc' id='L2722' title='0|6|6 - Total: 6'>                  int opPos = ts.tokenBeg, rp = -1;
</span><span class='bc' id='L2723' title='0|4|4 - Total: 4'>                  lineno = ts.lineno;
</span><span class='bc' id='L2724' title='0|2|2 - Total: 2'>                  mustHaveXML();
</span><span class='bc' id='L2725' title='0|2|2 - Total: 2'>                  setRequiresActivation();
</span><span class='bc' id='L2726' title='0|3|3 - Total: 3'>                  AstNode filter = expr();
</span><span class='bc' id='L2727' title='0|4|4 - Total: 4'>                  int end = getNodeEnd(filter);
</span><span class='bpc' id='L2728' title='0|1|1 - Total: 2'>                  if (mustMatchToken(Token.RP, "msg.no.paren")) {
</span><span class='bc' id='L2729' title='0|4|4 - Total: 4'>                      rp = ts.tokenBeg;
</span><span class='bc' id='L2730' title='0|4|4 - Total: 4'>                      end = ts.tokenEnd;
</span>                  }
<span class='bc' id='L2732' title='0|8|8 - Total: 8'>                  XmlDotQuery q = new XmlDotQuery(pos, end - pos);
</span><span class='bc' id='L2733' title='0|3|3 - Total: 3'>                  q.setLeft(pn);
</span><span class='bc' id='L2734' title='0|3|3 - Total: 3'>                  q.setRight(filter);
</span><span class='bc' id='L2735' title='0|3|3 - Total: 3'>                  q.setOperatorPosition(opPos);
</span><span class='bc' id='L2736' title='0|5|5 - Total: 5'>                  q.setRp(rp - pos);
</span><span class='bc' id='L2737' title='0|3|3 - Total: 3'>                  q.setLineno(lineno);
</span><span class='bc' id='L2738' title='0|2|2 - Total: 2'>                  pn = q;
</span><span class='bc' id='L2739' title='0|1|1 - Total: 1'>                  break;
</span>
              case Token.LB:
<span class='bc' id='L2742' title='0|2|2 - Total: 2'>                  consumeToken();
</span><span class='bc' id='L2743' title='0|6|6 - Total: 6'>                  int lb = ts.tokenBeg, rb = -1;
</span><span class='bc' id='L2744' title='0|4|4 - Total: 4'>                  lineno = ts.lineno;
</span><span class='bc' id='L2745' title='0|3|3 - Total: 3'>                  AstNode expr = expr();
</span><span class='bc' id='L2746' title='0|4|4 - Total: 4'>                  end = getNodeEnd(expr);
</span><span class='bpc' id='L2747' title='0|1|1 - Total: 2'>                  if (mustMatchToken(Token.RB, "msg.no.bracket.index")) {
</span><span class='bc' id='L2748' title='0|4|4 - Total: 4'>                      rb = ts.tokenBeg;
</span><span class='bc' id='L2749' title='0|4|4 - Total: 4'>                      end = ts.tokenEnd;
</span>                  }
<span class='bc' id='L2751' title='0|8|8 - Total: 8'>                  ElementGet g = new ElementGet(pos, end - pos);
</span><span class='bc' id='L2752' title='0|3|3 - Total: 3'>                  g.setTarget(pn);
</span><span class='bc' id='L2753' title='0|3|3 - Total: 3'>                  g.setElement(expr);
</span><span class='bc' id='L2754' title='0|4|4 - Total: 4'>                  g.setParens(lb, rb);
</span><span class='bc' id='L2755' title='0|3|3 - Total: 3'>                  g.setLineno(lineno);
</span><span class='bc' id='L2756' title='0|2|2 - Total: 2'>                  pn = g;
</span><span class='bc' id='L2757' title='0|1|1 - Total: 1'>                  break;
</span>
              case Token.LP:
<span class='bc' id='L2760' title='0|2|2 - Total: 2'>                  if (!allowCallSyntax) {
</span><span class='bc' id='L2761' title='0|1|1 - Total: 1'>                      break tailLoop;
</span>                  }
<span class='bc' id='L2763' title='0|4|4 - Total: 4'>                  lineno = ts.lineno;
</span><span class='bc' id='L2764' title='0|2|2 - Total: 2'>                  consumeToken();
</span><span class='bc' id='L2765' title='0|3|3 - Total: 3'>                  checkCallRequiresActivation(pn);
</span><span class='bc' id='L2766' title='0|5|5 - Total: 5'>                  FunctionCall f = new FunctionCall(pos);
</span><span class='bc' id='L2767' title='0|3|3 - Total: 3'>                  f.setTarget(pn);
</span>                  // Assign the line number for the function call to where
                  // the paren appeared, not where the name expression started.
<span class='bc' id='L2770' title='0|3|3 - Total: 3'>                  f.setLineno(lineno);
</span><span class='bc' id='L2771' title='0|7|7 - Total: 7'>                  f.setLp(ts.tokenBeg - pos);
</span><span class='bc' id='L2772' title='0|3|3 - Total: 3'>                  List<AstNode> args = argumentList();
</span><span class='bpc' id='L2773' title='0|3|3 - Total: 4'>                  if (args != null && args.size() > ARGC_LIMIT)
</span><span class='nc' id='L2774' title='0|0|0 - Total: 3'>                      reportError("msg.too.many.function.args");
</span><span class='bc' id='L2775' title='0|3|3 - Total: 3'>                  f.setArguments(args);
</span><span class='bc' id='L2776' title='0|7|7 - Total: 7'>                  f.setRp(ts.tokenBeg - pos);
</span><span class='bc' id='L2777' title='0|7|7 - Total: 7'>                  f.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L2778' title='0|2|2 - Total: 2'>                  pn = f;
</span><span class='bc' id='L2779' title='0|1|1 - Total: 1'>                  break;
</span>
              default:
<span class='bc' id='L2782' title='0|1|1 - Total: 1'>                  break tailLoop;
</span>            }
<span class='bc' id='L2784' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L2785' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    /**
     * Handles any construct following a "." or ".." operator.
     * @param pn the left-hand side (target) of the operator.  Never null.
     * @return a PropertyGet, XmlMemberGet, or ErrorNode
     */
    private AstNode propertyAccess(int tt, AstNode pn)
            throws IOException
    {
<span class='bpc' id='L2796' title='0|1|1 - Total: 2'>        if (pn == null) codeBug();
</span><span class='bc' id='L2797' title='0|10|10 - Total: 10'>        int memberTypeFlags = 0, lineno = ts.lineno, dotPos = ts.tokenBeg;
</span><span class='bc' id='L2798' title='0|2|2 - Total: 2'>        consumeToken();
</span>
<span class='bc' id='L2800' title='0|2|2 - Total: 2'>        if (tt == Token.DOTDOT) {
</span><span class='bc' id='L2801' title='0|2|2 - Total: 2'>            mustHaveXML();
</span><span class='bc' id='L2802' title='0|2|2 - Total: 2'>            memberTypeFlags = Node.DESCENDANTS_FLAG;
</span>        }

<span class='bc' id='L2805' title='0|2|2 - Total: 2'>        if (!compilerEnv.isXmlAvailable()) {
</span><span class='bc' id='L2806' title='0|3|3 - Total: 3'>            int maybeName = nextToken();
</span><span class='bpc' id='L2807' title='0|1|1 - Total: 2'>            if (maybeName != Token.NAME
</span><span class='nc' id='L2808' title='0|0|0 - Total: 2'>                    && !(compilerEnv.isReservedKeywordAsIdentifier()
</span><span class='nc' id='L2809' title='0|0|0 - Total: 2'>                    && TokenStream.isKeyword(ts.getString(), compilerEnv.getLanguageVersion(), inUseStrictDirective))) {
</span><span class='nc' id='L2810' title='0|0|0 - Total: 3'>              reportError("msg.no.name.after.dot");
</span>            }

<span class='bc' id='L2813' title='0|5|5 - Total: 5'>            Name name = createNameNode(true, Token.GETPROP);
</span><span class='bc' id='L2814' title='0|7|7 - Total: 7'>            PropertyGet pg = new PropertyGet(pn, name, dotPos);
</span><span class='bc' id='L2815' title='0|3|3 - Total: 3'>            pg.setLineno(lineno);
</span><span class='bc' id='L2816' title='0|2|2 - Total: 2'>            return pg;
</span>        }

<span class='bc' id='L2819' title='0|2|2 - Total: 2'>        AstNode ref = null;  // right side of . or .. operator
</span>
<span class='bc' id='L2821' title='0|3|3 - Total: 3'>        int token = nextToken();
</span><span class='bpc' id='L2822' title='0|5|5 - Total: 6'>        switch (token) {
</span>          case Token.THROW:
              // needed for generator.throw();
<span class='bc' id='L2825' title='0|9|9 - Total: 9'>              saveNameTokenData(ts.tokenBeg, "throw", ts.lineno);
</span><span class='bc' id='L2826' title='0|6|6 - Total: 6'>              ref = propertyName(-1, "throw", memberTypeFlags);
</span><span class='bc' id='L2827' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.NAME:
              // handles: name, ns::name, ns::*, ns::[expr]
<span class='bc' id='L2831' title='0|8|8 - Total: 8'>              ref = propertyName(-1, ts.getString(), memberTypeFlags);
</span><span class='bc' id='L2832' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.MUL:
              // handles: *, *::name, *::*, *::[expr]
<span class='bc' id='L2836' title='0|9|9 - Total: 9'>              saveNameTokenData(ts.tokenBeg, "*", ts.lineno);
</span><span class='bc' id='L2837' title='0|6|6 - Total: 6'>              ref = propertyName(-1, "*", memberTypeFlags);
</span><span class='bc' id='L2838' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.XMLATTR:
              // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',
              //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'
<span class='bc' id='L2843' title='0|3|3 - Total: 3'>              ref = attributeAccess();
</span><span class='bc' id='L2844' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.RESERVED: {
<span class='nc' id='L2847' title='0|0|0 - Total: 4'>              String name = ts.getString();
</span><span class='nc' id='L2848' title='0|0|0 - Total: 9'>              saveNameTokenData(ts.tokenBeg, name, ts.lineno);
</span><span class='nc' id='L2849' title='0|0|0 - Total: 6'>              ref = propertyName(-1, name, memberTypeFlags);
</span><span class='nc' id='L2850' title='0|0|0 - Total: 1'>              break;
</span>          }

          default:
<span class='bpc' id='L2854' title='0|1|1 - Total: 2'>              if (compilerEnv.isReservedKeywordAsIdentifier()) {
</span>                  // allow keywords as property names, e.g. ({if: 1})
<span class='bc' id='L2856' title='0|3|3 - Total: 3'>                  String name = Token.keywordToName(token);
</span><span class='bpc' id='L2857' title='0|1|1 - Total: 2'>                  if (name != null) {
</span><span class='bc' id='L2858' title='0|9|9 - Total: 9'>                      saveNameTokenData(ts.tokenBeg, name, ts.lineno);
</span><span class='bc' id='L2859' title='0|6|6 - Total: 6'>                      ref = propertyName(-1, name, memberTypeFlags);
</span><span class='bc' id='L2860' title='0|1|1 - Total: 1'>                      break;
</span>                  }
              }
<span class='nc' id='L2863' title='0|0|0 - Total: 3'>              reportError("msg.no.name.after.dot");
</span><span class='nc' id='L2864' title='0|0|0 - Total: 3'>              return makeErrorNode();
</span>        }

<span class='bc' id='L2867' title='0|3|3 - Total: 3'>        boolean xml = ref instanceof XmlRef;
</span><span class='bc' id='L2868' title='0|2|2 - Total: 2'>        InfixExpression result = xml ? new XmlMemberGet() : new PropertyGet();
</span><span class='bc' id='L2869' title='0|4|4 - Total: 4'>        if (xml && tt == Token.DOT)
</span><span class='bc' id='L2870' title='0|4|4 - Total: 4'>            result.setType(Token.DOT);
</span><span class='bc' id='L2871' title='0|3|3 - Total: 3'>        int pos = pn.getPosition();
</span><span class='bc' id='L2872' title='0|3|3 - Total: 3'>        result.setPosition(pos);
</span><span class='bc' id='L2873' title='0|7|7 - Total: 7'>        result.setLength(getNodeEnd(ref) - pos);
</span><span class='bc' id='L2874' title='0|5|5 - Total: 5'>        result.setOperatorPosition(dotPos - pos);
</span><span class='bc' id='L2875' title='0|4|4 - Total: 4'>        result.setLineno(pn.getLineno());
</span><span class='bc' id='L2876' title='0|3|3 - Total: 3'>        result.setLeft(pn);  // do this after setting position
</span><span class='bc' id='L2877' title='0|3|3 - Total: 3'>        result.setRight(ref);
</span><span class='bc' id='L2878' title='0|2|2 - Total: 2'>        return result;
</span>    }

    /**
     * Xml attribute expression:<p>
     *   {@code @attr}, {@code @ns::attr}, {@code @ns::*}, {@code @ns::*},
     *   {@code @*}, {@code @*::attr}, {@code @*::*}, {@code @ns::[expr]},
     *   {@code @*::[expr]}, {@code @[expr]} <p>
     * Called if we peeked an '@' token.
     */
    private AstNode attributeAccess()
        throws IOException
    {
<span class='bc' id='L2891' title='0|7|7 - Total: 7'>        int tt = nextToken(), atPos = ts.tokenBeg;
</span>
<span class='bpc' id='L2893' title='0|3|3 - Total: 4'>        switch (tt) {
</span>          // handles: @name, @ns::name, @ns::*, @ns::[expr]
          case Token.NAME:
<span class='bc' id='L2896' title='0|8|8 - Total: 8'>              return propertyName(atPos, ts.getString(), 0);
</span>
          // handles: @*, @*::name, @*::*, @*::[expr]
          case Token.MUL:
<span class='bc' id='L2900' title='0|9|9 - Total: 9'>              saveNameTokenData(ts.tokenBeg, "*", ts.lineno);
</span><span class='bc' id='L2901' title='0|6|6 - Total: 6'>              return propertyName(atPos, "*", 0);
</span>
          // handles @[expr]
          case Token.LB:
<span class='bc' id='L2905' title='0|6|6 - Total: 6'>              return xmlElemRef(atPos, null, -1);
</span>
          default:
<span class='nc' id='L2908' title='0|0|0 - Total: 3'>              reportError("msg.no.name.after.xmlAttr");
</span><span class='nc' id='L2909' title='0|0|0 - Total: 3'>              return makeErrorNode();
</span>        }
    }

    /**
     * Check if :: follows name in which case it becomes a qualified name.
     *
     * @param atPos a natural number if we just read an '@' token, else -1
     *
     * @param s the name or string that was matched (an identifier, "throw" or
     * "*").
     *
     * @param memberTypeFlags flags tracking whether we're a '.' or '..' child
     *
     * @return an XmlRef node if it's an attribute access, a child of a
     * '..' operator, or the name is followed by ::.  For a plain name,
     * returns a Name node.  Returns an ErrorNode for malformed XML
     * expressions.  (For now - might change to return a partial XmlRef.)
     */
    private AstNode propertyName(int atPos, String s, int memberTypeFlags)
        throws IOException
    {
<span class='bc' id='L2931' title='0|2|2 - Total: 2'>        int pos = atPos != -1 ? atPos : ts.tokenBeg, lineno = ts.lineno;
</span><span class='bc' id='L2932' title='0|2|2 - Total: 2'>        int colonPos = -1;
</span><span class='bc' id='L2933' title='0|6|6 - Total: 6'>        Name name = createNameNode(true, currentToken);
</span><span class='bc' id='L2934' title='0|2|2 - Total: 2'>        Name ns = null;
</span>
<span class='bc' id='L2936' title='0|2|2 - Total: 2'>        if (matchToken(Token.COLONCOLON)) {
</span><span class='bc' id='L2937' title='0|2|2 - Total: 2'>            ns = name;
</span><span class='bc' id='L2938' title='0|4|4 - Total: 4'>            colonPos = ts.tokenBeg;
</span>
<span class='bpc' id='L2940' title='0|3|3 - Total: 4'>            switch (nextToken()) {
</span>              // handles name::name
              case Token.NAME:
<span class='bc' id='L2943' title='0|3|3 - Total: 3'>                  name = createNameNode();
</span><span class='bc' id='L2944' title='0|1|1 - Total: 1'>                  break;
</span>
              // handles name::*
              case Token.MUL:
<span class='bc' id='L2948' title='0|9|9 - Total: 9'>                  saveNameTokenData(ts.tokenBeg, "*", ts.lineno);
</span><span class='bc' id='L2949' title='0|5|5 - Total: 5'>                  name = createNameNode(false, -1);
</span><span class='bc' id='L2950' title='0|1|1 - Total: 1'>                  break;
</span>
              // handles name::[expr] or *::[expr]
              case Token.LB:
<span class='bc' id='L2954' title='0|6|6 - Total: 6'>                  return xmlElemRef(atPos, ns, colonPos);
</span>
              default:
<span class='nc' id='L2957' title='0|0|0 - Total: 3'>                  reportError("msg.no.name.after.coloncolon");
</span><span class='nc' id='L2958' title='0|0|0 - Total: 3'>                  return makeErrorNode();
</span>            }
        }

<span class='bc' id='L2962' title='0|6|6 - Total: 6'>        if (ns == null && memberTypeFlags == 0 && atPos == -1) {
</span><span class='bc' id='L2963' title='0|2|2 - Total: 2'>            return name;
</span>        }

<span class='bc' id='L2966' title='0|10|10 - Total: 10'>        XmlPropRef ref = new XmlPropRef(pos, getNodeEnd(name) - pos);
</span><span class='bc' id='L2967' title='0|3|3 - Total: 3'>        ref.setAtPos(atPos);
</span><span class='bc' id='L2968' title='0|3|3 - Total: 3'>        ref.setNamespace(ns);
</span><span class='bc' id='L2969' title='0|3|3 - Total: 3'>        ref.setColonPos(colonPos);
</span><span class='bc' id='L2970' title='0|3|3 - Total: 3'>        ref.setPropName(name);
</span><span class='bc' id='L2971' title='0|3|3 - Total: 3'>        ref.setLineno(lineno);
</span><span class='bc' id='L2972' title='0|2|2 - Total: 2'>        return ref;
</span>    }

    /**
     * Parse the [expr] portion of an xml element reference, e.g.
     * @[expr], @*::[expr], or ns::[expr].
     */
    private XmlElemRef xmlElemRef(int atPos, Name namespace, int colonPos)
        throws IOException
    {
<span class='bc' id='L2982' title='0|2|2 - Total: 2'>        int lb = ts.tokenBeg, rb = -1, pos = atPos != -1 ? atPos : lb;
</span><span class='bc' id='L2983' title='0|3|3 - Total: 3'>        AstNode expr = expr();
</span><span class='bc' id='L2984' title='0|4|4 - Total: 4'>        int end = getNodeEnd(expr);
</span><span class='bpc' id='L2985' title='0|1|1 - Total: 2'>        if (mustMatchToken(Token.RB, "msg.no.bracket.index")) {
</span><span class='bc' id='L2986' title='0|4|4 - Total: 4'>            rb = ts.tokenBeg;
</span><span class='bc' id='L2987' title='0|4|4 - Total: 4'>            end = ts.tokenEnd;
</span>        }
<span class='bc' id='L2989' title='0|8|8 - Total: 8'>        XmlElemRef ref = new XmlElemRef(pos, end - pos);
</span><span class='bc' id='L2990' title='0|3|3 - Total: 3'>        ref.setNamespace(namespace);
</span><span class='bc' id='L2991' title='0|3|3 - Total: 3'>        ref.setColonPos(colonPos);
</span><span class='bc' id='L2992' title='0|3|3 - Total: 3'>        ref.setAtPos(atPos);
</span><span class='bc' id='L2993' title='0|3|3 - Total: 3'>        ref.setExpression(expr);
</span><span class='bc' id='L2994' title='0|4|4 - Total: 4'>        ref.setBrackets(lb, rb);
</span><span class='bc' id='L2995' title='0|2|2 - Total: 2'>        return ref;
</span>    }

    private AstNode destructuringPrimaryExpr()
        throws IOException, ParserException
    {
        try {
<span class='bc' id='L3002' title='0|3|3 - Total: 3'>            inDestructuringAssignment = true;
</span><span class='bc' id='L3003' title='0|5|5 - Total: 5'>            return primaryExpr();
</span>        } finally {
<span class='bc' id='L3005' title='0|7|7 - Total: 7'>            inDestructuringAssignment = false;
</span><span class='bc' id='L3006' title='0|2|2 - Total: 2'>        }
</span>    }

    private AstNode primaryExpr()
        throws IOException
    {
<span class='bc' id='L3012' title='0|3|3 - Total: 3'>        int ttFlagged = peekFlaggedToken();
</span><span class='bc' id='L3013' title='0|4|4 - Total: 4'>        int tt = ttFlagged & CLEAR_TI_MASK;
</span>
<span class='bpc' id='L3015' title='0|13|13 - Total: 15'>        switch(tt) {
</span>          case Token.FUNCTION:
<span class='bc' id='L3017' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3018' title='0|4|4 - Total: 4'>              return function(FunctionNode.FUNCTION_EXPRESSION);
</span>
          case Token.LB:
<span class='bc' id='L3021' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3022' title='0|3|3 - Total: 3'>              return arrayLiteral();
</span>
          case Token.LC:
<span class='bc' id='L3025' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3026' title='0|3|3 - Total: 3'>              return objectLiteral();
</span>
          case Token.LET:
<span class='bc' id='L3029' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3030' title='0|7|7 - Total: 7'>              return let(false, ts.tokenBeg);
</span>
          case Token.LP:
<span class='bc' id='L3033' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3034' title='0|3|3 - Total: 3'>              return parenExpr();
</span>
          case Token.XMLATTR:
<span class='bc' id='L3037' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3038' title='0|2|2 - Total: 2'>              mustHaveXML();
</span><span class='bc' id='L3039' title='0|3|3 - Total: 3'>              return attributeAccess();
</span>
          case Token.NAME:
<span class='bc' id='L3042' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3043' title='0|5|5 - Total: 5'>              return name(ttFlagged, tt);
</span>
          case Token.NUMBER: {
<span class='bc' id='L3046' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3047' title='0|4|4 - Total: 4'>              String s = ts.getString();
</span><span class='bpc' id='L3048' title='0|3|3 - Total: 4'>              if (this.inUseStrictDirective && ts.isNumberOldOctal()) {
</span><span class='nc' id='L3049' title='0|0|0 - Total: 3'>                  reportError("msg.no.old.octal.strict");
</span>              }
<span class='bpc' id='L3051' title='0|1|1 - Total: 2'>              if (ts.isNumberBinary()) {
</span><span class='nc' id='L3052' title='0|0|0 - Total: 9'>                  s = "0b"+s;
</span>              }
<span class='bc' id='L3054' title='0|2|2 - Total: 2'>              if (ts.isNumberOldOctal()) {
</span><span class='bc' id='L3055' title='0|9|9 - Total: 9'>                  s = "0"+s;
</span>              }
<span class='bpc' id='L3057' title='0|1|1 - Total: 2'>              if (ts.isNumberOctal()) {
</span><span class='nc' id='L3058' title='0|0|0 - Total: 9'>                  s = "0o"+s;
</span>              }
<span class='bc' id='L3060' title='0|2|2 - Total: 2'>              if (ts.isNumberHex()) {
</span><span class='bc' id='L3061' title='0|9|9 - Total: 9'>                  s = "0x"+s;
</span>              }
<span class='bc' id='L3063' title='0|9|9 - Total: 9'>              return new NumberLiteral(ts.tokenBeg,
</span>                                       s,
<span class='bc' id='L3065' title='0|2|2 - Total: 2'>                                       ts.getNumber());
</span>          }

          case Token.STRING:
<span class='bc' id='L3069' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3070' title='0|3|3 - Total: 3'>              return createStringLiteral();
</span>
          case Token.DIV:
          case Token.ASSIGN_DIV:
<span class='bc' id='L3074' title='0|2|2 - Total: 2'>              consumeToken();
</span>              // Got / or /= which in this context means a regexp
<span class='bc' id='L3076' title='0|4|4 - Total: 4'>              ts.readRegExp(tt);
</span><span class='bc' id='L3077' title='0|8|8 - Total: 8'>              int pos = ts.tokenBeg, end = ts.tokenEnd;
</span><span class='bc' id='L3078' title='0|8|8 - Total: 8'>              RegExpLiteral re = new RegExpLiteral(pos, end - pos);
</span><span class='bc' id='L3079' title='0|5|5 - Total: 5'>              re.setValue(ts.getString());
</span><span class='bc' id='L3080' title='0|5|5 - Total: 5'>              re.setFlags(ts.readAndClearRegExpFlags());
</span><span class='bc' id='L3081' title='0|2|2 - Total: 2'>              return re;
</span>
          case Token.NULL:
          case Token.THIS:
          case Token.FALSE:
          case Token.TRUE:
<span class='bc' id='L3087' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3088' title='0|8|8 - Total: 8'>              pos = ts.tokenBeg; end = ts.tokenEnd;
</span><span class='bc' id='L3089' title='0|9|9 - Total: 9'>              return new KeywordLiteral(pos, end - pos, tt);
</span>
          case Token.RESERVED:
<span class='bc' id='L3092' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='nc' id='L3093' title='0|0|0 - Total: 6'>              reportError("msg.reserved.id", ts.getString());
</span><span class='nc' id='L3094' title='0|0|0 - Total: 1'>              break;
</span>
          case Token.ERROR:
<span class='nc' id='L3097' title='0|0|0 - Total: 2'>              consumeToken();
</span>              // the scanner or one of its subroutines reported the error.
<span class='nc' id='L3099' title='0|0|0 - Total: 1'>              break;
</span>
          case Token.EOF:
<span class='nc' id='L3102' title='0|0|0 - Total: 2'>              consumeToken();
</span><span class='nc' id='L3103' title='0|0|0 - Total: 3'>              reportError("msg.unexpected.eof");
</span><span class='nc' id='L3104' title='0|0|0 - Total: 1'>              break;
</span>
          default:
<span class='bc' id='L3107' title='0|2|2 - Total: 2'>              consumeToken();
</span><span class='bc' id='L3108' title='0|3|3 - Total: 3'>              reportError("msg.syntax");
</span>              break;
        }
        // should only be reachable in IDE/error-recovery mode
<span class='bc' id='L3112' title='0|2|2 - Total: 2'>        consumeToken();
</span><span class='bc' id='L3113' title='0|3|3 - Total: 3'>        return makeErrorNode();
</span>    }

    private AstNode parenExpr() throws IOException {
<span class='bc' id='L3117' title='0|3|3 - Total: 3'>        boolean wasInForInit = inForInit;
</span><span class='bc' id='L3118' title='0|3|3 - Total: 3'>        inForInit = false;
</span>        try {
<span class='bc' id='L3120' title='0|3|3 - Total: 3'>            Comment jsdocNode = getAndResetJsDoc();
</span><span class='bc' id='L3121' title='0|4|4 - Total: 4'>            int lineno = ts.lineno;
</span><span class='bc' id='L3122' title='0|4|4 - Total: 4'>            int begin = ts.tokenBeg;
</span><span class='bc' id='L3123' title='0|2|2 - Total: 2'>            AstNode e = (peekToken() == Token.RP ? new EmptyExpression(begin) : expr());
</span><span class='bc' id='L3124' title='0|2|2 - Total: 2'>            if (peekToken() == Token.FOR) {
</span><span class='bc' id='L3125' title='0|7|7 - Total: 7'>                return generatorExpression(e, begin);
</span>            }
<span class='bc' id='L3127' title='0|5|5 - Total: 5'>            ParenthesizedExpression pn = new ParenthesizedExpression(e);
</span><span class='bc' id='L3128' title='0|2|2 - Total: 2'>            if (jsdocNode == null) {
</span><span class='bc' id='L3129' title='0|3|3 - Total: 3'>                jsdocNode = getAndResetJsDoc();
</span>            }
<span class='bc' id='L3131' title='0|2|2 - Total: 2'>            if (jsdocNode != null) {
</span><span class='bc' id='L3132' title='0|3|3 - Total: 3'>                pn.setJsDocNode(jsdocNode);
</span>            }
<span class='bc' id='L3134' title='0|5|5 - Total: 5'>            mustMatchToken(Token.RP, "msg.no.paren");
</span><span class='bc' id='L3135' title='0|4|4 - Total: 4'>            if (e.getType() == Token.EMPTY && peekToken() != Token.ARROW) {
</span><span class='nc' id='L3136' title='0|0|0 - Total: 3'>              reportError("msg.syntax");
</span><span class='nc' id='L3137' title='0|0|0 - Total: 5'>              return makeErrorNode();
</span>            }
<span class='bc' id='L3139' title='0|8|8 - Total: 8'>            pn.setLength(ts.tokenEnd - pn.getPosition());
</span><span class='bc' id='L3140' title='0|3|3 - Total: 3'>            pn.setLineno(lineno);
</span><span class='bc' id='L3141' title='0|4|4 - Total: 4'>            return pn;
</span>        } finally {
<span class='bpc' id='L3143' title='0|10|10 - Total: 13'>            inForInit = wasInForInit;
</span><span class='bc' id='L3144' title='0|2|2 - Total: 2'>        }
</span>    }

    private AstNode name(int ttFlagged, int tt) throws IOException {
<span class='bc' id='L3148' title='0|4|4 - Total: 4'>        String nameString = ts.getString();
</span><span class='bc' id='L3149' title='0|8|8 - Total: 8'>        int namePos = ts.tokenBeg, nameLineno = ts.lineno;
</span><span class='bc' id='L3150' title='0|4|4 - Total: 4'>        if (0 != (ttFlagged & TI_CHECK_LABEL) && peekToken() == Token.COLON) {
</span>            // Do not consume colon.  It is used as an unwind indicator
            // to return to statementHelper.
<span class='bc' id='L3153' title='0|10|10 - Total: 10'>            Label label = new Label(namePos, ts.tokenEnd - namePos);
</span><span class='bc' id='L3154' title='0|3|3 - Total: 3'>            label.setName(nameString);
</span><span class='bc' id='L3155' title='0|5|5 - Total: 5'>            label.setLineno(ts.lineno);
</span><span class='bc' id='L3156' title='0|2|2 - Total: 2'>            return label;
</span>        }
        // Not a label.  Unfortunately peeking the next token to check for
        // a colon has biffed ts.tokenBeg, ts.tokenEnd.  We store the name's
        // bounds in instance vars and createNameNode uses them.
<span class='bc' id='L3161' title='0|5|5 - Total: 5'>        saveNameTokenData(namePos, nameString, nameLineno);
</span>
<span class='bc' id='L3163' title='0|2|2 - Total: 2'>        if (compilerEnv.isXmlAvailable()) {
</span><span class='bc' id='L3164' title='0|6|6 - Total: 6'>            return propertyName(-1, nameString, 0);
</span>        } else {
<span class='bc' id='L3166' title='0|5|5 - Total: 5'>            return createNameNode(true, Token.NAME);
</span>        }
    }

    /**
     * May return an {@link ArrayLiteral} or {@link ArrayComprehension}.
     */
    private AstNode arrayLiteral()
        throws IOException
    {
<span class='bpc' id='L3176' title='0|1|1 - Total: 2'>        if (currentToken != Token.LB) codeBug();
</span><span class='bc' id='L3177' title='0|8|8 - Total: 8'>        int pos = ts.tokenBeg, end = ts.tokenEnd;
</span><span class='bc' id='L3178' title='0|4|4 - Total: 4'>        List<AstNode> elements = new ArrayList<AstNode>();
</span><span class='bc' id='L3179' title='0|5|5 - Total: 5'>        ArrayLiteral pn = new ArrayLiteral(pos);
</span><span class='bc' id='L3180' title='0|2|2 - Total: 2'>        boolean after_lb_or_comma = true;
</span><span class='bc' id='L3181' title='0|2|2 - Total: 2'>        int afterComma = -1;
</span><span class='bc' id='L3182' title='0|2|2 - Total: 2'>        int skipCount = 0;
</span>        for (;;) {
<span class='bc' id='L3184' title='0|3|3 - Total: 3'>            int tt = peekToken();
</span><span class='bc' id='L3185' title='0|2|2 - Total: 2'>            if (tt == Token.COMMA) {
</span><span class='bc' id='L3186' title='0|2|2 - Total: 2'>                consumeToken();
</span><span class='bc' id='L3187' title='0|4|4 - Total: 4'>                afterComma = ts.tokenEnd;
</span><span class='bc' id='L3188' title='0|2|2 - Total: 2'>                if (!after_lb_or_comma) {
</span><span class='bc' id='L3189' title='0|3|3 - Total: 3'>                    after_lb_or_comma = true;
</span>                } else {
<span class='bc' id='L3191' title='0|10|10 - Total: 10'>                    elements.add(new EmptyExpression(ts.tokenBeg, 1));
</span><span class='bc' id='L3192' title='0|2|2 - Total: 2'>                    skipCount++;
</span>                }
<span class='bc' id='L3194' title='0|2|2 - Total: 2'>            } else if (tt == Token.RB) {
</span><span class='bc' id='L3195' title='0|2|2 - Total: 2'>                consumeToken();
</span>                // for ([a,] in obj) is legal, but for ([a] in obj) is
                // not since we have both key and value supplied. The
                // trick is that [a,] and [a] are equivalent in other
                // array literal contexts. So we calculate a special
                // length value just for destructuring assignment.
<span class='bc' id='L3201' title='0|4|4 - Total: 4'>                end = ts.tokenEnd;
</span><span class='bc' id='L3202' title='0|2|2 - Total: 2'>                pn.setDestructuringLength(elements.size() +
</span>                                          (after_lb_or_comma ? 1 : 0));
<span class='bc' id='L3204' title='0|3|3 - Total: 3'>                pn.setSkipCount(skipCount);
</span><span class='bc' id='L3205' title='0|2|2 - Total: 2'>                if (afterComma != -1)
</span><span class='bc' id='L3206' title='0|6|6 - Total: 6'>                    warnTrailingComma(pos, elements, afterComma);
</span>                break;
<span class='bpc' id='L3208' title='0|3|3 - Total: 4'>            } else if (tt == Token.FOR && !after_lb_or_comma
</span><span class='bpc' id='L3209' title='0|1|1 - Total: 2'>                       && elements.size() == 1) {
</span><span class='bc' id='L3210' title='0|8|8 - Total: 8'>                return arrayComprehension(elements.get(0), pos);
</span><span class='bpc' id='L3211' title='0|1|1 - Total: 2'>            } else if (tt == Token.EOF) {
</span><span class='nc' id='L3212' title='0|0|0 - Total: 3'>                reportError("msg.no.bracket.arg");
</span><span class='nc' id='L3213' title='0|0|0 - Total: 1'>                break;
</span>            } else {
<span class='bc' id='L3215' title='0|2|2 - Total: 2'>                if (!after_lb_or_comma) {
</span><span class='nc' id='L3216' title='0|0|0 - Total: 3'>                    reportError("msg.no.bracket.arg");
</span>                }
<span class='bc' id='L3218' title='0|5|5 - Total: 5'>                elements.add(assignExpr());
</span><span class='bc' id='L3219' title='0|2|2 - Total: 2'>                after_lb_or_comma = false;
</span><span class='bc' id='L3220' title='0|2|2 - Total: 2'>                afterComma = -1;
</span>            }
<span class='bc' id='L3222' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L3223' title='0|2|2 - Total: 2'>        for (AstNode e : elements) {
</span><span class='bc' id='L3224' title='0|3|3 - Total: 3'>            pn.addElement(e);
</span><span class='bc' id='L3225' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L3226' title='0|5|5 - Total: 5'>        pn.setLength(end - pos);
</span><span class='bc' id='L3227' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    /**
     * Parse a JavaScript 1.7 Array comprehension.
     * @param result the first expression after the opening left-bracket
     * @param pos start of LB token that begins the array comprehension
     * @return the array comprehension or an error node
     */
    private AstNode arrayComprehension(AstNode result, int pos)
        throws IOException
    {
<span class='bc' id='L3239' title='0|4|4 - Total: 4'>        List<ArrayComprehensionLoop> loops =
</span>                new ArrayList<ArrayComprehensionLoop>();
<span class='bc' id='L3241' title='0|2|2 - Total: 2'>        while (peekToken() == Token.FOR) {
</span><span class='bc' id='L3242' title='0|6|6 - Total: 6'>            loops.add(arrayComprehensionLoop());
</span>        }
<span class='bc' id='L3244' title='0|2|2 - Total: 2'>        int ifPos = -1;
</span><span class='bc' id='L3245' title='0|2|2 - Total: 2'>        ConditionData data = null;
</span><span class='bc' id='L3246' title='0|2|2 - Total: 2'>        if (peekToken() == Token.IF) {
</span><span class='bc' id='L3247' title='0|2|2 - Total: 2'>            consumeToken();
</span><span class='bc' id='L3248' title='0|6|6 - Total: 6'>            ifPos = ts.tokenBeg - pos;
</span><span class='bc' id='L3249' title='0|3|3 - Total: 3'>            data = condition();
</span>        }
<span class='bc' id='L3251' title='0|5|5 - Total: 5'>        mustMatchToken(Token.RB, "msg.no.bracket.arg");
</span><span class='bc' id='L3252' title='0|10|10 - Total: 10'>        ArrayComprehension pn = new ArrayComprehension(pos, ts.tokenEnd - pos);
</span><span class='bc' id='L3253' title='0|3|3 - Total: 3'>        pn.setResult(result);
</span><span class='bc' id='L3254' title='0|3|3 - Total: 3'>        pn.setLoops(loops);
</span><span class='bc' id='L3255' title='0|2|2 - Total: 2'>        if (data != null) {
</span><span class='bc' id='L3256' title='0|3|3 - Total: 3'>            pn.setIfPosition(ifPos);
</span><span class='bc' id='L3257' title='0|4|4 - Total: 4'>            pn.setFilter(data.condition);
</span><span class='bc' id='L3258' title='0|6|6 - Total: 6'>            pn.setFilterLp(data.lp - pos);
</span><span class='bc' id='L3259' title='0|6|6 - Total: 6'>            pn.setFilterRp(data.rp - pos);
</span>        }
<span class='bc' id='L3261' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private ArrayComprehensionLoop arrayComprehensionLoop()
        throws IOException
    {
<span class='bpc' id='L3267' title='0|1|1 - Total: 2'>        if (nextToken() != Token.FOR) codeBug();
</span><span class='bc' id='L3268' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span><span class='bc' id='L3269' title='0|8|8 - Total: 8'>        int eachPos = -1, lp = -1, rp = -1, inPos = -1;
</span><span class='bc' id='L3270' title='0|4|4 - Total: 4'>        boolean isForIn = false, isForOf = false;
</span><span class='bc' id='L3271' title='0|5|5 - Total: 5'>        ArrayComprehensionLoop pn = new ArrayComprehensionLoop(pos);
</span>
<span class='bc' id='L3273' title='0|3|3 - Total: 3'>        pushScope(pn);
</span>        try {
<span class='bc' id='L3275' title='0|2|2 - Total: 2'>            if (matchToken(Token.NAME)) {
</span><span class='bpc' id='L3276' title='0|1|1 - Total: 2'>                if (ts.getString().equals("each")) {
</span><span class='bc' id='L3277' title='0|7|7 - Total: 7'>                    eachPos = ts.tokenBeg - pos;
</span>                } else {
<span class='nc' id='L3279' title='0|0|0 - Total: 3'>                    reportError("msg.no.paren.for");
</span>                }
            }
<span class='bpc' id='L3282' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.LP, "msg.no.paren.for")) {
</span><span class='bc' id='L3283' title='0|6|6 - Total: 6'>                lp = ts.tokenBeg - pos;
</span>            }

<span class='bc' id='L3286' title='0|2|2 - Total: 2'>            AstNode iter = null;
</span><span class='bpc' id='L3287' title='0|2|2 - Total: 3'>            switch (peekToken()) {
</span>              case Token.LB:
              case Token.LC:
                  // handle destructuring assignment
<span class='bc' id='L3291' title='0|3|3 - Total: 3'>                  iter = destructuringPrimaryExpr();
</span><span class='bc' id='L3292' title='0|3|3 - Total: 3'>                  markDestructuring(iter);
</span><span class='bc' id='L3293' title='0|1|1 - Total: 1'>                  break;
</span>              case Token.NAME:
<span class='bc' id='L3295' title='0|2|2 - Total: 2'>                  consumeToken();
</span><span class='bc' id='L3296' title='0|3|3 - Total: 3'>                  iter = createNameNode();
</span><span class='bc' id='L3297' title='0|1|1 - Total: 1'>                  break;
</span>              default:
<span class='nc' id='L3299' title='0|0|0 - Total: 3'>                  reportError("msg.bad.var");
</span>            }

            // Define as a let since we want the scope of the variable to
            // be restricted to the array comprehension
<span class='bc' id='L3304' title='0|2|2 - Total: 2'>            if (iter.getType() == Token.NAME) {
</span><span class='bc' id='L3305' title='0|7|7 - Total: 7'>                defineSymbol(Token.LET, ts.getString(), true);
</span>            }

<span class='bpc' id='L3308' title='0|2|2 - Total: 3'>            switch (nextToken()) {
</span>            case Token.IN:
<span class='bc' id='L3310' title='0|6|6 - Total: 6'>                inPos = ts.tokenBeg - pos;
</span><span class='bc' id='L3311' title='0|2|2 - Total: 2'>                isForIn = true;
</span><span class='bc' id='L3312' title='0|1|1 - Total: 1'>                break;
</span>            case Token.NAME:
<span class='bpc' id='L3314' title='0|1|1 - Total: 2'>                if ("of".equals(ts.getString())) {
</span><span class='bc' id='L3315' title='0|2|2 - Total: 2'>                    if (eachPos != -1) {
</span><span class='nc' id='L3316' title='0|0|0 - Total: 3'>                        reportError("msg.invalid.for.each");
</span>                    }
<span class='bc' id='L3318' title='0|6|6 - Total: 6'>                    inPos = ts.tokenBeg - pos;
</span><span class='bc' id='L3319' title='0|2|2 - Total: 2'>                    isForOf = true;
</span><span class='bc' id='L3320' title='0|1|1 - Total: 1'>                    break;
</span>                }
                // fallthru
            default:
<span class='nc' id='L3324' title='0|0|0 - Total: 3'>                reportError("msg.in.after.for.name");
</span>            }
<span class='bc' id='L3326' title='0|3|3 - Total: 3'>            AstNode obj = expr();
</span><span class='bpc' id='L3327' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.RP, "msg.no.paren.for.ctrl"))
</span><span class='bc' id='L3328' title='0|6|6 - Total: 6'>                rp = ts.tokenBeg - pos;
</span>
<span class='bc' id='L3330' title='0|7|7 - Total: 7'>            pn.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L3331' title='0|3|3 - Total: 3'>            pn.setIterator(iter);
</span><span class='bc' id='L3332' title='0|3|3 - Total: 3'>            pn.setIteratedObject(obj);
</span><span class='bc' id='L3333' title='0|3|3 - Total: 3'>            pn.setInPosition(inPos);
</span><span class='bc' id='L3334' title='0|3|3 - Total: 3'>            pn.setEachPosition(eachPos);
</span><span class='bc' id='L3335' title='0|2|2 - Total: 2'>            pn.setIsForEach(eachPos != -1);
</span><span class='bc' id='L3336' title='0|4|4 - Total: 4'>            pn.setParens(lp, rp);
</span><span class='bc' id='L3337' title='0|3|3 - Total: 3'>            pn.setIsForOf(isForOf);
</span><span class='bc' id='L3338' title='0|4|4 - Total: 4'>            return pn;
</span>        } finally {
<span class='bc' id='L3340' title='0|5|5 - Total: 5'>            popScope();
</span><span class='bc' id='L3341' title='0|2|2 - Total: 2'>        }
</span>    }

    private AstNode generatorExpression(AstNode result, int pos)
        throws IOException
    {
<span class='bc' id='L3347' title='0|6|6 - Total: 6'>        return generatorExpression(result, pos, false);
</span>    }
    
    private AstNode generatorExpression(AstNode result, int pos, boolean inFunctionParams)
        throws IOException
    {
        
<span class='bc' id='L3354' title='0|4|4 - Total: 4'>        List<GeneratorExpressionLoop> loops =
</span>                new ArrayList<GeneratorExpressionLoop>();
<span class='bc' id='L3356' title='0|2|2 - Total: 2'>        while (peekToken() == Token.FOR) {
</span><span class='bc' id='L3357' title='0|6|6 - Total: 6'>            loops.add(generatorExpressionLoop());
</span>        }
<span class='bc' id='L3359' title='0|2|2 - Total: 2'>        int ifPos = -1;
</span><span class='bc' id='L3360' title='0|2|2 - Total: 2'>        ConditionData data = null;
</span><span class='bc' id='L3361' title='0|2|2 - Total: 2'>        if (peekToken() == Token.IF) {
</span><span class='bc' id='L3362' title='0|2|2 - Total: 2'>            consumeToken();
</span><span class='bc' id='L3363' title='0|6|6 - Total: 6'>            ifPos = ts.tokenBeg - pos;
</span><span class='bc' id='L3364' title='0|3|3 - Total: 3'>            data = condition();
</span>        }
<span class='bc' id='L3366' title='0|2|2 - Total: 2'>        if(!inFunctionParams) {
</span><span class='bc' id='L3367' title='0|5|5 - Total: 5'>            mustMatchToken(Token.RP, "msg.no.paren.let");
</span>        }
<span class='bc' id='L3369' title='0|10|10 - Total: 10'>        GeneratorExpression pn = new GeneratorExpression(pos, ts.tokenEnd - pos);
</span><span class='bc' id='L3370' title='0|3|3 - Total: 3'>        pn.setResult(result);
</span><span class='bc' id='L3371' title='0|3|3 - Total: 3'>        pn.setLoops(loops);
</span><span class='bc' id='L3372' title='0|2|2 - Total: 2'>        if (data != null) {
</span><span class='bc' id='L3373' title='0|3|3 - Total: 3'>            pn.setIfPosition(ifPos);
</span><span class='bc' id='L3374' title='0|4|4 - Total: 4'>            pn.setFilter(data.condition);
</span><span class='bc' id='L3375' title='0|6|6 - Total: 6'>            pn.setFilterLp(data.lp - pos);
</span><span class='bc' id='L3376' title='0|6|6 - Total: 6'>            pn.setFilterRp(data.rp - pos);
</span>        }
<span class='bc' id='L3378' title='0|2|2 - Total: 2'>        return pn;
</span>    }
        
    private GeneratorExpressionLoop generatorExpressionLoop()
        throws IOException
    {
<span class='bpc' id='L3384' title='0|1|1 - Total: 2'>        if (nextToken() != Token.FOR) codeBug();
</span><span class='bc' id='L3385' title='0|4|4 - Total: 4'>        int pos = ts.tokenBeg;
</span><span class='bc' id='L3386' title='0|6|6 - Total: 6'>        int lp = -1, rp = -1, inPos = -1;
</span><span class='bc' id='L3387' title='0|5|5 - Total: 5'>        GeneratorExpressionLoop pn = new GeneratorExpressionLoop(pos);
</span>
<span class='bc' id='L3389' title='0|3|3 - Total: 3'>        pushScope(pn);
</span>        try {
<span class='bpc' id='L3391' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.LP, "msg.no.paren.for")) {
</span><span class='bc' id='L3392' title='0|6|6 - Total: 6'>                lp = ts.tokenBeg - pos;
</span>            }

<span class='bc' id='L3395' title='0|2|2 - Total: 2'>            AstNode iter = null;
</span><span class='bpc' id='L3396' title='0|1|1 - Total: 3'>            switch (peekToken()) {
</span>              case Token.LB:
              case Token.LC:
                  // handle destructuring assignment
<span class='nc' id='L3400' title='0|0|0 - Total: 3'>                  iter = destructuringPrimaryExpr();
</span><span class='nc' id='L3401' title='0|0|0 - Total: 3'>                  markDestructuring(iter);
</span><span class='nc' id='L3402' title='0|0|0 - Total: 1'>                  break;
</span>              case Token.NAME:
<span class='bc' id='L3404' title='0|2|2 - Total: 2'>                  consumeToken();
</span><span class='bc' id='L3405' title='0|3|3 - Total: 3'>                  iter = createNameNode();
</span><span class='bc' id='L3406' title='0|1|1 - Total: 1'>                  break;
</span>              default:
<span class='nc' id='L3408' title='0|0|0 - Total: 3'>                  reportError("msg.bad.var");
</span>            }

            // Define as a let since we want the scope of the variable to
            // be restricted to the array comprehension
<span class='bpc' id='L3413' title='0|1|1 - Total: 2'>            if (iter.getType() == Token.NAME) {
</span><span class='bc' id='L3414' title='0|7|7 - Total: 7'>                defineSymbol(Token.LET, ts.getString(), true);
</span>            }

<span class='bpc' id='L3417' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.IN, "msg.in.after.for.name"))
</span><span class='bc' id='L3418' title='0|6|6 - Total: 6'>                inPos = ts.tokenBeg - pos;
</span><span class='bc' id='L3419' title='0|3|3 - Total: 3'>            AstNode obj = expr();
</span><span class='bpc' id='L3420' title='0|1|1 - Total: 2'>            if (mustMatchToken(Token.RP, "msg.no.paren.for.ctrl"))
</span><span class='bc' id='L3421' title='0|6|6 - Total: 6'>                rp = ts.tokenBeg - pos;
</span>
<span class='bc' id='L3423' title='0|7|7 - Total: 7'>            pn.setLength(ts.tokenEnd - pos);
</span><span class='bc' id='L3424' title='0|3|3 - Total: 3'>            pn.setIterator(iter);
</span><span class='bc' id='L3425' title='0|3|3 - Total: 3'>            pn.setIteratedObject(obj);
</span><span class='bc' id='L3426' title='0|3|3 - Total: 3'>            pn.setInPosition(inPos);
</span><span class='bc' id='L3427' title='0|4|4 - Total: 4'>            pn.setParens(lp, rp);
</span><span class='bc' id='L3428' title='0|4|4 - Total: 4'>            return pn;
</span>        } finally {
<span class='bc' id='L3430' title='0|5|5 - Total: 5'>            popScope();
</span><span class='bc' id='L3431' title='0|2|2 - Total: 2'>        }
</span>    }

    private static final int PROP_ENTRY   = 1;
    private static final int GET_ENTRY    = 2;
    private static final int SET_ENTRY    = 4;
    private static final int METHOD_ENTRY = 8;

    private ObjectLiteral objectLiteral()
        throws IOException
    {
<span class='bc' id='L3442' title='0|8|8 - Total: 8'>        int pos = ts.tokenBeg, lineno = ts.lineno;
</span><span class='bc' id='L3443' title='0|2|2 - Total: 2'>        int afterComma = -1;
</span><span class='bc' id='L3444' title='0|4|4 - Total: 4'>        List<ObjectProperty> elems = new ArrayList<ObjectProperty>();
</span><span class='bc' id='L3445' title='0|2|2 - Total: 2'>        Set<String> getterNames = null;
</span><span class='bc' id='L3446' title='0|2|2 - Total: 2'>        Set<String> setterNames = null;
</span><span class='bc' id='L3447' title='0|2|2 - Total: 2'>        if (this.inUseStrictDirective) {
</span><span class='bc' id='L3448' title='0|4|4 - Total: 4'>            getterNames = new HashSet<String>();
</span><span class='bc' id='L3449' title='0|4|4 - Total: 4'>            setterNames = new HashSet<String>();
</span>        }
<span class='bc' id='L3451' title='0|3|3 - Total: 3'>        Comment objJsdocNode = getAndResetJsDoc();
</span>
      commaLoop:
        for (;;) {
<span class='bc' id='L3455' title='0|2|2 - Total: 2'>            String propertyName = null;
</span><span class='bc' id='L3456' title='0|2|2 - Total: 2'>            int entryKind = PROP_ENTRY;
</span><span class='bc' id='L3457' title='0|3|3 - Total: 3'>            int tt = peekToken();
</span><span class='bc' id='L3458' title='0|3|3 - Total: 3'>            Comment jsdocNode = getAndResetJsDoc();
</span>
<span class='bc' id='L3460' title='0|2|2 - Total: 2'>            if (tt == Token.RC) {
</span><span class='bc' id='L3461' title='0|2|2 - Total: 2'>                if (afterComma != -1)
</span><span class='bc' id='L3462' title='0|6|6 - Total: 6'>                    warnTrailingComma(pos, elems, afterComma);
</span>                break commaLoop;
            } else {
<span class='bc' id='L3465' title='0|3|3 - Total: 3'>                AstNode pname = objliteralProperty();
</span><span class='bc' id='L3466' title='0|2|2 - Total: 2'>                if (pname == null) {
</span><span class='bc' id='L3467' title='0|2|2 - Total: 2'>                    propertyName = null;
</span><span class='nc' id='L3468' title='0|0|0 - Total: 4'>                    reportError("msg.bad.prop");
</span>                } else {
<span class='bc' id='L3470' title='0|4|4 - Total: 4'>                    propertyName = ts.getString();
</span><span class='bc' id='L3471' title='0|4|4 - Total: 4'>                    int ppos = ts.tokenBeg;
</span><span class='bc' id='L3472' title='0|2|2 - Total: 2'>                    consumeToken();
</span>
                    // This code path needs to handle both destructuring object
                    // literals like:
                    // var {get, b} = {get: 1, b: 2};
                    // and getters like:
                    // var x = {get 1() { return 2; };
                    // So we check a whitelist of tokens to check if we're at the
                    // first case. (Because of keywords, the second case may be
                    // many tokens.)
<span class='bc' id='L3482' title='0|3|3 - Total: 3'>                    int peeked = peekToken();
</span><span class='bc' id='L3483' title='0|6|6 - Total: 6'>                    if (peeked != Token.COMMA
</span>                            && peeked != Token.COLON
                            && peeked != Token.RC)
                    {
<span class='bc' id='L3487' title='0|2|2 - Total: 2'>                        if (peeked == Token.LP) {
</span><span class='bc' id='L3488' title='0|3|3 - Total: 3'>                            entryKind = METHOD_ENTRY;
</span><span class='bpc' id='L3489' title='0|1|1 - Total: 2'>                        } else if (pname.getType() == Token.NAME) {
</span><span class='bc' id='L3490' title='0|2|2 - Total: 2'>                            if ("get".equals(propertyName)) {
</span><span class='bc' id='L3491' title='0|3|3 - Total: 3'>                                entryKind = GET_ENTRY;
</span><span class='bc' id='L3492' title='0|2|2 - Total: 2'>                            } else if ("set".equals(propertyName)) {
</span><span class='bc' id='L3493' title='0|2|2 - Total: 2'>                                entryKind = SET_ENTRY;
</span>                            }
                        }
<span class='bc' id='L3496' title='0|4|4 - Total: 4'>                        if (entryKind == GET_ENTRY || entryKind == SET_ENTRY) {
</span><span class='bc' id='L3497' title='0|3|3 - Total: 3'>                            pname = objliteralProperty();
</span><span class='bpc' id='L3498' title='0|1|1 - Total: 2'>                            if (pname == null) {
</span><span class='nc' id='L3499' title='0|0|0 - Total: 3'>                                reportError("msg.bad.prop");
</span>                            }
<span class='bc' id='L3501' title='0|2|2 - Total: 2'>                            consumeToken();
</span>                        }
<span class='bpc' id='L3503' title='0|1|1 - Total: 2'>                        if (pname == null) {
</span><span class='nc' id='L3504' title='0|0|0 - Total: 3'>                            propertyName = null;
</span>                        } else {
<span class='bc' id='L3506' title='0|4|4 - Total: 4'>                            propertyName = ts.getString();
</span><span class='bc' id='L3507' title='0|6|6 - Total: 6'>                            ObjectProperty objectProp = methodDefinition(
</span>                                    ppos, pname, entryKind);
<span class='bc' id='L3509' title='0|3|3 - Total: 3'>                            pname.setJsDocNode(jsdocNode);
</span><span class='bc' id='L3510' title='0|4|4 - Total: 4'>                            elems.add(objectProp);
</span><span class='bc' id='L3511' title='0|1|1 - Total: 1'>                        }
</span>                    } else {
<span class='bc' id='L3513' title='0|3|3 - Total: 3'>                        pname.setJsDocNode(jsdocNode);
</span><span class='bc' id='L3514' title='0|7|7 - Total: 7'>                        elems.add(plainProperty(pname, tt));
</span>                    }
                }
            }

<span class='bpc' id='L3519' title='0|3|3 - Total: 4'>            if (this.inUseStrictDirective && propertyName != null) {
</span><span class='bpc' id='L3520' title='0|2|2 - Total: 4'>                switch (entryKind) {
</span>                case PROP_ENTRY:
                case METHOD_ENTRY:
<span class='nc' id='L3523' title='0|0|0 - Total: 2'>                    if (getterNames.contains(propertyName)
</span><span class='nc' id='L3524' title='0|0|0 - Total: 2'>                            || setterNames.contains(propertyName)) {
</span><span class='nc' id='L3525' title='0|0|0 - Total: 4'>                        addError("msg.dup.obj.lit.prop.strict", propertyName);
</span>                    }
<span class='nc' id='L3527' title='0|0|0 - Total: 4'>                    getterNames.add(propertyName);
</span><span class='nc' id='L3528' title='0|0|0 - Total: 4'>                    setterNames.add(propertyName);
</span><span class='nc' id='L3529' title='0|0|0 - Total: 1'>                    break;
</span>                case GET_ENTRY:
<span class='bpc' id='L3531' title='0|1|1 - Total: 2'>                    if (getterNames.contains(propertyName)) {
</span><span class='nc' id='L3532' title='0|0|0 - Total: 4'>                        addError("msg.dup.obj.lit.prop.strict", propertyName);
</span>                    }
<span class='bc' id='L3534' title='0|4|4 - Total: 4'>                    getterNames.add(propertyName);
</span><span class='bc' id='L3535' title='0|1|1 - Total: 1'>                    break;
</span>                case SET_ENTRY:
<span class='bpc' id='L3537' title='0|1|1 - Total: 2'>                    if (setterNames.contains(propertyName)) {
</span><span class='nc' id='L3538' title='0|0|0 - Total: 4'>                        addError("msg.dup.obj.lit.prop.strict", propertyName);
</span>                    }
<span class='bc' id='L3540' title='0|4|4 - Total: 4'>                    setterNames.add(propertyName);
</span>                    break;
                }
            }

            // Eat any dangling jsdoc in the property.
<span class='bc' id='L3546' title='0|3|3 - Total: 3'>            getAndResetJsDoc();
</span>
<span class='bc' id='L3548' title='0|2|2 - Total: 2'>            if (matchToken(Token.COMMA)) {
</span><span class='bc' id='L3549' title='0|4|4 - Total: 4'>                afterComma = ts.tokenEnd;
</span>            } else {
                break commaLoop;
            }
<span class='bc' id='L3553' title='0|1|1 - Total: 1'>        }
</span>
<span class='bc' id='L3555' title='0|5|5 - Total: 5'>        mustMatchToken(Token.RC, "msg.no.brace.prop");
</span><span class='bc' id='L3556' title='0|10|10 - Total: 10'>        ObjectLiteral pn = new ObjectLiteral(pos, ts.tokenEnd - pos);
</span><span class='bc' id='L3557' title='0|2|2 - Total: 2'>        if (objJsdocNode != null) {
</span><span class='bc' id='L3558' title='0|3|3 - Total: 3'>            pn.setJsDocNode(objJsdocNode);
</span>        }
<span class='bc' id='L3560' title='0|3|3 - Total: 3'>        pn.setElements(elems);
</span><span class='bc' id='L3561' title='0|3|3 - Total: 3'>        pn.setLineno(lineno);
</span><span class='bc' id='L3562' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private AstNode objliteralProperty() throws IOException {
        AstNode pname;
<span class='bc' id='L3567' title='0|3|3 - Total: 3'>        int tt = peekToken();
</span><span class='bc' id='L3568' title='0|4|4 - Total: 4'>        switch(tt) {
</span>          case Token.NAME:
<span class='bc' id='L3570' title='0|3|3 - Total: 3'>              pname = createNameNode();
</span><span class='bc' id='L3571' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.STRING:
<span class='bc' id='L3574' title='0|3|3 - Total: 3'>              pname = createStringLiteral();
</span><span class='bc' id='L3575' title='0|1|1 - Total: 1'>              break;
</span>
          case Token.NUMBER:
<span class='bc' id='L3578' title='0|7|7 - Total: 7'>              pname = new NumberLiteral(
</span><span class='bc' id='L3579' title='0|6|6 - Total: 6'>                      ts.tokenBeg, ts.getString(), ts.getNumber());
</span><span class='bc' id='L3580' title='0|1|1 - Total: 1'>              break;
</span>
          default:
<span class='bc' id='L3583' title='0|2|2 - Total: 2'>              if (compilerEnv.isReservedKeywordAsIdentifier()
</span><span class='bpc' id='L3584' title='0|1|1 - Total: 2'>                      && TokenStream.isKeyword(ts.getString(), compilerEnv.getLanguageVersion(), inUseStrictDirective)) {
</span>                  // convert keyword to property name, e.g. ({if: 1})
<span class='bc' id='L3586' title='0|3|3 - Total: 3'>                  pname = createNameNode();
</span><span class='bc' id='L3587' title='0|1|1 - Total: 1'>                  break;
</span>              }
<span class='bc' id='L3589' title='0|2|2 - Total: 2'>              return null;
</span>        }

<span class='bc' id='L3592' title='0|2|2 - Total: 2'>        return pname;
</span>    }

    private ObjectProperty plainProperty(AstNode property, int ptt)
        throws IOException
    {
        // Support, e.g., |var {x, y} = o| as destructuring shorthand
        // for |var {x: x, y: y} = o|, as implemented in spidermonkey JS 1.8.
<span class='bc' id='L3600' title='0|3|3 - Total: 3'>        int tt = peekToken();
</span><span class='bpc' id='L3601' title='0|5|5 - Total: 6'>        if ((tt == Token.COMMA || tt == Token.RC) && ptt == Token.NAME
</span><span class='bc' id='L3602' title='0|2|2 - Total: 2'>                && compilerEnv.getLanguageVersion() >= Context.VERSION_1_8) {
</span><span class='bc' id='L3603' title='0|2|2 - Total: 2'>            if (!inDestructuringAssignment) {
</span><span class='nc' id='L3604' title='0|0|0 - Total: 3'>                reportError("msg.bad.object.init");
</span>            }
<span class='bc' id='L3606' title='0|8|8 - Total: 8'>            AstNode nn = new Name(property.getPosition(), property.getString());
</span><span class='bc' id='L3607' title='0|4|4 - Total: 4'>            ObjectProperty pn = new ObjectProperty();
</span><span class='bc' id='L3608' title='0|4|4 - Total: 4'>            pn.putProp(Node.DESTRUCTURING_SHORTHAND, Boolean.TRUE);
</span><span class='bc' id='L3609' title='0|4|4 - Total: 4'>            pn.setLeftAndRight(property, nn);
</span><span class='bc' id='L3610' title='0|2|2 - Total: 2'>            return pn;
</span>        }
<span class='bc' id='L3612' title='0|5|5 - Total: 5'>        mustMatchToken(Token.COLON, "msg.no.colon.prop");
</span><span class='bc' id='L3613' title='0|4|4 - Total: 4'>        ObjectProperty pn = new ObjectProperty();
</span><span class='bc' id='L3614' title='0|5|5 - Total: 5'>        pn.setOperatorPosition(ts.tokenBeg);
</span><span class='bc' id='L3615' title='0|5|5 - Total: 5'>        pn.setLeftAndRight(property, assignExpr());
</span><span class='bc' id='L3616' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private ObjectProperty methodDefinition(int pos, AstNode propName, int entryKind)
        throws IOException
    {
<span class='bc' id='L3622' title='0|4|4 - Total: 4'>        FunctionNode fn = function(FunctionNode.FUNCTION_EXPRESSION);
</span>        // We've already parsed the function name, so fn should be anonymous.
<span class='bc' id='L3624' title='0|3|3 - Total: 3'>        Name name = fn.getFunctionName();
</span><span class='bpc' id='L3625' title='0|3|3 - Total: 4'>        if (name != null && name.length() != 0) {
</span><span class='nc' id='L3626' title='0|0|0 - Total: 3'>            reportError("msg.bad.prop");
</span>        }
<span class='bc' id='L3628' title='0|5|5 - Total: 5'>        ObjectProperty pn = new ObjectProperty(pos);
</span><span class='bpc' id='L3629' title='0|3|3 - Total: 4'>        switch (entryKind) {
</span>        case GET_ENTRY:
<span class='bc' id='L3631' title='0|2|2 - Total: 2'>            pn.setIsGetterMethod();
</span><span class='bc' id='L3632' title='0|2|2 - Total: 2'>            fn.setFunctionIsGetterMethod();
</span><span class='bc' id='L3633' title='0|1|1 - Total: 1'>            break;
</span>        case SET_ENTRY:
<span class='bc' id='L3635' title='0|2|2 - Total: 2'>            pn.setIsSetterMethod();
</span><span class='bc' id='L3636' title='0|2|2 - Total: 2'>            fn.setFunctionIsSetterMethod();
</span><span class='bc' id='L3637' title='0|1|1 - Total: 1'>            break;
</span>        case METHOD_ENTRY:
<span class='bc' id='L3639' title='0|2|2 - Total: 2'>            pn.setIsNormalMethod();
</span><span class='bc' id='L3640' title='0|2|2 - Total: 2'>            fn.setFunctionIsNormalMethod();
</span>            break;
        }
<span class='bc' id='L3643' title='0|4|4 - Total: 4'>        int end = getNodeEnd(fn);
</span><span class='bc' id='L3644' title='0|3|3 - Total: 3'>        pn.setLeft(propName);
</span><span class='bc' id='L3645' title='0|3|3 - Total: 3'>        pn.setRight(fn);
</span><span class='bc' id='L3646' title='0|5|5 - Total: 5'>        pn.setLength(end - pos);
</span><span class='bc' id='L3647' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    private Name createNameNode() {
<span class='bc' id='L3651' title='0|5|5 - Total: 5'>        return createNameNode(false, Token.NAME);
</span>    }

    /**
     * Create a {@code Name} node using the token info from the
     * last scanned name.  In some cases we need to either synthesize
     * a name node, or we lost the name token information by peeking.
     * If the {@code token} parameter is not {@link Token#NAME}, then
     * we use token info saved in instance vars.
     */
    private Name createNameNode(boolean checkActivation, int token) {
<span class='bc' id='L3662' title='0|4|4 - Total: 4'>        int beg = ts.tokenBeg;
</span><span class='bc' id='L3663' title='0|4|4 - Total: 4'>        String s = ts.getString();
</span><span class='bc' id='L3664' title='0|4|4 - Total: 4'>        int lineno = ts.lineno;
</span><span class='bc' id='L3665' title='0|2|2 - Total: 2'>        if (!"".equals(prevNameTokenString)) {
</span><span class='bc' id='L3666' title='0|3|3 - Total: 3'>            beg = prevNameTokenStart;
</span><span class='bc' id='L3667' title='0|3|3 - Total: 3'>            s = prevNameTokenString;
</span><span class='bc' id='L3668' title='0|3|3 - Total: 3'>            lineno = prevNameTokenLineno;
</span><span class='bc' id='L3669' title='0|3|3 - Total: 3'>            prevNameTokenStart = 0;
</span><span class='bc' id='L3670' title='0|3|3 - Total: 3'>            prevNameTokenString = "";
</span><span class='bc' id='L3671' title='0|3|3 - Total: 3'>            prevNameTokenLineno = 0;
</span>        }
<span class='bpc' id='L3673' title='0|1|1 - Total: 2'>        if (s == null) {
</span><span class='nc' id='L3674' title='0|0|0 - Total: 2'>            if (compilerEnv.isIdeMode()) {
</span><span class='nc' id='L3675' title='0|0|0 - Total: 3'>                s = "";
</span>            } else {
<span class='nc' id='L3677' title='0|0|0 - Total: 3'>                codeBug();
</span>            }
        }
<span class='bc' id='L3680' title='0|6|6 - Total: 6'>        Name name = new Name(beg, s);
</span><span class='bc' id='L3681' title='0|3|3 - Total: 3'>        name.setLineno(lineno);
</span><span class='bc' id='L3682' title='0|2|2 - Total: 2'>        if (checkActivation) {
</span><span class='bc' id='L3683' title='0|4|4 - Total: 4'>            checkActivationName(s, token);
</span>        }
<span class='bc' id='L3685' title='0|2|2 - Total: 2'>        return name;
</span>    }

    private StringLiteral createStringLiteral() {
<span class='bc' id='L3689' title='0|8|8 - Total: 8'>        int pos = ts.tokenBeg, end = ts.tokenEnd;
</span><span class='bc' id='L3690' title='0|8|8 - Total: 8'>        StringLiteral s = new StringLiteral(pos, end - pos);
</span><span class='bc' id='L3691' title='0|5|5 - Total: 5'>        s.setLineno(ts.lineno);
</span><span class='bc' id='L3692' title='0|5|5 - Total: 5'>        s.setValue(ts.getString());
</span><span class='bc' id='L3693' title='0|5|5 - Total: 5'>        s.setQuoteCharacter(ts.getQuoteChar());
</span><span class='bc' id='L3694' title='0|2|2 - Total: 2'>        return s;
</span>    }

    protected void checkActivationName(String name, int token) {
<span class='bc' id='L3698' title='0|2|2 - Total: 2'>        if (!insideFunction()) {
</span><span class='bc' id='L3699' title='0|1|1 - Total: 1'>            return;
</span>        }
<span class='bc' id='L3701' title='0|2|2 - Total: 2'>        boolean activation = false;
</span><span class='bc' id='L3702' title='0|2|2 - Total: 2'>        if ("arguments".equals(name) &&
</span>            // An arrow function not generate arguments. So it not need activation.
<span class='bc' id='L3704' title='0|2|2 - Total: 2'>            ((FunctionNode)currentScriptOrFn).getFunctionType() != FunctionNode.ARROW_FUNCTION) {
</span><span class='bc' id='L3705' title='0|3|3 - Total: 3'>            activation = true;
</span><span class='bpc' id='L3706' title='0|1|1 - Total: 2'>        } else if (compilerEnv.getActivationNames() != null
</span><span class='nc' id='L3707' title='0|0|0 - Total: 2'>                && compilerEnv.getActivationNames().contains(name)) {
</span><span class='nc' id='L3708' title='0|0|0 - Total: 3'>            activation = true;
</span><span class='bc' id='L3709' title='0|2|2 - Total: 2'>        } else if ("length".equals(name)) {
</span><span class='bc' id='L3710' title='0|2|2 - Total: 2'>            if (token == Token.GETPROP
</span><span class='bpc' id='L3711' title='0|1|1 - Total: 2'>                && compilerEnv.getLanguageVersion() == Context.VERSION_1_2)
</span>            {
                // Use of "length" in 1.2 requires an activation object.
<span class='nc' id='L3714' title='0|0|0 - Total: 2'>                activation = true;
</span>            }
        }
<span class='bc' id='L3717' title='0|2|2 - Total: 2'>        if (activation) {
</span><span class='bc' id='L3718' title='0|2|2 - Total: 2'>            setRequiresActivation();
</span>        }
<span class='bc' id='L3720' title='0|1|1 - Total: 1'>    }
</span>
    protected void setRequiresActivation() {
<span class='bc' id='L3723' title='0|2|2 - Total: 2'>        if (insideFunction()) {
</span><span class='bc' id='L3724' title='0|4|4 - Total: 4'>            ((FunctionNode)currentScriptOrFn).setRequiresActivation();
</span>        }
<span class='bc' id='L3726' title='0|1|1 - Total: 1'>    }
</span>
    private void checkCallRequiresActivation(AstNode pn) {
<span class='bc' id='L3729' title='0|2|2 - Total: 2'>        if ((pn.getType() == Token.NAME
</span><span class='bc' id='L3730' title='0|2|2 - Total: 2'>             && "eval".equals(((Name)pn).getIdentifier()))
</span><span class='bc' id='L3731' title='0|2|2 - Total: 2'>            || (pn.getType() == Token.GETPROP &&
</span><span class='bc' id='L3732' title='0|2|2 - Total: 2'>                "eval".equals(((PropertyGet)pn).getProperty().getIdentifier())))
</span><span class='bc' id='L3733' title='0|2|2 - Total: 2'>            setRequiresActivation();
</span><span class='bc' id='L3734' title='0|1|1 - Total: 1'>    }
</span>
    protected void setIsGenerator() {
<span class='bpc' id='L3737' title='0|1|1 - Total: 2'>        if (insideFunction()) {
</span><span class='bc' id='L3738' title='0|4|4 - Total: 4'>            ((FunctionNode)currentScriptOrFn).setIsGenerator();
</span>        }
<span class='bc' id='L3740' title='0|1|1 - Total: 1'>    }
</span>
    private void checkBadIncDec(UnaryExpression expr) {
<span class='bc' id='L3743' title='0|5|5 - Total: 5'>        AstNode op = removeParens(expr.getOperand());
</span><span class='bc' id='L3744' title='0|3|3 - Total: 3'>        int tt = op.getType();
</span><span class='bpc' id='L3745' title='0|8|8 - Total: 10'>        if (!(tt == Token.NAME
</span>              || tt == Token.GETPROP
              || tt == Token.GETELEM
              || tt == Token.GET_REF
              || tt == Token.CALL))
<span class='nc' id='L3750' title='0|0|0 - Total: 2'>            reportError(expr.getType() == Token.INC
</span>                        ? "msg.bad.incr"
                        : "msg.bad.decr");
<span class='bc' id='L3753' title='0|1|1 - Total: 1'>    }
</span>
    private ErrorNode makeErrorNode() {
<span class='bc' id='L3756' title='0|14|14 - Total: 14'>        ErrorNode pn = new ErrorNode(ts.tokenBeg, ts.tokenEnd - ts.tokenBeg);
</span><span class='bc' id='L3757' title='0|5|5 - Total: 5'>        pn.setLineno(ts.lineno);
</span><span class='bc' id='L3758' title='0|2|2 - Total: 2'>        return pn;
</span>    }

    // Return end of node.  Assumes node does NOT have a parent yet.
    private int nodeEnd(AstNode node) {
<span class='bc' id='L3763' title='0|6|6 - Total: 6'>        return node.getPosition() + node.getLength();
</span>    }

    private void saveNameTokenData(int pos, String name, int lineno) {
<span class='bc' id='L3767' title='0|3|3 - Total: 3'>        prevNameTokenStart = pos;
</span><span class='bc' id='L3768' title='0|3|3 - Total: 3'>        prevNameTokenString = name;
</span><span class='bc' id='L3769' title='0|3|3 - Total: 3'>        prevNameTokenLineno = lineno;
</span><span class='bc' id='L3770' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Return the file offset of the beginning of the input source line
     * containing the passed position.
     *
     * @param pos an offset into the input source stream.  If the offset
     * is negative, it's converted to 0, and if it's beyond the end of
     * the source buffer, the last source position is used.
     *
     * @return the offset of the beginning of the line containing pos
     * (i.e. 1+ the offset of the first preceding newline).  Returns -1
     * if the {@link CompilerEnvirons} is not set to ide-mode,
     * and {@link #parse(java.io.Reader,String,int)} was used.
     */
    private int lineBeginningFor(int pos) {
<span class='nc' id='L3786' title='0|0|0 - Total: 2'>        if (sourceChars == null) {
</span><span class='nc' id='L3787' title='0|0|0 - Total: 2'>            return -1;
</span>        }
<span class='nc' id='L3789' title='0|0|0 - Total: 2'>        if (pos <= 0) {
</span><span class='nc' id='L3790' title='0|0|0 - Total: 2'>            return 0;
</span>        }
<span class='nc' id='L3792' title='0|0|0 - Total: 3'>        char[] buf = sourceChars;
</span><span class='nc' id='L3793' title='0|0|0 - Total: 2'>        if (pos >= buf.length) {
</span><span class='nc' id='L3794' title='0|0|0 - Total: 5'>            pos = buf.length - 1;
</span>        }
<span class='nc' id='L3796' title='0|0|0 - Total: 2'>        while (--pos >= 0) {
</span><span class='nc' id='L3797' title='0|0|0 - Total: 4'>            char c = buf[pos];
</span><span class='nc' id='L3798' title='0|0|0 - Total: 2'>            if (ScriptRuntime.isJSLineTerminator(c)) {
</span><span class='nc' id='L3799' title='0|0|0 - Total: 4'>                return pos + 1; // want position after the newline
</span>            }
<span class='nc' id='L3801' title='0|0|0 - Total: 1'>        }
</span><span class='nc' id='L3802' title='0|0|0 - Total: 2'>        return 0;
</span>    }

    private void warnMissingSemi(int pos, int end) {
        // Should probably change this to be a CompilerEnvirons setting,
        // with an enum Never, Always, Permissive, where Permissive means
        // don't warn for 1-line functions like function (s) {return x+2}
<span class='bc' id='L3809' title='0|2|2 - Total: 2'>        if (compilerEnv.isStrictMode()) {
</span><span class='bc' id='L3810' title='0|3|3 - Total: 3'>            int[] linep = new int[2];
</span><span class='bc' id='L3811' title='0|6|6 - Total: 6'>            String line = ts.getLine(end, linep);
</span>            // this code originally called lineBeginningFor() and in order to
            // preserve its different line-offset handling, we need to special
            // case ide-mode here
<span class='bc' id='L3815' title='0|2|2 - Total: 2'>            int beg = compilerEnv.isIdeMode()
</span><span class='bc' id='L3816' title='0|4|4 - Total: 4'>                      ? Math.max(pos, end - linep[1])
</span>                      : pos;
<span class='bc' id='L3818' title='0|2|2 - Total: 2'>            if (line != null) {
</span><span class='bc' id='L3819' title='0|16|16 - Total: 16'>                addStrictWarning("msg.missing.semi", "", beg, end - beg,
</span>                                 linep[0], line, linep[1]);
            } else {
                // no line information available, report warning at current line
<span class='bc' id='L3823' title='0|8|8 - Total: 8'>                addStrictWarning("msg.missing.semi", "", beg, end - beg);
</span>            }
        }
<span class='bc' id='L3826' title='0|1|1 - Total: 1'>    }
</span>
    private void warnTrailingComma(int pos, List<?> elems, int commaPos) {
<span class='bpc' id='L3829' title='0|1|1 - Total: 2'>        if (compilerEnv.getWarnTrailingComma()) {
</span>            // back up from comma to beginning of line or array/objlit
<span class='nc' id='L3831' title='0|0|0 - Total: 2'>            if (!elems.isEmpty()) {
</span><span class='nc' id='L3832' title='0|0|0 - Total: 6'>                pos = ((AstNode)elems.get(0)).getPosition();
</span>            }
<span class='nc' id='L3834' title='0|0|0 - Total: 6'>            pos = Math.max(pos, lineBeginningFor(commaPos));
</span><span class='nc' id='L3835' title='0|0|0 - Total: 7'>            addWarning("msg.extra.trailing.comma", pos, commaPos - pos);
</span>        }
<span class='bc' id='L3837' title='0|1|1 - Total: 1'>    }
</span>

    private String readFully(Reader reader) throws IOException {
<span class='bc' id='L3841' title='0|5|5 - Total: 5'>        BufferedReader in = new BufferedReader(reader);
</span>        try {
<span class='bc' id='L3843' title='0|3|3 - Total: 3'>            char[] cbuf = new char[1024];
</span><span class='bc' id='L3844' title='0|5|5 - Total: 5'>            StringBuilder sb = new StringBuilder(1024);
</span>            int bytes_read;
<span class='bc' id='L3846' title='0|2|2 - Total: 2'>            while ((bytes_read = in.read(cbuf, 0, 1024)) != -1) {
</span><span class='bc' id='L3847' title='0|7|7 - Total: 7'>                sb.append(cbuf, 0, bytes_read);
</span>            }
<span class='bc' id='L3849' title='0|5|5 - Total: 5'>            return sb.toString();
</span>        } finally {
<span class='bpc' id='L3851' title='0|2|2 - Total: 5'>            in.close();
</span><span class='nc' id='L3852' title='0|0|0 - Total: 2'>        }
</span>    }

    // helps reduce clutter in the already-large function() method
    protected class PerFunctionVariables
    {
        private ScriptNode savedCurrentScriptOrFn;
        private Scope savedCurrentScope;
        private int savedEndFlags;
        private boolean savedInForInit;
        private Map<String,LabeledStatement> savedLabelSet;
        private List<Loop> savedLoopSet;
        private List<Jump> savedLoopAndSwitchSet;

        PerFunctionVariables(FunctionNode fnNode) {
            savedCurrentScriptOrFn = Parser.this.currentScriptOrFn;
            Parser.this.currentScriptOrFn = fnNode;

            savedCurrentScope = Parser.this.currentScope;
            Parser.this.currentScope = fnNode;

            savedLabelSet = Parser.this.labelSet;
            Parser.this.labelSet = null;

            savedLoopSet = Parser.this.loopSet;
            Parser.this.loopSet = null;

            savedLoopAndSwitchSet = Parser.this.loopAndSwitchSet;
            Parser.this.loopAndSwitchSet = null;

            savedEndFlags = Parser.this.endFlags;
            Parser.this.endFlags = 0;

            savedInForInit = Parser.this.inForInit;
            Parser.this.inForInit = false;
        }

        void restore() {
            Parser.this.currentScriptOrFn = savedCurrentScriptOrFn;
            Parser.this.currentScope = savedCurrentScope;
            Parser.this.labelSet = savedLabelSet;
            Parser.this.loopSet = savedLoopSet;
            Parser.this.loopAndSwitchSet = savedLoopAndSwitchSet;
            Parser.this.endFlags = savedEndFlags;
            Parser.this.inForInit = savedInForInit;
        }
    }

    /**
     * Given a destructuring assignment with a left hand side parsed
     * as an array or object literal and a right hand side expression,
     * rewrite as a series of assignments to the variables defined in
     * left from property accesses to the expression on the right.
     * @param type declaration type: Token.VAR or Token.LET or -1
     * @param left array or object literal containing NAME nodes for
     *        variables to assign
     * @param right expression to assign from
     * @return expression that performs a series of assignments to
     *         the variables defined in left
     */
    Node createDestructuringAssignment(int type, Node left, Node right)
    {
<span class='bc' id='L3914' title='0|4|4 - Total: 4'>        String tempName = currentScriptOrFn.getNextTempName();
</span><span class='bc' id='L3915' title='0|7|7 - Total: 7'>        Node result = destructuringAssignmentHelper(type, left, right,
</span>            tempName);
<span class='bc' id='L3917' title='0|3|3 - Total: 3'>        Node comma = result.getLastChild();
</span><span class='bc' id='L3918' title='0|5|5 - Total: 5'>        comma.addChildToBack(createName(tempName));
</span><span class='bc' id='L3919' title='0|2|2 - Total: 2'>        return result;
</span>    }

    Node destructuringAssignmentHelper(int variableType, Node left,
                                       Node right, String tempName)
    {
<span class='bc' id='L3925' title='0|6|6 - Total: 6'>        Scope result = createScopeNode(Token.LETEXPR, left.getLineno());
</span><span class='bc' id='L3926' title='0|9|9 - Total: 9'>        result.addChildToFront(new Node(Token.LET,
</span><span class='bc' id='L3927' title='0|2|2 - Total: 2'>            createName(Token.NAME, tempName, right)));
</span>        try {
<span class='bc' id='L3929' title='0|3|3 - Total: 3'>            pushScope(result);
</span><span class='bc' id='L3930' title='0|5|5 - Total: 5'>            defineSymbol(Token.LET, tempName, true);
</span>        } finally {
<span class='bpc' id='L3932' title='0|2|2 - Total: 5'>            popScope();
</span><span class='bpc' id='L3933' title='0|1|1 - Total: 3'>        }
</span><span class='bc' id='L3934' title='0|5|5 - Total: 5'>        Node comma = new Node(Token.COMMA);
</span><span class='bc' id='L3935' title='0|3|3 - Total: 3'>        result.addChildToBack(comma);
</span><span class='bc' id='L3936' title='0|4|4 - Total: 4'>        List<String> destructuringNames = new ArrayList<String>();
</span><span class='bc' id='L3937' title='0|2|2 - Total: 2'>        boolean empty = true;
</span><span class='bpc' id='L3938' title='0|3|3 - Total: 4'>        switch (left.getType()) {
</span>          case Token.ARRAYLIT:
<span class='bc' id='L3940' title='0|9|9 - Total: 9'>              empty = destructuringArray((ArrayLiteral)left,
</span>                                         variableType, tempName, comma,
                                         destructuringNames);
<span class='bc' id='L3943' title='0|1|1 - Total: 1'>              break;
</span>          case Token.OBJECTLIT:
<span class='bc' id='L3945' title='0|9|9 - Total: 9'>              empty = destructuringObject((ObjectLiteral)left,
</span>                                          variableType, tempName, comma,
                                          destructuringNames);
<span class='bc' id='L3948' title='0|1|1 - Total: 1'>              break;
</span>          case Token.GETPROP:
          case Token.GETELEM:
<span class='bpc' id='L3951' title='0|1|1 - Total: 2'>              switch (variableType) {
</span>                  case Token.CONST:
                  case Token.LET:
                  case Token.VAR:
<span class='nc' id='L3955' title='0|0|0 - Total: 3'>                      reportError("msg.bad.assign.left");
</span>              }
<span class='bc' id='L3957' title='0|8|8 - Total: 8'>              comma.addChildToBack(simpleAssignment(left, createName(tempName)));
</span><span class='bc' id='L3958' title='0|1|1 - Total: 1'>              break;
</span>          default:
<span class='nc' id='L3960' title='0|0|0 - Total: 3'>              reportError("msg.bad.assign.left");
</span>        }
<span class='bc' id='L3962' title='0|2|2 - Total: 2'>        if (empty) {
</span>            // Don't want a COMMA node with no children. Just add a zero.
<span class='bc' id='L3964' title='0|5|5 - Total: 5'>            comma.addChildToBack(createNumber(0));
</span>        }
<span class='bc' id='L3966' title='0|4|4 - Total: 4'>        result.putProp(Node.DESTRUCTURING_NAMES, destructuringNames);
</span><span class='bc' id='L3967' title='0|2|2 - Total: 2'>        return result;
</span>    }

    boolean destructuringArray(ArrayLiteral array,
                               int variableType,
                               String tempName,
                               Node parent,
                               List<String> destructuringNames)
    {
<span class='bc' id='L3976' title='0|2|2 - Total: 2'>        boolean empty = true;
</span><span class='bc' id='L3977' title='0|2|2 - Total: 2'>        int setOp = variableType == Token.CONST
</span>            ? Token.SETCONST : Token.SETNAME;
<span class='bc' id='L3979' title='0|2|2 - Total: 2'>        int index = 0;
</span><span class='bc' id='L3980' title='0|2|2 - Total: 2'>        for (AstNode n : array.getElements()) {
</span><span class='bc' id='L3981' title='0|2|2 - Total: 2'>            if (n.getType() == Token.EMPTY) {
</span><span class='bc' id='L3982' title='0|1|1 - Total: 1'>                index++;
</span><span class='bc' id='L3983' title='0|1|1 - Total: 1'>                continue;
</span>            }
<span class='bc' id='L3985' title='0|5|5 - Total: 5'>            Node rightElem = new Node(Token.GETELEM,
</span><span class='bc' id='L3986' title='0|4|4 - Total: 4'>                                      createName(tempName),
</span><span class='bc' id='L3987' title='0|3|3 - Total: 3'>                                      createNumber(index));
</span><span class='bc' id='L3988' title='0|2|2 - Total: 2'>            if (n.getType() == Token.NAME) {
</span><span class='bc' id='L3989' title='0|3|3 - Total: 3'>                String name = n.getString();
</span><span class='bc' id='L3990' title='0|9|9 - Total: 9'>                parent.addChildToBack(new Node(setOp,
</span><span class='bc' id='L3991' title='0|3|3 - Total: 3'>                                              createName(Token.BINDNAME,
</span>                                                         name, null),
                                              rightElem));
<span class='bc' id='L3994' title='0|2|2 - Total: 2'>                if (variableType != -1) {
</span><span class='bc' id='L3995' title='0|5|5 - Total: 5'>                    defineSymbol(variableType, name, true);
</span><span class='bc' id='L3996' title='0|4|4 - Total: 4'>                    destructuringNames.add(name);
</span>                }
<span class='bc' id='L3998' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L3999' title='0|7|7 - Total: 7'>                parent.addChildToBack
</span><span class='bc' id='L4000' title='0|1|1 - Total: 1'>                    (destructuringAssignmentHelper
</span><span class='bc' id='L4001' title='0|1|1 - Total: 1'>                     (variableType, n,
</span>                      rightElem,
<span class='bc' id='L4003' title='0|1|1 - Total: 1'>                      currentScriptOrFn.getNextTempName()));
</span>            }
<span class='bc' id='L4005' title='0|1|1 - Total: 1'>            index++;
</span><span class='bc' id='L4006' title='0|2|2 - Total: 2'>            empty = false;
</span><span class='bc' id='L4007' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L4008' title='0|2|2 - Total: 2'>        return empty;
</span>    }

    boolean destructuringObject(ObjectLiteral node,
                                int variableType,
                                String tempName,
                                Node parent,
                                List<String> destructuringNames)
    {
<span class='bc' id='L4017' title='0|2|2 - Total: 2'>        boolean empty = true;
</span><span class='bpc' id='L4018' title='0|1|1 - Total: 2'>        int setOp = variableType == Token.CONST
</span>            ? Token.SETCONST : Token.SETNAME;

<span class='bc' id='L4021' title='0|2|2 - Total: 2'>        for (ObjectProperty prop : node.getElements()) {
</span><span class='bc' id='L4022' title='0|2|2 - Total: 2'>            int lineno = 0;
</span>            // This function is sometimes called from the IRFactory when
            // when executing regression tests, and in those cases the
            // tokenStream isn't set.  Deal with it.
<span class='bc' id='L4026' title='0|2|2 - Total: 2'>            if (ts != null) {
</span><span class='bc' id='L4027' title='0|4|4 - Total: 4'>              lineno = ts.lineno;
</span>            }
<span class='bc' id='L4029' title='0|3|3 - Total: 3'>            AstNode id = prop.getLeft();
</span><span class='bc' id='L4030' title='0|2|2 - Total: 2'>            Node rightElem = null;
</span><span class='bc' id='L4031' title='0|2|2 - Total: 2'>            if (id instanceof Name) {
</span><span class='bc' id='L4032' title='0|5|5 - Total: 5'>                Node s = Node.newString(((Name)id).getIdentifier());
</span><span class='bc' id='L4033' title='0|9|9 - Total: 9'>                rightElem = new Node(Token.GETPROP, createName(tempName), s);
</span><span class='bpc' id='L4034' title='0|1|1 - Total: 2'>            } else if (id instanceof StringLiteral) {
</span><span class='nc' id='L4035' title='0|0|0 - Total: 5'>                Node s = Node.newString(((StringLiteral)id).getValue());
</span><span class='nc' id='L4036' title='0|0|0 - Total: 9'>                rightElem = new Node(Token.GETPROP, createName(tempName), s);
</span><span class='bpc' id='L4037' title='0|1|1 - Total: 2'>            } else if (id instanceof NumberLiteral) {
</span><span class='bc' id='L4038' title='0|8|8 - Total: 8'>                Node s = createNumber((int)((NumberLiteral)id).getNumber());
</span><span class='bc' id='L4039' title='0|9|9 - Total: 9'>                rightElem = new Node(Token.GETELEM, createName(tempName), s);
</span><span class='bc' id='L4040' title='0|1|1 - Total: 1'>            } else {
</span><span class='nc' id='L4041' title='0|0|0 - Total: 3'>                throw codeBug();
</span>            }
<span class='bc' id='L4043' title='0|3|3 - Total: 3'>            rightElem.setLineno(lineno);
</span><span class='bc' id='L4044' title='0|3|3 - Total: 3'>            AstNode value = prop.getRight();
</span><span class='bc' id='L4045' title='0|2|2 - Total: 2'>            if (value.getType() == Token.NAME) {
</span><span class='bc' id='L4046' title='0|4|4 - Total: 4'>                String name = ((Name)value).getIdentifier();
</span><span class='bc' id='L4047' title='0|9|9 - Total: 9'>                parent.addChildToBack(new Node(setOp,
</span><span class='bc' id='L4048' title='0|3|3 - Total: 3'>                                              createName(Token.BINDNAME,
</span>                                                         name, null),
                                              rightElem));
<span class='bc' id='L4051' title='0|2|2 - Total: 2'>                if (variableType != -1) {
</span><span class='bc' id='L4052' title='0|5|5 - Total: 5'>                    defineSymbol(variableType, name, true);
</span><span class='bc' id='L4053' title='0|4|4 - Total: 4'>                    destructuringNames.add(name);
</span>                }
<span class='bc' id='L4055' title='0|1|1 - Total: 1'>            } else {
</span><span class='bc' id='L4056' title='0|7|7 - Total: 7'>                parent.addChildToBack
</span><span class='bc' id='L4057' title='0|1|1 - Total: 1'>                    (destructuringAssignmentHelper
</span><span class='bc' id='L4058' title='0|1|1 - Total: 1'>                     (variableType, value, rightElem,
</span><span class='bc' id='L4059' title='0|1|1 - Total: 1'>                      currentScriptOrFn.getNextTempName()));
</span>            }
<span class='bc' id='L4061' title='0|2|2 - Total: 2'>            empty = false;
</span><span class='bc' id='L4062' title='0|1|1 - Total: 1'>        }
</span><span class='bc' id='L4063' title='0|2|2 - Total: 2'>        return empty;
</span>    }

    protected Node createName(String name) {
<span class='bc' id='L4067' title='0|4|4 - Total: 4'>        checkActivationName(name, Token.NAME);
</span><span class='bc' id='L4068' title='0|4|4 - Total: 4'>        return Node.newString(Token.NAME, name);
</span>    }

    protected Node createName(int type, String name, Node child) {
<span class='bc' id='L4072' title='0|4|4 - Total: 4'>        Node result = createName(name);
</span><span class='bc' id='L4073' title='0|4|4 - Total: 4'>        result.setType(type);
</span><span class='bc' id='L4074' title='0|2|2 - Total: 2'>        if (child != null)
</span><span class='bc' id='L4075' title='0|3|3 - Total: 3'>            result.addChildToBack(child);
</span><span class='bc' id='L4076' title='0|2|2 - Total: 2'>        return result;
</span>    }

    protected Node createNumber(double number) {
<span class='bc' id='L4080' title='0|3|3 - Total: 3'>        return Node.newNumber(number);
</span>    }

    /**
     * Create a node that can be used to hold lexically scoped variable
     * definitions (via let declarations).
     *
     * @param token the token of the node to create
     * @param lineno line number of source
     * @return the created node
     */
    protected Scope createScopeNode(int token, int lineno) {
<span class='bc' id='L4092' title='0|4|4 - Total: 4'>        Scope scope =new Scope();
</span><span class='bc' id='L4093' title='0|4|4 - Total: 4'>        scope.setType(token);
</span><span class='bc' id='L4094' title='0|3|3 - Total: 3'>        scope.setLineno(lineno);
</span><span class='bc' id='L4095' title='0|2|2 - Total: 2'>        return scope;
</span>    }

    // Quickie tutorial for some of the interpreter bytecodes.
    //
    // GETPROP - for normal foo.bar prop access; right side is a name
    // GETELEM - for normal foo[bar] element access; rhs is an expr
    // SETPROP - for assignment when left side is a GETPROP
    // SETELEM - for assignment when left side is a GETELEM
    // DELPROP - used for delete foo.bar or foo[bar]
    //
    // GET_REF, SET_REF, DEL_REF - in general, these mean you're using
    // get/set/delete on a right-hand side expression (possibly with no
    // explicit left-hand side) that doesn't use the normal JavaScript
    // Object (i.e. ScriptableObject) get/set/delete functions, but wants
    // to provide its own versions instead.  It will ultimately implement
    // Ref, and currently SpecialRef (for __proto__ etc.) and XmlName
    // (for E4X XML objects) are the only implementations.  The runtime
    // notices these bytecodes and delegates get/set/delete to the object.
    //
    // BINDNAME:  used in assignments.  LHS is evaluated first to get a
    // specific object containing the property ("binding" the property
    // to the object) so that it's always the same object, regardless of
    // side effects in the RHS.

    protected Node simpleAssignment(Node left, Node right) {
<span class='bc' id='L4121' title='0|3|3 - Total: 3'>        int nodeType = left.getType();
</span><span class='bpc' id='L4122' title='0|3|3 - Total: 4'>        switch (nodeType) {
</span>          case Token.NAME:
<span class='bc' id='L4124' title='0|4|4 - Total: 4'>              String name = ((Name) left).getIdentifier();
</span><span class='bc' id='L4125' title='0|2|2 - Total: 2'>              if (inUseStrictDirective &&
</span><span class='bpc' id='L4126' title='0|2|2 - Total: 4'>                  ("eval".equals(name) || "arguments".equals(name)))
</span>              {
<span class='nc' id='L4128' title='0|0|0 - Total: 4'>                  reportError("msg.bad.id.strict", name);
</span>              }
<span class='bc' id='L4130' title='0|4|4 - Total: 4'>              left.setType(Token.BINDNAME);
</span><span class='bc' id='L4131' title='0|7|7 - Total: 7'>              return new Node(Token.SETNAME, left, right);
</span>
          case Token.GETPROP:
          case Token.GETELEM: {
              Node obj, id;
              // If it's a PropertyGet or ElementGet, we're in the parse pass.
              // We could alternately have PropertyGet and ElementGet
              // override getFirstChild/getLastChild and return the appropriate
              // field, but that seems just as ugly as this casting.
<span class='bc' id='L4140' title='0|2|2 - Total: 2'>              if (left instanceof PropertyGet) {
</span><span class='bc' id='L4141' title='0|4|4 - Total: 4'>                  obj = ((PropertyGet)left).getTarget();
</span><span class='bc' id='L4142' title='0|5|5 - Total: 5'>                  id = ((PropertyGet)left).getProperty();
</span><span class='bpc' id='L4143' title='0|1|1 - Total: 2'>              } else if (left instanceof ElementGet) {
</span><span class='nc' id='L4144' title='0|0|0 - Total: 4'>                  obj = ((ElementGet)left).getTarget();
</span><span class='nc' id='L4145' title='0|0|0 - Total: 5'>                  id = ((ElementGet)left).getElement();
</span>              } else {
                  // This branch is called during IRFactory transform pass.
<span class='bc' id='L4148' title='0|3|3 - Total: 3'>                  obj = left.getFirstChild();
</span><span class='bc' id='L4149' title='0|3|3 - Total: 3'>                  id = left.getLastChild();
</span>              }
              int type;
<span class='bc' id='L4152' title='0|2|2 - Total: 2'>              if (nodeType == Token.GETPROP) {
</span><span class='bc' id='L4153' title='0|2|2 - Total: 2'>                  type = Token.SETPROP;
</span>                  // TODO(stevey) - see https://bugzilla.mozilla.org/show_bug.cgi?id=492036
                  // The new AST code generates NAME tokens for GETPROP ids where the old parser
                  // generated STRING nodes. If we don't set the type to STRING below, this will
                  // cause java.lang.VerifyError in codegen for code like
                  // "var obj={p:3};[obj.p]=[9];"
<span class='bc' id='L4159' title='0|5|5 - Total: 5'>                  id.setType(Token.STRING);
</span>              } else {
<span class='bc' id='L4161' title='0|2|2 - Total: 2'>                  type = Token.SETELEM;
</span>              }
<span class='bc' id='L4163' title='0|8|8 - Total: 8'>              return new Node(type, obj, id, right);
</span>          }
          case Token.GET_REF: {
<span class='bc' id='L4166' title='0|3|3 - Total: 3'>              Node ref = left.getFirstChild();
</span><span class='bc' id='L4167' title='0|3|3 - Total: 3'>              checkMutableReference(ref);
</span><span class='bc' id='L4168' title='0|7|7 - Total: 7'>              return new Node(Token.SET_REF, ref, right);
</span>          }
        }

<span class='nc' id='L4172' title='0|0|0 - Total: 3'>        throw codeBug();
</span>    }

    protected void checkMutableReference(Node n) {
<span class='bc' id='L4176' title='0|5|5 - Total: 5'>        int memberTypeFlags = n.getIntProp(Node.MEMBER_TYPE_PROP, 0);
</span><span class='bc' id='L4177' title='0|2|2 - Total: 2'>        if ((memberTypeFlags & Node.DESCENDANTS_FLAG) != 0) {
</span><span class='nc' id='L4178' title='0|0|0 - Total: 3'>            reportError("msg.bad.assign.left");
</span>        }
<span class='bc' id='L4180' title='0|1|1 - Total: 1'>    }
</span>
    // remove any ParenthesizedExpression wrappers
    protected AstNode removeParens(AstNode node) {
<span class='bc' id='L4184' title='0|2|2 - Total: 2'>        while (node instanceof ParenthesizedExpression) {
</span><span class='bc' id='L4185' title='0|5|5 - Total: 5'>            node = ((ParenthesizedExpression)node).getExpression();
</span>        }
<span class='bc' id='L4187' title='0|2|2 - Total: 2'>        return node;
</span>    }

    void markDestructuring(AstNode node) {
<span class='bc' id='L4191' title='0|2|2 - Total: 2'>        if (node instanceof DestructuringForm) {
</span><span class='bc' id='L4192' title='0|5|5 - Total: 5'>            ((DestructuringForm)node).setIsDestructuring(true);
</span><span class='bc' id='L4193' title='0|2|2 - Total: 2'>        } else if (node instanceof ParenthesizedExpression) {
</span><span class='bc' id='L4194' title='0|5|5 - Total: 5'>            markDestructuring(((ParenthesizedExpression)node).getExpression());
</span>        }
<span class='bc' id='L4196' title='0|1|1 - Total: 1'>    }
</span>
    // throw a failed-assertion with some helpful debugging info
    private RuntimeException codeBug()
        throws RuntimeException
    {
<span class='nc' id='L4202' title='0|0|0 - Total: 23'>        throw Kit.codeBug("ts.cursor=" + ts.cursor
</span>                          + ", ts.tokenBeg=" + ts.tokenBeg
                          + ", currentToken=" + currentToken);
    }

    public void setDefaultUseStrictDirective(boolean useStrict) {
<span class='bc' id='L4208' title='0|3|3 - Total: 3'>        defaultUseStrictDirective = useStrict;
</span><span class='bc' id='L4209' title='0|1|1 - Total: 1'>    }
</span>
    public boolean inUseStrictDirective() {
<span class='bc' id='L4212' title='0|3|3 - Total: 3'>        return inUseStrictDirective;
</span>    }
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>