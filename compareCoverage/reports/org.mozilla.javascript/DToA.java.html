<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.DToA.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.DToA.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/****************************************************************
  *
  * The author of this software is David M. Gay.
  *
  * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose without fee is hereby granted, provided that this entire notice
  * is included in all copies of any software which is or includes a copy
  * or modification of this software and in all copies of the supporting
  * documentation for such software.
  *
  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY
  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
  *
  ***************************************************************/

package org.mozilla.javascript;

import java.math.BigInteger;

<span class='nc' id='L30' title='0|0|0 - Total: 3'>class DToA {
</span>

    private static char BASEDIGIT(int digit) {
<span class='nc' id='L34' title='0|0|0 - Total: 2'>        return (char)((digit >= 10) ? 'a' - 10 + digit : '0' + digit);
</span>    }

    static final int
        DTOSTR_STANDARD = 0,              /* Either fixed or exponential format; round-trip */
        DTOSTR_STANDARD_EXPONENTIAL = 1,  /* Always exponential format; round-trip */
        DTOSTR_FIXED = 2,                 /* Round to <precision> digits after the decimal point; exponential if number is large */
        DTOSTR_EXPONENTIAL = 3,           /* Always exponential format; <precision> significant digits */
        DTOSTR_PRECISION = 4;             /* Either fixed or exponential format; <precision> significant digits */


    private static final int Frac_mask = 0xfffff;
    private static final int Exp_shift = 20;
    private static final int Exp_msk1 = 0x100000;

    private static final long Frac_maskL = 0xfffffffffffffL;
    private static final int Exp_shiftL = 52;
    private static final long Exp_msk1L = 0x10000000000000L;

    private static final int Bias = 1023;
    private static final int P = 53;

    private static final int Exp_shift1 = 20;
    private static final int Exp_mask  = 0x7ff00000;
    private static final int Exp_mask_shifted = 0x7ff;
    private static final int Bndry_mask  = 0xfffff;
    private static final int Log2P = 1;

    private static final int Sign_bit = 0x80000000;
    private static final int Exp_11  = 0x3ff00000;
    private static final int Ten_pmax = 22;
    private static final int Quick_max = 14;
    private static final int Bletch = 0x10;
    private static final int Frac_mask1 = 0xfffff;
    private static final int Int_max = 14;
    private static final int n_bigtens = 5;


<span class='uc' id='L72' title='95|95|95 - Total: 95'>    private static final double tens[] = {
</span>        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
        1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
        1e20, 1e21, 1e22
    };

<span class='uc' id='L78' title='23|23|23 - Total: 23'>    private static final double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };
</span>
    private static int lo0bits(int y)
    {
        int k;
<span class='uc' id='L83' title='2|2|2 - Total: 2'>        int x = y;
</span>
<span class='uc' id='L85' title='2|2|2 - Total: 2'>        if ((x & 7) != 0) {
</span><span class='uc' id='L86' title='2|2|2 - Total: 2'>            if ((x & 1) != 0)
</span><span class='uc' id='L87' title='2|2|2 - Total: 2'>                return 0;
</span><span class='uc' id='L88' title='2|2|2 - Total: 2'>            if ((x & 2) != 0) {
</span><span class='uc' id='L89' title='2|2|2 - Total: 2'>                return 1;
</span>            }
<span class='uc' id='L91' title='2|2|2 - Total: 2'>            return 2;
</span>        }
<span class='uc' id='L93' title='2|2|2 - Total: 2'>        k = 0;
</span><span class='uc' id='L94' title='2|2|2 - Total: 2'>        if ((x & 0xffff) == 0) {
</span><span class='uc' id='L95' title='2|2|2 - Total: 2'>            k = 16;
</span><span class='uc' id='L96' title='4|4|4 - Total: 4'>            x >>>= 16;
</span>        }
<span class='uc' id='L98' title='2|2|2 - Total: 2'>        if ((x & 0xff) == 0) {
</span><span class='uc' id='L99' title='1|1|1 - Total: 1'>            k += 8;
</span><span class='uc' id='L100' title='4|4|4 - Total: 4'>            x >>>= 8;
</span>        }
<span class='uc' id='L102' title='2|2|2 - Total: 2'>        if ((x & 0xf) == 0) {
</span><span class='uc' id='L103' title='1|1|1 - Total: 1'>            k += 4;
</span><span class='uc' id='L104' title='4|4|4 - Total: 4'>            x >>>= 4;
</span>        }
<span class='uc' id='L106' title='2|2|2 - Total: 2'>        if ((x & 0x3) == 0) {
</span><span class='uc' id='L107' title='1|1|1 - Total: 1'>            k += 2;
</span><span class='uc' id='L108' title='4|4|4 - Total: 4'>            x >>>= 2;
</span>        }
<span class='uc' id='L110' title='2|2|2 - Total: 2'>        if ((x & 1) == 0) {
</span><span class='uc' id='L111' title='1|1|1 - Total: 1'>            k++;
</span><span class='uc' id='L112' title='4|4|4 - Total: 4'>            x >>>= 1;
</span><span class='upc' id='L113' title='1|1|1 - Total: 2'>            if ((x & 1) == 0)
</span><span class='nc' id='L114' title='0|0|0 - Total: 2'>                return 32;
</span>        }
<span class='uc' id='L116' title='2|2|2 - Total: 2'>        return k;
</span>    }

    /* Return the number (0 through 32) of most significant zero bits in x. */
    private static int hi0bits(int x)
    {
<span class='uc' id='L122' title='2|2|2 - Total: 2'>        int k = 0;
</span>
<span class='upc' id='L124' title='1|1|1 - Total: 2'>        if ((x & 0xffff0000) == 0) {
</span><span class='nc' id='L125' title='0|0|0 - Total: 2'>            k = 16;
</span><span class='nc' id='L126' title='0|0|0 - Total: 4'>            x <<= 16;
</span>        }
<span class='uc' id='L128' title='2|2|2 - Total: 2'>        if ((x & 0xff000000) == 0) {
</span><span class='uc' id='L129' title='1|1|1 - Total: 1'>            k += 8;
</span><span class='uc' id='L130' title='4|4|4 - Total: 4'>            x <<= 8;
</span>        }
<span class='uc' id='L132' title='2|2|2 - Total: 2'>        if ((x & 0xf0000000) == 0) {
</span><span class='uc' id='L133' title='1|1|1 - Total: 1'>            k += 4;
</span><span class='uc' id='L134' title='4|4|4 - Total: 4'>            x <<= 4;
</span>        }
<span class='uc' id='L136' title='2|2|2 - Total: 2'>        if ((x & 0xc0000000) == 0) {
</span><span class='uc' id='L137' title='1|1|1 - Total: 1'>            k += 2;
</span><span class='uc' id='L138' title='4|4|4 - Total: 4'>            x <<= 2;
</span>        }
<span class='uc' id='L140' title='2|2|2 - Total: 2'>        if ((x & 0x80000000) == 0) {
</span><span class='uc' id='L141' title='1|1|1 - Total: 1'>            k++;
</span><span class='upc' id='L142' title='1|1|1 - Total: 2'>            if ((x & 0x40000000) == 0)
</span><span class='nc' id='L143' title='0|0|0 - Total: 2'>                return 32;
</span>        }
<span class='uc' id='L145' title='2|2|2 - Total: 2'>        return k;
</span>    }

    private static void stuffBits(byte bits[], int offset, int val)
    {
<span class='uc' id='L150' title='7|7|7 - Total: 7'>        bits[offset] = (byte)(val >> 24);
</span><span class='uc' id='L151' title='9|9|9 - Total: 9'>        bits[offset + 1] = (byte)(val >> 16);
</span><span class='uc' id='L152' title='9|9|9 - Total: 9'>        bits[offset + 2] = (byte)(val >> 8);
</span><span class='uc' id='L153' title='7|7|7 - Total: 7'>        bits[offset + 3] = (byte)(val);
</span><span class='uc' id='L154' title='1|1|1 - Total: 1'>    }
</span>
    /* Convert d into the form b*2^e, where b is an odd integer.  b is the returned
     * Bigint and e is the returned binary exponent.  Return the number of significant
     * bits in b in bits.  d must be finite and nonzero. */
    private static BigInteger d2b(double d, int[] e, int[] bits)
    {
        byte dbl_bits[];
        int i, k, y, z, de;
<span class='uc' id='L163' title='3|3|3 - Total: 3'>        long dBits = Double.doubleToLongBits(d);
</span><span class='uc' id='L164' title='5|5|5 - Total: 5'>        int d0 = (int)(dBits >>> 32);
</span><span class='uc' id='L165' title='3|3|3 - Total: 3'>        int d1 = (int)(dBits);
</span>
<span class='uc' id='L167' title='4|4|4 - Total: 4'>        z = d0 & Frac_mask;
</span><span class='uc' id='L168' title='4|4|4 - Total: 4'>        d0 &= 0x7fffffff;   /* clear sign bit, which we ignore */
</span>
<span class='upc' id='L170' title='1|1|1 - Total: 2'>        if ((de = (d0 >>> Exp_shift)) != 0)
</span><span class='uc' id='L171' title='4|4|4 - Total: 4'>            z |= Exp_msk1;
</span>
<span class='uc' id='L173' title='2|2|2 - Total: 2'>        if ((y = d1) != 0) {
</span><span class='uc' id='L174' title='3|3|3 - Total: 3'>            dbl_bits = new byte[8];
</span><span class='uc' id='L175' title='3|3|3 - Total: 3'>            k = lo0bits(y);
</span><span class='uc' id='L176' title='4|4|4 - Total: 4'>            y >>>= k;
</span><span class='uc' id='L177' title='2|2|2 - Total: 2'>            if (k != 0) {
</span><span class='uc' id='L178' title='10|10|10 - Total: 10'>                stuffBits(dbl_bits, 4, y | z << (32 - k));
</span><span class='uc' id='L179' title='5|5|5 - Total: 5'>                z >>= k;
</span>            }
            else
<span class='uc' id='L182' title='4|4|4 - Total: 4'>                stuffBits(dbl_bits, 4, y);
</span><span class='uc' id='L183' title='4|4|4 - Total: 4'>            stuffBits(dbl_bits, 0, z);
</span><span class='uc' id='L184' title='2|2|2 - Total: 2'>            i = (z != 0) ? 2 : 1;
</span>        }
        else {
    //        JS_ASSERT(z);
<span class='uc' id='L188' title='3|3|3 - Total: 3'>            dbl_bits = new byte[4];
</span><span class='uc' id='L189' title='3|3|3 - Total: 3'>            k = lo0bits(z);
</span><span class='uc' id='L190' title='4|4|4 - Total: 4'>            z >>>= k;
</span><span class='uc' id='L191' title='4|4|4 - Total: 4'>            stuffBits(dbl_bits, 0, z);
</span><span class='uc' id='L192' title='1|1|1 - Total: 1'>            k += 32;
</span><span class='uc' id='L193' title='2|2|2 - Total: 2'>            i = 1;
</span>        }
<span class='upc' id='L195' title='1|1|1 - Total: 2'>        if (de != 0) {
</span><span class='uc' id='L196' title='10|10|10 - Total: 10'>            e[0] = de - Bias - (P-1) + k;
</span><span class='uc' id='L197' title='7|7|7 - Total: 7'>            bits[0] = P - k;
</span>        }
        else {
<span class='nc' id='L200' title='0|0|0 - Total: 12'>            e[0] = de - Bias - (P-1) + 1 + k;
</span><span class='nc' id='L201' title='0|0|0 - Total: 9'>            bits[0] = 32*i - hi0bits(z);
</span>        }
<span class='uc' id='L203' title='5|5|5 - Total: 5'>        return new BigInteger(dbl_bits);
</span>    }

    static String JS_dtobasestr(int base, double d)
    {
<span class='upc' id='L208' title='2|2|2 - Total: 4'>        if (!(2 <= base && base <= 36))
</span><span class='nc' id='L209' title='0|0|0 - Total: 12'>            throw new IllegalArgumentException("Bad base: "+base);
</span>
        /* Check for Infinity and NaN */
<span class='upc' id='L212' title='1|1|1 - Total: 2'>        if (Double.isNaN(d)) {
</span><span class='nc' id='L213' title='0|0|0 - Total: 2'>            return "NaN";
</span><span class='upc' id='L214' title='1|1|1 - Total: 2'>        } else if (Double.isInfinite(d)) {
</span><span class='nc' id='L215' title='0|0|0 - Total: 2'>            return (d > 0.0) ? "Infinity" : "-Infinity";
</span><span class='upc' id='L216' title='1|1|1 - Total: 2'>        } else if (d == 0) {
</span>            // ALERT: should it distinguish -0.0 from +0.0 ?
<span class='nc' id='L218' title='0|0|0 - Total: 2'>            return "0";
</span>        }

        boolean negative;
<span class='upc' id='L222' title='1|1|1 - Total: 2'>        if (d >= 0.0) {
</span><span class='uc' id='L223' title='3|3|3 - Total: 3'>            negative = false;
</span>        } else {
<span class='nc' id='L225' title='0|0|0 - Total: 2'>            negative = true;
</span><span class='nc' id='L226' title='0|0|0 - Total: 3'>            d = -d;
</span>        }

        /* Get the integer part of d including '-' sign. */
        String intDigits;

<span class='uc' id='L232' title='3|3|3 - Total: 3'>        double dfloor = Math.floor(d);
</span><span class='uc' id='L233' title='3|3|3 - Total: 3'>        long lfloor = (long)dfloor;
</span><span class='upc' id='L234' title='1|1|1 - Total: 2'>        if (lfloor == dfloor) {
</span>            // int part fits long
<span class='upc' id='L236' title='1|1|1 - Total: 2'>            intDigits = Long.toString((negative) ? -lfloor : lfloor, base);
</span>        } else {
            // BigInteger should be used
<span class='nc' id='L239' title='0|0|0 - Total: 3'>            long floorBits = Double.doubleToLongBits(dfloor);
</span><span class='nc' id='L240' title='0|0|0 - Total: 7'>            int exp = (int)(floorBits >> Exp_shiftL) & Exp_mask_shifted;
</span>            long mantissa;
<span class='nc' id='L242' title='0|0|0 - Total: 2'>            if (exp == 0) {
</span><span class='nc' id='L243' title='0|0|0 - Total: 7'>                mantissa = (floorBits & Frac_maskL) << 1;
</span>            } else {
<span class='nc' id='L245' title='0|0|0 - Total: 6'>                mantissa = (floorBits & Frac_maskL) | Exp_msk1L;
</span>            }
<span class='nc' id='L247' title='0|0|0 - Total: 2'>            if (negative) {
</span><span class='nc' id='L248' title='0|0|0 - Total: 3'>                mantissa = -mantissa;
</span>            }
<span class='nc' id='L250' title='0|0|0 - Total: 1'>            exp -= 1075;
</span><span class='nc' id='L251' title='0|0|0 - Total: 3'>            BigInteger x = BigInteger.valueOf(mantissa);
</span><span class='nc' id='L252' title='0|0|0 - Total: 2'>            if (exp > 0) {
</span><span class='nc' id='L253' title='0|0|0 - Total: 5'>                x = x.shiftLeft(exp);
</span><span class='nc' id='L254' title='0|0|0 - Total: 2'>            } else if (exp < 0) {
</span><span class='nc' id='L255' title='0|0|0 - Total: 5'>                x = x.shiftRight(-exp);
</span>            }
<span class='nc' id='L257' title='0|0|0 - Total: 4'>            intDigits = x.toString(base);
</span>        }

<span class='upc' id='L260' title='1|1|1 - Total: 2'>        if (d == dfloor) {
</span>            // No fraction part
<span class='uc' id='L262' title='2|2|2 - Total: 2'>            return intDigits;
</span>        } else {
            /* We have a fraction. */

            StringBuilder buffer;       /* The output string */
            int digit;
            double df;           /* The fractional part of d */
            BigInteger b;

<span class='nc' id='L271' title='0|0|0 - Total: 4'>            buffer = new StringBuilder();
</span><span class='nc' id='L272' title='0|0|0 - Total: 6'>            buffer.append(intDigits).append('.');
</span><span class='nc' id='L273' title='0|0|0 - Total: 4'>            df = d - dfloor;
</span>
<span class='nc' id='L275' title='0|0|0 - Total: 3'>            long dBits = Double.doubleToLongBits(d);
</span><span class='nc' id='L276' title='0|0|0 - Total: 5'>            int word0 = (int)(dBits >> 32);
</span><span class='nc' id='L277' title='0|0|0 - Total: 3'>            int word1 = (int)(dBits);
</span>
<span class='nc' id='L279' title='0|0|0 - Total: 3'>            int[] e = new int[1];
</span><span class='nc' id='L280' title='0|0|0 - Total: 3'>            int[] bbits = new int[1];
</span>
<span class='nc' id='L282' title='0|0|0 - Total: 5'>            b = d2b(df, e, bbits);
</span>//            JS_ASSERT(e < 0);
            /* At this point df = b * 2^e.  e must be less than zero because 0 < df < 1. */

<span class='nc' id='L286' title='0|0|0 - Total: 7'>            int s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);
</span><span class='nc' id='L287' title='0|0|0 - Total: 2'>            if (s2 == 0)
</span><span class='nc' id='L288' title='0|0|0 - Total: 2'>                s2 = -1;
</span><span class='nc' id='L289' title='0|0|0 - Total: 1'>            s2 += Bias + P;
</span>            /* 1/2^s2 = (nextDouble(d) - d)/2 */
//            JS_ASSERT(-s2 < e);
<span class='nc' id='L292' title='0|0|0 - Total: 3'>            BigInteger mlo = BigInteger.valueOf(1);
</span><span class='nc' id='L293' title='0|0|0 - Total: 2'>            BigInteger mhi = mlo;
</span><span class='nc' id='L294' title='0|0|0 - Total: 6'>            if ((word1 == 0) && ((word0 & Bndry_mask) == 0)
</span>                && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {
                /* The special case.  Here we want to be within a quarter of the last input
                   significant digit instead of one half of it when the output string's value is less than d.  */
<span class='nc' id='L298' title='0|0|0 - Total: 1'>                s2 += Log2P;
</span><span class='nc' id='L299' title='0|0|0 - Total: 3'>                mhi = BigInteger.valueOf(1<<Log2P);
</span>            }

<span class='nc' id='L302' title='0|0|0 - Total: 8'>            b = b.shiftLeft(e[0] + s2);
</span><span class='nc' id='L303' title='0|0|0 - Total: 3'>            BigInteger s = BigInteger.valueOf(1);
</span><span class='nc' id='L304' title='0|0|0 - Total: 4'>            s = s.shiftLeft(s2);
</span>            /* At this point we have the following:
             *   s = 2^s2;
             *   1 > df = b/2^s2 > 0;
             *   (d - prevDouble(d))/2 = mlo/2^s2;
             *   (nextDouble(d) - d)/2 = mhi/2^s2. */
<span class='nc' id='L310' title='0|0|0 - Total: 4'>            BigInteger bigBase = BigInteger.valueOf(base);
</span>
<span class='nc' id='L312' title='0|0|0 - Total: 2'>            boolean done = false;
</span>            do {
<span class='nc' id='L314' title='0|0|0 - Total: 4'>                b = b.multiply(bigBase);
</span><span class='nc' id='L315' title='0|0|0 - Total: 4'>                BigInteger[] divResult = b.divideAndRemainder(s);
</span><span class='nc' id='L316' title='0|0|0 - Total: 4'>                b = divResult[1];
</span><span class='nc' id='L317' title='0|0|0 - Total: 6'>                digit = (char)(divResult[0].intValue());
</span><span class='nc' id='L318' title='0|0|0 - Total: 2'>                if (mlo == mhi)
</span><span class='nc' id='L319' title='0|0|0 - Total: 7'>                    mlo = mhi = mlo.multiply(bigBase);
</span>                else {
<span class='nc' id='L321' title='0|0|0 - Total: 4'>                    mlo = mlo.multiply(bigBase);
</span><span class='nc' id='L322' title='0|0|0 - Total: 4'>                    mhi = mhi.multiply(bigBase);
</span>                }

                /* Do we yet have the shortest string that will round to d? */
<span class='nc' id='L326' title='0|0|0 - Total: 4'>                int j = b.compareTo(mlo);
</span>                /* j is b/2^s2 compared with mlo/2^s2. */
<span class='nc' id='L328' title='0|0|0 - Total: 4'>                BigInteger delta = s.subtract(mhi);
</span><span class='nc' id='L329' title='0|0|0 - Total: 2'>                int j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);
</span>                /* j1 is b/2^s2 compared with 1 - mhi/2^s2. */
<span class='nc' id='L331' title='0|0|0 - Total: 4'>                if (j1 == 0 && ((word1 & 1) == 0)) {
</span><span class='nc' id='L332' title='0|0|0 - Total: 2'>                    if (j > 0)
</span><span class='nc' id='L333' title='0|0|0 - Total: 1'>                        digit++;
</span><span class='nc' id='L334' title='0|0|0 - Total: 3'>                    done = true;
</span>                } else
<span class='nc' id='L336' title='0|0|0 - Total: 6'>                if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {
</span><span class='nc' id='L337' title='0|0|0 - Total: 2'>                    if (j1 > 0) {
</span>                        /* Either dig or dig+1 would work here as the least significant digit.
                           Use whichever would produce an output value closer to d. */
<span class='nc' id='L340' title='0|0|0 - Total: 4'>                        b = b.shiftLeft(1);
</span><span class='nc' id='L341' title='0|0|0 - Total: 4'>                        j1 = b.compareTo(s);
</span><span class='nc' id='L342' title='0|0|0 - Total: 2'>                        if (j1 > 0) /* The even test (|| (j1 == 0 && (digit & 1))) is not here because it messes up odd base output
</span>                                     * such as 3.5 in base 3.  */
<span class='nc' id='L344' title='0|0|0 - Total: 1'>                            digit++;
</span>                    }
<span class='nc' id='L346' title='0|0|0 - Total: 3'>                    done = true;
</span><span class='nc' id='L347' title='0|0|0 - Total: 2'>                } else if (j1 > 0) {
</span><span class='nc' id='L348' title='0|0|0 - Total: 1'>                    digit++;
</span><span class='nc' id='L349' title='0|0|0 - Total: 2'>                    done = true;
</span>                }
//                JS_ASSERT(digit < (uint32)base);
<span class='nc' id='L352' title='0|0|0 - Total: 5'>                buffer.append(BASEDIGIT(digit));
</span><span class='nc' id='L353' title='0|0|0 - Total: 2'>            } while (!done);
</span>
<span class='nc' id='L355' title='0|0|0 - Total: 3'>            return buffer.toString();
</span>        }

    }

    /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
     *
     * Inspired by "How to Print Floating-Point Numbers Accurately" by
     * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].
     *
     * Modifications:
     *  1. Rather than iterating, we use a simple numeric overestimate
     *     to determine k = floor(log10(d)).  We scale relevant
     *     quantities using O(log2(k)) rather than O(k) multiplications.
     *  2. For some modes > 2 (corresponding to ecvt and fcvt), we don't
     *     try to generate digits strictly left to right.  Instead, we
     *     compute with fewer bits and propagate the carry if necessary
     *     when rounding the final digit up.  This is often faster.
     *  3. Under the assumption that input will be rounded nearest,
     *     mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.
     *     That is, we allow equality in stopping tests when the
     *     round-nearest rule will give the same floating-point value
     *     as would satisfaction of the stopping test with strict
     *     inequality.
     *  4. We remove common factors of powers of 2 from relevant
     *     quantities.
     *  5. When converting floating-point integers less than 1e16,
     *     we use floating-point arithmetic rather than resorting
     *     to multiple-precision integers.
     *  6. When asked to produce fewer than 15 digits, we first try
     *     to get by with floating-point arithmetic; we resort to
     *     multiple-precision integer arithmetic only if we cannot
     *     guarantee that the floating-point calculation has given
     *     the correctly rounded result.  For k requested digits and
     *     "uniformly" distributed input, the probability is
     *     something like 10^(k-15) that we must resort to the Long
     *     calculation.
     */

    static int word0(double d)
    {
<span class='uc' id='L396' title='3|3|3 - Total: 3'>        long dBits = Double.doubleToLongBits(d);
</span><span class='uc' id='L397' title='5|5|5 - Total: 5'>        return (int)(dBits >> 32);
</span>    }

    static double setWord0(double d, int i)
    {
<span class='uc' id='L402' title='3|3|3 - Total: 3'>        long dBits = Double.doubleToLongBits(d);
</span><span class='uc' id='L403' title='9|9|9 - Total: 9'>        dBits = ((long)i << 32) | (dBits & 0x0FFFFFFFFL);
</span><span class='uc' id='L404' title='3|3|3 - Total: 3'>        return Double.longBitsToDouble(dBits);
</span>    }

    static int word1(double d)
    {
<span class='uc' id='L409' title='3|3|3 - Total: 3'>        long dBits = Double.doubleToLongBits(d);
</span><span class='uc' id='L410' title='3|3|3 - Total: 3'>        return (int)(dBits);
</span>    }

    /* Return b * 5^k.  k must be nonnegative. */
    // XXXX the C version built a cache of these
    static BigInteger pow5mult(BigInteger b, int k)
    {
<span class='uc' id='L417' title='7|7|7 - Total: 7'>        return b.multiply(BigInteger.valueOf(5).pow(k));
</span>    }

    static boolean roundOff(StringBuilder buf)
    {
<span class='uc' id='L422' title='3|3|3 - Total: 3'>        int i = buf.length();
</span><span class='uc' id='L423' title='2|2|2 - Total: 2'>        while (i != 0) {
</span><span class='uc' id='L424' title='1|1|1 - Total: 1'>            --i;
</span><span class='uc' id='L425' title='4|4|4 - Total: 4'>            char c = buf.charAt(i);
</span><span class='uc' id='L426' title='2|2|2 - Total: 2'>            if (c != '9') {
</span><span class='uc' id='L427' title='7|7|7 - Total: 7'>                buf.setCharAt(i, (char)(c + 1));
</span><span class='uc' id='L428' title='5|5|5 - Total: 5'>                buf.setLength(i + 1);
</span><span class='uc' id='L429' title='2|2|2 - Total: 2'>                return false;
</span>            }
<span class='uc' id='L431' title='1|1|1 - Total: 1'>        }
</span><span class='uc' id='L432' title='3|3|3 - Total: 3'>        buf.setLength(0);
</span><span class='uc' id='L433' title='2|2|2 - Total: 2'>        return true;
</span>    }

    /* Always emits at least one digit. */
    /* If biasUp is set, then rounding in modes 2 and 3 will round away from zero
     * when the number is exactly halfway between two representable values.  For example,
     * rounding 2.5 to zero digits after the decimal point will return 3 and not 2.
     * 2.49 will still round to 2, and 2.51 will still round to 3. */
    /* bufsize should be at least 20 for modes 0 and 1.  For the other modes,
     * bufsize should be two greater than the maximum number of output characters expected. */
    static int
    JS_dtoa(double d, int mode, boolean biasUp, int ndigits,
                    boolean[] sign, StringBuilder buf)
    {
        /*  Arguments ndigits, decpt, sign are similar to those
            of ecvt and fcvt; trailing zeros are suppressed from
            the returned string.  If not null, *rve is set to point
            to the end of the return value.  If d is +-Infinity or NaN,
            then *decpt is set to 9999.

            mode:
            0 ==> shortest string that yields d when read in
            and rounded to nearest.
            1 ==> like 0, but with Steele & White stopping rule;
            e.g. with IEEE P754 arithmetic , mode 0 gives
            1e23 whereas mode 1 gives 9.999999999999999e22.
            2 ==> max(1,ndigits) significant digits.  This gives a
            return value similar to that of ecvt, except
            that trailing zeros are suppressed.
            3 ==> through ndigits past the decimal point.  This
            gives a return value similar to that from fcvt,
            except that trailing zeros are suppressed, and
            ndigits can be negative.
            4-9 should give the same return values as 2-3, i.e.,
            4 <= mode <= 9 ==> same return as mode
            2 + (mode & 1).  These modes are mainly for
            debugging; often they run slower but sometimes
            faster than modes 2-3.
            4,5,8,9 ==> left-to-right digit generation.
            6-9 ==> don't try fast floating-point estimate
            (if applicable).

            Values of mode other than 0-9 are treated as mode 0.

            Sufficient space is allocated to the return value
            to hold the suppressed trailing zeros.
        */

        int b2, b5, i, ieps, ilim, ilim0, ilim1,
            j, j1, k, k0, m2, m5, s2, s5;
        char dig;
        long L;
        long x;
        BigInteger b, b1, delta, mlo, mhi, S;
<span class='uc' id='L487' title='3|3|3 - Total: 3'>        int[] be = new int[1];
</span><span class='uc' id='L488' title='3|3|3 - Total: 3'>        int[] bbits = new int[1];
</span>        double d2, ds, eps;
        boolean spec_case, denorm, k_check, try_quick, leftright;

<span class='uc' id='L492' title='2|2|2 - Total: 2'>        if ((word0(d) & Sign_bit) != 0) {
</span>            /* set sign for everything, including 0's and NaNs */
<span class='uc' id='L494' title='4|4|4 - Total: 4'>            sign[0] = true;
</span>            // word0(d) &= ~Sign_bit;  /* clear sign bit */
<span class='uc' id='L496' title='8|8|8 - Total: 8'>            d = setWord0(d, word0(d) & ~Sign_bit);
</span>        }
        else
<span class='uc' id='L499' title='4|4|4 - Total: 4'>            sign[0] = false;
</span>
<span class='upc' id='L501' title='1|1|1 - Total: 2'>        if ((word0(d) & Exp_mask) == Exp_mask) {
</span>            /* Infinity or NaN */
<span class='nc' id='L503' title='0|0|0 - Total: 4'>            buf.append(((word1(d) == 0) && ((word0(d) & Frac_mask) == 0)) ? "Infinity" : "NaN");
</span><span class='nc' id='L504' title='0|0|0 - Total: 2'>            return 9999;
</span>        }
<span class='upc' id='L506' title='1|1|1 - Total: 2'>        if (d == 0) {
</span>//          no_digits:
<span class='nc' id='L508' title='0|0|0 - Total: 3'>            buf.setLength(0);
</span><span class='nc' id='L509' title='0|0|0 - Total: 4'>            buf.append('0');        /* copy "0" to buffer */
</span><span class='nc' id='L510' title='0|0|0 - Total: 2'>            return 1;
</span>        }

<span class='uc' id='L513' title='5|5|5 - Total: 5'>        b = d2b(d, be, bbits);
</span><span class='upc' id='L514' title='1|1|1 - Total: 2'>        if ((i = (word0(d) >>> Exp_shift1 & (Exp_mask>>Exp_shift1))) != 0) {
</span><span class='uc' id='L515' title='9|9|9 - Total: 9'>            d2 = setWord0(d, (word0(d) & Frac_mask1) | Exp_11);
</span>            /* log(x)   ~=~ log(1.5) + (x-1.5)/1.5
             * log10(x)  =  log(x) / log(10)
             *      ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
             * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)
             *
             * This suggests computing an approximation k to log10(d) by
             *
             * k = (i - Bias)*0.301029995663981
             *  + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
             *
             * We want k to be too large rather than too small.
             * The error in the first-order Taylor series approximation
             * is in our favor, so we just round up the constant enough
             * to compensate for any error in the multiplication of
             * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,
             * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
             * adding 1e-13 to the constant term more than suffices.
             * Hence we adjust the constant term to 0.1760912590558.
             * (We could get a more accurate k by invoking log10,
             *  but this is probably not worthwhile.)
             */
<span class='uc' id='L537' title='1|1|1 - Total: 1'>            i -= Bias;
</span><span class='uc' id='L538' title='3|3|3 - Total: 3'>            denorm = false;
</span>        }
        else {
            /* d is denormalized */
<span class='nc' id='L542' title='0|0|0 - Total: 10'>            i = bbits[0] + be[0] + (Bias + (P-1) - 1);
</span><span class='nc' id='L543' title='0|0|0 - Total: 2'>            x = (i > 32)
</span><span class='nc' id='L544' title='0|0|0 - Total: 16'>                    ? ((long) word0(d)) << (64 - i) | word1(d) >>> (i - 32)
</span><span class='nc' id='L545' title='0|0|0 - Total: 7'>                    : ((long) word1(d)) << (32 - i);
</span>//            d2 = x;
//            word0(d2) -= 31*Exp_msk1; /* adjust exponent */
<span class='nc' id='L548' title='0|0|0 - Total: 9'>            d2 = setWord0(x, word0(x) - 31*Exp_msk1);
</span><span class='nc' id='L549' title='0|0|0 - Total: 1'>            i -= (Bias + (P-1) - 1) + 1;
</span><span class='nc' id='L550' title='0|0|0 - Total: 2'>            denorm = true;
</span>        }
        /* At this point d = f*2^i, where 1 <= f < 2.  d2 is an approximation of f. */
<span class='uc' id='L553' title='13|13|13 - Total: 13'>        ds = (d2-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;
</span><span class='uc' id='L554' title='3|3|3 - Total: 3'>        k = (int)ds;
</span><span class='upc' id='L555' title='3|3|3 - Total: 4'>        if (ds < 0.0 && ds != k)
</span><span class='uc' id='L556' title='1|1|1 - Total: 1'>            k--;    /* want k = floor(ds) */
</span><span class='uc' id='L557' title='2|2|2 - Total: 2'>        k_check = true;
</span><span class='uc' id='L558' title='4|4|4 - Total: 4'>        if (k >= 0 && k <= Ten_pmax) {
</span><span class='upc' id='L559' title='1|1|1 - Total: 2'>            if (d < tens[k])
</span><span class='nc' id='L560' title='0|0|0 - Total: 1'>                k--;
</span><span class='uc' id='L561' title='2|2|2 - Total: 2'>            k_check = false;
</span>        }
        /* At this point floor(log10(d)) <= k <= floor(log10(d))+1.
           If k_check is zero, we're guaranteed that k = floor(log10(d)). */
<span class='uc' id='L565' title='8|8|8 - Total: 8'>        j = bbits[0] - i - 1;
</span>        /* At this point d = b/2^j, where b is an odd integer. */
<span class='uc' id='L567' title='2|2|2 - Total: 2'>        if (j >= 0) {
</span><span class='uc' id='L568' title='2|2|2 - Total: 2'>            b2 = 0;
</span><span class='uc' id='L569' title='3|3|3 - Total: 3'>            s2 = j;
</span>        }
        else {
<span class='uc' id='L572' title='3|3|3 - Total: 3'>            b2 = -j;
</span><span class='uc' id='L573' title='2|2|2 - Total: 2'>            s2 = 0;
</span>        }
<span class='uc' id='L575' title='2|2|2 - Total: 2'>        if (k >= 0) {
</span><span class='uc' id='L576' title='2|2|2 - Total: 2'>            b5 = 0;
</span><span class='uc' id='L577' title='2|2|2 - Total: 2'>            s5 = k;
</span><span class='uc' id='L578' title='5|5|5 - Total: 5'>            s2 += k;
</span>        }
        else {
<span class='uc' id='L581' title='4|4|4 - Total: 4'>            b2 -= k;
</span><span class='uc' id='L582' title='3|3|3 - Total: 3'>            b5 = -k;
</span><span class='uc' id='L583' title='2|2|2 - Total: 2'>            s5 = 0;
</span>        }
        /* At this point d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5), where b is an odd integer,
           b2 >= 0, b5 >= 0, s2 >= 0, and s5 >= 0. */
<span class='upc' id='L587' title='2|2|2 - Total: 4'>        if (mode < 0 || mode > 9)
</span><span class='nc' id='L588' title='0|0|0 - Total: 2'>            mode = 0;
</span><span class='uc' id='L589' title='2|2|2 - Total: 2'>        try_quick = true;
</span><span class='upc' id='L590' title='1|1|1 - Total: 2'>        if (mode > 5) {
</span><span class='nc' id='L591' title='0|0|0 - Total: 1'>            mode -= 4;
</span><span class='nc' id='L592' title='0|0|0 - Total: 2'>            try_quick = false;
</span>        }
<span class='uc' id='L594' title='2|2|2 - Total: 2'>        leftright = true;
</span><span class='uc' id='L595' title='4|4|4 - Total: 4'>        ilim = ilim1 = 0;
</span><span class='upc' id='L596' title='3|3|3 - Total: 6'>        switch(mode) {
</span>            case 0:
            case 1:
<span class='uc' id='L599' title='4|4|4 - Total: 4'>                ilim = ilim1 = -1;
</span><span class='uc' id='L600' title='2|2|2 - Total: 2'>                i = 18;
</span><span class='uc' id='L601' title='2|2|2 - Total: 2'>                ndigits = 0;
</span><span class='uc' id='L602' title='1|1|1 - Total: 1'>                break;
</span>            case 2:
<span class='uc' id='L604' title='2|2|2 - Total: 2'>                leftright = false;
</span>                /* fallthru */
            case 4:
<span class='upc' id='L607' title='1|1|1 - Total: 2'>                if (ndigits <= 0)
</span><span class='nc' id='L608' title='0|0|0 - Total: 2'>                    ndigits = 1;
</span><span class='uc' id='L609' title='6|6|6 - Total: 6'>                ilim = ilim1 = i = ndigits;
</span><span class='uc' id='L610' title='1|1|1 - Total: 1'>                break;
</span>            case 3:
<span class='uc' id='L612' title='2|2|2 - Total: 2'>                leftright = false;
</span>                /* fallthru */
            case 5:
<span class='uc' id='L615' title='6|6|6 - Total: 6'>                i = ndigits + k + 1;
</span><span class='uc' id='L616' title='2|2|2 - Total: 2'>                ilim = i;
</span><span class='uc' id='L617' title='4|4|4 - Total: 4'>                ilim1 = i - 1;
</span><span class='uc' id='L618' title='2|2|2 - Total: 2'>                if (i <= 0)
</span><span class='uc' id='L619' title='2|2|2 - Total: 2'>                    i = 1;
</span>        }
        /* ilim is the maximum number of significant digits we want, based on k and ndigits. */
        /* ilim1 is the maximum number of significant digits we want, based on k and ndigits,
           when it turns out that k was computed too high by one. */

<span class='uc' id='L625' title='2|2|2 - Total: 2'>        boolean fast_failed = false;
</span><span class='upc' id='L626' title='5|5|5 - Total: 6'>        if (ilim >= 0 && ilim <= Quick_max && try_quick) {
</span>
            /* Try to get by with floating-point arithmetic. */

<span class='uc' id='L630' title='2|2|2 - Total: 2'>            i = 0;
</span><span class='uc' id='L631' title='2|2|2 - Total: 2'>            d2 = d;
</span><span class='uc' id='L632' title='2|2|2 - Total: 2'>            k0 = k;
</span><span class='uc' id='L633' title='2|2|2 - Total: 2'>            ilim0 = ilim;
</span><span class='uc' id='L634' title='2|2|2 - Total: 2'>            ieps = 2; /* conservative */
</span>            /* Divide d by 10^k, keeping track of the roundoff error and avoiding overflows. */
<span class='uc' id='L636' title='2|2|2 - Total: 2'>            if (k > 0) {
</span><span class='uc' id='L637' title='6|6|6 - Total: 6'>                ds = tens[k&0xf];
</span><span class='uc' id='L638' title='4|4|4 - Total: 4'>                j = k >> 4;
</span><span class='upc' id='L639' title='1|1|1 - Total: 2'>                if ((j & Bletch) != 0) {
</span>                    /* prevent overflows */
<span class='nc' id='L641' title='0|0|0 - Total: 4'>                    j &= Bletch - 1;
</span><span class='nc' id='L642' title='0|0|0 - Total: 6'>                    d /= bigtens[n_bigtens-1];
</span><span class='nc' id='L643' title='0|0|0 - Total: 1'>                    ieps++;
</span>                }
<span class='upc' id='L645' title='1|1|1 - Total: 2'>                for(; (j != 0); j >>= 1, i++)
</span><span class='nc' id='L646' title='0|0|0 - Total: 2'>                    if ((j & 1) != 0) {
</span><span class='nc' id='L647' title='0|0|0 - Total: 1'>                        ieps++;
</span><span class='nc' id='L648' title='0|0|0 - Total: 6'>                        ds *= bigtens[i];
</span>                    }
<span class='uc' id='L650' title='5|5|5 - Total: 5'>                d /= ds;
</span>            }
<span class='uc' id='L652' title='2|2|2 - Total: 2'>            else if ((j1 = -k) != 0) {
</span><span class='uc' id='L653' title='8|8|8 - Total: 8'>                d *= tens[j1 & 0xf];
</span><span class='uc' id='L654' title='2|2|2 - Total: 2'>                for(j = j1 >> 4; (j != 0); j >>= 1, i++)
</span><span class='upc' id='L655' title='1|1|1 - Total: 2'>                    if ((j & 1) != 0) {
</span><span class='uc' id='L656' title='1|1|1 - Total: 1'>                        ieps++;
</span><span class='uc' id='L657' title='6|6|6 - Total: 6'>                        d *= bigtens[i];
</span>                    }
            }
            /* Check that k was computed correctly. */
<span class='upc' id='L661' title='5|5|5 - Total: 6'>            if (k_check && d < 1.0 && ilim > 0) {
</span><span class='nc' id='L662' title='0|0|0 - Total: 2'>                if (ilim1 <= 0)
</span><span class='nc' id='L663' title='0|0|0 - Total: 3'>                    fast_failed = true;
</span>                else {
<span class='nc' id='L665' title='0|0|0 - Total: 2'>                    ilim = ilim1;
</span><span class='nc' id='L666' title='0|0|0 - Total: 1'>                    k--;
</span><span class='nc' id='L667' title='0|0|0 - Total: 4'>                    d *= 10.;
</span><span class='nc' id='L668' title='0|0|0 - Total: 1'>                    ieps++;
</span>                }
            }
            /* eps bounds the cumulative error. */
//            eps = ieps*d + 7.0;
//            word0(eps) -= (P-1)*Exp_msk1;
<span class='uc' id='L674' title='7|7|7 - Total: 7'>            eps = ieps*d + 7.0;
</span><span class='uc' id='L675' title='7|7|7 - Total: 7'>            eps = setWord0(eps, word0(eps) - (P-1)*Exp_msk1);
</span><span class='uc' id='L676' title='2|2|2 - Total: 2'>            if (ilim == 0) {
</span><span class='uc' id='L677' title='4|4|4 - Total: 4'>                S = mhi = null;
</span><span class='uc' id='L678' title='4|4|4 - Total: 4'>                d -= 5.0;
</span><span class='upc' id='L679' title='1|1|1 - Total: 2'>                if (d > eps) {
</span><span class='nc' id='L680' title='0|0|0 - Total: 4'>                    buf.append('1');
</span><span class='nc' id='L681' title='0|0|0 - Total: 1'>                    k++;
</span><span class='nc' id='L682' title='0|0|0 - Total: 4'>                    return k + 1;
</span>                }
<span class='uc' id='L684' title='2|2|2 - Total: 2'>                if (d < -eps) {
</span><span class='uc' id='L685' title='3|3|3 - Total: 3'>                    buf.setLength(0);
</span><span class='uc' id='L686' title='4|4|4 - Total: 4'>                    buf.append('0');        /* copy "0" to buffer */
</span><span class='uc' id='L687' title='2|2|2 - Total: 2'>                    return 1;
</span>                }
<span class='uc' id='L689' title='2|2|2 - Total: 2'>                fast_failed = true;
</span>            }
<span class='uc' id='L691' title='2|2|2 - Total: 2'>            if (!fast_failed) {
</span><span class='uc' id='L692' title='2|2|2 - Total: 2'>                fast_failed = true;
</span><span class='upc' id='L693' title='1|1|1 - Total: 2'>                if (leftright) {
</span>                    /* Use Steele & White method of only
                     * generating digits needed.
                     */
<span class='nc' id='L697' title='0|0|0 - Total: 10'>                    eps = 0.5/tens[ilim-1] - eps;
</span><span class='nc' id='L698' title='0|0|0 - Total: 2'>                    for(i = 0;;) {
</span><span class='nc' id='L699' title='0|0|0 - Total: 3'>                        L = (long)d;
</span><span class='nc' id='L700' title='0|0|0 - Total: 5'>                        d -= L;
</span><span class='nc' id='L701' title='0|0|0 - Total: 8'>                        buf.append((char)('0' + L));
</span><span class='nc' id='L702' title='0|0|0 - Total: 2'>                        if (d < eps) {
</span><span class='nc' id='L703' title='0|0|0 - Total: 4'>                            return k + 1;
</span>                        }
<span class='nc' id='L705' title='0|0|0 - Total: 2'>                        if (1.0 - d < eps) {
</span>//                            goto bump_up;
                                char lastCh;
                                while (true) {
<span class='nc' id='L709' title='0|0|0 - Total: 7'>                                    lastCh = buf.charAt(buf.length() - 1);
</span><span class='nc' id='L710' title='0|0|0 - Total: 6'>                                    buf.setLength(buf.length() - 1);
</span><span class='nc' id='L711' title='0|0|0 - Total: 2'>                                    if (lastCh != '9') break;
</span><span class='nc' id='L712' title='0|0|0 - Total: 2'>                                    if (buf.length() == 0) {
</span><span class='nc' id='L713' title='0|0|0 - Total: 1'>                                        k++;
</span><span class='nc' id='L714' title='0|0|0 - Total: 2'>                                        lastCh = '0';
</span><span class='nc' id='L715' title='0|0|0 - Total: 1'>                                        break;
</span>                                    }
                                }
<span class='nc' id='L718' title='0|0|0 - Total: 7'>                                buf.append((char)(lastCh + 1));
</span><span class='nc' id='L719' title='0|0|0 - Total: 4'>                                return k + 1;
</span>                        }
<span class='nc' id='L721' title='0|0|0 - Total: 2'>                        if (++i >= ilim)
</span><span class='nc' id='L722' title='0|0|0 - Total: 1'>                            break;
</span><span class='nc' id='L723' title='0|0|0 - Total: 4'>                        eps *= 10.0;
</span><span class='nc' id='L724' title='0|0|0 - Total: 5'>                        d *= 10.0;
</span>                    }
                }
                else {
                    /* Generate ilim digits, then fix them up. */
<span class='uc' id='L729' title='8|8|8 - Total: 8'>                    eps *= tens[ilim-1];
</span><span class='uc' id='L730' title='8|8|8 - Total: 8'>                    for(i = 1;; i++, d *= 10.0) {
</span><span class='uc' id='L731' title='3|3|3 - Total: 3'>                        L = (long)d;
</span><span class='uc' id='L732' title='5|5|5 - Total: 5'>                        d -= L;
</span><span class='uc' id='L733' title='8|8|8 - Total: 8'>                        buf.append((char)('0' + L));
</span><span class='uc' id='L734' title='2|2|2 - Total: 2'>                        if (i == ilim) {
</span><span class='uc' id='L735' title='2|2|2 - Total: 2'>                            if (d > 0.5 + eps) {
</span>//                                goto bump_up;
                                char lastCh;
                                while (true) {
<span class='uc' id='L739' title='7|7|7 - Total: 7'>                                    lastCh = buf.charAt(buf.length() - 1);
</span><span class='uc' id='L740' title='6|6|6 - Total: 6'>                                    buf.setLength(buf.length() - 1);
</span><span class='upc' id='L741' title='1|1|1 - Total: 2'>                                    if (lastCh != '9') break;
</span><span class='nc' id='L742' title='0|0|0 - Total: 2'>                                    if (buf.length() == 0) {
</span><span class='nc' id='L743' title='0|0|0 - Total: 1'>                                        k++;
</span><span class='nc' id='L744' title='0|0|0 - Total: 2'>                                        lastCh = '0';
</span><span class='nc' id='L745' title='0|0|0 - Total: 1'>                                        break;
</span>                                    }
                                }
<span class='uc' id='L748' title='7|7|7 - Total: 7'>                                buf.append((char)(lastCh + 1));
</span><span class='uc' id='L749' title='4|4|4 - Total: 4'>                                return k + 1;
</span>                            }
                            else
<span class='upc' id='L752' title='1|1|1 - Total: 2'>                                if (d < 0.5 - eps) {
</span><span class='uc' id='L753' title='2|2|2 - Total: 2'>                                    stripTrailingZeroes(buf);
</span>//                                    while(*--s == '0') ;
//                                    s++;
<span class='uc' id='L756' title='4|4|4 - Total: 4'>                                    return k + 1;
</span>                                }
                            break;
                        }
                    }
                }
            }
<span class='upc' id='L763' title='1|1|1 - Total: 2'>            if (fast_failed) {
</span><span class='uc' id='L764' title='3|3|3 - Total: 3'>                buf.setLength(0);
</span><span class='uc' id='L765' title='2|2|2 - Total: 2'>                d = d2;
</span><span class='uc' id='L766' title='2|2|2 - Total: 2'>                k = k0;
</span><span class='uc' id='L767' title='2|2|2 - Total: 2'>                ilim = ilim0;
</span>            }
        }

        /* Do we have a "small" integer? */

<span class='uc' id='L773' title='4|4|4 - Total: 4'>        if (be[0] >= 0 && k <= Int_max) {
</span>            /* Yes. */
<span class='uc' id='L775' title='4|4|4 - Total: 4'>            ds = tens[k];
</span><span class='upc' id='L776' title='1|1|1 - Total: 4'>            if (ndigits < 0 && ilim <= 0) {
</span><span class='nc' id='L777' title='0|0|0 - Total: 4'>                S = mhi = null;
</span><span class='nc' id='L778' title='0|0|0 - Total: 8'>                if (ilim < 0 || d < 5*ds || (!biasUp && d == 5*ds)) {
</span><span class='nc' id='L779' title='0|0|0 - Total: 3'>                    buf.setLength(0);
</span><span class='nc' id='L780' title='0|0|0 - Total: 4'>                    buf.append('0');        /* copy "0" to buffer */
</span><span class='nc' id='L781' title='0|0|0 - Total: 2'>                    return 1;
</span>                }
<span class='nc' id='L783' title='0|0|0 - Total: 4'>                buf.append('1');
</span><span class='nc' id='L784' title='0|0|0 - Total: 1'>                k++;
</span><span class='nc' id='L785' title='0|0|0 - Total: 4'>                return k + 1;
</span>            }
<span class='upc' id='L787' title='2|2|2 - Total: 4'>            for(i = 1;; i++) {
</span><span class='uc' id='L788' title='5|5|5 - Total: 5'>                L = (long) (d / ds);
</span><span class='uc' id='L789' title='7|7|7 - Total: 7'>                d -= L*ds;
</span><span class='uc' id='L790' title='8|8|8 - Total: 8'>                buf.append((char)('0' + L));
</span><span class='upc' id='L791' title='1|1|1 - Total: 2'>                if (i == ilim) {
</span><span class='nc' id='L792' title='0|0|0 - Total: 4'>                    d += d;
</span><span class='nc' id='L793' title='0|0|0 - Total: 8'>                    if ((d > ds) || (d == ds && (((L & 1) != 0) || biasUp))) {
</span>//                    bump_up:
//                        while(*--s == '9')
//                            if (s == buf) {
//                                k++;
//                                *s = '0';
//                                break;
//                            }
//                        ++*s++;
                        char lastCh;
                        while (true) {
<span class='nc' id='L804' title='0|0|0 - Total: 7'>                            lastCh = buf.charAt(buf.length() - 1);
</span><span class='nc' id='L805' title='0|0|0 - Total: 6'>                            buf.setLength(buf.length() - 1);
</span><span class='nc' id='L806' title='0|0|0 - Total: 2'>                            if (lastCh != '9') break;
</span><span class='nc' id='L807' title='0|0|0 - Total: 2'>                            if (buf.length() == 0) {
</span><span class='nc' id='L808' title='0|0|0 - Total: 1'>                                k++;
</span><span class='nc' id='L809' title='0|0|0 - Total: 2'>                                lastCh = '0';
</span><span class='nc' id='L810' title='0|0|0 - Total: 1'>                                break;
</span>                            }
                        }
<span class='nc' id='L813' title='0|0|0 - Total: 7'>                        buf.append((char)(lastCh + 1));
</span><span class='nc' id='L814' title='0|0|0 - Total: 1'>                    }
</span>                    break;
                }
<span class='uc' id='L817' title='4|4|4 - Total: 4'>                d *= 10.0;
</span><span class='upc' id='L818' title='1|1|1 - Total: 2'>                if (d == 0)
</span><span class='uc' id='L819' title='1|1|1 - Total: 1'>                    break;
</span>            }
<span class='uc' id='L821' title='4|4|4 - Total: 4'>            return k + 1;
</span>        }

<span class='uc' id='L824' title='2|2|2 - Total: 2'>        m2 = b2;
</span><span class='uc' id='L825' title='2|2|2 - Total: 2'>        m5 = b5;
</span><span class='uc' id='L826' title='4|4|4 - Total: 4'>        mhi = mlo = null;
</span><span class='uc' id='L827' title='2|2|2 - Total: 2'>        if (leftright) {
</span><span class='upc' id='L828' title='1|1|1 - Total: 2'>            if (mode < 2) {
</span><span class='upc' id='L829' title='1|1|1 - Total: 2'>                i = (denorm) ? be[0] + (Bias + (P-1) - 1 + 1) : 1 + P - bbits[0];
</span>                /* i is 1 plus the number of trailing zero bits in d's significand. Thus,
                   (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 lsb of d)/10^k. */
            }
            else {
<span class='nc' id='L834' title='0|0|0 - Total: 4'>                j = ilim - 1;
</span><span class='nc' id='L835' title='0|0|0 - Total: 2'>                if (m5 >= j)
</span><span class='nc' id='L836' title='0|0|0 - Total: 5'>                    m5 -= j;
</span>                else {
<span class='nc' id='L838' title='0|0|0 - Total: 8'>                    s5 += j -= m5;
</span><span class='nc' id='L839' title='0|0|0 - Total: 4'>                    b5 += j;
</span><span class='nc' id='L840' title='0|0|0 - Total: 2'>                    m5 = 0;
</span>                }
<span class='nc' id='L842' title='0|0|0 - Total: 2'>                if ((i = ilim) < 0) {
</span><span class='nc' id='L843' title='0|0|0 - Total: 4'>                    m2 -= i;
</span><span class='nc' id='L844' title='0|0|0 - Total: 2'>                    i = 0;
</span>                }
                /* (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 * 10^(1-ilim))/10^k. */
            }
<span class='uc' id='L848' title='4|4|4 - Total: 4'>            b2 += i;
</span><span class='uc' id='L849' title='4|4|4 - Total: 4'>            s2 += i;
</span><span class='uc' id='L850' title='3|3|3 - Total: 3'>            mhi = BigInteger.valueOf(1);
</span>            /* (mhi * 2^m2 * 5^m5) / (2^s2 * 5^s5) = one-half of last printed (when mode >= 2) or
               input (when mode < 2) significant digit, divided by 10^k. */
        }
        /* We still have d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5).  Reduce common factors in
           b2, m2, and s2 without changing the equalities. */
<span class='upc' id='L856' title='2|2|2 - Total: 4'>        if (m2 > 0 && s2 > 0) {
</span><span class='uc' id='L857' title='2|2|2 - Total: 2'>            i = (m2 < s2) ? m2 : s2;
</span><span class='uc' id='L858' title='4|4|4 - Total: 4'>            b2 -= i;
</span><span class='uc' id='L859' title='4|4|4 - Total: 4'>            m2 -= i;
</span><span class='uc' id='L860' title='4|4|4 - Total: 4'>            s2 -= i;
</span>        }

        /* Fold b5 into b and m5 into mhi. */
<span class='uc' id='L864' title='2|2|2 - Total: 2'>        if (b5 > 0) {
</span><span class='uc' id='L865' title='2|2|2 - Total: 2'>            if (leftright) {
</span><span class='upc' id='L866' title='1|1|1 - Total: 2'>                if (m5 > 0) {
</span><span class='uc' id='L867' title='4|4|4 - Total: 4'>                    mhi = pow5mult(mhi, m5);
</span><span class='uc' id='L868' title='4|4|4 - Total: 4'>                    b1 = mhi.multiply(b);
</span><span class='uc' id='L869' title='2|2|2 - Total: 2'>                    b = b1;
</span>                }
<span class='upc' id='L871' title='1|1|1 - Total: 2'>                if ((j = b5 - m5) != 0)
</span><span class='nc' id='L872' title='0|0|0 - Total: 5'>                    b = pow5mult(b, j);
</span>            }
            else
<span class='uc' id='L875' title='4|4|4 - Total: 4'>                b = pow5mult(b, b5);
</span>        }
        /* Now we have d/10^k = (b * 2^b2) / (2^s2 * 5^s5) and
           (mhi * 2^m2) / (2^s2 * 5^s5) = one-half of last printed or input significant digit, divided by 10^k. */

<span class='uc' id='L880' title='3|3|3 - Total: 3'>        S = BigInteger.valueOf(1);
</span><span class='uc' id='L881' title='2|2|2 - Total: 2'>        if (s5 > 0)
</span><span class='uc' id='L882' title='4|4|4 - Total: 4'>            S = pow5mult(S, s5);
</span>        /* Now we have d/10^k = (b * 2^b2) / (S * 2^s2) and
           (mhi * 2^m2) / (S * 2^s2) = one-half of last printed or input significant digit, divided by 10^k. */

        /* Check for special case that d is a normalized power of 2. */
<span class='uc' id='L887' title='2|2|2 - Total: 2'>        spec_case = false;
</span><span class='uc' id='L888' title='2|2|2 - Total: 2'>        if (mode < 2) {
</span><span class='upc' id='L889' title='1|1|1 - Total: 4'>            if ( (word1(d) == 0) && ((word0(d) & Bndry_mask) == 0)
</span><span class='nc' id='L890' title='0|0|0 - Total: 2'>                && ((word0(d) & (Exp_mask & Exp_mask << 1)) != 0)
</span>                ) {
                /* The special case.  Here we want to be within a quarter of the last input
                   significant digit instead of one half of it when the decimal output string's value is less than d.  */
<span class='nc' id='L894' title='0|0|0 - Total: 1'>                b2 += Log2P;
</span><span class='nc' id='L895' title='0|0|0 - Total: 1'>                s2 += Log2P;
</span><span class='nc' id='L896' title='0|0|0 - Total: 2'>                spec_case = true;
</span>            }
        }

        /* Arrange for convenient computation of quotients:
         * shift left if necessary so divisor has 4 leading 0 bits.
         *
         * Perhaps we should just compute leading 28 bits of S once
         * and for all and pass them and a shift to quorem, so it
         * can do shifts and ors to compute the numerator for q.
         */
<span class='uc' id='L907' title='3|3|3 - Total: 3'>        byte [] S_bytes = S.toByteArray();
</span><span class='uc' id='L908' title='2|2|2 - Total: 2'>        int S_hiWord = 0;
</span><span class='uc' id='L909' title='2|2|2 - Total: 2'>        for (int idx = 0; idx < 4; idx++) {
</span><span class='uc' id='L910' title='4|4|4 - Total: 4'>            S_hiWord = (S_hiWord << 8);
</span><span class='uc' id='L911' title='2|2|2 - Total: 2'>            if (idx < S_bytes.length)
</span><span class='uc' id='L912' title='8|8|8 - Total: 8'>                S_hiWord |= (S_bytes[idx] & 0xFF);
</span>        }
<span class='upc' id='L914' title='3|3|3 - Total: 4'>        if ((i = (((s5 != 0) ? 32 - hi0bits(S_hiWord) : 1) + s2) & 0x1f) != 0)
</span><span class='uc' id='L915' title='4|4|4 - Total: 4'>            i = 32 - i;
</span>        /* i is the number of leading zero bits in the most significant word of S*2^s2. */
<span class='uc' id='L917' title='2|2|2 - Total: 2'>        if (i > 4) {
</span><span class='uc' id='L918' title='1|1|1 - Total: 1'>            i -= 4;
</span><span class='uc' id='L919' title='4|4|4 - Total: 4'>            b2 += i;
</span><span class='uc' id='L920' title='4|4|4 - Total: 4'>            m2 += i;
</span><span class='uc' id='L921' title='5|5|5 - Total: 5'>            s2 += i;
</span>        }
<span class='uc' id='L923' title='2|2|2 - Total: 2'>        else if (i < 4) {
</span><span class='uc' id='L924' title='1|1|1 - Total: 1'>            i += 28;
</span><span class='uc' id='L925' title='4|4|4 - Total: 4'>            b2 += i;
</span><span class='uc' id='L926' title='4|4|4 - Total: 4'>            m2 += i;
</span><span class='uc' id='L927' title='4|4|4 - Total: 4'>            s2 += i;
</span>        }
        /* Now S*2^s2 has exactly four leading zero bits in its most significant word. */
<span class='upc' id='L930' title='1|1|1 - Total: 2'>        if (b2 > 0)
</span><span class='uc' id='L931' title='4|4|4 - Total: 4'>            b = b.shiftLeft(b2);
</span><span class='uc' id='L932' title='2|2|2 - Total: 2'>        if (s2 > 0)
</span><span class='uc' id='L933' title='4|4|4 - Total: 4'>            S = S.shiftLeft(s2);
</span>        /* Now we have d/10^k = b/S and
           (mhi * 2^m2) / S = maximum acceptable error, divided by 10^k. */
<span class='uc' id='L936' title='2|2|2 - Total: 2'>        if (k_check) {
</span><span class='uc' id='L937' title='2|2|2 - Total: 2'>            if (b.compareTo(S) < 0) {
</span><span class='uc' id='L938' title='1|1|1 - Total: 1'>                k--;
</span><span class='uc' id='L939' title='5|5|5 - Total: 5'>                b = b.multiply(BigInteger.valueOf(10));  /* we botched the k estimate */
</span><span class='upc' id='L940' title='1|1|1 - Total: 2'>                if (leftright)
</span><span class='uc' id='L941' title='5|5|5 - Total: 5'>                    mhi = mhi.multiply(BigInteger.valueOf(10));
</span><span class='uc' id='L942' title='2|2|2 - Total: 2'>                ilim = ilim1;
</span>            }
        }
        /* At this point 1 <= d/10^k = b/S < 10. */

<span class='uc' id='L947' title='4|4|4 - Total: 4'>        if (ilim <= 0 && mode > 2) {
</span>            /* We're doing fixed-mode output and d is less than the minimum nonzero output in this mode.
               Output either zero or the minimum nonzero output depending on which is closer to d. */
<span class='uc' id='L950' title='2|2|2 - Total: 2'>            if ((ilim < 0 )
</span><span class='upc' id='L951' title='3|3|3 - Total: 6'>                    || ((i = b.compareTo(S = S.multiply(BigInteger.valueOf(5)))) < 0)
</span>                    || ((i == 0 && !biasUp))) {
            /* Always emit at least one digit.  If the number appears to be zero
               using the current mode, then emit one '0' digit and set decpt to 1. */
            /*no_digits:
                k = -1 - ndigits;
                goto ret; */
<span class='uc' id='L958' title='3|3|3 - Total: 3'>                buf.setLength(0);
</span><span class='uc' id='L959' title='4|4|4 - Total: 4'>                buf.append('0');        /* copy "0" to buffer */
</span><span class='uc' id='L960' title='2|2|2 - Total: 2'>                return 1;
</span>//                goto no_digits;
            }
//        one_digit:
<span class='uc' id='L964' title='4|4|4 - Total: 4'>            buf.append('1');
</span><span class='uc' id='L965' title='1|1|1 - Total: 1'>            k++;
</span><span class='uc' id='L966' title='4|4|4 - Total: 4'>            return k + 1;
</span>        }
<span class='uc' id='L968' title='2|2|2 - Total: 2'>        if (leftright) {
</span><span class='uc' id='L969' title='2|2|2 - Total: 2'>            if (m2 > 0)
</span><span class='uc' id='L970' title='4|4|4 - Total: 4'>                mhi = mhi.shiftLeft(m2);
</span>
            /* Compute mlo -- check for special case
             * that d is a normalized power of 2.
             */

<span class='uc' id='L976' title='2|2|2 - Total: 2'>            mlo = mhi;
</span><span class='upc' id='L977' title='1|1|1 - Total: 2'>            if (spec_case) {
</span><span class='nc' id='L978' title='0|0|0 - Total: 2'>                mhi = mlo;
</span><span class='nc' id='L979' title='0|0|0 - Total: 4'>                mhi = mhi.shiftLeft(Log2P);
</span>            }
            /* mlo/S = maximum acceptable error, divided by 10^k, if the output is less than d. */
            /* mhi/S = maximum acceptable error, divided by 10^k, if the output is greater than d. */

<span class='uc' id='L984' title='4|4|4 - Total: 4'>            for(i = 1;;i++) {
</span><span class='uc' id='L985' title='4|4|4 - Total: 4'>                BigInteger[] divResult = b.divideAndRemainder(S);
</span><span class='uc' id='L986' title='4|4|4 - Total: 4'>                b = divResult[1];
</span><span class='uc' id='L987' title='8|8|8 - Total: 8'>                dig = (char)(divResult[0].intValue() + '0');
</span>                /* Do we yet have the shortest decimal string
                 * that will round to d?
                 */
<span class='uc' id='L991' title='4|4|4 - Total: 4'>                j = b.compareTo(mlo);
</span>                /* j is b/S compared with mlo/S. */
<span class='uc' id='L993' title='4|4|4 - Total: 4'>                delta = S.subtract(mhi);
</span><span class='upc' id='L994' title='1|1|1 - Total: 2'>                j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);
</span>                /* j1 is b/S compared with 1 - mhi/S. */
<span class='upc' id='L996' title='4|4|4 - Total: 6'>                if ((j1 == 0) && (mode == 0) && ((word1(d) & 1) == 0)) {
</span><span class='uc' id='L997' title='2|2|2 - Total: 2'>                    if (dig == '9') {
</span><span class='uc' id='L998' title='4|4|4 - Total: 4'>                        buf.append('9');
</span><span class='upc' id='L999' title='1|1|1 - Total: 2'>                        if (roundOff(buf)) {
</span><span class='uc' id='L1000' title='1|1|1 - Total: 1'>                            k++;
</span><span class='uc' id='L1001' title='4|4|4 - Total: 4'>                            buf.append('1');
</span>                        }
<span class='uc' id='L1003' title='4|4|4 - Total: 4'>                        return k + 1;
</span>//                        goto round_9_up;
                    }
<span class='upc' id='L1006' title='1|1|1 - Total: 2'>                    if (j > 0)
</span><span class='uc' id='L1007' title='5|5|5 - Total: 5'>                        dig++;
</span><span class='uc' id='L1008' title='4|4|4 - Total: 4'>                    buf.append(dig);
</span><span class='uc' id='L1009' title='4|4|4 - Total: 4'>                    return k + 1;
</span>                }
<span class='upc' id='L1011' title='5|5|5 - Total: 6'>                if ((j < 0)
</span>                        || ((j == 0)
                            && (mode == 0)
<span class='upc' id='L1014' title='1|1|1 - Total: 2'>                            && ((word1(d) & 1) == 0)
</span>                    )) {
<span class='uc' id='L1016' title='1|2|2 - Total: 2'>                    if (j1 > 0) {
</span>                        /* Either dig or dig+1 would work here as the least significant decimal digit.
                           Use whichever would produce a decimal value closer to d. */
<span class='bc' id='L1019' title='0|4|4 - Total: 4'>                        b = b.shiftLeft(1);
</span><span class='bc' id='L1020' title='0|4|4 - Total: 4'>                        j1 = b.compareTo(S);
</span><span class='bpc' id='L1021' title='0|2|2 - Total: 10'>                        if (((j1 > 0) || (j1 == 0 && (((dig & 1) == 1) || biasUp)))
</span>                            && (dig++ == '9')) {
<span class='nc' id='L1023' title='0|0|0 - Total: 4'>                                buf.append('9');
</span><span class='nc' id='L1024' title='0|0|0 - Total: 2'>                                if (roundOff(buf)) {
</span><span class='nc' id='L1025' title='0|0|0 - Total: 1'>                                    k++;
</span><span class='nc' id='L1026' title='0|0|0 - Total: 4'>                                    buf.append('1');
</span>                                }
<span class='nc' id='L1028' title='0|0|0 - Total: 4'>                                return k + 1;
</span>//                                goto round_9_up;
                        }
                    }
<span class='uc' id='L1032' title='4|4|4 - Total: 4'>                    buf.append(dig);
</span><span class='uc' id='L1033' title='4|4|4 - Total: 4'>                    return k + 1;
</span>                }
<span class='uc' id='L1035' title='2|2|2 - Total: 2'>                if (j1 > 0) {
</span><span class='uc' id='L1036' title='2|2|2 - Total: 2'>                    if (dig == '9') { /* possible if i == 1 */
</span>//                    round_9_up:
//                        *s++ = '9';
//                        goto roundoff;
<span class='uc' id='L1040' title='4|4|4 - Total: 4'>                        buf.append('9');
</span><span class='upc' id='L1041' title='1|1|1 - Total: 2'>                        if (roundOff(buf)) {
</span><span class='uc' id='L1042' title='1|1|1 - Total: 1'>                            k++;
</span><span class='uc' id='L1043' title='4|4|4 - Total: 4'>                            buf.append('1');
</span>                        }
<span class='uc' id='L1045' title='4|4|4 - Total: 4'>                        return k + 1;
</span>                    }
<span class='uc' id='L1047' title='7|7|7 - Total: 7'>                    buf.append((char)(dig + 1));
</span><span class='uc' id='L1048' title='4|4|4 - Total: 4'>                    return k + 1;
</span>                }
<span class='uc' id='L1050' title='4|4|4 - Total: 4'>                buf.append(dig);
</span><span class='upc' id='L1051' title='1|1|1 - Total: 2'>                if (i == ilim)
</span><span class='nc' id='L1052' title='0|0|0 - Total: 1'>                    break;
</span><span class='uc' id='L1053' title='5|5|5 - Total: 5'>                b = b.multiply(BigInteger.valueOf(10));
</span><span class='upc' id='L1054' title='1|1|1 - Total: 2'>                if (mlo == mhi)
</span><span class='uc' id='L1055' title='8|8|8 - Total: 8'>                    mlo = mhi = mhi.multiply(BigInteger.valueOf(10));
</span>                else {
<span class='nc' id='L1057' title='0|0|0 - Total: 5'>                    mlo = mlo.multiply(BigInteger.valueOf(10));
</span><span class='nc' id='L1058' title='0|0|0 - Total: 5'>                    mhi = mhi.multiply(BigInteger.valueOf(10));
</span>                }
            }
        }
        else
<span class='uc' id='L1063' title='4|4|4 - Total: 4'>            for(i = 1;; i++) {
</span>//                (char)(dig = quorem(b,S) + '0');
<span class='uc' id='L1065' title='4|4|4 - Total: 4'>                BigInteger[] divResult = b.divideAndRemainder(S);
</span><span class='uc' id='L1066' title='4|4|4 - Total: 4'>                b = divResult[1];
</span><span class='uc' id='L1067' title='8|8|8 - Total: 8'>                dig = (char)(divResult[0].intValue() + '0');
</span><span class='uc' id='L1068' title='4|4|4 - Total: 4'>                buf.append(dig);
</span><span class='uc' id='L1069' title='2|2|2 - Total: 2'>                if (i >= ilim)
</span><span class='uc' id='L1070' title='1|1|1 - Total: 1'>                    break;
</span><span class='uc' id='L1071' title='5|5|5 - Total: 5'>                b = b.multiply(BigInteger.valueOf(10));
</span>            }

        /* Round off last digit */

<span class='uc' id='L1076' title='4|4|4 - Total: 4'>        b = b.shiftLeft(1);
</span><span class='uc' id='L1077' title='4|4|4 - Total: 4'>        j = b.compareTo(S);
</span><span class='upc' id='L1078' title='1|1|1 - Total: 8'>        if ((j > 0) || (j == 0 && (((dig & 1) == 1) || biasUp))) {
</span>//        roundoff:
//            while(*--s == '9')
//                if (s == buf) {
//                    k++;
//                    *s++ = '1';
//                    goto ret;
//                }
//            ++*s++;
<span class='upc' id='L1087' title='1|1|1 - Total: 2'>            if (roundOff(buf)) {
</span><span class='nc' id='L1088' title='0|0|0 - Total: 1'>                k++;
</span><span class='nc' id='L1089' title='0|0|0 - Total: 4'>                buf.append('1');
</span><span class='nc' id='L1090' title='0|0|0 - Total: 4'>                return k + 1;
</span>            }
        }
        else {
<span class='nc' id='L1094' title='0|0|0 - Total: 2'>            stripTrailingZeroes(buf);
</span>//            while(*--s == '0') ;
//            s++;
        }
//      ret:
//        Bfree(S);
//        if (mhi) {
//            if (mlo && mlo != mhi)
//                Bfree(mlo);
//            Bfree(mhi);
//        }
//      ret1:
//        Bfree(b);
//        JS_ASSERT(s < buf + bufsize);
<span class='uc' id='L1108' title='4|4|4 - Total: 4'>        return k + 1;
</span>    }

    private static void
    stripTrailingZeroes(StringBuilder buf)
    {
//      while(*--s == '0') ;
//      s++;
<span class='uc' id='L1116' title='3|3|3 - Total: 3'>        int bl = buf.length();
</span><span class='upc' id='L1117' title='2|2|2 - Total: 4'>        while(bl-->0 && buf.charAt(bl) == '0') {
</span>          // empty
        }
<span class='uc' id='L1120' title='5|5|5 - Total: 5'>        buf.setLength(bl + 1);
</span><span class='uc' id='L1121' title='1|1|1 - Total: 1'>    }
</span>
    /* Mapping of JSDToStrMode -> JS_dtoa mode */
<span class='uc' id='L1124' title='24|24|24 - Total: 24'>    private static final int dtoaModes[] = {
</span>        0,   /* DTOSTR_STANDARD */
        0,   /* DTOSTR_STANDARD_EXPONENTIAL, */
        3,   /* DTOSTR_FIXED, */
        2,   /* DTOSTR_EXPONENTIAL, */
        2};  /* DTOSTR_PRECISION */

    static void
    JS_dtostr(StringBuilder buffer, int mode, int precision, double d)
    {
        int decPt;                                    /* Position of decimal point relative to first digit returned by JS_dtoa */
<span class='uc' id='L1135' title='3|3|3 - Total: 3'>        boolean[] sign = new boolean[1];            /* true if the sign bit was set in d */
</span>        int nDigits;                                /* Number of significand digits returned by JS_dtoa */

//        JS_ASSERT(bufferSize >= (size_t)(mode <= DTOSTR_STANDARD_EXPONENTIAL ? DTOSTR_STANDARD_BUFFER_SIZE :
//                DTOSTR_VARIABLE_BUFFER_SIZE(precision)));

<span class='upc' id='L1141' title='4|4|4 - Total: 6'>        if (mode == DTOSTR_FIXED && (d >= 1e21 || d <= -1e21))
</span><span class='nc' id='L1142' title='0|0|0 - Total: 2'>            mode = DTOSTR_STANDARD; /* Change mode here rather than below because the buffer may not be large enough to hold a large integer. */
</span>
<span class='uc' id='L1144' title='2|2|2 - Total: 2'>        decPt = JS_dtoa(d, dtoaModes[mode], mode >= DTOSTR_FIXED, precision, sign, buffer);
</span><span class='uc' id='L1145' title='3|3|3 - Total: 3'>        nDigits = buffer.length();
</span>
        /* If Infinity, -Infinity, or NaN, return the string regardless of the mode. */
<span class='upc' id='L1148' title='1|1|1 - Total: 2'>        if (decPt != 9999) {
</span><span class='uc' id='L1149' title='2|2|2 - Total: 2'>            boolean exponentialNotation = false;
</span><span class='uc' id='L1150' title='2|2|2 - Total: 2'>            int minNDigits = 0;         /* Minimum number of significand digits required by mode and precision */
</span>            int p;

<span class='upc' id='L1153' title='4|4|4 - Total: 6'>            switch (mode) {
</span>                case DTOSTR_STANDARD:
<span class='uc' id='L1155' title='4|4|4 - Total: 4'>                    if (decPt < -5 || decPt > 21)
</span><span class='uc' id='L1156' title='3|3|3 - Total: 3'>                        exponentialNotation = true;
</span>                    else
<span class='uc' id='L1158' title='2|2|2 - Total: 2'>                        minNDigits = decPt;
</span><span class='uc' id='L1159' title='1|1|1 - Total: 1'>                    break;
</span>
                case DTOSTR_FIXED:
<span class='upc' id='L1162' title='1|1|1 - Total: 2'>                    if (precision >= 0)
</span><span class='uc' id='L1163' title='5|5|5 - Total: 5'>                        minNDigits = decPt + precision;
</span>                    else
<span class='nc' id='L1165' title='0|0|0 - Total: 2'>                        minNDigits = decPt;
</span><span class='nc' id='L1166' title='0|0|0 - Total: 1'>                    break;
</span>
                case DTOSTR_EXPONENTIAL:
//                    JS_ASSERT(precision > 0);
<span class='uc' id='L1170' title='2|2|2 - Total: 2'>                    minNDigits = precision;
</span>                    /* fallthru */
                case DTOSTR_STANDARD_EXPONENTIAL:
<span class='uc' id='L1173' title='2|2|2 - Total: 2'>                    exponentialNotation = true;
</span><span class='uc' id='L1174' title='1|1|1 - Total: 1'>                    break;
</span>
                case DTOSTR_PRECISION:
//                    JS_ASSERT(precision > 0);
<span class='uc' id='L1178' title='2|2|2 - Total: 2'>                    minNDigits = precision;
</span><span class='upc' id='L1179' title='2|2|2 - Total: 4'>                    if (decPt < -5 || decPt > precision)
</span><span class='nc' id='L1180' title='0|0|0 - Total: 2'>                        exponentialNotation = true;
</span>                    break;
            }

            /* If the number has fewer than minNDigits, pad it with zeros at the end */
<span class='uc' id='L1185' title='2|2|2 - Total: 2'>            if (nDigits < minNDigits) {
</span><span class='uc' id='L1186' title='2|2|2 - Total: 2'>                p = minNDigits;
</span><span class='uc' id='L1187' title='2|2|2 - Total: 2'>                nDigits = minNDigits;
</span>                do {
<span class='uc' id='L1189' title='4|4|4 - Total: 4'>                    buffer.append('0');
</span><span class='uc' id='L1190' title='2|2|2 - Total: 2'>                } while (buffer.length() != p);
</span>            }

<span class='uc' id='L1193' title='2|2|2 - Total: 2'>            if (exponentialNotation) {
</span>                /* Insert a decimal point if more than one significand digit */
<span class='uc' id='L1195' title='2|2|2 - Total: 2'>                if (nDigits != 1) {
</span><span class='uc' id='L1196' title='5|5|5 - Total: 5'>                    buffer.insert(1, '.');
</span>                }
<span class='uc' id='L1198' title='4|4|4 - Total: 4'>                buffer.append('e');
</span><span class='uc' id='L1199' title='2|2|2 - Total: 2'>                if ((decPt - 1) >= 0)
</span><span class='uc' id='L1200' title='4|4|4 - Total: 4'>                    buffer.append('+');
</span><span class='uc' id='L1201' title='7|7|7 - Total: 7'>                buffer.append(decPt - 1);
</span>//                JS_snprintf(numEnd, bufferSize - (numEnd - buffer), "e%+d", decPt-1);
<span class='uc' id='L1203' title='2|2|2 - Total: 2'>            } else if (decPt != nDigits) {
</span>                /* Some kind of a fraction in fixed notation */
//                JS_ASSERT(decPt <= nDigits);
<span class='uc' id='L1206' title='2|2|2 - Total: 2'>                if (decPt > 0) {
</span>                    /* dd...dd . dd...dd */
<span class='uc' id='L1208' title='6|6|6 - Total: 6'>                    buffer.insert(decPt, '.');
</span>                } else {
                    /* 0 . 00...00dd...dd */
<span class='uc' id='L1211' title='2|2|2 - Total: 2'>                    for (int i = 0; i < 1 - decPt; i++)
</span><span class='uc' id='L1212' title='5|5|5 - Total: 5'>                        buffer.insert(0, '0');
</span><span class='uc' id='L1213' title='5|5|5 - Total: 5'>                    buffer.insert(1, '.');
</span>                }
            }
        }

        /* If negative and neither -0.0 nor NaN, output a leading '-'. */
<span class='uc' id='L1219' title='2|2|2 - Total: 2'>        if (sign[0] &&
</span><span class='upc' id='L1220' title='1|1|1 - Total: 4'>                !(word0(d) == Sign_bit && word1(d) == 0) &&
</span><span class='upc' id='L1221' title='1|1|1 - Total: 2'>                !((word0(d) & Exp_mask) == Exp_mask &&
</span><span class='nc' id='L1222' title='0|0|0 - Total: 4'>                  ((word1(d) != 0) || ((word0(d) & Frac_mask) != 0)))) {
</span><span class='uc' id='L1223' title='5|5|5 - Total: 5'>            buffer.insert(0, '-');
</span>        }
<span class='uc' id='L1225' title='1|1|1 - Total: 1'>    }
</span>
}

</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>