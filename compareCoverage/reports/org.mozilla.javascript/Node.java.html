<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.Node.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.Node.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import org.mozilla.javascript.ast.Comment;
import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.ast.Jump;
import org.mozilla.javascript.ast.Name;
import org.mozilla.javascript.ast.NumberLiteral;
import org.mozilla.javascript.ast.Scope;
import org.mozilla.javascript.ast.ScriptNode;

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * This class implements the root of the intermediate representation.
 *
 * @author Norris Boyd
 * @author Mike McCabe
 */
public class Node implements Iterable<Node>
{
    public static final int
        FUNCTION_PROP      =  1,
        LOCAL_PROP         =  2,
        LOCAL_BLOCK_PROP   =  3,
        REGEXP_PROP        =  4,
        CASEARRAY_PROP     =  5,

    //  the following properties are defined and manipulated by the
    //  optimizer -
    //  TARGETBLOCK_PROP - the block referenced by a branch node
    //  VARIABLE_PROP - the variable referenced by a BIND or NAME node
    //  ISNUMBER_PROP - this node generates code on Number children and
    //                  delivers a Number result (as opposed to Objects)
    //  DIRECTCALL_PROP - this call node should emit code to test the function
    //                    object against the known class and call direct if it
    //                    matches.

        TARGETBLOCK_PROP     =  6,
        VARIABLE_PROP        =  7,
        ISNUMBER_PROP        =  8,
        DIRECTCALL_PROP      =  9,
        SPECIALCALL_PROP     = 10,
        SKIP_INDEXES_PROP    = 11, // array of skipped indexes of array literal
        OBJECT_IDS_PROP      = 12, // array of properties for object literal
        INCRDECR_PROP        = 13, // pre or post type of increment/decrement
        CATCH_SCOPE_PROP     = 14, // index of catch scope block in catch
        LABEL_ID_PROP        = 15, // label id: code generation uses it
        MEMBER_TYPE_PROP     = 16, // type of element access operation
        NAME_PROP            = 17, // property name
        CONTROL_BLOCK_PROP   = 18, // flags a control block that can drop off
        PARENTHESIZED_PROP   = 19, // expression is parenthesized
        GENERATOR_END_PROP   = 20,
        DESTRUCTURING_ARRAY_LENGTH = 21,
        DESTRUCTURING_NAMES  = 22,
        DESTRUCTURING_PARAMS = 23,
        JSDOC_PROP           = 24,
        EXPRESSION_CLOSURE_PROP = 25, // JS 1.8 expression closure pseudo-return
        DESTRUCTURING_SHORTHAND = 26, // JS 1.8 destructuring shorthand
        ARROW_FUNCTION_PROP  = 27,
        LAST_PROP            = 27;

    // values of ISNUMBER_PROP to specify
    // which of the children are Number types
    public static final int
        BOTH = 0,
        LEFT = 1,
        RIGHT = 2;

    public static final int    // values for SPECIALCALL_PROP
        NON_SPECIALCALL  = 0,
        SPECIALCALL_EVAL = 1,
        SPECIALCALL_WITH = 2;

    public static final int   // flags for INCRDECR_PROP
        DECR_FLAG = 0x1,
        POST_FLAG = 0x2;

    public static final int   // flags for MEMBER_TYPE_PROP
        PROPERTY_FLAG    = 0x1, // property access: element is valid name
        ATTRIBUTE_FLAG   = 0x2, // x.@y or x..@y
        DESCENDANTS_FLAG = 0x4; // x..y or x..@i

    private static class PropListItem
    {
        PropListItem next;
        int type;
        int intValue;
        Object objectValue;
    }

<span class='uc' id='L98' title='2|2|2 - Total: 2'>    public Node(int nodeType) {
</span><span class='uc' id='L99' title='3|3|3 - Total: 3'>        type = nodeType;
</span><span class='uc' id='L100' title='1|1|1 - Total: 1'>    }
</span>
<span class='uc' id='L102' title='2|2|2 - Total: 2'>    public Node(int nodeType, Node child) {
</span><span class='uc' id='L103' title='3|3|3 - Total: 3'>        type = nodeType;
</span><span class='uc' id='L104' title='6|6|6 - Total: 6'>        first = last = child;
</span><span class='uc' id='L105' title='3|3|3 - Total: 3'>        child.next = null;
</span><span class='uc' id='L106' title='1|1|1 - Total: 1'>    }
</span>
<span class='uc' id='L108' title='2|2|2 - Total: 2'>    public Node(int nodeType, Node left, Node right) {
</span><span class='uc' id='L109' title='3|3|3 - Total: 3'>        type = nodeType;
</span><span class='uc' id='L110' title='3|3|3 - Total: 3'>        first = left;
</span><span class='uc' id='L111' title='3|3|3 - Total: 3'>        last = right;
</span><span class='uc' id='L112' title='3|3|3 - Total: 3'>        left.next = right;
</span><span class='uc' id='L113' title='3|3|3 - Total: 3'>        right.next = null;
</span><span class='uc' id='L114' title='1|1|1 - Total: 1'>    }
</span>
<span class='uc' id='L116' title='2|2|2 - Total: 2'>    public Node(int nodeType, Node left, Node mid, Node right) {
</span><span class='uc' id='L117' title='3|3|3 - Total: 3'>        type = nodeType;
</span><span class='uc' id='L118' title='3|3|3 - Total: 3'>        first = left;
</span><span class='uc' id='L119' title='3|3|3 - Total: 3'>        last = right;
</span><span class='uc' id='L120' title='3|3|3 - Total: 3'>        left.next = mid;
</span><span class='uc' id='L121' title='3|3|3 - Total: 3'>        mid.next = right;
</span><span class='uc' id='L122' title='3|3|3 - Total: 3'>        right.next = null;
</span><span class='uc' id='L123' title='1|1|1 - Total: 1'>    }
</span>
<span class='uc' id='L125' title='2|2|2 - Total: 2'>    public Node(int nodeType, int line) {
</span><span class='uc' id='L126' title='3|3|3 - Total: 3'>        type = nodeType;
</span><span class='uc' id='L127' title='3|3|3 - Total: 3'>        lineno = line;
</span><span class='uc' id='L128' title='1|1|1 - Total: 1'>    }
</span>
    public Node(int nodeType, Node child, int line) {
<span class='uc' id='L131' title='4|4|4 - Total: 4'>        this(nodeType, child);
</span><span class='uc' id='L132' title='3|3|3 - Total: 3'>        lineno = line;
</span><span class='uc' id='L133' title='1|1|1 - Total: 1'>    }
</span>
    public Node(int nodeType, Node left, Node right, int line) {
<span class='nc' id='L136' title='0|0|0 - Total: 5'>        this(nodeType, left, right);
</span><span class='nc' id='L137' title='0|0|0 - Total: 3'>        lineno = line;
</span><span class='nc' id='L138' title='0|0|0 - Total: 1'>    }
</span>
    public Node(int nodeType, Node left, Node mid, Node right, int line) {
<span class='uc' id='L141' title='6|6|6 - Total: 6'>        this(nodeType, left, mid, right);
</span><span class='uc' id='L142' title='3|3|3 - Total: 3'>        lineno = line;
</span><span class='uc' id='L143' title='1|1|1 - Total: 1'>    }
</span>
    public static Node newNumber(double number) {
<span class='uc' id='L146' title='4|4|4 - Total: 4'>        NumberLiteral n = new NumberLiteral();
</span><span class='uc' id='L147' title='3|3|3 - Total: 3'>        n.setNumber(number);
</span><span class='uc' id='L148' title='2|2|2 - Total: 2'>        return n;
</span>    }

    public static Node newString(String str) {
<span class='uc' id='L152' title='4|4|4 - Total: 4'>        return newString(Token.STRING, str);
</span>    }

    public static Node newString(int type, String str) {
<span class='uc' id='L156' title='4|4|4 - Total: 4'>        Name name = new Name();
</span><span class='uc' id='L157' title='3|3|3 - Total: 3'>        name.setIdentifier(str);
</span><span class='uc' id='L158' title='4|4|4 - Total: 4'>        name.setType(type);
</span><span class='uc' id='L159' title='2|2|2 - Total: 2'>        return name;
</span>    }

    public int getType() {
<span class='uc' id='L163' title='3|3|3 - Total: 3'>        return type;
</span>    }

    /**
     * Sets the node type and returns this node.
     */
    public Node setType(int type) {
<span class='uc' id='L170' title='3|3|3 - Total: 3'>        this.type = type;
</span><span class='uc' id='L171' title='2|2|2 - Total: 2'>        return this;
</span>    }

    /**
     * Gets the JsDoc comment string attached to this node.
     * @return the comment string or {@code null} if no JsDoc is attached to
     *     this node
     */
    public String getJsDoc() {
<span class='uc' id='L180' title='3|3|3 - Total: 3'>        Comment comment = getJsDocNode();
</span><span class='uc' id='L181' title='2|2|2 - Total: 2'>        if (comment != null) {
</span><span class='uc' id='L182' title='3|3|3 - Total: 3'>          return comment.getValue();
</span>        }
<span class='uc' id='L184' title='2|2|2 - Total: 2'>        return null;
</span>    }

    /**
     * Gets the JsDoc Comment object attached to this node.
     * @return the Comment or {@code null} if no JsDoc is attached to
     *     this node
     */
    public Comment getJsDocNode() {
<span class='uc' id='L193' title='5|5|5 - Total: 5'>        return (Comment) getProp(JSDOC_PROP);
</span>    }

    /**
     * Sets the JsDoc comment string attached to this node.
     */
    public void setJsDocNode(Comment jsdocNode) {
<span class='uc' id='L200' title='4|4|4 - Total: 4'>        putProp(JSDOC_PROP, jsdocNode);
</span><span class='uc' id='L201' title='1|1|1 - Total: 1'>    }
</span>
    public boolean hasChildren() {
<span class='uc' id='L204' title='2|2|2 - Total: 2'>        return first != null;
</span>    }

    public Node getFirstChild() {
<span class='uc' id='L208' title='3|3|3 - Total: 3'>        return first;
</span>    }

    public Node getLastChild() {
<span class='uc' id='L212' title='3|3|3 - Total: 3'>        return last;
</span>    }

    public Node getNext() {
<span class='uc' id='L216' title='3|3|3 - Total: 3'>        return next;
</span>    }

    public Node getChildBefore(Node child) {
<span class='uc' id='L220' title='2|2|2 - Total: 2'>        if (child == first)
</span><span class='uc' id='L221' title='2|2|2 - Total: 2'>            return null;
</span><span class='uc' id='L222' title='3|3|3 - Total: 3'>        Node n = first;
</span><span class='uc' id='L223' title='2|2|2 - Total: 2'>        while (n.next != child) {
</span><span class='uc' id='L224' title='3|3|3 - Total: 3'>            n = n.next;
</span><span class='upc' id='L225' title='1|1|1 - Total: 2'>            if (n == null)
</span><span class='nc' id='L226' title='0|0|0 - Total: 5'>                throw new RuntimeException("node is not a child");
</span>        }
<span class='uc' id='L228' title='2|2|2 - Total: 2'>        return n;
</span>    }

    public Node getLastSibling() {
<span class='uc' id='L232' title='2|2|2 - Total: 2'>        Node n = this;
</span><span class='uc' id='L233' title='2|2|2 - Total: 2'>        while (n.next != null) {
</span><span class='uc' id='L234' title='4|4|4 - Total: 4'>            n = n.next;
</span>        }
<span class='uc' id='L236' title='2|2|2 - Total: 2'>        return n;
</span>    }

    public void addChildToFront(Node child) {
<span class='uc' id='L240' title='4|4|4 - Total: 4'>        child.next = first;
</span><span class='uc' id='L241' title='3|3|3 - Total: 3'>        first = child;
</span><span class='uc' id='L242' title='2|2|2 - Total: 2'>        if (last == null) {
</span><span class='uc' id='L243' title='3|3|3 - Total: 3'>            last = child;
</span>        }
<span class='uc' id='L245' title='1|1|1 - Total: 1'>    }
</span>
    public void addChildToBack(Node child) {
<span class='uc' id='L248' title='3|3|3 - Total: 3'>        child.next = null;
</span><span class='uc' id='L249' title='2|2|2 - Total: 2'>        if (last == null) {
</span><span class='uc' id='L250' title='6|6|6 - Total: 6'>            first = last = child;
</span><span class='uc' id='L251' title='1|1|1 - Total: 1'>            return;
</span>        }
<span class='uc' id='L253' title='4|4|4 - Total: 4'>        last.next = child;
</span><span class='uc' id='L254' title='3|3|3 - Total: 3'>        last = child;
</span><span class='uc' id='L255' title='1|1|1 - Total: 1'>    }
</span>
    public void addChildrenToFront(Node children) {
<span class='uc' id='L258' title='3|3|3 - Total: 3'>        Node lastSib = children.getLastSibling();
</span><span class='uc' id='L259' title='4|4|4 - Total: 4'>        lastSib.next = first;
</span><span class='uc' id='L260' title='3|3|3 - Total: 3'>        first = children;
</span><span class='uc' id='L261' title='2|2|2 - Total: 2'>        if (last == null) {
</span><span class='uc' id='L262' title='3|3|3 - Total: 3'>            last = lastSib;
</span>        }
<span class='uc' id='L264' title='1|1|1 - Total: 1'>    }
</span>
    public void addChildrenToBack(Node children) {
<span class='uc' id='L267' title='2|2|2 - Total: 2'>        if (last != null) {
</span><span class='uc' id='L268' title='4|4|4 - Total: 4'>            last.next = children;
</span>        }
<span class='uc' id='L270' title='4|4|4 - Total: 4'>        last = children.getLastSibling();
</span><span class='uc' id='L271' title='2|2|2 - Total: 2'>        if (first == null) {
</span><span class='uc' id='L272' title='3|3|3 - Total: 3'>            first = children;
</span>        }
<span class='uc' id='L274' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Add 'child' before 'node'.
     */
    public void addChildBefore(Node newChild, Node node) {
<span class='upc' id='L280' title='1|1|1 - Total: 2'>        if (newChild.next != null)
</span><span class='nc' id='L281' title='0|0|0 - Total: 5'>            throw new RuntimeException(
</span>                      "newChild had siblings in addChildBefore");
<span class='uc' id='L283' title='2|2|2 - Total: 2'>        if (first == node) {
</span><span class='uc' id='L284' title='4|4|4 - Total: 4'>            newChild.next = first;
</span><span class='uc' id='L285' title='3|3|3 - Total: 3'>            first = newChild;
</span><span class='uc' id='L286' title='1|1|1 - Total: 1'>            return;
</span>        }
<span class='uc' id='L288' title='4|4|4 - Total: 4'>        Node prev = getChildBefore(node);
</span><span class='uc' id='L289' title='4|4|4 - Total: 4'>        addChildAfter(newChild, prev);
</span><span class='uc' id='L290' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Add 'child' after 'node'.
     */
    public void addChildAfter(Node newChild, Node node) {
<span class='upc' id='L296' title='1|1|1 - Total: 2'>        if (newChild.next != null)
</span><span class='nc' id='L297' title='0|0|0 - Total: 5'>            throw new RuntimeException(
</span>                      "newChild had siblings in addChildAfter");
<span class='uc' id='L299' title='4|4|4 - Total: 4'>        newChild.next = node.next;
</span><span class='uc' id='L300' title='3|3|3 - Total: 3'>        node.next = newChild;
</span><span class='uc' id='L301' title='2|2|2 - Total: 2'>        if (last == node)
</span><span class='uc' id='L302' title='3|3|3 - Total: 3'>            last = newChild;
</span><span class='uc' id='L303' title='1|1|1 - Total: 1'>    }
</span>
    public void removeChild(Node child) {
<span class='uc' id='L306' title='4|4|4 - Total: 4'>        Node prev = getChildBefore(child);
</span><span class='uc' id='L307' title='2|2|2 - Total: 2'>        if (prev == null)
</span><span class='uc' id='L308' title='6|6|6 - Total: 6'>            first = first.next;
</span>        else
<span class='uc' id='L310' title='4|4|4 - Total: 4'>            prev.next = child.next;
</span><span class='uc' id='L311' title='2|2|2 - Total: 2'>        if (child == last) last = prev;
</span><span class='uc' id='L312' title='3|3|3 - Total: 3'>        child.next = null;
</span><span class='uc' id='L313' title='1|1|1 - Total: 1'>    }
</span>
    public void replaceChild(Node child, Node newChild) {
<span class='uc' id='L316' title='4|4|4 - Total: 4'>        newChild.next = child.next;
</span><span class='upc' id='L317' title='1|1|1 - Total: 2'>        if (child == first) {
</span><span class='uc' id='L318' title='4|4|4 - Total: 4'>            first = newChild;
</span>        } else {
<span class='nc' id='L320' title='0|0|0 - Total: 4'>            Node prev = getChildBefore(child);
</span><span class='nc' id='L321' title='0|0|0 - Total: 3'>            prev.next = newChild;
</span>        }
<span class='uc' id='L323' title='2|2|2 - Total: 2'>        if (child == last)
</span><span class='uc' id='L324' title='3|3|3 - Total: 3'>            last = newChild;
</span><span class='uc' id='L325' title='3|3|3 - Total: 3'>        child.next = null;
</span><span class='uc' id='L326' title='1|1|1 - Total: 1'>    }
</span>
    public void replaceChildAfter(Node prevChild, Node newChild) {
<span class='uc' id='L329' title='3|3|3 - Total: 3'>        Node child = prevChild.next;
</span><span class='uc' id='L330' title='4|4|4 - Total: 4'>        newChild.next = child.next;
</span><span class='uc' id='L331' title='3|3|3 - Total: 3'>        prevChild.next = newChild;
</span><span class='uc' id='L332' title='2|2|2 - Total: 2'>        if (child == last)
</span><span class='uc' id='L333' title='3|3|3 - Total: 3'>            last = newChild;
</span><span class='uc' id='L334' title='3|3|3 - Total: 3'>        child.next = null;
</span><span class='uc' id='L335' title='1|1|1 - Total: 1'>    }
</span>
    public void removeChildren() {
<span class='uc' id='L338' title='6|6|6 - Total: 6'>        first = last = null;
</span><span class='uc' id='L339' title='1|1|1 - Total: 1'>    }
</span>
<span class='uc' id='L341' title='6|6|6 - Total: 6'>    private static final Node NOT_SET = new Node(Token.ERROR);
</span>
    /**
     * Iterates over the children of this Node.  Supports child removal.  Not
     * thread-safe.  If anyone changes the child list before the iterator
     * finishes, the results are undefined and probably bad.
     */
    public class NodeIterator implements Iterator<Node> {
        private Node cursor;  // points to node to be returned next
        private Node prev = NOT_SET;
        private Node prev2;
        private boolean removed = false;

        public NodeIterator() {
            cursor = Node.this.first;
        }

        public boolean hasNext() {
            return cursor != null;
        }

        public Node next() {
            if (cursor == null) {
                throw new NoSuchElementException();
            }
            removed = false;
            prev2 = prev;
            prev = cursor;
            cursor = cursor.next;
            return prev;
        }

        public void remove() {
            if (prev == NOT_SET) {
                throw new IllegalStateException("next() has not been called");
            }
            if (removed) {
                throw new IllegalStateException(
                    "remove() already called for current element");
            }
            if (prev == first) {
                first = prev.next;
            } else if (prev == last) {
                prev2.next = null;
                last = prev2;
            } else {
                prev2.next = cursor;
            }
        }
    }

    /**
     * Returns an {@link java.util.Iterator} over the node's children.
     */
    public Iterator<Node> iterator() {
<span class='uc' id='L396' title='5|5|5 - Total: 5'>        return new NodeIterator();
</span>    }

    private static final String propToString(int propType)
    {
        if (Token.printTrees) {
            // If Context.printTrees is false, the compiler
            // can remove all these strings.
            switch (propType) {
                case FUNCTION_PROP:        return "function";
                case LOCAL_PROP:           return "local";
                case LOCAL_BLOCK_PROP:     return "local_block";
                case REGEXP_PROP:          return "regexp";
                case CASEARRAY_PROP:       return "casearray";

                case TARGETBLOCK_PROP:     return "targetblock";
                case VARIABLE_PROP:        return "variable";
                case ISNUMBER_PROP:        return "isnumber";
                case DIRECTCALL_PROP:      return "directcall";

                case SPECIALCALL_PROP:     return "specialcall";
                case SKIP_INDEXES_PROP:    return "skip_indexes";
                case OBJECT_IDS_PROP:      return "object_ids_prop";
                case INCRDECR_PROP:        return "incrdecr_prop";
                case CATCH_SCOPE_PROP:     return "catch_scope_prop";
                case LABEL_ID_PROP:        return "label_id_prop";
                case MEMBER_TYPE_PROP:     return "member_type_prop";
                case NAME_PROP:            return "name_prop";
                case CONTROL_BLOCK_PROP:   return "control_block_prop";
                case PARENTHESIZED_PROP:   return "parenthesized_prop";
                case GENERATOR_END_PROP:   return "generator_end";
                case DESTRUCTURING_ARRAY_LENGTH:
                                           return "destructuring_array_length";
                case DESTRUCTURING_NAMES:  return "destructuring_names";
                case DESTRUCTURING_PARAMS: return "destructuring_params";

                default: Kit.codeBug();
            }
        }
<span class='nc' id='L435' title='0|0|0 - Total: 2'>        return null;
</span>    }

    private PropListItem lookupProperty(int propType)
    {
<span class='uc' id='L440' title='3|3|3 - Total: 3'>        PropListItem x = propListHead;
</span><span class='uc' id='L441' title='4|4|4 - Total: 4'>        while (x != null && propType != x.type) {
</span><span class='uc' id='L442' title='4|4|4 - Total: 4'>            x = x.next;
</span>        }
<span class='uc' id='L444' title='2|2|2 - Total: 2'>        return x;
</span>    }

    private PropListItem ensureProperty(int propType)
    {
<span class='uc' id='L449' title='4|4|4 - Total: 4'>        PropListItem item = lookupProperty(propType);
</span><span class='uc' id='L450' title='2|2|2 - Total: 2'>        if (item == null) {
</span><span class='uc' id='L451' title='5|5|5 - Total: 5'>            item = new PropListItem();
</span><span class='uc' id='L452' title='3|3|3 - Total: 3'>            item.type = propType;
</span><span class='uc' id='L453' title='4|4|4 - Total: 4'>            item.next = propListHead;
</span><span class='uc' id='L454' title='3|3|3 - Total: 3'>            propListHead = item;
</span>        }
<span class='uc' id='L456' title='2|2|2 - Total: 2'>        return item;
</span>    }

    public void removeProp(int propType)
    {
<span class='uc' id='L461' title='3|3|3 - Total: 3'>        PropListItem x = propListHead;
</span><span class='uc' id='L462' title='2|2|2 - Total: 2'>        if (x != null) {
</span><span class='uc' id='L463' title='2|2|2 - Total: 2'>            PropListItem prev = null;
</span><span class='upc' id='L464' title='1|1|1 - Total: 2'>            while (x.type != propType) {
</span><span class='nc' id='L465' title='0|0|0 - Total: 2'>                prev = x;
</span><span class='nc' id='L466' title='0|0|0 - Total: 3'>                x = x.next;
</span><span class='nc' id='L467' title='0|0|0 - Total: 2'>                if (x == null) { return; }
</span>            }
<span class='upc' id='L469' title='1|1|1 - Total: 2'>            if (prev == null) {
</span><span class='uc' id='L470' title='5|5|5 - Total: 5'>                propListHead = x.next;
</span>            } else {
<span class='nc' id='L472' title='0|0|0 - Total: 4'>                prev.next = x.next;
</span>            }
        }
<span class='uc' id='L475' title='1|1|1 - Total: 1'>    }
</span>
    public Object getProp(int propType)
    {
<span class='uc' id='L479' title='4|4|4 - Total: 4'>        PropListItem item = lookupProperty(propType);
</span><span class='uc' id='L480' title='2|2|2 - Total: 2'>        if (item == null) { return null; }
</span><span class='uc' id='L481' title='3|3|3 - Total: 3'>        return item.objectValue;
</span>    }

    public int getIntProp(int propType, int defaultValue)
    {
<span class='uc' id='L486' title='4|4|4 - Total: 4'>        PropListItem item = lookupProperty(propType);
</span><span class='uc' id='L487' title='2|2|2 - Total: 2'>        if (item == null) { return defaultValue; }
</span><span class='uc' id='L488' title='3|3|3 - Total: 3'>        return item.intValue;
</span>    }

    public int getExistingIntProp(int propType)
    {
<span class='uc' id='L493' title='4|4|4 - Total: 4'>        PropListItem item = lookupProperty(propType);
</span><span class='upc' id='L494' title='1|1|1 - Total: 2'>        if (item == null) { Kit.codeBug(); }
</span><span class='uc' id='L495' title='3|3|3 - Total: 3'>        return item.intValue;
</span>    }

    public void putProp(int propType, Object prop)
    {
<span class='uc' id='L500' title='2|2|2 - Total: 2'>        if (prop == null) {
</span><span class='uc' id='L501' title='4|4|4 - Total: 4'>            removeProp(propType);
</span>        } else {
<span class='uc' id='L503' title='4|4|4 - Total: 4'>            PropListItem item = ensureProperty(propType);
</span><span class='uc' id='L504' title='3|3|3 - Total: 3'>            item.objectValue = prop;
</span>        }
<span class='uc' id='L506' title='1|1|1 - Total: 1'>    }
</span>
    public void putIntProp(int propType, int prop)
    {
<span class='uc' id='L510' title='4|4|4 - Total: 4'>        PropListItem item = ensureProperty(propType);
</span><span class='uc' id='L511' title='3|3|3 - Total: 3'>        item.intValue = prop;
</span><span class='uc' id='L512' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Return the line number recorded for this node.
     * @return the line number
     */
    public int getLineno() {
<span class='uc' id='L519' title='3|3|3 - Total: 3'>        return lineno;
</span>    }

    public void setLineno(int lineno) {
<span class='uc' id='L523' title='3|3|3 - Total: 3'>        this.lineno = lineno;
</span><span class='uc' id='L524' title='1|1|1 - Total: 1'>    }
</span>
    /** Can only be called when <tt>getType() == Token.NUMBER</tt> */
    public final double getDouble() {
<span class='uc' id='L528' title='4|4|4 - Total: 4'>        return ((NumberLiteral)this).getNumber();
</span>    }

    public final void setDouble(double number) {
<span class='uc' id='L532' title='4|4|4 - Total: 4'>        ((NumberLiteral)this).setNumber(number);
</span><span class='uc' id='L533' title='1|1|1 - Total: 1'>    }
</span>
    /** Can only be called when node has String context. */
    public final String getString() {
<span class='uc' id='L537' title='4|4|4 - Total: 4'>        return ((Name)this).getIdentifier();
</span>    }

    /** Can only be called when node has String context. */
    public final void setString(String s) {
<span class='upc' id='L542' title='1|1|1 - Total: 2'>        if (s == null) Kit.codeBug();
</span><span class='uc' id='L543' title='4|4|4 - Total: 4'>        ((Name)this).setIdentifier(s);
</span><span class='uc' id='L544' title='1|1|1 - Total: 1'>    }
</span>
    /** Can only be called when node has String context. */
    public Scope getScope() {
<span class='nc' id='L548' title='0|0|0 - Total: 4'>        return ((Name)this).getScope();
</span>    }

    /** Can only be called when node has String context. */
    public void setScope(Scope s) {
<span class='nc' id='L553' title='0|0|0 - Total: 2'>        if (s == null) Kit.codeBug();
</span><span class='nc' id='L554' title='0|0|0 - Total: 2'>        if (!(this instanceof Name)) {
</span><span class='nc' id='L555' title='0|0|0 - Total: 2'>            throw Kit.codeBug();
</span>        }
<span class='nc' id='L557' title='0|0|0 - Total: 4'>        ((Name)this).setScope(s);
</span><span class='nc' id='L558' title='0|0|0 - Total: 1'>    }
</span>
    public static Node newTarget()
    {
<span class='uc' id='L562' title='5|5|5 - Total: 5'>        return new Node(Token.TARGET);
</span>    }

    public final int labelId()
    {
<span class='upc' id='L567' title='3|3|3 - Total: 4'>        if (type != Token.TARGET && type != Token.YIELD) Kit.codeBug();
</span><span class='uc' id='L568' title='5|5|5 - Total: 5'>        return getIntProp(LABEL_ID_PROP, -1);
</span>    }

    public void labelId(int labelId)
    {
<span class='upc' id='L573' title='3|3|3 - Total: 4'>        if (type != Token.TARGET  && type != Token.YIELD) Kit.codeBug();
</span><span class='uc' id='L574' title='4|4|4 - Total: 4'>        putIntProp(LABEL_ID_PROP, labelId);
</span><span class='uc' id='L575' title='1|1|1 - Total: 1'>    }
</span>

    /**
     * Does consistent-return analysis on the function body when strict mode is
     * enabled.
     *
     *   function (x) { return (x+1) }
     * is ok, but
     *   function (x) { if (x &lt; 0) return (x+1); }
     * is not becuase the function can potentially return a value when the
     * condition is satisfied and if not, the function does not explicitly
     * return value.
     *
     * This extends to checking mismatches such as "return" and "return <value>"
     * used in the same function. Warnings are not emitted if inconsistent
     * returns exist in code that can be statically shown to be unreachable.
     * Ex.
     * <pre>function (x) { while (true) { ... if (..) { return value } ... } }
     * </pre>
     * emits no warning. However if the loop had a break statement, then a
     * warning would be emitted.
     *
     * The consistency analysis looks at control structures such as loops, ifs,
     * switch, try-catch-finally blocks, examines the reachable code paths and
     * warns the user about an inconsistent set of termination possibilities.
     *
     * Caveat: Since the parser flattens many control structures into almost
     * straight-line code with gotos, it makes such analysis hard. Hence this
     * analyser is written to taken advantage of patterns of code generated by
     * the parser (for loops, try blocks and such) and does not do a full
     * control flow analysis of the gotos and break/continue statements.
     * Future changes to the parser will affect this analysis.
     */

    /**
     * These flags enumerate the possible ways a statement/function can
     * terminate. These flags are used by endCheck() and by the Parser to
     * detect inconsistent return usage.
     *
     * END_UNREACHED is reserved for code paths that are assumed to always be
     * able to execute (example: throw, continue)
     *
     * END_DROPS_OFF indicates if the statement can transfer control to the
     * next one. Statement such as return dont. A compound statement may have
     * some branch that drops off control to the next statement.
     *
     * END_RETURNS indicates that the statement can return (without arguments)
     * END_RETURNS_VALUE indicates that the statement can return a value.
     *
     * A compound statement such as
     * if (condition) {
     *   return value;
     * }
     * Will be detected as (END_DROPS_OFF | END_RETURN_VALUE) by endCheck()
     */
    public static final int END_UNREACHED = 0;
    public static final int END_DROPS_OFF = 1;
    public static final int END_RETURNS = 2;
    public static final int END_RETURNS_VALUE = 4;
    public static final int END_YIELDS = 8;

    /**
     * Checks that every return usage in a function body is consistent with the
     * requirements of strict-mode.
     * @return true if the function satisfies strict mode requirement.
     */
    public boolean hasConsistentReturnUsage()
    {
<span class='nc' id='L644' title='0|0|0 - Total: 3'>        int n = endCheck();
</span><span class='nc' id='L645' title='0|0|0 - Total: 4'>        return (n & END_RETURNS_VALUE) == 0 ||
</span>               (n & (END_DROPS_OFF|END_RETURNS|END_YIELDS)) == 0;
    }

    /**
     * Returns in the then and else blocks must be consistent with each other.
     * If there is no else block, then the return statement can fall through.
     * @return logical OR of END_* flags
     */
    private int endCheckIf()
    {
        Node th, el;
<span class='nc' id='L657' title='0|0|0 - Total: 2'>        int rv = END_UNREACHED;
</span>
<span class='nc' id='L659' title='0|0|0 - Total: 3'>        th = next;
</span><span class='nc' id='L660' title='0|0|0 - Total: 4'>        el = ((Jump)this).target;
</span>
<span class='nc' id='L662' title='0|0|0 - Total: 3'>        rv = th.endCheck();
</span>
<span class='nc' id='L664' title='0|0|0 - Total: 2'>        if (el != null)
</span><span class='nc' id='L665' title='0|0|0 - Total: 6'>            rv |= el.endCheck();
</span>        else
<span class='nc' id='L667' title='0|0|0 - Total: 4'>            rv |= END_DROPS_OFF;
</span>
<span class='nc' id='L669' title='0|0|0 - Total: 2'>        return rv;
</span>    }

    /**
     * Consistency of return statements is checked between the case statements.
     * If there is no default, then the switch can fall through. If there is a
     * default,we check to see if all code paths in the default return or if
     * there is a code path that can fall through.
     * @return logical OR of END_* flags
     */
    private int endCheckSwitch()
    {
<span class='nc' id='L681' title='0|0|0 - Total: 2'>        int rv = END_UNREACHED;
</span>
        // examine the cases
//         for (n = first.next; n != null; n = n.next)
//         {
//             if (n.type == Token.CASE) {
//                 rv |= ((Jump)n).target.endCheck();
//             } else
//                 break;
//         }

//         // we don't care how the cases drop into each other
//         rv &= ~END_DROPS_OFF;

//         // examine the default
//         n = ((Jump)this).getDefault();
//         if (n != null)
//             rv |= n.endCheck();
//         else
//             rv |= END_DROPS_OFF;

//         // remove the switch block
//         rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);

<span class='nc' id='L705' title='0|0|0 - Total: 2'>        return rv;
</span>    }

    /**
     * If the block has a finally, return consistency is checked in the
     * finally block. If all code paths in the finally returns, then the
     * returns in the try-catch blocks don't matter. If there is a code path
     * that does not return or if there is no finally block, the returns
     * of the try and catch blocks are checked for mismatch.
     * @return logical OR of END_* flags
     */
    private int endCheckTry()
    {
<span class='nc' id='L718' title='0|0|0 - Total: 2'>        int rv = END_UNREACHED;
</span>
        // a TryStatement isn't a jump - needs rewriting

        // check the finally if it exists
//         n = ((Jump)this).getFinally();
//         if(n != null) {
//             rv = n.next.first.endCheck();
//         } else {
//             rv = END_DROPS_OFF;
//         }

//         // if the finally block always returns, then none of the returns
//         // in the try or catch blocks matter
//         if ((rv & END_DROPS_OFF) != 0) {
//             rv &= ~END_DROPS_OFF;

//             // examine the try block
//             rv |= first.endCheck();

//             // check each catch block
//             n = ((Jump)this).target;
//             if (n != null)
//             {
//                 // point to the first catch_scope
//                 for (n = n.next.first; n != null; n = n.next.next)
//                 {
//                     // check the block of user code in the catch_scope
//                     rv |= n.next.first.next.first.endCheck();
//                 }
//             }
//         }

<span class='nc' id='L751' title='0|0|0 - Total: 2'>        return rv;
</span>    }

    /**
     * Return statement in the loop body must be consistent. The default
     * assumption for any kind of a loop is that it will eventually terminate.
     * The only exception is a loop with a constant true condition. Code that
     * follows such a loop is examined only if one can statically determine
     * that there is a break out of the loop.
     * <pre>
     *  for(&lt;&gt; ; &lt;&gt;; &lt;&gt;) {}
     *  for(&lt;&gt; in &lt;&gt; ) {}
     *  while(&lt;&gt;) { }
     *  do { } while(&lt;&gt;)
     * </pre>
     * @return logical OR of END_* flags
     */
    private int endCheckLoop()
    {
        Node n;
<span class='nc' id='L771' title='0|0|0 - Total: 2'>        int rv = END_UNREACHED;
</span>
        // To find the loop body, we look at the second to last node of the
        // loop node, which should be the predicate that the loop should
        // satisfy.
        // The target of the predicate is the loop-body for all 4 kinds of
        // loops.
<span class='nc' id='L778' title='0|0|0 - Total: 2'>        for (n = first; n.next != last; n = n.next) {
</span>            /* skip */
        }
<span class='nc' id='L781' title='0|0|0 - Total: 2'>        if (n.type != Token.IFEQ)
</span><span class='nc' id='L782' title='0|0|0 - Total: 2'>            return END_DROPS_OFF;
</span>
        // The target's next is the loop body block
<span class='nc' id='L785' title='0|0|0 - Total: 6'>        rv = ((Jump)n).target.next.endCheck();
</span>
        // check to see if the loop condition is true
<span class='nc' id='L788' title='0|0|0 - Total: 2'>        if (n.first.type == Token.TRUE)
</span><span class='nc' id='L789' title='0|0|0 - Total: 4'>            rv &= ~END_DROPS_OFF;
</span>
        // look for effect of breaks
<span class='nc' id='L792' title='0|0|0 - Total: 7'>        rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);
</span>
<span class='nc' id='L794' title='0|0|0 - Total: 2'>        return rv;
</span>    }

    /**
     * A general block of code is examined statement by statement. If any
     * statement (even compound ones) returns in all branches, then subsequent
     * statements are not examined.
     * @return logical OR of END_* flags
     */
    private int endCheckBlock()
    {
        Node n;
<span class='nc' id='L806' title='0|0|0 - Total: 2'>        int rv = END_DROPS_OFF;
</span>
        // check each statment and if the statement can continue onto the next
        // one, then check the next statement
<span class='nc' id='L810' title='0|0|0 - Total: 4'>        for (n=first; ((rv & END_DROPS_OFF) != 0) && n != null; n = n.next)
</span>        {
<span class='nc' id='L812' title='0|0|0 - Total: 4'>            rv &= ~END_DROPS_OFF;
</span><span class='nc' id='L813' title='0|0|0 - Total: 5'>            rv |= n.endCheck();
</span>        }
<span class='nc' id='L815' title='0|0|0 - Total: 2'>        return rv;
</span>    }

    /**
     * A labelled statement implies that there maybe a break to the label. The
     * function processes the labelled statement and then checks the
     * CONTROL_BLOCK_PROP property to see if there is ever a break to the
     * particular label.
     * @return logical OR of END_* flags
     */
    private int endCheckLabel()
    {
<span class='nc' id='L827' title='0|0|0 - Total: 2'>        int rv = END_UNREACHED;
</span>
<span class='nc' id='L829' title='0|0|0 - Total: 4'>        rv = next.endCheck();
</span><span class='nc' id='L830' title='0|0|0 - Total: 7'>        rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);
</span>
<span class='nc' id='L832' title='0|0|0 - Total: 2'>        return rv;
</span>    }

    /**
     * When a break is encountered annotate the statement being broken
     * out of by setting its CONTROL_BLOCK_PROP property.
     * @return logical OR of END_* flags
     */
    private int endCheckBreak()
    {
<span class='nc' id='L842' title='0|0|0 - Total: 4'>        Node n = ((Jump) this).getJumpStatement();
</span><span class='nc' id='L843' title='0|0|0 - Total: 4'>        n.putIntProp(CONTROL_BLOCK_PROP, END_DROPS_OFF);
</span><span class='nc' id='L844' title='0|0|0 - Total: 2'>        return END_UNREACHED;
</span>    }

    /**
     * endCheck() examines the body of a function, doing a basic reachability
     * analysis and returns a combination of flags END_* flags that indicate
     * how the function execution can terminate. These constitute only the
     * pessimistic set of termination conditions. It is possible that at
     * runtime certain code paths will never be actually taken. Hence this
     * analysis will flag errors in cases where there may not be errors.
     * @return logical OR of END_* flags
     */
    private int endCheck()
    {
<span class='nc' id='L858' title='0|0|0 - Total: 9'>        switch(type)
</span>        {
            case Token.BREAK:
<span class='nc' id='L861' title='0|0|0 - Total: 3'>                return endCheckBreak();
</span>
            case Token.EXPR_VOID:
<span class='nc' id='L864' title='0|0|0 - Total: 2'>                if (this.first != null)
</span><span class='nc' id='L865' title='0|0|0 - Total: 4'>                    return first.endCheck();
</span><span class='nc' id='L866' title='0|0|0 - Total: 2'>                return END_DROPS_OFF;
</span>
            case Token.YIELD:
<span class='nc' id='L869' title='0|0|0 - Total: 2'>                return END_YIELDS;
</span>
            case Token.CONTINUE:
            case Token.THROW:
<span class='nc' id='L873' title='0|0|0 - Total: 2'>                return END_UNREACHED;
</span>
            case Token.RETURN:
<span class='nc' id='L876' title='0|0|0 - Total: 2'>                if (this.first != null)
</span><span class='nc' id='L877' title='0|0|0 - Total: 2'>                    return END_RETURNS_VALUE;
</span>                else
<span class='nc' id='L879' title='0|0|0 - Total: 2'>                    return END_RETURNS;
</span>
            case Token.TARGET:
<span class='nc' id='L882' title='0|0|0 - Total: 2'>                if (next != null)
</span><span class='nc' id='L883' title='0|0|0 - Total: 4'>                    return next.endCheck();
</span>                else
<span class='nc' id='L885' title='0|0|0 - Total: 2'>                    return END_DROPS_OFF;
</span>
            case Token.LOOP:
<span class='nc' id='L888' title='0|0|0 - Total: 3'>                return endCheckLoop();
</span>
            case Token.LOCAL_BLOCK:
            case Token.BLOCK:
                // there are several special kinds of blocks
<span class='nc' id='L893' title='0|0|0 - Total: 2'>                if (first == null)
</span><span class='nc' id='L894' title='0|0|0 - Total: 2'>                    return END_DROPS_OFF;
</span>
<span class='nc' id='L896' title='0|0|0 - Total: 5'>                switch(first.type) {
</span>                    case Token.LABEL:
<span class='nc' id='L898' title='0|0|0 - Total: 4'>                        return first.endCheckLabel();
</span>
                    case Token.IFNE:
<span class='nc' id='L901' title='0|0|0 - Total: 4'>                        return first.endCheckIf();
</span>
                    case Token.SWITCH:
<span class='nc' id='L904' title='0|0|0 - Total: 4'>                        return first.endCheckSwitch();
</span>
                    case Token.TRY:
<span class='nc' id='L907' title='0|0|0 - Total: 4'>                        return first.endCheckTry();
</span>
                    default:
<span class='nc' id='L910' title='0|0|0 - Total: 3'>                        return endCheckBlock();
</span>                }

            default:
<span class='nc' id='L914' title='0|0|0 - Total: 2'>                return END_DROPS_OFF;
</span>        }
    }

    public boolean hasSideEffects()
    {
<span class='nc' id='L920' title='0|0|0 - Total: 5'>        switch (type) {
</span>          case Token.EXPR_VOID:
          case Token.COMMA:
<span class='nc' id='L923' title='0|0|0 - Total: 2'>            if (last != null)
</span><span class='nc' id='L924' title='0|0|0 - Total: 4'>                return last.hasSideEffects();
</span>            else
<span class='nc' id='L926' title='0|0|0 - Total: 2'>                return true;
</span>
          case Token.HOOK:
<span class='nc' id='L929' title='0|0|0 - Total: 6'>            if (first == null ||
</span>                first.next == null ||
                first.next.next == null)
<span class='nc' id='L932' title='0|0|0 - Total: 2'>                Kit.codeBug();
</span><span class='nc' id='L933' title='0|0|0 - Total: 2'>            return first.next.hasSideEffects() &&
</span><span class='nc' id='L934' title='0|0|0 - Total: 2'>                   first.next.next.hasSideEffects();
</span>
          case Token.AND:
          case Token.OR:
<span class='nc' id='L938' title='0|0|0 - Total: 4'>            if (first == null || last == null)
</span><span class='nc' id='L939' title='0|0|0 - Total: 2'>                Kit.codeBug();
</span><span class='nc' id='L940' title='0|0|0 - Total: 4'>            return first.hasSideEffects() || last.hasSideEffects();
</span>
          case Token.ERROR:         // Avoid cascaded error messages
          case Token.EXPR_RESULT:
          case Token.ASSIGN:
          case Token.ASSIGN_ADD:
          case Token.ASSIGN_SUB:
          case Token.ASSIGN_MUL:
          case Token.ASSIGN_DIV:
          case Token.ASSIGN_MOD:
          case Token.ASSIGN_BITOR:
          case Token.ASSIGN_BITXOR:
          case Token.ASSIGN_BITAND:
          case Token.ASSIGN_LSH:
          case Token.ASSIGN_RSH:
          case Token.ASSIGN_URSH:
          case Token.ENTERWITH:
          case Token.LEAVEWITH:
          case Token.RETURN:
          case Token.GOTO:
          case Token.IFEQ:
          case Token.IFNE:
          case Token.NEW:
          case Token.DELPROP:
          case Token.SETNAME:
          case Token.SETPROP:
          case Token.SETELEM:
          case Token.CALL:
          case Token.THROW:
          case Token.RETHROW:
          case Token.SETVAR:
          case Token.CATCH_SCOPE:
          case Token.RETURN_RESULT:
          case Token.SET_REF:
          case Token.DEL_REF:
          case Token.REF_CALL:
          case Token.TRY:
          case Token.SEMI:
          case Token.INC:
          case Token.DEC:
          case Token.IF:
          case Token.ELSE:
          case Token.SWITCH:
          case Token.WHILE:
          case Token.DO:
          case Token.FOR:
          case Token.BREAK:
          case Token.CONTINUE:
          case Token.VAR:
          case Token.CONST:
          case Token.LET:
          case Token.LETEXPR:
          case Token.WITH:
          case Token.WITHEXPR:
          case Token.CATCH:
          case Token.FINALLY:
          case Token.BLOCK:
          case Token.LABEL:
          case Token.TARGET:
          case Token.LOOP:
          case Token.JSR:
          case Token.SETPROP_OP:
          case Token.SETELEM_OP:
          case Token.LOCAL_BLOCK:
          case Token.SET_REF_OP:
          case Token.YIELD:
<span class='nc' id='L1006' title='0|0|0 - Total: 2'>            return true;
</span>
          default:
<span class='nc' id='L1009' title='0|0|0 - Total: 2'>            return false;
</span>        }
    }

    /**
     * Recursively unlabel every TARGET or YIELD node in the tree.
     *
     * This is used and should only be used for inlining finally blocks where
     * jsr instructions used to be. It is somewhat hackish, but implementing
     * a clone() operation would take much, much more effort.
     *
     * This solution works for inlining finally blocks because you should never
     * be writing any given block to the class file simultaneously. Therefore,
     * an unlabeling will never occur in the middle of a block.
     */
    public void resetTargets()
    {
<span class='upc' id='L1026' title='1|1|1 - Total: 2'>        if (type == Token.FINALLY) {
</span><span class='uc' id='L1027' title='3|3|3 - Total: 3'>            resetTargets_r();
</span>        } else {
<span class='nc' id='L1029' title='0|0|0 - Total: 2'>            Kit.codeBug();
</span>        }
<span class='uc' id='L1031' title='1|1|1 - Total: 1'>    }
</span>
    private void resetTargets_r()
    {
<span class='upc' id='L1035' title='3|3|3 - Total: 4'>        if (type == Token.TARGET || type == Token.YIELD) {
</span><span class='uc' id='L1036' title='3|3|3 - Total: 3'>            labelId(-1);
</span>        }
<span class='uc' id='L1038' title='3|3|3 - Total: 3'>        Node child = first;
</span><span class='uc' id='L1039' title='2|2|2 - Total: 2'>        while (child != null) {
</span><span class='uc' id='L1040' title='2|2|2 - Total: 2'>            child.resetTargets_r();
</span><span class='uc' id='L1041' title='4|4|4 - Total: 4'>            child = child.next;
</span>        }
<span class='uc' id='L1043' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public String toString()
    {
        if (Token.printTrees) {
            StringBuilder sb = new StringBuilder();
            toString(new ObjToIntMap(), sb);
            return sb.toString();
        }
<span class='nc' id='L1053' title='0|0|0 - Total: 4'>        return String.valueOf(type);
</span>    }

    private void toString(ObjToIntMap printIds, StringBuilder sb)
    {
        if (Token.printTrees) {
            sb.append(Token.name(type));
            if (this instanceof Name) {
                sb.append(' ');
                sb.append(getString());
                Scope scope = getScope();
                if (scope != null) {
                    sb.append("[scope: ");
                    appendPrintId(scope, printIds, sb);
                    sb.append("]");
                }
            } else if (this instanceof Scope) {
                if (this instanceof ScriptNode) {
                    ScriptNode sof = (ScriptNode)this;
                    if (this instanceof FunctionNode) {
                        FunctionNode fn = (FunctionNode)this;
                        sb.append(' ');
                        sb.append(fn.getName());
                    }
                    sb.append(" [source name: ");
                    sb.append(sof.getSourceName());
                    sb.append("] [encoded source length: ");
                    sb.append(sof.getEncodedSourceEnd()
                              - sof.getEncodedSourceStart());
                    sb.append("] [base line: ");
                    sb.append(sof.getBaseLineno());
                    sb.append("] [end line: ");
                    sb.append(sof.getEndLineno());
                    sb.append(']');
                }
                if (((Scope)this).getSymbolTable() != null) {
                    sb.append(" [scope ");
                    appendPrintId(this, printIds, sb);
                    sb.append(": ");
                    Iterator<String> iter =
                        ((Scope) this).getSymbolTable().keySet().iterator();
                    while (iter.hasNext()) {
                        sb.append(iter.next());
                        sb.append(" ");
                    }
                    sb.append("]");
                }
            } else if (this instanceof Jump) {
                Jump jump = (Jump)this;
                if (type == Token.BREAK || type == Token.CONTINUE) {
                    sb.append(" [label: ");
                    appendPrintId(jump.getJumpStatement(), printIds, sb);
                    sb.append(']');
                } else if (type == Token.TRY) {
                    Node catchNode = jump.target;
                    Node finallyTarget = jump.getFinally();
                    if (catchNode != null) {
                        sb.append(" [catch: ");
                        appendPrintId(catchNode, printIds, sb);
                        sb.append(']');
                    }
                    if (finallyTarget != null) {
                        sb.append(" [finally: ");
                        appendPrintId(finallyTarget, printIds, sb);
                        sb.append(']');
                    }
                } else if (type == Token.LABEL || type == Token.LOOP
                           || type == Token.SWITCH)
                {
                    sb.append(" [break: ");
                    appendPrintId(jump.target, printIds, sb);
                    sb.append(']');
                    if (type == Token.LOOP) {
                        sb.append(" [continue: ");
                        appendPrintId(jump.getContinue(), printIds, sb);
                        sb.append(']');
                    }
                } else {
                    sb.append(" [target: ");
                    appendPrintId(jump.target, printIds, sb);
                    sb.append(']');
                }
            } else if (type == Token.NUMBER) {
                sb.append(' ');
                sb.append(getDouble());
            } else if (type == Token.TARGET) {
                sb.append(' ');
                appendPrintId(this, printIds, sb);
            }
            if (lineno != -1) {
                sb.append(' ');
                sb.append(lineno);
            }

            for (PropListItem x = propListHead; x != null; x = x.next) {
                int type = x.type;
                sb.append(" [");
                sb.append(propToString(type));
                sb.append(": ");
                String value;
                switch (type) {
                  case TARGETBLOCK_PROP : // can't add this as it recurses
                    value = "target block property";
                    break;
                  case LOCAL_BLOCK_PROP :     // can't add this as it is dull
                    value = "last local block";
                    break;
                  case ISNUMBER_PROP:
                    switch (x.intValue) {
                      case BOTH:
                        value = "both";
                        break;
                      case RIGHT:
                        value = "right";
                        break;
                      case LEFT:
                        value = "left";
                        break;
                      default:
                        throw Kit.codeBug();
                    }
                    break;
                  case SPECIALCALL_PROP:
                    switch (x.intValue) {
                      case SPECIALCALL_EVAL:
                        value = "eval";
                        break;
                      case SPECIALCALL_WITH:
                        value = "with";
                        break;
                      default:
                        // NON_SPECIALCALL should not be stored
                        throw Kit.codeBug();
                    }
                    break;
                  case OBJECT_IDS_PROP: {
                    Object[] a = (Object[]) x.objectValue;
                    value = "[";
                    for (int i=0; i < a.length; i++) {
                        value += a[i].toString();
                        if (i+1 < a.length)
                            value += ", ";
                    }
                    value += "]";
                    break;
                  }
                  default :
                    Object obj = x.objectValue;
                    if (obj != null) {
                        value = obj.toString();
                    } else {
                        value = String.valueOf(x.intValue);
                    }
                    break;
                }
                sb.append(value);
                sb.append(']');
            }
        }
<span class='nc' id='L1212' title='0|0|0 - Total: 1'>    }
</span>
    public String toStringTree(ScriptNode treeTop) {
        if (Token.printTrees) {
            StringBuilder sb = new StringBuilder();
            toStringTreeHelper(treeTop, this, null, 0, sb);
            return sb.toString();
        }
<span class='nc' id='L1220' title='0|0|0 - Total: 2'>        return null;
</span>    }

    private static void toStringTreeHelper(ScriptNode treeTop, Node n,
                                           ObjToIntMap printIds,
                                           int level, StringBuilder sb)
    {
        if (Token.printTrees) {
            if (printIds == null) {
                printIds = new ObjToIntMap();
                generatePrintIds(treeTop, printIds);
            }
            for (int i = 0; i != level; ++i) {
                sb.append("    ");
            }
            n.toString(printIds, sb);
            sb.append('\n');
            for (Node cursor = n.getFirstChild(); cursor != null;
                 cursor = cursor.getNext())
            {
                if (cursor.getType() == Token.FUNCTION) {
                    int fnIndex = cursor.getExistingIntProp(Node.FUNCTION_PROP);
                    FunctionNode fn = treeTop.getFunctionNode(fnIndex);
                    toStringTreeHelper(fn, fn, null, level + 1, sb);
                } else {
                    toStringTreeHelper(treeTop, cursor, printIds, level+1, sb);
                }
            }
        }
<span class='nc' id='L1249' title='0|0|0 - Total: 1'>    }
</span>
    private static void generatePrintIds(Node n, ObjToIntMap map)
    {
        if (Token.printTrees) {
            map.put(n, map.size());
            for (Node cursor = n.getFirstChild(); cursor != null;
                 cursor = cursor.getNext())
            {
                generatePrintIds(cursor, map);
            }
        }
<span class='nc' id='L1261' title='0|0|0 - Total: 1'>    }
</span>
    private static void appendPrintId(Node n, ObjToIntMap printIds,
                                      StringBuilder sb)
    {
        if (Token.printTrees) {
            if (n != null) {
                int id = printIds.get(n, -1);
                sb.append('#');
                if (id != -1) {
                    sb.append(id + 1);
                } else {
                    sb.append("<not_available>");
                }
            }
        }
<span class='nc' id='L1277' title='0|0|0 - Total: 1'>    }
</span>
<span class='uc' id='L1279' title='15|15|15 - Total: 15'>    protected int type = Token.ERROR; // type of the node, e.g. Token.NAME
</span>    protected Node next;             // next sibling
    protected Node first;    // first element of a linked list of children
    protected Node last;     // last element of a linked list of children
<span class='uc' id='L1283' title='15|15|15 - Total: 15'>    protected int lineno = -1;
</span>
    /**
     * Linked list of properties. Since vast majority of nodes would have
     * no more then 2 properties, linked list saves memory and provides
     * fast lookup. If this does not holds, propListHead can be replaced
     * by UintMap.
     */
    protected PropListItem propListHead;
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>