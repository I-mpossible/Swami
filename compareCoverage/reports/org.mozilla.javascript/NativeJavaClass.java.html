<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.NativeJavaClass.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.NativeJavaClass.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import java.lang.reflect.*;
import java.util.Map;

/**
 * This class reflects Java classes into the JavaScript environment, mainly
 * for constructors and static members.  We lazily reflect properties,
 * and currently do not guarantee that a single j.l.Class is only
 * reflected once into the JS environment, although we should.
 * The only known case where multiple reflections
 * are possible occurs when a j.l.Class is wrapped as part of a
 * method return or property access, rather than by walking the
 * Packages/java tree.
 *
 * @author Mike Shaver
 * @see NativeJavaArray
 * @see NativeJavaObject
 * @see NativeJavaPackage
 */

public class NativeJavaClass extends NativeJavaObject implements Function
{
    static final long serialVersionUID = -6460763940409461664L;

    // Special property for getting the underlying Java class object.
    static final String javaClassPropertyName = "__javaObject__";

<span class='nc' id='L35' title='0|0|0 - Total: 2'>    public NativeJavaClass() {
</span><span class='nc' id='L36' title='0|0|0 - Total: 1'>    }
</span>
    public NativeJavaClass(Scriptable scope, Class<?> cl) {
<span class='uc' id='L39' title='5|5|5 - Total: 5'>        this(scope, cl, false);
</span><span class='uc' id='L40' title='1|1|1 - Total: 1'>    }
</span>
    public NativeJavaClass(Scriptable scope, Class<?> cl, boolean isAdapter) {
<span class='uc' id='L43' title='6|6|6 - Total: 6'>        super(scope, cl, null, isAdapter);
</span><span class='uc' id='L44' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    protected void initMembers() {
<span class='uc' id='L48' title='4|4|4 - Total: 4'>        Class<?> cl = (Class<?>)javaObject;
</span><span class='uc' id='L49' title='9|9|9 - Total: 9'>        members = JavaMembers.lookupClass(parent, cl, cl, isAdapter);
</span><span class='uc' id='L50' title='8|8|8 - Total: 8'>        staticFieldAndMethods = members.getFieldAndMethodsObjects(this, cl, true);
</span><span class='uc' id='L51' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public String getClassName() {
<span class='nc' id='L55' title='0|0|0 - Total: 2'>        return "JavaClass";
</span>    }

    @Override
    public boolean has(String name, Scriptable start) {
<span class='nc' id='L60' title='0|0|0 - Total: 4'>        return members.has(name, true) || javaClassPropertyName.equals(name);
</span>    }

    @Override
    public Object get(String name, Scriptable start) {
        // When used as a constructor, ScriptRuntime.newObject() asks
        // for our prototype to create an object of the correct type.
        // We don't really care what the object is, since we're returning
        // one constructed out of whole cloth, so we return null.
<span class='upc' id='L69' title='1|1|1 - Total: 2'>        if (name.equals("prototype"))
</span><span class='nc' id='L70' title='0|0|0 - Total: 2'>            return null;
</span>
<span class='upc' id='L72' title='1|1|1 - Total: 2'>         if (staticFieldAndMethods != null) {
</span><span class='nc' id='L73' title='0|0|0 - Total: 5'>            Object result = staticFieldAndMethods.get(name);
</span><span class='nc' id='L74' title='0|0|0 - Total: 2'>            if (result != null)
</span><span class='nc' id='L75' title='0|0|0 - Total: 2'>                return result;
</span>        }

<span class='uc' id='L78' title='2|2|2 - Total: 2'>        if (members.has(name, true)) {
</span><span class='uc' id='L79' title='9|9|9 - Total: 9'>            return members.get(this, name, javaObject, true);
</span>        }

<span class='uc' id='L82' title='2|2|2 - Total: 2'>        Context cx = Context.getContext();
</span><span class='uc' id='L83' title='3|3|3 - Total: 3'>        Scriptable scope = ScriptableObject.getTopLevelScope(start);
</span><span class='uc' id='L84' title='3|3|3 - Total: 3'>        WrapFactory wrapFactory = cx.getWrapFactory();
</span>
<span class='upc' id='L86' title='1|1|1 - Total: 2'>        if (javaClassPropertyName.equals(name)) {
</span><span class='nc' id='L87' title='0|0|0 - Total: 8'>            return wrapFactory.wrap(cx, scope, javaObject,
</span>                                    ScriptRuntime.ClassClass);
        }

        // experimental:  look for nested classes by appending $name to
        // current class' name.
<span class='uc' id='L93' title='5|5|5 - Total: 5'>        Class<?> nestedClass = findNestedClass(getClassObject(), name);
</span><span class='upc' id='L94' title='1|1|1 - Total: 2'>        if (nestedClass != null) {
</span><span class='uc' id='L95' title='6|6|6 - Total: 6'>            Scriptable nestedValue = wrapFactory.wrapJavaClass(cx, scope,
</span>                    nestedClass);
<span class='uc' id='L97' title='3|3|3 - Total: 3'>            nestedValue.setParentScope(this);
</span><span class='uc' id='L98' title='2|2|2 - Total: 2'>            return nestedValue;
</span>        }

<span class='nc' id='L101' title='0|0|0 - Total: 5'>        throw members.reportMemberNotFound(name);
</span>    }

    @Override
    public void put(String name, Scriptable start, Object value) {
<span class='nc' id='L106' title='0|0|0 - Total: 9'>        members.put(this, name, javaObject, value, true);
</span><span class='nc' id='L107' title='0|0|0 - Total: 1'>    }
</span>
    @Override
    public Object[] getIds() {
<span class='nc' id='L111' title='0|0|0 - Total: 5'>        return members.getIds(true);
</span>    }

    public Class<?> getClassObject() {
<span class='uc' id='L115' title='4|4|4 - Total: 4'>        return (Class<?>) super.unwrap();
</span>    }

    @Override
    public Object getDefaultValue(Class<?> hint) {
<span class='upc' id='L120' title='3|3|3 - Total: 4'>        if (hint == null || hint == ScriptRuntime.StringClass)
</span><span class='uc' id='L121' title='3|3|3 - Total: 3'>            return this.toString();
</span><span class='nc' id='L122' title='0|0|0 - Total: 2'>        if (hint == ScriptRuntime.BooleanClass)
</span><span class='nc' id='L123' title='0|0|0 - Total: 2'>            return Boolean.TRUE;
</span><span class='nc' id='L124' title='0|0|0 - Total: 2'>        if (hint == ScriptRuntime.NumberClass)
</span><span class='nc' id='L125' title='0|0|0 - Total: 2'>            return ScriptRuntime.NaNobj;
</span><span class='nc' id='L126' title='0|0|0 - Total: 2'>        return this;
</span>    }

    public Object call(Context cx, Scriptable scope, Scriptable thisObj,
                       Object[] args)
    {
        // If it looks like a "cast" of an object to this class type,
        // walk the prototype chain to see if there's a wrapper of a
        // object that's an instanceof this class.
<span class='nc' id='L135' title='0|0|0 - Total: 4'>        if (args.length == 1 && args[0] instanceof Scriptable) {
</span><span class='nc' id='L136' title='0|0|0 - Total: 3'>            Class<?> c = getClassObject();
</span><span class='nc' id='L137' title='0|0|0 - Total: 5'>            Scriptable p = (Scriptable) args[0];
</span>            do {
<span class='nc' id='L139' title='0|0|0 - Total: 2'>                if (p instanceof Wrapper) {
</span><span class='nc' id='L140' title='0|0|0 - Total: 4'>                    Object o = ((Wrapper) p).unwrap();
</span><span class='nc' id='L141' title='0|0|0 - Total: 2'>                    if (c.isInstance(o))
</span><span class='nc' id='L142' title='0|0|0 - Total: 2'>                        return p;
</span>                }
<span class='nc' id='L144' title='0|0|0 - Total: 3'>                p = p.getPrototype();
</span><span class='nc' id='L145' title='0|0|0 - Total: 2'>            } while (p != null);
</span>        }
<span class='nc' id='L147' title='0|0|0 - Total: 6'>        return construct(cx, scope, args);
</span>    }

    public Scriptable construct(Context cx, Scriptable scope, Object[] args)
    {
<span class='uc' id='L152' title='3|3|3 - Total: 3'>        Class<?> classObject = getClassObject();
</span><span class='uc' id='L153' title='3|3|3 - Total: 3'>        int modifiers = classObject.getModifiers();
</span><span class='uc' id='L154' title='2|2|2 - Total: 2'>        if (! (Modifier.isInterface(modifiers) ||
</span><span class='uc' id='L155' title='2|2|2 - Total: 2'>               Modifier.isAbstract(modifiers)))
</span>        {
<span class='uc' id='L157' title='4|4|4 - Total: 4'>            NativeJavaMethod ctors = members.ctors;
</span><span class='uc' id='L158' title='5|5|5 - Total: 5'>            int index = ctors.findCachedFunction(cx, args);
</span><span class='upc' id='L159' title='1|1|1 - Total: 2'>            if (index < 0) {
</span><span class='nc' id='L160' title='0|0|0 - Total: 3'>                String sig = NativeJavaMethod.scriptSignature(args);
</span><span class='nc' id='L161' title='0|0|0 - Total: 4'>                throw Context.reportRuntimeError2(
</span><span class='nc' id='L162' title='0|0|0 - Total: 2'>                    "msg.no.java.ctor", classObject.getName(), sig);
</span>            }

            // Found the constructor, so try invoking it.
<span class='uc' id='L166' title='9|9|9 - Total: 9'>            return constructSpecific(cx, scope, args, ctors.methods[index]);
</span>        } else {
<span class='upc' id='L168' title='1|1|1 - Total: 2'>            if (args.length == 0) {
</span><span class='nc' id='L169' title='0|0|0 - Total: 3'>                throw Context.reportRuntimeError0("msg.adapter.zero.args");
</span>            }
<span class='uc' id='L171' title='3|3|3 - Total: 3'>            Scriptable topLevel = ScriptableObject.getTopLevelScope(this);
</span><span class='uc' id='L172' title='2|2|2 - Total: 2'>            String msg = "";
</span>            try {
                // When running on Android create an InterfaceAdapter since our
                // bytecode generation won't work on Dalvik VM.
<span class='upc' id='L176' title='1|1|1 - Total: 2'>                if ("Dalvik".equals(System.getProperty("java.vm.name"))
</span><span class='nc' id='L177' title='0|0|0 - Total: 2'>                        && classObject.isInterface()) {
</span><span class='nc' id='L178' title='0|0|0 - Total: 6'>                    Object obj = createInterfaceAdapter(classObject,
</span><span class='nc' id='L179' title='0|0|0 - Total: 1'>                            ScriptableObject.ensureScriptableObject(args[0]));
</span><span class='nc' id='L180' title='0|0|0 - Total: 8'>                    return cx.getWrapFactory().wrapAsJavaObject(cx, scope, obj, null);
</span>                }
                // use JavaAdapter to construct a new class on the fly that
                // implements/extends this interface/abstract class.
<span class='uc' id='L184' title='5|5|5 - Total: 5'>                Object v = topLevel.get("JavaAdapter", topLevel);
</span><span class='upc' id='L185' title='1|1|1 - Total: 2'>                if (v != NOT_FOUND) {
</span><span class='uc' id='L186' title='3|3|3 - Total: 3'>                    Function f = (Function) v;
</span>                    // Args are (interface, js object)
<span class='uc' id='L188' title='13|13|13 - Total: 13'>                    Object[] adapterArgs = { this, args[0] };
</span><span class='uc' id='L189' title='6|6|6 - Total: 6'>                    return f.construct(cx, topLevel, adapterArgs);
</span>                }
<span class='nc' id='L191' title='0|0|0 - Total: 1'>            } catch (Exception ex) {
</span>                // fall through to error
<span class='nc' id='L193' title='0|0|0 - Total: 3'>                String m = ex.getMessage();
</span><span class='nc' id='L194' title='0|0|0 - Total: 2'>                if (m != null)
</span><span class='nc' id='L195' title='0|0|0 - Total: 2'>                    msg = m;
</span><span class='nc' id='L196' title='0|0|0 - Total: 1'>            }
</span><span class='nc' id='L197' title='0|0|0 - Total: 5'>            throw Context.reportRuntimeError2(
</span><span class='nc' id='L198' title='0|0|0 - Total: 1'>                "msg.cant.instantiate", msg, classObject.getName());
</span>        }
    }

    static Scriptable constructSpecific(Context cx, Scriptable scope,
                                        Object[] args, MemberBox ctor)
    {
<span class='uc' id='L205' title='4|4|4 - Total: 4'>        Object instance = constructInternal(args, ctor);
</span>        // we need to force this to be wrapped, because construct _has_
        // to return a scriptable
<span class='uc' id='L208' title='3|3|3 - Total: 3'>        Scriptable topLevel = ScriptableObject.getTopLevelScope(scope);
</span><span class='uc' id='L209' title='7|7|7 - Total: 7'>        return cx.getWrapFactory().wrapNewObject(cx, topLevel, instance);
</span>    }

    static Object constructInternal(Object[] args, MemberBox ctor)
    {
<span class='uc' id='L214' title='3|3|3 - Total: 3'>        Class<?>[] argTypes = ctor.argTypes;
</span>
<span class='upc' id='L216' title='1|1|1 - Total: 2'>        if (ctor.vararg) {
</span>            // marshall the explicit parameter
<span class='nc' id='L218' title='0|0|0 - Total: 4'>            Object[] newArgs = new Object[argTypes.length];
</span><span class='nc' id='L219' title='0|0|0 - Total: 2'>            for (int i = 0; i < argTypes.length-1; i++) {
</span><span class='nc' id='L220' title='0|0|0 - Total: 10'>                newArgs[i] = Context.jsToJava(args[i], argTypes[i]);
</span>            }

            Object varArgs;

            // Handle special situation where a single variable parameter
            // is given and it is a Java or ECMA array.
<span class='nc' id='L227' title='0|0|0 - Total: 8'>            if (args.length == argTypes.length &&
</span>                (args[args.length-1] == null ||
                 args[args.length-1] instanceof NativeArray ||
                 args[args.length-1] instanceof NativeJavaArray))
            {
                // convert the ECMA array into a native array
<span class='nc' id='L233' title='0|0|0 - Total: 15'>                varArgs = Context.jsToJava(args[args.length-1],
</span>                                           argTypes[argTypes.length - 1]);
            } else {
                // marshall the variable parameter
<span class='nc' id='L237' title='0|0|0 - Total: 6'>                Class<?> componentType = argTypes[argTypes.length - 1].
</span><span class='nc' id='L238' title='0|0|0 - Total: 2'>                                        getComponentType();
</span><span class='nc' id='L239' title='0|0|0 - Total: 10'>                varArgs = Array.newInstance(componentType,
</span>                                            args.length - argTypes.length + 1);
<span class='nc' id='L241' title='0|0|0 - Total: 2'>                for (int i=0; i < Array.getLength(varArgs); i++) {
</span><span class='nc' id='L242' title='0|0|0 - Total: 11'>                    Object value = Context.jsToJava(args[argTypes.length-1 + i],
</span>                                                    componentType);
<span class='nc' id='L244' title='0|0|0 - Total: 4'>                    Array.set(varArgs, i, value);
</span>                }
            }

            // add varargs
<span class='nc' id='L249' title='0|0|0 - Total: 7'>            newArgs[argTypes.length-1] = varArgs;
</span>            // replace the original args with the new one
<span class='nc' id='L251' title='0|0|0 - Total: 2'>            args = newArgs;
</span><span class='nc' id='L252' title='0|0|0 - Total: 1'>        } else {
</span><span class='uc' id='L253' title='2|2|2 - Total: 2'>            Object[] origArgs = args;
</span><span class='uc' id='L254' title='2|2|2 - Total: 2'>            for (int i = 0; i < args.length; i++) {
</span><span class='uc' id='L255' title='4|4|4 - Total: 4'>                Object arg = args[i];
</span><span class='uc' id='L256' title='6|6|6 - Total: 6'>                Object x = Context.jsToJava(arg, argTypes[i]);
</span><span class='uc' id='L257' title='2|2|2 - Total: 2'>                if (x != arg) {
</span><span class='uc' id='L258' title='2|2|2 - Total: 2'>                    if (args == origArgs) {
</span><span class='uc' id='L259' title='4|4|4 - Total: 4'>                        args = origArgs.clone();
</span>                    }
<span class='uc' id='L261' title='4|4|4 - Total: 4'>                    args[i] = x;
</span>                }
            }
        }

<span class='uc' id='L266' title='4|4|4 - Total: 4'>        return ctor.newInstance(args);
</span>    }

    @Override
    public String toString() {
<span class='uc' id='L271' title='13|13|13 - Total: 13'>        return "[JavaClass " + getClassObject().getName() + "]";
</span>    }

    /**
     * Determines if prototype is a wrapped Java object and performs
     * a Java "instanceof".
     * Exception: if value is an instance of NativeJavaClass, it isn't
     * considered an instance of the Java class; this forestalls any
     * name conflicts between java.lang.Class's methods and the
     * static methods exposed by a JavaNativeClass.
     */
    @Override
    public boolean hasInstance(Scriptable value) {

<span class='upc' id='L285' title='3|3|3 - Total: 4'>        if (value instanceof Wrapper &&
</span>            !(value instanceof NativeJavaClass)) {
<span class='uc' id='L287' title='4|4|4 - Total: 4'>            Object instance = ((Wrapper)value).unwrap();
</span>
<span class='uc' id='L289' title='5|5|5 - Total: 5'>            return getClassObject().isInstance(instance);
</span>        }

        // value wasn't something we understand
<span class='uc' id='L293' title='2|2|2 - Total: 2'>        return false;
</span>    }

    private static Class<?> findNestedClass(Class<?> parentClass, String name) {
<span class='uc' id='L297' title='12|12|12 - Total: 12'>        String nestedClassName = parentClass.getName() + '$' + name;
</span><span class='uc' id='L298' title='3|3|3 - Total: 3'>        ClassLoader loader = parentClass.getClassLoader();
</span><span class='upc' id='L299' title='1|1|1 - Total: 2'>        if (loader == null) {
</span>            // ALERT: if loader is null, nested class should be loaded
            // via system class loader which can be different from the
            // loader that brought Rhino classes that Class.forName() would
            // use, but ClassLoader.getSystemClassLoader() is Java 2 only
<span class='nc' id='L304' title='0|0|0 - Total: 3'>            return Kit.classOrNull(nestedClassName);
</span>        } else {
<span class='uc' id='L306' title='4|4|4 - Total: 4'>            return Kit.classOrNull(loader, nestedClassName);
</span>        }
    }

    private Map<String,FieldAndMethods> staticFieldAndMethods;
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>