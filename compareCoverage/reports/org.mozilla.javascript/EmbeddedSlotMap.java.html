<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.EmbeddedSlotMap.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.EmbeddedSlotMap.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

/*
 * This class implements the SlotMap interface using an embedded hash table. This hash table
 * has the minimum overhead needed to get the job done. In particular, it embeds the Slot
 * directly into the hash table rather than creating an intermediate object, which seems
 * to have a measurable performance benefit.
 */

import java.util.Iterator;
import static org.mozilla.javascript.ScriptableObject.SlotAccess.*;

public class EmbeddedSlotMap
    implements SlotMap {

    private ScriptableObject.Slot[] slots;

    // gateways into the definition-order linked list of slots
    private ScriptableObject.Slot firstAdded;
    private ScriptableObject.Slot lastAdded;

    private int count;

    // initial slot array size, must be a power of 2
    private static final int INITIAL_SLOT_SIZE = 4;

    private static final class Iter
        implements Iterator<ScriptableObject.Slot>
    {
        private ScriptableObject.Slot next;

        Iter(ScriptableObject.Slot slot) {
            next = slot;
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public ScriptableObject.Slot next() {
            ScriptableObject.Slot ret = next;
            next = next.orderedNext;
            return ret;
        }
    }

    public EmbeddedSlotMap()
<span class='uc' id='L56' title='2|2|2 - Total: 2'>    {
</span><span class='uc' id='L57' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public int size() {
<span class='uc' id='L61' title='3|3|3 - Total: 3'>        return count;
</span>    }

    @Override
    public boolean isEmpty() {
<span class='uc' id='L66' title='2|2|2 - Total: 2'>        return count == 0;
</span>    }

    @Override
    public Iterator<ScriptableObject.Slot> iterator() {
<span class='uc' id='L71' title='6|6|6 - Total: 6'>        return new Iter(firstAdded);
</span>    }

    /**
     * Locate the slot with the given name or index.
     */
    @Override
    public ScriptableObject.Slot query(Object key, int index)
    {
<span class='uc' id='L80' title='2|2|2 - Total: 2'>        if (slots == null) {
</span><span class='uc' id='L81' title='2|2|2 - Total: 2'>            return null;
</span>        }

<span class='uc' id='L84' title='2|2|2 - Total: 2'>        final int indexOrHash = (key != null ? key.hashCode() : index);
</span><span class='uc' id='L85' title='6|6|6 - Total: 6'>        final int slotIndex = getSlotIndex(slots.length, indexOrHash);
</span><span class='uc' id='L86' title='5|5|5 - Total: 5'>        for (ScriptableObject.Slot slot = slots[slotIndex];
</span><span class='uc' id='L87' title='2|2|2 - Total: 2'>            slot != null;
</span><span class='uc' id='L88' title='4|4|4 - Total: 4'>            slot = slot.next) {
</span><span class='uc' id='L89' title='3|3|3 - Total: 3'>            Object skey = slot.name;
</span><span class='uc' id='L90' title='6|6|6 - Total: 6'>            if (indexOrHash == slot.indexOrHash &&
</span>                (skey == key ||
<span class='uc' id='L92' title='2|2|2 - Total: 2'>                    (key != null && key.equals(skey)))) {
</span><span class='uc' id='L93' title='2|2|2 - Total: 2'>                return slot;
</span>            }
        }
<span class='uc' id='L96' title='2|2|2 - Total: 2'>        return null;
</span>    }

    /**
     * Locate the slot with given name or index. Depending on the accessType
     * parameter and the current slot status, a new slot may be allocated.
     *
     * @param key either a String or a Symbol object that identifies the property
     * @param index index or 0 if slot holds property name.
     */
    @Override
    public ScriptableObject.Slot get(Object key, int index, ScriptableObject.SlotAccess accessType)
    {
<span class='uc' id='L109' title='4|4|4 - Total: 4'>        if (slots == null && accessType == QUERY) {
</span><span class='uc' id='L110' title='2|2|2 - Total: 2'>            return null;
</span>        }

<span class='uc' id='L113' title='2|2|2 - Total: 2'>        final int indexOrHash = (key != null ? key.hashCode() : index);
</span><span class='uc' id='L114' title='2|2|2 - Total: 2'>        ScriptableObject.Slot slot = null;
</span>
<span class='uc' id='L116' title='2|2|2 - Total: 2'>        if (slots != null) {
</span><span class='uc' id='L117' title='6|6|6 - Total: 6'>            final int slotIndex = getSlotIndex(slots.length, indexOrHash);
</span><span class='uc' id='L118' title='5|5|5 - Total: 5'>            for (slot = slots[slotIndex];
</span><span class='uc' id='L119' title='2|2|2 - Total: 2'>                 slot != null;
</span><span class='uc' id='L120' title='4|4|4 - Total: 4'>                 slot = slot.next) {
</span><span class='uc' id='L121' title='3|3|3 - Total: 3'>                Object skey = slot.name;
</span><span class='uc' id='L122' title='6|6|6 - Total: 6'>                if (indexOrHash == slot.indexOrHash &&
</span>                        (skey == key ||
<span class='uc' id='L124' title='2|2|2 - Total: 2'>                                (key != null && key.equals(skey)))) {
</span><span class='uc' id='L125' title='1|1|1 - Total: 1'>                    break;
</span>                }
            }
<span class='upc' id='L128' title='4|4|4 - Total: 5'>            switch (accessType) {
</span>                case QUERY:
<span class='uc' id='L130' title='2|2|2 - Total: 2'>                    return slot;
</span>                case MODIFY:
                case MODIFY_CONST:
<span class='uc' id='L133' title='2|2|2 - Total: 2'>                    if (slot != null) {
</span><span class='uc' id='L134' title='2|2|2 - Total: 2'>                        return slot;
</span>                    }
                    break;
                case MODIFY_GETTER_SETTER:
<span class='uc' id='L138' title='2|2|2 - Total: 2'>                    if (slot instanceof ScriptableObject.GetterSlot) {
</span><span class='uc' id='L139' title='2|2|2 - Total: 2'>                        return slot;
</span>                    }
                    break;
                case CONVERT_ACCESSOR_TO_DATA:
<span class='upc' id='L143' title='1|1|1 - Total: 2'>                    if ( !(slot instanceof ScriptableObject.GetterSlot) ) {
</span><span class='nc' id='L144' title='0|0|0 - Total: 2'>                        return slot;
</span>                    }
                    break;
            }
        }

        // A new slot has to be inserted or the old has to be replaced
        // by GetterSlot. Time to synchronize.
<span class='uc' id='L152' title='7|7|7 - Total: 7'>        return createSlot(key, indexOrHash, accessType, slot);
</span>    }

    private ScriptableObject.Slot createSlot(Object key, int indexOrHash,
        ScriptableObject.SlotAccess accessType, ScriptableObject.Slot existingSlot) {
<span class='uc' id='L157' title='2|2|2 - Total: 2'>        if (count == 0) {
</span>            // Always throw away old slots if any on empty insert.
<span class='uc' id='L159' title='5|5|5 - Total: 5'>            slots = new ScriptableObject.Slot[INITIAL_SLOT_SIZE];
</span><span class='uc' id='L160' title='2|2|2 - Total: 2'>        } else if (existingSlot != null) {
</span>            // Re-search the slot list because it is a singly-linked list to find
            // where to replace it with a new object if necessary
<span class='uc' id='L163' title='6|6|6 - Total: 6'>            final int insertPos = getSlotIndex(slots.length, indexOrHash);
</span><span class='uc' id='L164' title='5|5|5 - Total: 5'>            ScriptableObject.Slot prev = slots[insertPos];
</span><span class='uc' id='L165' title='2|2|2 - Total: 2'>            ScriptableObject.Slot slot = prev;
</span><span class='upc' id='L166' title='1|1|1 - Total: 2'>            while (slot != null) {
</span><span class='upc' id='L167' title='4|4|4 - Total: 6'>                if (slot.indexOrHash == indexOrHash &&
</span>                    (slot.name == key ||
<span class='upc' id='L169' title='1|1|1 - Total: 2'>                        (key != null && key.equals(slot.name)))) {
</span><span class='uc' id='L170' title='1|1|1 - Total: 1'>                    break;
</span>                }
<span class='nc' id='L172' title='0|0|0 - Total: 2'>                prev = slot;
</span><span class='nc' id='L173' title='0|0|0 - Total: 4'>                slot = slot.next;
</span>            }

<span class='upc' id='L176' title='1|1|1 - Total: 2'>            if (slot != null) {
</span>                // A slot with same name/index already exists. This means that
                // a slot is being redefined from a value to a getter slot or
                // vice versa, or it could be a race in application code.
                // Check if we need to replace the slot depending on the
                // accessType flag and return the appropriate slot instance.
                ScriptableObject.Slot newSlot;

<span class='upc' id='L184' title='3|3|3 - Total: 4'>                if (accessType == MODIFY_GETTER_SETTER
</span>                    && !(slot instanceof ScriptableObject.GetterSlot)) {
<span class='uc' id='L186' title='5|5|5 - Total: 5'>                    newSlot = new ScriptableObject.GetterSlot(key, indexOrHash,
</span><span class='uc' id='L187' title='4|4|4 - Total: 4'>                        slot.getAttributes());
</span><span class='upc' id='L188' title='2|2|2 - Total: 4'>                } else if (accessType == CONVERT_ACCESSOR_TO_DATA
</span>                    && (slot instanceof ScriptableObject.GetterSlot)) {
<span class='uc' id='L190' title='9|9|9 - Total: 9'>                    newSlot = new ScriptableObject.Slot(key, indexOrHash, slot.getAttributes());
</span><span class='nc' id='L191' title='0|0|0 - Total: 2'>                } else if (accessType == MODIFY_CONST) {
</span><span class='nc' id='L192' title='0|0|0 - Total: 2'>                    return null;
</span>                } else {
<span class='nc' id='L194' title='0|0|0 - Total: 2'>                    return slot;
</span>                }

<span class='uc' id='L197' title='4|4|4 - Total: 4'>                newSlot.value = slot.value;
</span><span class='uc' id='L198' title='4|4|4 - Total: 4'>                newSlot.next = slot.next;
</span>
                // Replace new slot in linked list, keeping same order
<span class='uc' id='L201' title='2|2|2 - Total: 2'>                if (slot == firstAdded) {
</span><span class='uc' id='L202' title='4|4|4 - Total: 4'>                    firstAdded = newSlot;
</span>                } else {
<span class='uc' id='L204' title='3|3|3 - Total: 3'>                    ScriptableObject.Slot ps = firstAdded;
</span><span class='upc' id='L205' title='3|3|3 - Total: 4'>                    while ((ps != null) && (ps.orderedNext != slot)) {
</span><span class='uc' id='L206' title='4|4|4 - Total: 4'>                        ps = ps.orderedNext;
</span>                    }
<span class='upc' id='L208' title='1|1|1 - Total: 2'>                    if (ps != null) {
</span><span class='uc' id='L209' title='3|3|3 - Total: 3'>                        ps.orderedNext = newSlot;
</span>                    }
                }
<span class='uc' id='L212' title='4|4|4 - Total: 4'>                newSlot.orderedNext = slot.orderedNext;
</span><span class='uc' id='L213' title='2|2|2 - Total: 2'>                if (slot == lastAdded) {
</span><span class='uc' id='L214' title='3|3|3 - Total: 3'>                    lastAdded = newSlot;
</span>                }

                // add new slot to hash table
<span class='upc' id='L218' title='1|1|1 - Total: 2'>                if (prev == slot) {
</span><span class='uc' id='L219' title='6|6|6 - Total: 6'>                    slots[insertPos] = newSlot;
</span>                } else {
<span class='nc' id='L221' title='0|0|0 - Total: 3'>                    prev.next = newSlot;
</span>                }
<span class='uc' id='L223' title='2|2|2 - Total: 2'>                return newSlot;
</span>            }
        }

        // If we get here, then we are going to insert a new slot
        // Check if the table is not too full before inserting.
<span class='uc' id='L229' title='2|2|2 - Total: 2'>        if (4 * (count + 1) > 3 * slots.length) {
</span>            // table size must be a power of 2 -- always grow by x2!
<span class='uc' id='L231' title='7|7|7 - Total: 7'>            ScriptableObject.Slot[] newSlots = new ScriptableObject.Slot[slots.length * 2];
</span><span class='uc' id='L232' title='5|5|5 - Total: 5'>            copyTable(slots, newSlots);
</span><span class='uc' id='L233' title='3|3|3 - Total: 3'>            slots = newSlots;
</span>        }

<span class='uc' id='L236' title='2|2|2 - Total: 2'>        ScriptableObject.Slot newSlot = (accessType == MODIFY_GETTER_SETTER
</span>                ? new ScriptableObject.GetterSlot(key, indexOrHash, 0)
                : new ScriptableObject.Slot(key, indexOrHash, 0));
<span class='uc' id='L239' title='2|2|2 - Total: 2'>        if (accessType == MODIFY_CONST) {
</span><span class='uc' id='L240' title='3|3|3 - Total: 3'>            newSlot.setAttributes(ScriptableObject.CONST);
</span>        }
<span class='uc' id='L242' title='3|3|3 - Total: 3'>        insertNewSlot(newSlot);
</span><span class='uc' id='L243' title='2|2|2 - Total: 2'>        return newSlot;
</span>    }

    @Override
    public void addSlot(ScriptableObject.Slot newSlot) {
<span class='uc' id='L248' title='2|2|2 - Total: 2'>        if (slots == null) {
</span><span class='uc' id='L249' title='4|4|4 - Total: 4'>            slots = new ScriptableObject.Slot[INITIAL_SLOT_SIZE];
</span>        }
<span class='uc' id='L251' title='3|3|3 - Total: 3'>        insertNewSlot(newSlot);
</span><span class='uc' id='L252' title='1|1|1 - Total: 1'>    }
</span>
    private void insertNewSlot(ScriptableObject.Slot newSlot) {
<span class='uc' id='L255' title='6|6|6 - Total: 6'>        ++count;
</span>        // add new slot to linked list
<span class='uc' id='L257' title='2|2|2 - Total: 2'>        if (lastAdded != null) {
</span><span class='uc' id='L258' title='4|4|4 - Total: 4'>            lastAdded.orderedNext = newSlot;
</span>        }
<span class='uc' id='L260' title='2|2|2 - Total: 2'>        if (firstAdded == null) {
</span><span class='uc' id='L261' title='3|3|3 - Total: 3'>            firstAdded = newSlot;
</span>        }
<span class='uc' id='L263' title='3|3|3 - Total: 3'>        lastAdded = newSlot;
</span>        // add new slot to hash table, return it
<span class='uc' id='L265' title='5|5|5 - Total: 5'>        addKnownAbsentSlot(slots, newSlot);
</span><span class='uc' id='L266' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public void remove(Object key, int index) {
<span class='uc' id='L270' title='2|2|2 - Total: 2'>        int indexOrHash = (key != null ? key.hashCode() : index);
</span>
<span class='uc' id='L272' title='2|2|2 - Total: 2'>        if (count != 0) {
</span><span class='uc' id='L273' title='6|6|6 - Total: 6'>            final int slotIndex = getSlotIndex(slots.length, indexOrHash);
</span><span class='uc' id='L274' title='5|5|5 - Total: 5'>            ScriptableObject.Slot prev = slots[slotIndex];
</span><span class='uc' id='L275' title='2|2|2 - Total: 2'>            ScriptableObject.Slot slot = prev;
</span><span class='uc' id='L276' title='2|2|2 - Total: 2'>            while (slot != null) {
</span><span class='upc' id='L277' title='5|5|5 - Total: 6'>                if (slot.indexOrHash == indexOrHash &&
</span>                        (slot.name == key ||
<span class='upc' id='L279' title='1|1|1 - Total: 2'>                                (key != null && key.equals(slot.name))))
</span>                {
<span class='uc' id='L281' title='1|1|1 - Total: 1'>                    break;
</span>                }
<span class='uc' id='L283' title='2|2|2 - Total: 2'>                prev = slot;
</span><span class='uc' id='L284' title='4|4|4 - Total: 4'>                slot = slot.next;
</span>            }
<span class='uc' id='L286' title='2|2|2 - Total: 2'>            if (slot != null) {
</span>                // non-configurable
<span class='uc' id='L288' title='2|2|2 - Total: 2'>                if ((slot.getAttributes() & ScriptableObject.PERMANENT) != 0) {
</span><span class='uc' id='L289' title='2|2|2 - Total: 2'>                    Context cx = Context.getContext();
</span><span class='upc' id='L290' title='1|1|1 - Total: 2'>                    if (cx.isStrictMode()) {
</span><span class='nc' id='L291' title='0|0|0 - Total: 4'>                        throw ScriptRuntime.typeError1("msg.delete.property.with.configurable.false", key);
</span>                    }
<span class='uc' id='L293' title='1|1|1 - Total: 1'>                    return;
</span>                }
<span class='uc' id='L295' title='6|6|6 - Total: 6'>                count--;
</span>                // remove slot from hash table
<span class='uc' id='L297' title='2|2|2 - Total: 2'>                if (prev == slot) {
</span><span class='uc' id='L298' title='7|7|7 - Total: 7'>                    slots[slotIndex] = slot.next;
</span>                } else {
<span class='uc' id='L300' title='4|4|4 - Total: 4'>                    prev.next = slot.next;
</span>                }

                // remove from ordered list. Previously this was done lazily in
                // getIds() but delete is an infrequent operation so O(n)
                // should be ok

                // ordered list always uses the actual slot
<span class='uc' id='L308' title='2|2|2 - Total: 2'>                if (slot == firstAdded) {
</span><span class='uc' id='L309' title='2|2|2 - Total: 2'>                    prev = null;
</span><span class='uc' id='L310' title='5|5|5 - Total: 5'>                    firstAdded = slot.orderedNext;
</span>                } else {
<span class='uc' id='L312' title='3|3|3 - Total: 3'>                    prev = firstAdded;
</span><span class='uc' id='L313' title='2|2|2 - Total: 2'>                    while (prev.orderedNext != slot) {
</span><span class='uc' id='L314' title='4|4|4 - Total: 4'>                        prev = prev.orderedNext;
</span>                    }
<span class='uc' id='L316' title='4|4|4 - Total: 4'>                    prev.orderedNext = slot.orderedNext;
</span>                }
<span class='uc' id='L318' title='2|2|2 - Total: 2'>                if (slot == lastAdded) {
</span><span class='uc' id='L319' title='3|3|3 - Total: 3'>                    lastAdded = prev;
</span>                }
            }
        }
<span class='uc' id='L323' title='1|1|1 - Total: 1'>    }
</span>
    private void copyTable(ScriptableObject.Slot[] oldSlots, ScriptableObject.Slot[] newSlots)
    {
<span class='uc' id='L327' title='2|2|2 - Total: 2'>        for (ScriptableObject.Slot slot : oldSlots) {
</span><span class='uc' id='L328' title='2|2|2 - Total: 2'>            while (slot != null) {
</span><span class='uc' id='L329' title='3|3|3 - Total: 3'>                ScriptableObject.Slot nextSlot = slot.next;
</span><span class='uc' id='L330' title='3|3|3 - Total: 3'>                slot.next = null;
</span><span class='uc' id='L331' title='4|4|4 - Total: 4'>                addKnownAbsentSlot(newSlots, slot);
</span><span class='uc' id='L332' title='2|2|2 - Total: 2'>                slot = nextSlot;
</span><span class='uc' id='L333' title='1|1|1 - Total: 1'>            }
</span>        }
<span class='uc' id='L335' title='1|1|1 - Total: 1'>    }
</span>
    /**
     * Add slot with keys that are known to absent from the table.
     * This is an optimization to use when inserting into empty table,
     * after table growth or during deserialization.
     */
    private void addKnownAbsentSlot(ScriptableObject.Slot[] addSlots, ScriptableObject.Slot slot)
    {
<span class='uc' id='L344' title='6|6|6 - Total: 6'>        final int insertPos = getSlotIndex(addSlots.length, slot.indexOrHash);
</span><span class='uc' id='L345' title='4|4|4 - Total: 4'>        ScriptableObject.Slot old = addSlots[insertPos];
</span><span class='uc' id='L346' title='4|4|4 - Total: 4'>        addSlots[insertPos] = slot;
</span><span class='uc' id='L347' title='3|3|3 - Total: 3'>        slot.next = old;
</span><span class='uc' id='L348' title='1|1|1 - Total: 1'>    }
</span>
    private static int getSlotIndex(int tableSize, int indexOrHash)
    {
        // This is a Java trick to efficiently "mod" the hash code by the table size.
        // It only works if the table size is a power of 2.
        // The performance improvement is measurable.
<span class='uc' id='L355' title='6|6|6 - Total: 6'>        return indexOrHash & (tableSize - 1);
</span>    }
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>