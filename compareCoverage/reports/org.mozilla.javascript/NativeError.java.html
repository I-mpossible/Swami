<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.NativeError.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.NativeError.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import java.io.Serializable;
import java.lang.reflect.Method;

/**
 *
 * The class of error objects
 *
 *  ECMA 15.11
 */
<span class='uc' id='L18' title='3|3|3 - Total: 3'>final class NativeError extends IdScriptableObject
</span>{
    static final long serialVersionUID = -5338413581437645187L;

<span class='uc' id='L22' title='2|2|2 - Total: 2'>    private static final Object ERROR_TAG = "Error";
</span>
    private static final Method ERROR_DELEGATE_GET_STACK;
    private static final Method ERROR_DELEGATE_SET_STACK;

    static {
        try {
            // Pre-cache methods to be called via reflection
<span class='uc' id='L30' title='10|10|10 - Total: 10'>            ERROR_DELEGATE_GET_STACK = NativeError.class.getMethod("getStackDelegated", Scriptable.class);
</span><span class='uc' id='L31' title='14|14|14 - Total: 14'>            ERROR_DELEGATE_SET_STACK = NativeError.class.getMethod("setStackDelegated", Scriptable.class, Object.class);
</span><span class='nc' id='L32' title='0|0|0 - Total: 1'>        } catch (NoSuchMethodException nsm) {
</span><span class='nc' id='L33' title='0|0|0 - Total: 5'>            throw new RuntimeException(nsm);
</span><span class='uc' id='L34' title='1|1|1 - Total: 1'>        }
</span><span class='uc' id='L35' title='1|1|1 - Total: 1'>    }
</span>
    /** Default stack limit is set to "Infinity", here represented as a negative int */
    public static final int DEFAULT_STACK_LIMIT = -1;

    // This is used by "captureStackTrace"
    private static final String STACK_HIDE_KEY = "_stackHide";

    private RhinoException stackProvider;

    static void init(Scriptable scope, boolean sealed)
    {
<span class='uc' id='L47' title='4|4|4 - Total: 4'>        NativeError obj = new NativeError();
</span><span class='uc' id='L48' title='4|4|4 - Total: 4'>        ScriptableObject.putProperty(obj, "name", "Error");
</span><span class='uc' id='L49' title='4|4|4 - Total: 4'>        ScriptableObject.putProperty(obj, "message", "");
</span><span class='uc' id='L50' title='4|4|4 - Total: 4'>        ScriptableObject.putProperty(obj, "fileName", "");
</span><span class='uc' id='L51' title='5|5|5 - Total: 5'>        ScriptableObject.putProperty(obj, "lineNumber", Integer.valueOf(0));
</span><span class='uc' id='L52' title='4|4|4 - Total: 4'>        obj.setAttributes("name", ScriptableObject.DONTENUM);
</span><span class='uc' id='L53' title='4|4|4 - Total: 4'>        obj.setAttributes("message", ScriptableObject.DONTENUM);
</span><span class='uc' id='L54' title='6|6|6 - Total: 6'>        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
</span><span class='uc' id='L55' title='3|3|3 - Total: 3'>        NativeCallSite.init(obj, sealed);
</span><span class='uc' id='L56' title='1|1|1 - Total: 1'>    }
</span>
    static NativeError make(Context cx, Scriptable scope,
                            IdFunctionObject ctorObj, Object[] args)
    {
<span class='uc' id='L61' title='7|7|7 - Total: 7'>        Scriptable proto = (Scriptable)(ctorObj.get("prototype", ctorObj));
</span>
<span class='uc' id='L63' title='4|4|4 - Total: 4'>        NativeError obj = new NativeError();
</span><span class='uc' id='L64' title='3|3|3 - Total: 3'>        obj.setPrototype(proto);
</span><span class='uc' id='L65' title='3|3|3 - Total: 3'>        obj.setParentScope(scope);
</span>
<span class='uc' id='L67' title='3|3|3 - Total: 3'>        int arglen = args.length;
</span><span class='uc' id='L68' title='2|2|2 - Total: 2'>        if (arglen >= 1) {
</span><span class='uc' id='L69' title='2|2|2 - Total: 2'>            if (args[0] != Undefined.instance) {
</span><span class='uc' id='L70' title='6|6|6 - Total: 6'>                ScriptableObject.putProperty(obj, "message",
</span><span class='uc' id='L71' title='1|1|1 - Total: 1'>                        ScriptRuntime.toString(args[0]));
</span>            }
<span class='uc' id='L73' title='2|2|2 - Total: 2'>            if (arglen >= 2) {
</span><span class='uc' id='L74' title='6|6|6 - Total: 6'>                ScriptableObject.putProperty(obj, "fileName", args[1]);
</span><span class='uc' id='L75' title='2|2|2 - Total: 2'>                if (arglen >= 3) {
</span><span class='uc' id='L76' title='5|5|5 - Total: 5'>                    int line = ScriptRuntime.toInt32(args[2]);
</span><span class='uc' id='L77' title='4|4|4 - Total: 4'>                    ScriptableObject.putProperty(obj, "lineNumber",
</span><span class='uc' id='L78' title='1|1|1 - Total: 1'>                            Integer.valueOf(line));
</span>                }
            }
        }
<span class='uc' id='L82' title='2|2|2 - Total: 2'>        return obj;
</span>    }

    @Override
    protected void fillConstructorProperties(IdFunctionObject ctor)
    {
<span class='uc' id='L88' title='7|7|7 - Total: 7'>        addIdFunctionProperty(ctor, ERROR_TAG, ConstructorId_captureStackTrace,
</span>                                  "captureStackTrace", 2);

        // This is running on the global "Error" object. Associate an object there that can store
        // default stack trace, etc.
        // This prevents us from having to add two additional fields to every Error object.
<span class='uc' id='L94' title='5|5|5 - Total: 5'>        ProtoProps protoProps = new ProtoProps();
</span><span class='uc' id='L95' title='5|5|5 - Total: 5'>        associateValue(ProtoProps.KEY, protoProps);
</span>
        // Define constructor properties that delegate to the ProtoProps object.
<span class='uc' id='L98' title='7|7|7 - Total: 7'>        ctor.defineProperty("stackTraceLimit", protoProps,
</span>                            ProtoProps.GET_STACK_LIMIT, ProtoProps.SET_STACK_LIMIT, 0);
<span class='uc' id='L100' title='7|7|7 - Total: 7'>        ctor.defineProperty("prepareStackTrace", protoProps,
</span>                            ProtoProps.GET_PREPARE_STACK, ProtoProps.SET_PREPARE_STACK, 0);

<span class='uc' id='L103' title='3|3|3 - Total: 3'>        super.fillConstructorProperties(ctor);
</span><span class='uc' id='L104' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public String getClassName()
    {
<span class='uc' id='L109' title='2|2|2 - Total: 2'>        return "Error";
</span>    }

    @Override
    public String toString()
    {
        // According to spec, Error.prototype.toString() may return undefined.
<span class='uc' id='L116' title='3|3|3 - Total: 3'>        Object toString = js_toString(this);
</span><span class='upc' id='L117' title='1|1|1 - Total: 2'>        return toString instanceof String ? (String) toString : super.toString();
</span>    }

    @Override
    protected void initPrototypeId(int id)
    {
        String s;
        int arity;
<span class='upc' id='L125' title='3|3|3 - Total: 4'>        switch (id) {
</span><span class='uc' id='L126' title='5|5|5 - Total: 5'>          case Id_constructor: arity=1; s="constructor"; break;
</span><span class='uc' id='L127' title='5|5|5 - Total: 5'>          case Id_toString:    arity=0; s="toString";    break;
</span><span class='uc' id='L128' title='5|5|5 - Total: 5'>          case Id_toSource:    arity=0; s="toSource";    break;
</span><span class='nc' id='L129' title='0|0|0 - Total: 6'>          default: throw new IllegalArgumentException(String.valueOf(id));
</span>        }
<span class='uc' id='L131' title='7|7|7 - Total: 7'>        initPrototypeMethod(ERROR_TAG, id, s, arity);
</span><span class='uc' id='L132' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,
                             Scriptable thisObj, Object[] args)
    {
<span class='upc' id='L138' title='1|1|1 - Total: 2'>        if (!f.hasTag(ERROR_TAG)) {
</span><span class='nc' id='L139' title='0|0|0 - Total: 8'>            return super.execIdCall(f, cx, scope, thisObj, args);
</span>        }
<span class='uc' id='L141' title='3|3|3 - Total: 3'>        int id = f.methodId();
</span><span class='upc' id='L142' title='4|4|4 - Total: 5'>        switch (id) {
</span>          case Id_constructor:
<span class='uc' id='L144' title='6|6|6 - Total: 6'>            return make(cx, scope, f, args);
</span>
          case Id_toString:
<span class='uc' id='L147' title='3|3|3 - Total: 3'>            return js_toString(thisObj);
</span>
          case Id_toSource:
<span class='uc' id='L150' title='5|5|5 - Total: 5'>            return js_toSource(cx, scope, thisObj);
</span>
          case ConstructorId_captureStackTrace:
<span class='uc' id='L153' title='4|4|4 - Total: 4'>            js_captureStackTrace(cx, thisObj, args);
</span><span class='uc' id='L154' title='2|2|2 - Total: 2'>            return Undefined.instance;
</span>        }
<span class='nc' id='L156' title='0|0|0 - Total: 6'>        throw new IllegalArgumentException(String.valueOf(id));
</span>    }

    public void setStackProvider(RhinoException re) {
        // We go some extra miles to make sure the stack property is only
        // generated on demand, is cached after the first access, and is
        // overwritable like an ordinary property. Hence this setup with
        // the getter and setter below.
<span class='upc' id='L164' title='1|1|1 - Total: 2'>        if (stackProvider == null) {
</span><span class='uc' id='L165' title='3|3|3 - Total: 3'>            stackProvider = re;
</span><span class='uc' id='L166' title='7|7|7 - Total: 7'>            defineProperty("stack", this,
</span>                           ERROR_DELEGATE_GET_STACK, ERROR_DELEGATE_SET_STACK,
                           DONTENUM);
        }
<span class='uc' id='L170' title='1|1|1 - Total: 1'>    }
</span>
    public Object getStackDelegated(Scriptable target) {
<span class='upc' id='L173' title='1|1|1 - Total: 2'>        if (stackProvider == null) {
</span><span class='nc' id='L174' title='0|0|0 - Total: 2'>            return NOT_FOUND;
</span>        }

        // Get the object where prototype stuff is stored.
<span class='uc' id='L178' title='2|2|2 - Total: 2'>        int limit = DEFAULT_STACK_LIMIT;
</span><span class='uc' id='L179' title='2|2|2 - Total: 2'>        Function prepare = null;
</span><span class='uc' id='L180' title='4|4|4 - Total: 4'>        NativeError cons = (NativeError)getPrototype();
</span><span class='uc' id='L181' title='5|5|5 - Total: 5'>        ProtoProps pp = (ProtoProps)cons.getAssociatedValue(ProtoProps.KEY);
</span>
<span class='uc' id='L183' title='2|2|2 - Total: 2'>        if (pp != null) {
</span><span class='uc' id='L184' title='3|3|3 - Total: 3'>            limit = pp.getStackTraceLimit();
</span><span class='uc' id='L185' title='3|3|3 - Total: 3'>            prepare = pp.getPrepareStackTrace();
</span>        }

        // This key is only set by captureStackTrace
<span class='uc' id='L189' title='5|5|5 - Total: 5'>        String hideFunc = (String)getAssociatedValue(STACK_HIDE_KEY);
</span><span class='uc' id='L190' title='6|6|6 - Total: 6'>        ScriptStackElement[] stack = stackProvider.getScriptStack(limit, hideFunc);
</span>
        // Determine whether to format the stack trace ourselves, or call the user's code to do it
        Object value;
<span class='uc' id='L194' title='2|2|2 - Total: 2'>        if (prepare == null) {
</span><span class='uc' id='L195' title='7|7|7 - Total: 7'>            value = RhinoException.formatStackTrace(stack, stackProvider.details());
</span>        } else {
<span class='uc' id='L197' title='5|5|5 - Total: 5'>            value = callPrepareStack(prepare, stack);
</span>        }

        // We store the stack as local property both to cache it
        // and to make the property writable
<span class='uc' id='L202' title='4|4|4 - Total: 4'>        setStackDelegated(target, value);
</span><span class='uc' id='L203' title='2|2|2 - Total: 2'>        return value;
</span>    }

    public void setStackDelegated(Scriptable target, Object value) {
<span class='uc' id='L207' title='3|3|3 - Total: 3'>        target.delete("stack");
</span><span class='uc' id='L208' title='3|3|3 - Total: 3'>        stackProvider = null;
</span><span class='uc' id='L209' title='5|5|5 - Total: 5'>        target.put("stack", target, value);
</span><span class='uc' id='L210' title='1|1|1 - Total: 1'>    }
</span>
    private Object callPrepareStack(Function prepare, ScriptStackElement[] stack)
    {
<span class='uc' id='L214' title='2|2|2 - Total: 2'>        Context cx = Context.getCurrentContext();
</span><span class='uc' id='L215' title='4|4|4 - Total: 4'>        Object[] elts = new Object[stack.length];
</span>
        // The "prepareStackTrace" function takes an array of CallSite objects.
<span class='uc' id='L218' title='2|2|2 - Total: 2'>        for (int i = 0; i < stack.length; i++) {
</span><span class='uc' id='L219' title='6|6|6 - Total: 6'>            NativeCallSite site = (NativeCallSite)cx.newObject(this, "CallSite");
</span><span class='uc' id='L220' title='5|5|5 - Total: 5'>            site.setElement(stack[i]);
</span><span class='uc' id='L221' title='4|4|4 - Total: 4'>            elts[i] = site;
</span>        }

<span class='uc' id='L224' title='5|5|5 - Total: 5'>        Scriptable eltArray = cx.newArray(this, elts);
</span><span class='uc' id='L225' title='16|16|16 - Total: 16'>        return prepare.call(cx, prepare, this, new Object[] { this, eltArray });
</span>    }

    private static Object js_toString(Scriptable thisObj) {
<span class='uc' id='L229' title='4|4|4 - Total: 4'>        Object name = ScriptableObject.getProperty(thisObj, "name");
</span><span class='uc' id='L230' title='4|4|4 - Total: 4'>        if (name == NOT_FOUND || name == Undefined.instance) {
</span><span class='uc' id='L231' title='3|3|3 - Total: 3'>            name = "Error";
</span>        } else {
<span class='uc' id='L233' title='3|3|3 - Total: 3'>            name = ScriptRuntime.toString(name);
</span>        }
<span class='uc' id='L235' title='4|4|4 - Total: 4'>        Object msg = ScriptableObject.getProperty(thisObj, "message");
</span><span class='uc' id='L236' title='4|4|4 - Total: 4'>        if (msg == NOT_FOUND || msg == Undefined.instance) {
</span><span class='uc' id='L237' title='3|3|3 - Total: 3'>            msg = "";
</span>        } else {
<span class='uc' id='L239' title='3|3|3 - Total: 3'>            msg = ScriptRuntime.toString(msg);
</span>        }
<span class='upc' id='L241' title='1|1|1 - Total: 2'>        if (name.toString().length() == 0) {
</span><span class='nc' id='L242' title='0|0|0 - Total: 2'>            return msg;
</span><span class='uc' id='L243' title='2|2|2 - Total: 2'>        } else if (msg.toString().length() == 0) {
</span><span class='uc' id='L244' title='2|2|2 - Total: 2'>            return name;
</span>        } else {
<span class='uc' id='L246' title='13|13|13 - Total: 13'>            return ((String) name) + ": " + ((String) msg);
</span>        }
    }

    private static String js_toSource(Context cx, Scriptable scope,
                                      Scriptable thisObj)
    {
        // Emulation of SpiderMonkey behavior
<span class='uc' id='L254' title='4|4|4 - Total: 4'>        Object name = ScriptableObject.getProperty(thisObj, "name");
</span><span class='uc' id='L255' title='4|4|4 - Total: 4'>        Object message = ScriptableObject.getProperty(thisObj, "message");
</span><span class='uc' id='L256' title='4|4|4 - Total: 4'>        Object fileName = ScriptableObject.getProperty(thisObj, "fileName");
</span><span class='uc' id='L257' title='4|4|4 - Total: 4'>        Object lineNumber = ScriptableObject.getProperty(thisObj, "lineNumber");
</span>
<span class='uc' id='L259' title='4|4|4 - Total: 4'>        StringBuilder sb = new StringBuilder();
</span><span class='uc' id='L260' title='4|4|4 - Total: 4'>        sb.append("(new ");
</span><span class='upc' id='L261' title='1|1|1 - Total: 2'>        if (name == NOT_FOUND) {
</span><span class='nc' id='L262' title='0|0|0 - Total: 2'>            name = Undefined.instance;
</span>        }
<span class='uc' id='L264' title='5|5|5 - Total: 5'>        sb.append(ScriptRuntime.toString(name));
</span><span class='uc' id='L265' title='4|4|4 - Total: 4'>        sb.append("(");
</span><span class='upc' id='L266' title='1|1|1 - Total: 6'>        if (message != NOT_FOUND
</span>            || fileName != NOT_FOUND
            || lineNumber != NOT_FOUND)
        {
<span class='upc' id='L270' title='1|1|1 - Total: 2'>            if (message == NOT_FOUND) {
</span><span class='nc' id='L271' title='0|0|0 - Total: 2'>                message = "";
</span>            }
<span class='uc' id='L273' title='7|7|7 - Total: 7'>            sb.append(ScriptRuntime.uneval(cx, scope, message));
</span><span class='upc' id='L274' title='1|1|1 - Total: 4'>            if (fileName != NOT_FOUND || lineNumber != NOT_FOUND) {
</span><span class='uc' id='L275' title='4|4|4 - Total: 4'>                sb.append(", ");
</span><span class='upc' id='L276' title='1|1|1 - Total: 2'>                if (fileName == NOT_FOUND) {
</span><span class='nc' id='L277' title='0|0|0 - Total: 2'>                    fileName = "";
</span>                }
<span class='uc' id='L279' title='7|7|7 - Total: 7'>                sb.append(ScriptRuntime.uneval(cx, scope, fileName));
</span><span class='upc' id='L280' title='1|1|1 - Total: 2'>                if (lineNumber != NOT_FOUND) {
</span><span class='uc' id='L281' title='3|3|3 - Total: 3'>                    int line = ScriptRuntime.toInt32(lineNumber);
</span><span class='uc' id='L282' title='2|2|2 - Total: 2'>                    if (line != 0) {
</span><span class='uc' id='L283' title='4|4|4 - Total: 4'>                        sb.append(", ");
</span><span class='uc' id='L284' title='6|6|6 - Total: 6'>                        sb.append(ScriptRuntime.toString(line));
</span>                    }
                }
            }
        }
<span class='uc' id='L289' title='4|4|4 - Total: 4'>        sb.append("))");
</span><span class='uc' id='L290' title='3|3|3 - Total: 3'>        return sb.toString();
</span>    }

    private static void js_captureStackTrace(Context cx, Scriptable thisObj, Object[] args)
    {
<span class='uc' id='L295' title='8|8|8 - Total: 8'>        ScriptableObject obj = (ScriptableObject)ScriptRuntime.toObjectOrNull(cx, args[0], thisObj);
</span><span class='uc' id='L296' title='2|2|2 - Total: 2'>        Function func = null;
</span><span class='upc' id='L297' title='1|1|1 - Total: 2'>        if (args.length > 1) {
</span><span class='uc' id='L298' title='8|8|8 - Total: 8'>            func = (Function)ScriptRuntime.toObjectOrNull(cx, args[1], thisObj);
</span>        }

        // Create a new error that will have the correct prototype so we can re-use "getStackTrace"
<span class='uc' id='L302' title='6|6|6 - Total: 6'>        NativeError err = (NativeError)cx.newObject(thisObj, "Error");
</span>        // Wire it up so that it will have an actual exception with a stack trace
<span class='uc' id='L304' title='6|6|6 - Total: 6'>        err.setStackProvider(new EvaluatorException("[object Object]"));
</span>
        // Figure out if they passed a function used to hide part of the stack
<span class='uc' id='L307' title='2|2|2 - Total: 2'>        if (func != null) {
</span><span class='uc' id='L308' title='5|5|5 - Total: 5'>            Object funcName = func.get("name", func);
</span><span class='upc' id='L309' title='2|2|2 - Total: 4'>            if ((funcName != null) && !Undefined.instance.equals(funcName)) {
</span><span class='uc' id='L310' title='6|6|6 - Total: 6'>                err.associateValue(STACK_HIDE_KEY, Context.toString(funcName));
</span>            }
        }

        // Define a property on the specified object to get that stack
        // that delegates to our new error. Build the stack trace lazily
        // using the "getStack" code from NativeError.
<span class='uc' id='L317' title='7|7|7 - Total: 7'>        obj.defineProperty("stack", err,
</span>                           ERROR_DELEGATE_GET_STACK, ERROR_DELEGATE_SET_STACK, 0);
<span class='uc' id='L319' title='1|1|1 - Total: 1'>    }
</span>
    @Override
    protected int findPrototypeId(String s)
    {
        int id;
// #string_id_map#
// #generated# Last update: 2007-05-09 08:15:45 EDT
<span class='uc' id='L327' title='4|4|4 - Total: 4'>        L0: { id = 0; String X = null; int c;
</span><span class='uc' id='L328' title='3|3|3 - Total: 3'>            int s_length = s.length();
</span><span class='uc' id='L329' title='2|2|2 - Total: 2'>            if (s_length==8) {
</span><span class='uc' id='L330' title='4|4|4 - Total: 4'>                c=s.charAt(3);
</span><span class='uc' id='L331' title='2|2|2 - Total: 2'>                if (c=='o') { X="toSource";id=Id_toSource; }
</span><span class='uc' id='L332' title='2|2|2 - Total: 2'>                else if (c=='t') { X="toString";id=Id_toString; }
</span>            }
<span class='uc' id='L334' title='2|2|2 - Total: 2'>            else if (s_length==11) { X="constructor";id=Id_constructor; }
</span><span class='upc' id='L335' title='5|5|5 - Total: 6'>            if (X!=null && X!=s && !X.equals(s)) id = 0;
</span>            break L0;
        }
// #/generated#
<span class='uc' id='L339' title='2|2|2 - Total: 2'>        return id;
</span>    }

    private static final int
        Id_constructor    = 1,
        Id_toString       = 2,
        Id_toSource       = 3,
        ConstructorId_captureStackTrace = -1,

        MAX_PROTOTYPE_ID  = 3;

// #/string_id_map#

    /**
     * We will attch this object to the constructor and use it solely to store the constructor properties
     * that are "global." We can't make them static because there can be many contexts in the same JVM.
     */
    private static final class ProtoProps
        implements Serializable
    {
        static final String KEY = "_ErrorPrototypeProps";

        static final Method GET_STACK_LIMIT;
        static final Method SET_STACK_LIMIT;
        static final Method GET_PREPARE_STACK;
        static final Method SET_PREPARE_STACK;

        static {
            try {
                GET_STACK_LIMIT = ProtoProps.class.getMethod("getStackTraceLimit", Scriptable.class);
                SET_STACK_LIMIT = ProtoProps.class.getMethod("setStackTraceLimit", Scriptable.class, Object.class);
                GET_PREPARE_STACK = ProtoProps.class.getMethod("getPrepareStackTrace", Scriptable.class);
                SET_PREPARE_STACK = ProtoProps.class.getMethod("setPrepareStackTrace", Scriptable.class, Object.class);
            } catch (NoSuchMethodException nsm) {
                throw new RuntimeException(nsm);
            }
        }

        private static final long serialVersionUID = 1907180507775337939L;

        private int stackTraceLimit = DEFAULT_STACK_LIMIT;
        private Function prepareStackTrace;

        public Object getStackTraceLimit(Scriptable thisObj) {
            if (stackTraceLimit >= 0) {
                return stackTraceLimit;
            } else {
                return Double.POSITIVE_INFINITY;
            }
        }

        public int getStackTraceLimit() {
            return stackTraceLimit;
        }

        public void setStackTraceLimit(Scriptable thisObj, Object value) {
            double limit = Context.toNumber(value);
            if (Double.isNaN(limit) || Double.isInfinite(limit)) {
                stackTraceLimit = -1;
            } else {
                stackTraceLimit = (int)limit;
            }
        }

        public Object getPrepareStackTrace(Scriptable thisObj)
        {
            Object ps = getPrepareStackTrace();
            return (ps == null ? Undefined.instance : ps);
        }

        public Function getPrepareStackTrace() {
            return prepareStackTrace;
        }

        public void setPrepareStackTrace(Scriptable thisObj, Object value) {
            if ((value == null) || Undefined.instance.equals(value)) {
                prepareStackTrace = null;
            } else if (value instanceof Function) {
                prepareStackTrace = (Function)value;
            }
        }
    }
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>