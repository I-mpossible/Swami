<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.commonjs.module.Require.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.commonjs.module.Require.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.commonjs.module;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.mozilla.javascript.BaseFunction;
import org.mozilla.javascript.Context;
import org.mozilla.javascript.Script;
import org.mozilla.javascript.ScriptRuntime;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ScriptableObject;

/**
 * Implements the require() function as defined by
 * <a href="http://wiki.commonjs.org/wiki/Modules/1.1">Common JS modules</a>.
 * <h1>Thread safety</h1>
 * You will ordinarily create one instance of require() for every top-level
 * scope. This ordinarily means one instance per program execution, except if
 * you use shared top-level scopes and installing most objects into them.
 * Module loading is thread safe, so using a single require() in a shared
 * top-level scope is also safe.
 * <h1>Creation</h1>
 * If you need to create many otherwise identical require() functions for
 * different scopes, you might want to use {@link RequireBuilder} for
 * convenience.
 * <h1>Making it available</h1>
 * In order to make the require() function available to your JavaScript
 * program, you need to invoke either {@link #install(Scriptable)} or
 * {@link #requireMain(Context, String)}.
 * @author Attila Szegedi
 * @version $Id: Require.java,v 1.4 2011/04/07 20:26:11 hannes%helma.at Exp $
 */
public class Require extends BaseFunction
{
    private static final long serialVersionUID = 1L;

    private final ModuleScriptProvider moduleScriptProvider;
    private final Scriptable nativeScope;
    private final Scriptable paths;
    private final boolean sandboxed;
    private final Script preExec;
    private final Script postExec;
<span class='bc' id='L51' title='0|3|3 - Total: 3'>    private String mainModuleId = null;
</span>    private Scriptable mainExports;

    // Modules that completed loading; visible to all threads
<span class='bc' id='L55' title='0|5|5 - Total: 5'>    private final Map<String, Scriptable> exportedModuleInterfaces =
</span>        new ConcurrentHashMap<String, Scriptable>();
<span class='bc' id='L57' title='0|5|5 - Total: 5'>    private final Object loadLock = new Object();
</span>    // Modules currently being loaded on the thread. Used to resolve circular
    // dependencies while loading.
    private static final ThreadLocal<Map<String, Scriptable>>
<span class='bc' id='L61' title='0|5|5 - Total: 5'>        loadingModuleInterfaces = new ThreadLocal<Map<String,Scriptable>>();
</span>
    /**
     * Creates a new instance of the require() function. Upon constructing it,
     * you will either want to install it in the global (or some other) scope
     * using {@link #install(Scriptable)}, or alternatively, you can load the
     * program's main module using {@link #requireMain(Context, String)} and
     * then act on the main module's exports.
     * @param cx the current context
     * @param nativeScope a scope that provides the standard native JavaScript
     * objects.
     * @param moduleScriptProvider a provider for module scripts
     * @param preExec an optional script that is executed in every module's
     * scope before its module script is run.
     * @param postExec an optional script that is executed in every module's
     * scope after its module script is run.
     * @param sandboxed if set to true, the require function will be sandboxed.
     * This means that it doesn't have the "paths" property, and also that the
     * modules it loads don't export the "module.uri" property.
     */
    public Require(Context cx, Scriptable nativeScope,
            ModuleScriptProvider moduleScriptProvider, Script preExec,
<span class='bc' id='L83' title='0|2|2 - Total: 2'>            Script postExec, boolean sandboxed) {
</span><span class='bc' id='L84' title='0|3|3 - Total: 3'>        this.moduleScriptProvider = moduleScriptProvider;
</span><span class='bc' id='L85' title='0|3|3 - Total: 3'>        this.nativeScope = nativeScope;
</span><span class='bc' id='L86' title='0|3|3 - Total: 3'>        this.sandboxed = sandboxed;
</span><span class='bc' id='L87' title='0|3|3 - Total: 3'>        this.preExec = preExec;
</span><span class='bc' id='L88' title='0|3|3 - Total: 3'>        this.postExec = postExec;
</span><span class='bc' id='L89' title='0|4|4 - Total: 4'>        setPrototype(ScriptableObject.getFunctionPrototype(nativeScope));
</span><span class='bc' id='L90' title='0|2|2 - Total: 2'>        if(!sandboxed) {
</span><span class='bc' id='L91' title='0|6|6 - Total: 6'>            paths = cx.newArray(nativeScope, 0);
</span><span class='bc' id='L92' title='0|6|6 - Total: 6'>            defineReadOnlyProperty(this, "paths", paths);
</span>        }
        else {
<span class='bc' id='L95' title='0|3|3 - Total: 3'>            paths = null;
</span>        }
<span class='bc' id='L97' title='0|1|1 - Total: 1'>    }
</span>
    /**
     * Calling this method establishes a module as being the main module of the
     * program to which this require() instance belongs. The module will be
     * loaded as if require()'d and its "module" property will be set as the
     * "main" property of this require() instance. You have to call this method
     * before the module has been loaded (that is, the call to this method must
     * be the first to require the module and thus trigger its loading). Note
     * that the main module will execute in its own scope and not in the global
     * scope. Since all other modules see the global scope, executing the main
     * module in the global scope would open it for tampering by other modules.
     * @param cx the current context
     * @param mainModuleId the ID of the main module
     * @return the "exports" property of the main module
     * @throws IllegalStateException if the main module is already loaded when
     * required, or if this require() instance already has a different main
     * module set.
     */
    public Scriptable requireMain(Context cx, String mainModuleId) {
<span class='bc' id='L117' title='0|2|2 - Total: 2'>        if(this.mainModuleId != null) {
</span><span class='bc' id='L118' title='0|2|2 - Total: 2'>            if (!this.mainModuleId.equals(mainModuleId)) {
</span><span class='bc' id='L119' title='0|13|13 - Total: 13'>                throw new IllegalStateException("Main module already set to " +
</span>                    this.mainModuleId);
            }
<span class='bc' id='L122' title='0|3|3 - Total: 3'>            return mainExports;
</span>        }

        ModuleScript moduleScript;
        try {
            // try to get the module script to see if it is on the module path
<span class='bc' id='L128' title='0|10|10 - Total: 10'>            moduleScript = moduleScriptProvider.getModuleScript(
</span>                    cx, mainModuleId, null, null, paths);
<span class='nc' id='L130' title='0|0|0 - Total: 1'>        } catch (RuntimeException x) {
</span><span class='nc' id='L131' title='0|0|0 - Total: 2'>            throw x;
</span><span class='nc' id='L132' title='0|0|0 - Total: 1'>        } catch (Exception x) {
</span><span class='nc' id='L133' title='0|0|0 - Total: 5'>            throw new RuntimeException(x);
</span><span class='bc' id='L134' title='0|1|1 - Total: 1'>        }
</span>
<span class='bpc' id='L136' title='0|1|1 - Total: 2'>        if (moduleScript != null) {
</span><span class='bc' id='L137' title='0|10|10 - Total: 10'>            mainExports = getExportedModuleInterface(cx, mainModuleId,
</span>                    null, null, true);
<span class='nc' id='L139' title='0|0|0 - Total: 2'>        } else if (!sandboxed) {
</span>
<span class='nc' id='L141' title='0|0|0 - Total: 2'>            URI mainUri = null;
</span>
            // try to resolve to an absolute URI or file path
            try {
<span class='nc' id='L145' title='0|0|0 - Total: 5'>                mainUri = new URI(mainModuleId);
</span><span class='nc' id='L146' title='0|0|0 - Total: 1'>            } catch (URISyntaxException usx) {
</span>                // fall through
<span class='nc' id='L148' title='0|0|0 - Total: 1'>            }
</span>
            // if not an absolute uri resolve to a file path
<span class='nc' id='L151' title='0|0|0 - Total: 4'>            if (mainUri == null || !mainUri.isAbsolute()) {
</span><span class='nc' id='L152' title='0|0|0 - Total: 5'>                File file = new File(mainModuleId);
</span><span class='nc' id='L153' title='0|0|0 - Total: 2'>                if (!file.isFile()) {
</span><span class='nc' id='L154' title='0|0|0 - Total: 15'>                    throw ScriptRuntime.throwError(cx, nativeScope,
</span>                            "Module \"" + mainModuleId + "\" not found.");
                }
<span class='nc' id='L157' title='0|0|0 - Total: 3'>                mainUri = file.toURI();
</span>            }
<span class='nc' id='L159' title='0|0|0 - Total: 10'>            mainExports = getExportedModuleInterface(cx, mainUri.toString(),
</span>                    mainUri, null, true);
        }

<span class='bc' id='L163' title='0|3|3 - Total: 3'>        this.mainModuleId = mainModuleId;
</span><span class='bc' id='L164' title='0|3|3 - Total: 3'>        return mainExports;
</span>    }

    /**
     * Binds this instance of require() into the specified scope under the
     * property name "require".
     * @param scope the scope where the require() function is to be installed.
     */
    public void install(Scriptable scope) {
<span class='bc' id='L173' title='0|4|4 - Total: 4'>        ScriptableObject.putProperty(scope, "require", this);
</span><span class='bc' id='L174' title='0|1|1 - Total: 1'>    }
</span>
    @Override
    public Object call(Context cx, Scriptable scope, Scriptable thisObj,
            Object[] args)
    {
<span class='bpc' id='L180' title='0|3|3 - Total: 4'>        if(args == null || args.length < 1) {
</span><span class='bc' id='L181' title='0|5|5 - Total: 5'>            throw ScriptRuntime.throwError(cx, scope,
</span>                    "require() needs one argument");
        }

<span class='bc' id='L185' title='0|7|7 - Total: 7'>        String id = (String)Context.jsToJava(args[0], String.class);
</span><span class='bc' id='L186' title='0|2|2 - Total: 2'>        URI uri = null;
</span><span class='bc' id='L187' title='0|2|2 - Total: 2'>        URI base = null;
</span><span class='bc' id='L188' title='0|4|4 - Total: 4'>        if (id.startsWith("./") || id.startsWith("../")) {
</span><span class='bc' id='L189' title='0|2|2 - Total: 2'>            if (!(thisObj instanceof ModuleScope)) {
</span><span class='bc' id='L190' title='0|14|14 - Total: 14'>                throw ScriptRuntime.throwError(cx, scope,
</span>                        "Can't resolve relative module ID \"" + id +
                                "\" when require() is used outside of a module");
            }

<span class='bc' id='L195' title='0|3|3 - Total: 3'>            ModuleScope moduleScope = (ModuleScope) thisObj;
</span><span class='bc' id='L196' title='0|3|3 - Total: 3'>            base = moduleScope.getBase();
</span><span class='bc' id='L197' title='0|3|3 - Total: 3'>            URI current = moduleScope.getUri();
</span><span class='bc' id='L198' title='0|4|4 - Total: 4'>            uri = current.resolve(id);
</span>
<span class='bpc' id='L200' title='0|1|1 - Total: 2'>            if (base == null) {
</span>                // calling module is absolute, resolve to absolute URI
                // (but without file extension)
<span class='nc' id='L203' title='0|0|0 - Total: 4'>                id = uri.toString();
</span>            } else {
                // try to convert to a relative URI rooted on base
<span class='bc' id='L206' title='0|7|7 - Total: 7'>                id = base.relativize(current).resolve(id).toString();
</span><span class='bpc' id='L207' title='0|1|1 - Total: 2'>                if (id.charAt(0) == '.') {
</span>                    // resulting URI is not contained in base,
                    // throw error or make absolute depending on sandbox flag.
<span class='nc' id='L210' title='0|0|0 - Total: 2'>                    if (sandboxed) {
</span><span class='nc' id='L211' title='0|0|0 - Total: 14'>                        throw ScriptRuntime.throwError(cx, scope,
</span>                            "Module \"" + id + "\" is not contained in sandbox.");
                    } else {
<span class='nc' id='L214' title='0|0|0 - Total: 3'>                        id = uri.toString();
</span>                    }
                }
            }
        }
<span class='bc' id='L219' title='0|8|8 - Total: 8'>        return getExportedModuleInterface(cx, id, uri, base, false);
</span>    }

    @Override
    public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
<span class='bc' id='L224' title='0|5|5 - Total: 5'>        throw ScriptRuntime.throwError(cx, scope,
</span>                "require() can not be invoked as a constructor");
    }

    private Scriptable getExportedModuleInterface(Context cx, String id,
            URI uri, URI base, boolean isMain)
    {
        // Check if the requested module is already completely loaded
<span class='bc' id='L232' title='0|6|6 - Total: 6'>        Scriptable exports = exportedModuleInterfaces.get(id);
</span><span class='bc' id='L233' title='0|2|2 - Total: 2'>        if(exports != null) {
</span><span class='bc' id='L234' title='0|2|2 - Total: 2'>            if(isMain) {
</span><span class='bc' id='L235' title='0|5|5 - Total: 5'>                throw new IllegalStateException(
</span>                        "Attempt to set main module after it was loaded");
            }
<span class='bc' id='L238' title='0|2|2 - Total: 2'>            return exports;
</span>        }
        // Check if it is currently being loaded on the current thread
        // (supporting circular dependencies).
<span class='bc' id='L242' title='0|1|1 - Total: 1'>        Map<String, Scriptable> threadLoadingModules =
</span><span class='bc' id='L243' title='0|3|3 - Total: 3'>            loadingModuleInterfaces.get();
</span><span class='bc' id='L244' title='0|2|2 - Total: 2'>        if(threadLoadingModules != null) {
</span><span class='bc' id='L245' title='0|5|5 - Total: 5'>            exports = threadLoadingModules.get(id);
</span><span class='bc' id='L246' title='0|2|2 - Total: 2'>            if(exports != null) {
</span><span class='bc' id='L247' title='0|2|2 - Total: 2'>                return exports;
</span>            }
        }
        // The requested module is neither already loaded, nor is it being
        // loaded on the current thread. End of fast path. We must synchronize
        // now, as we have to guarantee that at most one thread can load
        // modules at any one time. Otherwise, two threads could end up
        // attempting to load two circularly dependent modules in opposite
        // order, which would lead to either unacceptable non-determinism or
        // deadlock, depending on whether we underprotected or overprotected it
        // with locks.
<span class='bc' id='L258' title='0|5|5 - Total: 5'>        synchronized(loadLock) {
</span>            // Recheck if it is already loaded - other thread might've
            // completed loading it just as we entered the synchronized block.
<span class='bc' id='L261' title='0|6|6 - Total: 6'>            exports = exportedModuleInterfaces.get(id);
</span><span class='bpc' id='L262' title='0|1|1 - Total: 2'>            if(exports != null) {
</span><span class='nc' id='L263' title='0|0|0 - Total: 4'>                return exports;
</span>            }
            // Nope, still not loaded; we're loading it then.
<span class='bc' id='L266' title='0|7|7 - Total: 7'>            final ModuleScript moduleScript = getModule(cx, id, uri, base);
</span><span class='bpc' id='L267' title='0|3|3 - Total: 4'>            if (sandboxed && !moduleScript.isSandboxed()) {
</span><span class='nc' id='L268' title='0|0|0 - Total: 15'>                throw ScriptRuntime.throwError(cx, nativeScope, "Module \""
</span>                        + id + "\" is not contained in sandbox.");
            }
<span class='bc' id='L271' title='0|5|5 - Total: 5'>            exports = cx.newObject(nativeScope);
</span>            // Are we the outermost locked invocation on this thread?
<span class='bc' id='L273' title='0|2|2 - Total: 2'>            final boolean outermostLocked = threadLoadingModules == null;
</span><span class='bc' id='L274' title='0|2|2 - Total: 2'>            if(outermostLocked) {
</span><span class='bc' id='L275' title='0|4|4 - Total: 4'>                threadLoadingModules = new HashMap<String, Scriptable>();
</span><span class='bc' id='L276' title='0|3|3 - Total: 3'>                loadingModuleInterfaces.set(threadLoadingModules);
</span>            }
            // Must make the module exports available immediately on the
            // current thread, to satisfy the CommonJS Modules/1.1 requirement
            // that "If there is a dependency cycle, the foreign module may not
            // have finished executing at the time it is required by one of its
            // transitive dependencies; in this case, the object returned by
            // "require" must contain at least the exports that the foreign
            // module has prepared before the call to require that led to the
            // current module's execution."
<span class='bc' id='L286' title='0|5|5 - Total: 5'>            threadLoadingModules.put(id, exports);
</span>            try {
                // Support non-standard Node.js feature to allow modules to
                // replace the exports object by setting module.exports.
<span class='bc' id='L290' title='0|8|8 - Total: 8'>                Scriptable newExports = executeModuleScript(cx, id, exports,
</span>                        moduleScript, isMain);
<span class='bpc' id='L292' title='0|1|1 - Total: 2'>                if (exports != newExports) {
</span><span class='nc' id='L293' title='0|0|0 - Total: 5'>                    threadLoadingModules.put(id, newExports);
</span><span class='nc' id='L294' title='0|0|0 - Total: 2'>                    exports = newExports;
</span>                }
            }
<span class='nc' id='L297' title='0|0|0 - Total: 1'>            catch(RuntimeException e) {
</span>                // Throw loaded module away if there was an exception
<span class='nc' id='L299' title='0|0|0 - Total: 4'>                threadLoadingModules.remove(id);
</span><span class='nc' id='L300' title='0|0|0 - Total: 2'>                throw e;
</span>            }
            finally {
<span class='bpc' id='L303' title='0|2|2 - Total: 4'>                if(outermostLocked) {
</span>                    // Make loaded modules visible to other threads only after
                    // the topmost triggering load has completed. This strategy
                    // (compared to the one where we'd make each module
                    // globally available as soon as it loads) prevents other
                    // threads from observing a partially loaded circular
                    // dependency of a module that completed loading.
<span class='bpc' id='L310' title='0|4|4 - Total: 8'>                    exportedModuleInterfaces.putAll(threadLoadingModules);
</span><span class='bpc' id='L311' title='0|4|4 - Total: 7'>                    loadingModuleInterfaces.set(null);
</span>                }
<span class='nc' id='L313' title='0|0|0 - Total: 2'>            }
</span><span class='bc' id='L314' title='0|8|8 - Total: 8'>        }
</span><span class='bc' id='L315' title='0|2|2 - Total: 2'>        return exports;
</span>    }

    private Scriptable executeModuleScript(Context cx, String id,
            Scriptable exports, ModuleScript moduleScript, boolean isMain)
    {
<span class='bc' id='L321' title='0|6|6 - Total: 6'>        final ScriptableObject moduleObject = (ScriptableObject)cx.newObject(
</span>                nativeScope);
<span class='bc' id='L323' title='0|3|3 - Total: 3'>        URI uri = moduleScript.getUri();
</span><span class='bc' id='L324' title='0|3|3 - Total: 3'>        URI base = moduleScript.getBase();
</span><span class='bc' id='L325' title='0|4|4 - Total: 4'>        defineReadOnlyProperty(moduleObject, "id", id);
</span><span class='bc' id='L326' title='0|2|2 - Total: 2'>        if(!sandboxed) {
</span><span class='bc' id='L327' title='0|5|5 - Total: 5'>            defineReadOnlyProperty(moduleObject, "uri", uri.toString());
</span>        }
<span class='bc' id='L329' title='0|8|8 - Total: 8'>        final Scriptable executionScope = new ModuleScope(nativeScope, uri, base);
</span>        // Set this so it can access the global JS environment objects.
        // This means we're currently using the "MGN" approach (ModuleScript
        // with Global Natives) as specified here:
        // <http://wiki.commonjs.org/wiki/Modules/ProposalForNativeExtension>
<span class='bc' id='L334' title='0|5|5 - Total: 5'>        executionScope.put("exports", executionScope, exports);
</span><span class='bc' id='L335' title='0|5|5 - Total: 5'>        executionScope.put("module", executionScope, moduleObject);
</span><span class='bc' id='L336' title='0|5|5 - Total: 5'>        moduleObject.put("exports", moduleObject, exports);
</span><span class='bc' id='L337' title='0|3|3 - Total: 3'>        install(executionScope);
</span><span class='bc' id='L338' title='0|2|2 - Total: 2'>        if(isMain) {
</span><span class='bc' id='L339' title='0|4|4 - Total: 4'>            defineReadOnlyProperty(this, "main", moduleObject);
</span>        }
<span class='bc' id='L341' title='0|5|5 - Total: 5'>        executeOptionalScript(preExec, cx, executionScope);
</span><span class='bc' id='L342' title='0|6|6 - Total: 6'>        moduleScript.getScript().exec(cx, executionScope);
</span><span class='bc' id='L343' title='0|5|5 - Total: 5'>        executeOptionalScript(postExec, cx, executionScope);
</span><span class='bc' id='L344' title='0|7|7 - Total: 7'>        return ScriptRuntime.toObject(cx, nativeScope,
</span><span class='bc' id='L345' title='0|1|1 - Total: 1'>                ScriptableObject.getProperty(moduleObject, "exports"));
</span>    }

    private static void executeOptionalScript(Script script, Context cx,
            Scriptable executionScope)
    {
<span class='bpc' id='L351' title='0|1|1 - Total: 2'>        if(script != null) {
</span><span class='nc' id='L352' title='0|0|0 - Total: 5'>            script.exec(cx, executionScope);
</span>        }
<span class='bc' id='L354' title='0|1|1 - Total: 1'>    }
</span>
    private static void defineReadOnlyProperty(ScriptableObject obj,
            String name, Object value) {
<span class='bc' id='L358' title='0|4|4 - Total: 4'>        ScriptableObject.putProperty(obj, name, value);
</span><span class='bc' id='L359' title='0|4|4 - Total: 4'>        obj.setAttributes(name, ScriptableObject.READONLY |
</span>                ScriptableObject.PERMANENT);
<span class='bc' id='L361' title='0|1|1 - Total: 1'>    }
</span>
    private ModuleScript getModule(Context cx, String id, URI uri, URI base) {
        try {
<span class='bc' id='L365' title='0|8|8 - Total: 8'>            final ModuleScript moduleScript =
</span><span class='bc' id='L366' title='0|2|2 - Total: 2'>                    moduleScriptProvider.getModuleScript(cx, id, uri, base, paths);
</span><span class='bc' id='L367' title='0|2|2 - Total: 2'>            if (moduleScript == null) {
</span><span class='bc' id='L368' title='0|15|15 - Total: 15'>                throw ScriptRuntime.throwError(cx, nativeScope, "Module \""
</span>                        + id + "\" not found.");
            }
<span class='bc' id='L371' title='0|2|2 - Total: 2'>            return moduleScript;
</span>        }
<span class='bc' id='L373' title='0|1|1 - Total: 1'>        catch(RuntimeException e) {
</span><span class='bc' id='L374' title='0|2|2 - Total: 2'>            throw e;
</span>        }
<span class='nc' id='L376' title='0|0|0 - Total: 1'>        catch(Exception e) {
</span><span class='nc' id='L377' title='0|0|0 - Total: 3'>            throw Context.throwAsScriptRuntimeEx(e);
</span>        }
    }

    @Override
    public String getFunctionName() {
<span class='nc' id='L383' title='0|0|0 - Total: 2'>        return "require";
</span>    }

    @Override
    public int getArity() {
<span class='nc' id='L388' title='0|0|0 - Total: 2'>        return 1;
</span>    }

    @Override
    public int getLength() {
<span class='nc' id='L393' title='0|0|0 - Total: 2'>        return 1;
</span>    }
}
</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>