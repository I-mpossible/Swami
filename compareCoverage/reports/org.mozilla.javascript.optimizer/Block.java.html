<?xml version='1.0' encoding='UTF-8'?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns='http://www.w3.org/1999/xhtml' lang='en'><head><meta http-equiv='Content-Type' content='text/html;charset=UTF-8'/><title>org.mozilla.javascript.optimizer.Block.java</title><link rel='stylesheet' href='../.resources/report.css' type='text/css'/><link rel='stylesheet' href='../.resources/prettify.css' type='text/css'/><link rel='stylesheet' href='../.resources/custom.css' type='text/css'/><script type='text/javascript' src='../.resources/prettify.js'></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><h1>org.mozilla.javascript.optimizer.Block.java</h1><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table><pre class='source lang-java linenums'>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.optimizer;

import org.mozilla.javascript.*;
import org.mozilla.javascript.ast.Jump;

import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;

import java.io.PrintWriter;
import java.io.StringWriter;

class Block
{

    private static class FatBlock
    {

        private static Block[] reduceToArray(ObjToIntMap map)
        {
            Block[] result = null;
            if (!map.isEmpty()) {
                result = new Block[map.size()];
                int i = 0;
                ObjToIntMap.Iterator iter = map.newIterator();
                for (iter.start(); !iter.done(); iter.next()) {
                    FatBlock fb = (FatBlock)(iter.getKey());
                    result[i++] = fb.realBlock;
                }
            }
            return result;
        }

        void addSuccessor(FatBlock b)  { successors.put(b, 0); }
        void addPredecessor(FatBlock b)  { predecessors.put(b, 0); }

        Block[] getSuccessors() { return reduceToArray(successors); }
        Block[] getPredecessors() { return reduceToArray(predecessors); }

        // all the Blocks that come immediately after this
        private ObjToIntMap successors = new ObjToIntMap();
        // all the Blocks that come immediately before this
        private ObjToIntMap predecessors = new ObjToIntMap();

        Block realBlock;
    }

    Block(int startNodeIndex, int endNodeIndex)
<span class='uc' id='L53' title='2|2|2 - Total: 2'>    {
</span><span class='uc' id='L54' title='3|3|3 - Total: 3'>        itsStartNodeIndex = startNodeIndex;
</span><span class='uc' id='L55' title='3|3|3 - Total: 3'>        itsEndNodeIndex = endNodeIndex;
</span><span class='uc' id='L56' title='1|1|1 - Total: 1'>    }
</span>
    static void runFlowAnalyzes(OptFunctionNode fn, Node[] statementNodes)
    {
<span class='uc' id='L60' title='4|4|4 - Total: 4'>        int paramCount = fn.fnode.getParamCount();
</span><span class='uc' id='L61' title='4|4|4 - Total: 4'>        int varCount = fn.fnode.getParamAndVarCount();
</span><span class='uc' id='L62' title='3|3|3 - Total: 3'>        int[] varTypes = new int[varCount];
</span>        // If the variable is a parameter, it could have any type.
<span class='uc' id='L64' title='2|2|2 - Total: 2'>        for (int i = 0; i != paramCount; ++i) {
</span><span class='uc' id='L65' title='4|4|4 - Total: 4'>            varTypes[i] = Optimizer.AnyType;
</span>        }
        // If the variable is from a "var" statement, its typeEvent will be set
        // when we see the setVar node.
<span class='uc' id='L69' title='2|2|2 - Total: 2'>        for (int i = paramCount; i != varCount; ++i) {
</span><span class='uc' id='L70' title='4|4|4 - Total: 4'>            varTypes[i] = Optimizer.NoType;
</span>        }

<span class='uc' id='L73' title='3|3|3 - Total: 3'>        Block[] theBlocks = buildBlocks(statementNodes);
</span>
        if (DEBUG) {
            ++debug_blockCount;
            System.out.println("-------------------"+fn.fnode.getFunctionName()+"  "+debug_blockCount+"--------");
            System.out.println(fn.fnode.toStringTree(fn.fnode));
            System.out.println(toString(theBlocks, statementNodes));
        }

<span class='uc' id='L82' title='5|5|5 - Total: 5'>        reachingDefDataFlow(fn, statementNodes, theBlocks, varTypes);
</span><span class='uc' id='L83' title='5|5|5 - Total: 5'>        typeFlow(fn, statementNodes, theBlocks, varTypes);
</span>
        if (DEBUG) {
            for (int i = 0; i < theBlocks.length; i++) {
                System.out.println("For block " + theBlocks[i].itsBlockID);
                theBlocks[i].printLiveOnEntrySet(fn);
            }
            System.out.println("Variable Table, size = " + varCount);
            for (int i = 0; i != varCount; i++) {
                System.out.println("["+i+"] type: "+varTypes[i]);
            }
        }

<span class='uc' id='L96' title='2|2|2 - Total: 2'>        for (int i = paramCount; i != varCount; i++) {
</span><span class='uc' id='L97' title='2|2|2 - Total: 2'>            if (varTypes[i] == Optimizer.NumberType) {
</span><span class='uc' id='L98' title='3|3|3 - Total: 3'>                fn.setIsNumberVar(i);
</span>            }
        }

<span class='uc' id='L102' title='1|1|1 - Total: 1'>    }
</span>
    private static Block[] buildBlocks(Node[] statementNodes)
    {
        // a mapping from each target node to the block it begins
<span class='uc' id='L107' title='4|4|4 - Total: 4'>        Map<Node,FatBlock> theTargetBlocks = new HashMap<Node,FatBlock>();
</span><span class='uc' id='L108' title='4|4|4 - Total: 4'>        ObjArray theBlocks = new ObjArray();
</span>
        // there's a block that starts at index 0
<span class='uc' id='L111' title='2|2|2 - Total: 2'>        int beginNodeIndex = 0;
</span>
<span class='uc' id='L113' title='2|2|2 - Total: 2'>        for (int i = 0; i < statementNodes.length; i++) {
</span><span class='uc' id='L114' title='3|3|3 - Total: 3'>            switch (statementNodes[i].getType()) {
</span>                case Token.TARGET :
                {
<span class='uc' id='L117' title='2|2|2 - Total: 2'>                    if (i != beginNodeIndex) {
</span><span class='uc' id='L118' title='6|6|6 - Total: 6'>                        FatBlock fb = newFatBlock(beginNodeIndex, i - 1);
</span><span class='uc' id='L119' title='2|2|2 - Total: 2'>                        if (statementNodes[beginNodeIndex].getType() == Token.TARGET) {
</span><span class='uc' id='L120' title='7|7|7 - Total: 7'>                            theTargetBlocks.put(statementNodes[beginNodeIndex], fb);
</span>                        }
<span class='uc' id='L122' title='3|3|3 - Total: 3'>                        theBlocks.add(fb);
</span>                        // start the next block at this node
<span class='uc' id='L124' title='2|2|2 - Total: 2'>                        beginNodeIndex = i;
</span><span class='uc' id='L125' title='1|1|1 - Total: 1'>                    }
</span>                }
                break;
                case Token.IFNE :
                case Token.IFEQ :
                case Token.GOTO :
                {
<span class='uc' id='L132' title='4|4|4 - Total: 4'>                    FatBlock fb = newFatBlock(beginNodeIndex, i);
</span><span class='uc' id='L133' title='2|2|2 - Total: 2'>                    if (statementNodes[beginNodeIndex].getType() == Token.TARGET) {
</span><span class='uc' id='L134' title='7|7|7 - Total: 7'>                        theTargetBlocks.put(statementNodes[beginNodeIndex], fb);
</span>                    }
<span class='uc' id='L136' title='3|3|3 - Total: 3'>                    theBlocks.add(fb);
</span>                    // start the next block at the next node
<span class='uc' id='L138' title='4|4|4 - Total: 4'>                    beginNodeIndex = i + 1;
</span>                }
                break;
            }
        }

<span class='upc' id='L144' title='1|1|1 - Total: 2'>        if (beginNodeIndex != statementNodes.length) {
</span><span class='uc' id='L145' title='7|7|7 - Total: 7'>            FatBlock fb = newFatBlock(beginNodeIndex, statementNodes.length - 1);
</span><span class='uc' id='L146' title='2|2|2 - Total: 2'>            if (statementNodes[beginNodeIndex].getType() == Token.TARGET) {
</span><span class='uc' id='L147' title='7|7|7 - Total: 7'>                theTargetBlocks.put(statementNodes[beginNodeIndex], fb);
</span>            }
<span class='uc' id='L149' title='3|3|3 - Total: 3'>            theBlocks.add(fb);
</span>        }

        // build successor and predecessor links

<span class='uc' id='L154' title='2|2|2 - Total: 2'>        for (int i = 0; i < theBlocks.size(); i++) {
</span><span class='uc' id='L155' title='6|6|6 - Total: 6'>            FatBlock fb = (FatBlock)(theBlocks.get(i));
</span>
<span class='uc' id='L157' title='6|6|6 - Total: 6'>            Node blockEndNode = statementNodes[fb.realBlock.itsEndNodeIndex];
</span><span class='uc' id='L158' title='3|3|3 - Total: 3'>            int blockEndNodeType = blockEndNode.getType();
</span>
<span class='uc' id='L160' title='4|4|4 - Total: 4'>            if ((blockEndNodeType != Token.GOTO) && (i < (theBlocks.size() - 1))) {
</span><span class='uc' id='L161' title='8|8|8 - Total: 8'>                FatBlock fallThruTarget = (FatBlock)(theBlocks.get(i + 1));
</span><span class='uc' id='L162' title='3|3|3 - Total: 3'>                fb.addSuccessor(fallThruTarget);
</span><span class='uc' id='L163' title='3|3|3 - Total: 3'>                fallThruTarget.addPredecessor(fb);
</span>            }


<span class='uc' id='L167' title='6|6|6 - Total: 6'>            if ( (blockEndNodeType == Token.IFNE)
</span>                    || (blockEndNodeType == Token.IFEQ)
                    || (blockEndNodeType == Token.GOTO) ) {
<span class='uc' id='L170' title='4|4|4 - Total: 4'>                Node target = ((Jump)blockEndNode).target;
</span><span class='uc' id='L171' title='5|5|5 - Total: 5'>                FatBlock branchTargetBlock = theTargetBlocks.get(target);
</span><span class='uc' id='L172' title='5|5|5 - Total: 5'>                target.putProp(Node.TARGETBLOCK_PROP, branchTargetBlock.realBlock);
</span><span class='uc' id='L173' title='3|3|3 - Total: 3'>                fb.addSuccessor(branchTargetBlock);
</span><span class='uc' id='L174' title='3|3|3 - Total: 3'>                branchTargetBlock.addPredecessor(fb);
</span>            }
        }

<span class='uc' id='L178' title='4|4|4 - Total: 4'>        Block[] result = new Block[theBlocks.size()];
</span>
<span class='uc' id='L180' title='2|2|2 - Total: 2'>        for (int i = 0; i < theBlocks.size(); i++) {
</span><span class='uc' id='L181' title='6|6|6 - Total: 6'>            FatBlock fb = (FatBlock)(theBlocks.get(i));
</span><span class='uc' id='L182' title='3|3|3 - Total: 3'>            Block b = fb.realBlock;
</span><span class='uc' id='L183' title='4|4|4 - Total: 4'>            b.itsSuccessors = fb.getSuccessors();
</span><span class='uc' id='L184' title='4|4|4 - Total: 4'>            b.itsPredecessors = fb.getPredecessors();
</span><span class='uc' id='L185' title='3|3|3 - Total: 3'>            b.itsBlockID = i;
</span><span class='uc' id='L186' title='4|4|4 - Total: 4'>            result[i] = b;
</span>        }

<span class='uc' id='L189' title='2|2|2 - Total: 2'>        return result;
</span>    }

    private static FatBlock newFatBlock(int startNodeIndex, int endNodeIndex)
    {
<span class='uc' id='L194' title='5|5|5 - Total: 5'>        FatBlock fb = new FatBlock();
</span><span class='uc' id='L195' title='7|7|7 - Total: 7'>        fb.realBlock = new Block(startNodeIndex, endNodeIndex);
</span><span class='uc' id='L196' title='2|2|2 - Total: 2'>        return fb;
</span>    }

    private static String toString(Block[] blockList, Node[] statementNodes)
    {
<span class='nc' id='L201' title='0|0|0 - Total: 2'>        if (!DEBUG) return null;
</span>
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);

        pw.println(blockList.length + " Blocks");
        for (int i = 0; i < blockList.length; i++) {
            Block b = blockList[i];
            pw.println("#" + b.itsBlockID);
            pw.println("from " + b.itsStartNodeIndex
                    + " "
                    + statementNodes[b.itsStartNodeIndex].toString());
            pw.println("thru " + b.itsEndNodeIndex
                    + " "
                    + statementNodes[b.itsEndNodeIndex].toString());
            pw.print("Predecessors ");
            if (b.itsPredecessors != null) {
                for (int j = 0; j < b.itsPredecessors.length; j++) {
                    pw.print(b.itsPredecessors[j].itsBlockID + " ");
                }
                pw.println();
            } else {
                pw.println("none");
            }
            pw.print("Successors ");
            if (b.itsSuccessors != null) {
                for (int j = 0; j < b.itsSuccessors.length; j++) {
                    pw.print(b.itsSuccessors[j].itsBlockID + " ");
                }
                pw.println();
            } else {
                pw.println("none");
            }
        }
        return sw.toString();
    }

    private static void reachingDefDataFlow(OptFunctionNode fn, Node[] statementNodes,
                                            Block theBlocks[], int[] varTypes)
    {
/*
    initialize the liveOnEntry and liveOnExit sets, then discover the variables
    that are def'd by each function, and those that are used before being def'd
    (hence liveOnEntry)
*/
<span class='uc' id='L246' title='2|2|2 - Total: 2'>        for (int i = 0; i < theBlocks.length; i++) {
</span><span class='uc' id='L247' title='6|6|6 - Total: 6'>            theBlocks[i].initLiveOnEntrySets(fn, statementNodes);
</span>        }
/*
    this visits every block starting at the last, re-adding the predecessors of
    any block whose inputs change as a result of the dataflow.
    REMIND, better would be to visit in CFG postorder
*/
<span class='uc' id='L254' title='4|4|4 - Total: 4'>        boolean visit[] = new boolean[theBlocks.length];
</span><span class='uc' id='L255' title='4|4|4 - Total: 4'>        boolean doneOnce[] = new boolean[theBlocks.length];
</span><span class='uc' id='L256' title='5|5|5 - Total: 5'>        int vIndex = theBlocks.length - 1;
</span><span class='uc' id='L257' title='2|2|2 - Total: 2'>        boolean needRescan = false;
</span><span class='uc' id='L258' title='4|4|4 - Total: 4'>        visit[vIndex] = true;
</span>        while (true) {
<span class='uc' id='L260' title='4|4|4 - Total: 4'>            if (visit[vIndex] || !doneOnce[vIndex]) {
</span><span class='uc' id='L261' title='4|4|4 - Total: 4'>                doneOnce[vIndex] = true;
</span><span class='uc' id='L262' title='4|4|4 - Total: 4'>                visit[vIndex] = false;
</span><span class='uc' id='L263' title='2|2|2 - Total: 2'>                if (theBlocks[vIndex].doReachedUseDataFlow()) {
</span><span class='uc' id='L264' title='5|5|5 - Total: 5'>                    Block pred[] = theBlocks[vIndex].itsPredecessors;
</span><span class='uc' id='L265' title='2|2|2 - Total: 2'>                    if (pred != null) {
</span><span class='uc' id='L266' title='2|2|2 - Total: 2'>                        for (int i = 0; i < pred.length; i++) {
</span><span class='uc' id='L267' title='5|5|5 - Total: 5'>                            int index = pred[i].itsBlockID;
</span><span class='uc' id='L268' title='4|4|4 - Total: 4'>                            visit[index] = true;
</span><span class='uc' id='L269' title='2|2|2 - Total: 2'>                            needRescan |= (index > vIndex);
</span>                        }
                    }
                }
            }
<span class='uc' id='L274' title='2|2|2 - Total: 2'>            if (vIndex == 0) {
</span><span class='uc' id='L275' title='2|2|2 - Total: 2'>                if (needRescan) {
</span><span class='uc' id='L276' title='5|5|5 - Total: 5'>                    vIndex = theBlocks.length - 1;
</span><span class='uc' id='L277' title='3|3|3 - Total: 3'>                    needRescan = false;
</span>                } else {
                    break;
                }
            } else {
<span class='uc' id='L282' title='2|2|2 - Total: 2'>                vIndex--;
</span>            }
        }
/*
        if any variable is live on entry to block 0, we have to mark it as
        not jRegable - since it means that someone is trying to access the
        'undefined'-ness of that variable.
*/

<span class='uc' id='L291' title='5|5|5 - Total: 5'>        theBlocks[0].markAnyTypeVariables(varTypes);
</span><span class='uc' id='L292' title='1|1|1 - Total: 1'>    }
</span>
    private static void typeFlow(OptFunctionNode fn, Node[] statementNodes,
                                 Block theBlocks[], int[] varTypes)
    {
<span class='uc' id='L297' title='4|4|4 - Total: 4'>        boolean visit[] = new boolean[theBlocks.length];
</span><span class='uc' id='L298' title='4|4|4 - Total: 4'>        boolean doneOnce[] = new boolean[theBlocks.length];
</span><span class='uc' id='L299' title='2|2|2 - Total: 2'>        int vIndex = 0;
</span><span class='uc' id='L300' title='2|2|2 - Total: 2'>        boolean needRescan = false;
</span><span class='uc' id='L301' title='4|4|4 - Total: 4'>        visit[vIndex] = true;
</span>        while (true) {
<span class='upc' id='L303' title='3|3|3 - Total: 4'>            if (visit[vIndex] || !doneOnce[vIndex]) {
</span><span class='uc' id='L304' title='4|4|4 - Total: 4'>                doneOnce[vIndex] = true;
</span><span class='uc' id='L305' title='4|4|4 - Total: 4'>                visit[vIndex] = false;
</span><span class='uc' id='L306' title='2|2|2 - Total: 2'>                if (theBlocks[vIndex].doTypeFlow(fn, statementNodes, varTypes))
</span>                {
<span class='uc' id='L308' title='5|5|5 - Total: 5'>                    Block succ[] = theBlocks[vIndex].itsSuccessors;
</span><span class='uc' id='L309' title='2|2|2 - Total: 2'>                    if (succ != null) {
</span><span class='uc' id='L310' title='2|2|2 - Total: 2'>                        for (int i = 0; i < succ.length; i++) {
</span><span class='uc' id='L311' title='5|5|5 - Total: 5'>                            int index = succ[i].itsBlockID;
</span><span class='uc' id='L312' title='4|4|4 - Total: 4'>                            visit[index] = true;
</span><span class='upc' id='L313' title='1|1|1 - Total: 2'>                            needRescan |= (index < vIndex);
</span>                        }
                    }
                }
            }
<span class='uc' id='L318' title='2|2|2 - Total: 2'>            if (vIndex == (theBlocks.length - 1)) {
</span><span class='upc' id='L319' title='1|1|1 - Total: 2'>                if (needRescan) {
</span><span class='nc' id='L320' title='0|0|0 - Total: 2'>                    vIndex = 0;
</span><span class='nc' id='L321' title='0|0|0 - Total: 3'>                    needRescan = false;
</span>                } else {
                    break;
                }
            } else {
<span class='uc' id='L326' title='2|2|2 - Total: 2'>                vIndex++;
</span>            }
        }
<span class='uc' id='L329' title='1|1|1 - Total: 1'>    }
</span>
    private static boolean assignType(int[] varTypes, int index, int type)
    {
<span class='uc' id='L333' title='4|4|4 - Total: 4'>        int prev = varTypes[index];
</span><span class='uc' id='L334' title='2|2|2 - Total: 2'>        return prev != (varTypes[index] |= type);
</span>    }

    private void markAnyTypeVariables(int[] varTypes)
    {
<span class='uc' id='L339' title='2|2|2 - Total: 2'>        for (int i = 0; i != varTypes.length; i++) {
</span><span class='uc' id='L340' title='2|2|2 - Total: 2'>            if (itsLiveOnEntrySet.get(i)) {
</span><span class='uc' id='L341' title='5|5|5 - Total: 5'>                assignType(varTypes, i, Optimizer.AnyType);
</span>            }
        }

<span class='uc' id='L345' title='1|1|1 - Total: 1'>    }
</span>
    /*
        We're tracking uses and defs - in order to
        build the def set and to identify the last use
        nodes.

        The itsNotDefSet is built reversed then flipped later.

    */
    private void lookForVariableAccess(OptFunctionNode fn, Node n)
    {
<span class='uc' id='L357' title='5|5|5 - Total: 5'>        switch (n.getType()) {
</span>            case Token.TYPEOFNAME:
            {
                // TYPEOFNAME may be used with undefined names, which is why
                // this is handled separately from GETVAR above.
<span class='uc' id='L362' title='5|5|5 - Total: 5'>                int varIndex = fn.fnode.getIndexForNameNode(n);
</span><span class='uc' id='L363' title='4|4|4 - Total: 4'>                if (varIndex > -1 && !itsNotDefSet.get(varIndex))
</span><span class='uc' id='L364' title='4|4|4 - Total: 4'>                    itsUseBeforeDefSet.set(varIndex);
</span>            }
<span class='uc' id='L366' title='1|1|1 - Total: 1'>            break;
</span>            case Token.DEC :
            case Token.INC :
            {
<span class='uc' id='L370' title='3|3|3 - Total: 3'>                Node child = n.getFirstChild();
</span><span class='uc' id='L371' title='2|2|2 - Total: 2'>                if (child.getType() == Token.GETVAR) {
</span><span class='uc' id='L372' title='4|4|4 - Total: 4'>                    int varIndex = fn.getVarIndex(child);
</span><span class='uc' id='L373' title='2|2|2 - Total: 2'>                    if (!itsNotDefSet.get(varIndex))
</span><span class='uc' id='L374' title='4|4|4 - Total: 4'>                        itsUseBeforeDefSet.set(varIndex);
</span><span class='uc' id='L375' title='4|4|4 - Total: 4'>                    itsNotDefSet.set(varIndex);
</span><span class='uc' id='L376' title='1|1|1 - Total: 1'>                } else {
</span><span class='uc' id='L377' title='4|4|4 - Total: 4'>                    lookForVariableAccess(fn, child);
</span>                }
            }
<span class='uc' id='L380' title='1|1|1 - Total: 1'>            break;
</span>            case Token.SETVAR :
            case Token.SETCONSTVAR :
            {
<span class='uc' id='L384' title='3|3|3 - Total: 3'>                Node lhs = n.getFirstChild();
</span><span class='uc' id='L385' title='3|3|3 - Total: 3'>                Node rhs = lhs.getNext();
</span><span class='uc' id='L386' title='4|4|4 - Total: 4'>                lookForVariableAccess(fn, rhs);
</span><span class='uc' id='L387' title='6|6|6 - Total: 6'>                itsNotDefSet.set(fn.getVarIndex(n));
</span>            }
<span class='uc' id='L389' title='1|1|1 - Total: 1'>            break;
</span>            case Token.GETVAR :
            {
<span class='uc' id='L392' title='4|4|4 - Total: 4'>                int varIndex = fn.getVarIndex(n);
</span><span class='uc' id='L393' title='2|2|2 - Total: 2'>                if (!itsNotDefSet.get(varIndex))
</span><span class='uc' id='L394' title='4|4|4 - Total: 4'>                    itsUseBeforeDefSet.set(varIndex);
</span>            }
<span class='uc' id='L396' title='1|1|1 - Total: 1'>            break;
</span>            default :
<span class='uc' id='L398' title='3|3|3 - Total: 3'>                Node child = n.getFirstChild();
</span><span class='uc' id='L399' title='2|2|2 - Total: 2'>                while (child != null) {
</span><span class='uc' id='L400' title='4|4|4 - Total: 4'>                    lookForVariableAccess(fn, child);
</span><span class='uc' id='L401' title='4|4|4 - Total: 4'>                    child = child.getNext();
</span>                }
                break;
        }
<span class='uc' id='L405' title='1|1|1 - Total: 1'>    }
</span>
    /*
        build the live on entry/exit sets.
        Then walk the trees looking for defs/uses of variables
        and build the def and useBeforeDef sets.
    */
    private void initLiveOnEntrySets(OptFunctionNode fn, Node[] statementNodes)
    {
<span class='uc' id='L414' title='3|3|3 - Total: 3'>        int listLength = fn.getVarCount();
</span><span class='uc' id='L415' title='6|6|6 - Total: 6'>        itsUseBeforeDefSet = new BitSet(listLength);
</span><span class='uc' id='L416' title='6|6|6 - Total: 6'>        itsNotDefSet = new BitSet(listLength);
</span><span class='uc' id='L417' title='6|6|6 - Total: 6'>        itsLiveOnEntrySet = new BitSet(listLength);
</span><span class='uc' id='L418' title='6|6|6 - Total: 6'>        itsLiveOnExitSet = new BitSet(listLength);
</span><span class='uc' id='L419' title='2|2|2 - Total: 2'>        for (int i = itsStartNodeIndex; i <= itsEndNodeIndex; i++) {
</span><span class='uc' id='L420' title='4|4|4 - Total: 4'>            Node n = statementNodes[i];
</span><span class='uc' id='L421' title='4|4|4 - Total: 4'>            lookForVariableAccess(fn, n);
</span>        }
<span class='uc' id='L423' title='5|5|5 - Total: 5'>        itsNotDefSet.flip(0, listLength);         // truth in advertising
</span><span class='uc' id='L424' title='1|1|1 - Total: 1'>    }
</span>
    /*
        the liveOnEntry of each successor is the liveOnExit for this block.
        The liveOnEntry for this block is -
        liveOnEntry = liveOnExit - defsInThisBlock + useBeforeDefsInThisBlock

    */
    private boolean doReachedUseDataFlow()
    {
<span class='uc' id='L434' title='3|3|3 - Total: 3'>        itsLiveOnExitSet.clear();
</span><span class='uc' id='L435' title='2|2|2 - Total: 2'>        if (itsSuccessors != null) {
</span><span class='uc' id='L436' title='2|2|2 - Total: 2'>            for (int i = 0; i < itsSuccessors.length; i++) {
</span><span class='uc' id='L437' title='8|8|8 - Total: 8'>                itsLiveOnExitSet.or(itsSuccessors[i].itsLiveOnEntrySet);
</span>            }
        }
<span class='uc' id='L440' title='11|11|11 - Total: 11'>        return updateEntrySet(itsLiveOnEntrySet, itsLiveOnExitSet,
</span>                              itsUseBeforeDefSet, itsNotDefSet);
    }

    private boolean updateEntrySet(BitSet entrySet, BitSet exitSet,
                                   BitSet useBeforeDef, BitSet notDef) {
<span class='uc' id='L446' title='3|3|3 - Total: 3'>        int card = entrySet.cardinality();
</span><span class='uc' id='L447' title='3|3|3 - Total: 3'>        entrySet.or(exitSet);
</span><span class='uc' id='L448' title='3|3|3 - Total: 3'>        entrySet.and(notDef);
</span><span class='uc' id='L449' title='3|3|3 - Total: 3'>        entrySet.or(useBeforeDef);
</span><span class='uc' id='L450' title='2|2|2 - Total: 2'>        return entrySet.cardinality() != card;
</span>    }

    /*
        the type of an expression is relatively unknown. Cases we can be sure
        about are -
            Literals,
            Arithmetic operations - always return a Number
    */
    private static int findExpressionType(OptFunctionNode fn, Node n,
                                          int[] varTypes)
    {
<span class='uc' id='L462' title='14|14|14 - Total: 14'>        switch (n.getType()) {
</span>            case Token.NUMBER:
<span class='uc' id='L464' title='2|2|2 - Total: 2'>                return Optimizer.NumberType;
</span>
            case Token.CALL:
            case Token.NEW:
            case Token.REF_CALL:
<span class='uc' id='L469' title='2|2|2 - Total: 2'>                return Optimizer.AnyType;
</span>
            case Token.GETELEM:
            case Token.GETPROP:
            case Token.NAME:
            case Token.THIS:
<span class='uc' id='L475' title='2|2|2 - Total: 2'>                return Optimizer.AnyType;
</span>
            case Token.GETVAR:
<span class='uc' id='L478' title='6|6|6 - Total: 6'>                return varTypes[fn.getVarIndex(n)];
</span>
            case Token.INC:
            case Token.DEC:
            case Token.MUL:
            case Token.DIV:
            case Token.MOD:
            case Token.BITOR:
            case Token.BITXOR:
            case Token.BITAND:
            case Token.BITNOT:
            case Token.LSH:
            case Token.RSH:
            case Token.URSH:
            case Token.SUB:
            case Token.POS:
            case Token.NEG:
<span class='uc' id='L495' title='2|2|2 - Total: 2'>                return Optimizer.NumberType;
</span>
            case Token.VOID:
                // NYI: undefined type
<span class='uc' id='L499' title='2|2|2 - Total: 2'>                return Optimizer.AnyType;
</span>
            case Token.FALSE:
            case Token.TRUE:
            case Token.EQ:
            case Token.NE:
            case Token.LT:
            case Token.LE:
            case Token.GT:
            case Token.GE:
            case Token.SHEQ:
            case Token.SHNE:
            case Token.NOT:
            case Token.INSTANCEOF:
            case Token.IN:
            case Token.DEL_REF:
            case Token.DELPROP:
                // NYI: boolean type
<span class='uc' id='L517' title='2|2|2 - Total: 2'>                return Optimizer.AnyType;
</span>
            case Token.STRING:
            case Token.TYPEOF:
            case Token.TYPEOFNAME:
                // NYI: string type
<span class='uc' id='L523' title='2|2|2 - Total: 2'>                return Optimizer.AnyType;
</span>
            case Token.NULL:
            case Token.REGEXP:
            case Token.ARRAYCOMP:
            case Token.ARRAYLIT:
            case Token.OBJECTLIT:
<span class='uc' id='L530' title='2|2|2 - Total: 2'>                return Optimizer.AnyType; // XXX: actually, we know it's not
</span>            // number, but no type yet for that

            case Token.ADD: {
                // if the lhs & rhs are known to be numbers, we can be sure that's
                // the result, otherwise it could be a string.
<span class='uc' id='L536' title='3|3|3 - Total: 3'>                Node child = n.getFirstChild();
</span><span class='uc' id='L537' title='5|5|5 - Total: 5'>                int lType = findExpressionType(fn, child, varTypes);
</span><span class='uc' id='L538' title='6|6|6 - Total: 6'>                int rType = findExpressionType(fn, child.getNext(), varTypes);
</span><span class='uc' id='L539' title='4|4|4 - Total: 4'>                return lType | rType;    // we're not distinguishing strings yet
</span>            }

            case Token.HOOK: {
<span class='uc' id='L543' title='4|4|4 - Total: 4'>                Node ifTrue = n.getFirstChild().getNext();
</span><span class='uc' id='L544' title='3|3|3 - Total: 3'>                Node ifFalse = ifTrue.getNext();
</span><span class='uc' id='L545' title='5|5|5 - Total: 5'>                int ifTrueType = findExpressionType(fn, ifTrue, varTypes);
</span><span class='uc' id='L546' title='5|5|5 - Total: 5'>                int ifFalseType = findExpressionType(fn, ifFalse, varTypes);
</span><span class='uc' id='L547' title='4|4|4 - Total: 4'>                return ifTrueType | ifFalseType;
</span>            }

            case Token.COMMA:
            case Token.SETVAR:
            case Token.SETCONSTVAR:
            case Token.SETNAME:
            case Token.SETPROP:
            case Token.SETELEM:
<span class='uc' id='L556' title='6|6|6 - Total: 6'>                return findExpressionType(fn, n.getLastChild(), varTypes);
</span>
            case Token.AND:
            case Token.OR: {
<span class='uc' id='L560' title='3|3|3 - Total: 3'>                Node child = n.getFirstChild();
</span><span class='uc' id='L561' title='5|5|5 - Total: 5'>                int lType = findExpressionType(fn, child, varTypes);
</span><span class='uc' id='L562' title='6|6|6 - Total: 6'>                int rType = findExpressionType(fn, child.getNext(), varTypes);
</span><span class='uc' id='L563' title='4|4|4 - Total: 4'>                return lType | rType;
</span>            }
        }

<span class='uc' id='L567' title='2|2|2 - Total: 2'>        return Optimizer.AnyType;
</span>    }

    private static boolean findDefPoints(OptFunctionNode fn, Node n,
                                         int[] varTypes)
    {
<span class='uc' id='L573' title='2|2|2 - Total: 2'>        boolean result = false;
</span><span class='uc' id='L574' title='3|3|3 - Total: 3'>        Node first = n.getFirstChild();
</span><span class='uc' id='L575' title='2|2|2 - Total: 2'>        for (Node next = first; next != null; next = next.getNext()) {
</span><span class='uc' id='L576' title='7|7|7 - Total: 7'>            result |= findDefPoints(fn, next, varTypes);
</span>        }
<span class='uc' id='L578' title='3|3|3 - Total: 3'>        switch (n.getType()) {
</span>            case Token.DEC :
            case Token.INC :
<span class='uc' id='L581' title='2|2|2 - Total: 2'>                if (first.getType() == Token.GETVAR) {
</span>                    // theVar is a Number now
<span class='uc' id='L583' title='4|4|4 - Total: 4'>                    int i = fn.getVarIndex(first);
</span><span class='uc' id='L584' title='2|2|2 - Total: 2'>                    if (!fn.fnode.getParamAndVarConst()[i]) {
</span><span class='uc' id='L585' title='7|7|7 - Total: 7'>                        result |= assignType(varTypes, i, Optimizer.NumberType);
</span>                    }
<span class='uc' id='L587' title='1|1|1 - Total: 1'>                }
</span>                break;
            case Token.SETVAR :
            case Token.SETCONSTVAR : {
<span class='uc' id='L591' title='3|3|3 - Total: 3'>                Node rValue = first.getNext();
</span><span class='uc' id='L592' title='5|5|5 - Total: 5'>                int theType = findExpressionType(fn, rValue, varTypes);
</span><span class='uc' id='L593' title='4|4|4 - Total: 4'>                int i = fn.getVarIndex(n);
</span><span class='uc' id='L594' title='2|2|2 - Total: 2'>                if (!(n.getType() == Token.SETVAR
</span><span class='uc' id='L595' title='2|2|2 - Total: 2'>                        && fn.fnode.getParamAndVarConst()[i])) {
</span><span class='uc' id='L596' title='8|8|8 - Total: 8'>                    result |= assignType(varTypes, i, theType);
</span>                }
                break;
            }
        }
<span class='uc' id='L601' title='2|2|2 - Total: 2'>        return result;
</span>    }

    private boolean doTypeFlow(OptFunctionNode fn, Node[] statementNodes,
                               int[] varTypes)
    {
<span class='uc' id='L607' title='2|2|2 - Total: 2'>        boolean changed = false;
</span>
<span class='uc' id='L609' title='2|2|2 - Total: 2'>        for (int i = itsStartNodeIndex; i <= itsEndNodeIndex; i++) {
</span><span class='uc' id='L610' title='4|4|4 - Total: 4'>            Node n = statementNodes[i];
</span><span class='upc' id='L611' title='1|1|1 - Total: 2'>            if (n != null) {
</span><span class='uc' id='L612' title='7|7|7 - Total: 7'>                changed |= findDefPoints(fn, n, varTypes);
</span>            }
        }

<span class='uc' id='L616' title='2|2|2 - Total: 2'>        return changed;
</span>    }

    private void printLiveOnEntrySet(OptFunctionNode fn)
    {
        if (DEBUG) {
            for (int i = 0; i < fn.getVarCount(); i++) {
                String name = fn.fnode.getParamOrVarName(i);
                if (itsUseBeforeDefSet.get(i))
                    System.out.println(name + " is used before def'd");
                if (itsNotDefSet.get(i))
                    System.out.println(name + " is not def'd");
                if (itsLiveOnEntrySet.get(i))
                    System.out.println(name + " is live on entry");
                if (itsLiveOnExitSet.get(i))
                    System.out.println(name + " is live on exit");
            }
        }
<span class='nc' id='L634' title='0|0|0 - Total: 1'>    }
</span>
    // all the Blocks that come immediately after this
    private Block[] itsSuccessors;
    // all the Blocks that come immediately before this
    private Block[] itsPredecessors;

    private int itsStartNodeIndex;       // the Node at the start of the block
    private int itsEndNodeIndex;         // the Node at the end of the block

    private int itsBlockID;               // a unique index for each block

    // reaching def bit sets -
    private BitSet itsLiveOnEntrySet;
    private BitSet itsLiveOnExitSet;
    private BitSet itsUseBeforeDefSet;
    private BitSet itsNotDefSet;

    static final boolean DEBUG = false;
    private static int debug_blockCount;

}

</pre></body></html><table class='legend'><tr><td class='nc'>Not Covered</td><td class='ac'>Covered by test suite 1</td><td class='bc'>Covered by test suite 2</td><td class='uc'>Covered by the union test suite</td><td class='apc'>Partially Covered by test suite 1</td><td class='bpc'>Partially Covered by test suite 2</td><td class='upc'>Partially Covered by the union test suite</td></tr></table>